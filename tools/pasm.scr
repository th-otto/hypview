

screen( "Copyright" )
PASM.HLP wurde bersetzt am 3.Februar 1992.

(c) 1990 Borland International, Inc.
\end

screen( "Index" )
Index der verfgbaren Schlsselw”rter:

     \#A..\#       \#B..\#       \#C..\#      \#D..\#

     \#E..\#       \#F..\#       \#G..\#      \#H..\#

     \#I..\#       \#J..\#       \#K..\#      \#L..\#

     \#M..\#       \#N..\#       \#O..\#      \#P..\#

     \#Q..\#       \#R..\#       \#S..\#      \#T..\#

     \#U..\#       \#V..\#       \#W..\#      \#X..\#

     \#Y..\#       \#Z..\#

     \#Sonstiges\#
\end

screen( capsensitive("Assembler") )
Pure Assembler auf einen Blick
----------------------------------------------------------------------

\link("Optionen")Aufruf und Optionen\#

\#Formale Beschreibung\#

\link("Befehlsbersicht")Befehle\#

\#Direktiven\#

\#Makros\#

\#Codeoptimierung\#

\#Fehlermeldungen\#

\#Abkrzungen\#
\end

screen( "Formale Beschreibung" )
Formale Beschreibung des Pure Assemblers
----------------------------------------

\#Zeichensatz\#                  \#Kommentare\#

\#Bezeichner\#                   \#Register-Spezifikationen\#

\link("Symbole")Labels\#                       \#Gr”en-Spezifikationen\#

\#Numerische Konstanten\#        \#Adressierungsarten\#

\#Stringkonstanten\#             \#Positionsz„hler\#

\#Ausdrcke\#                    \#Fliekomma-Ausdrcke\#

\#Priorit„ten der Operatoren\#
\end

screen( "Prozessor" )
Die MC680x0 Prozessor-Familie
----------------------------------------------------------------------

Weitere Informationen ber die MC680x0  Prozessor-Familie  k”nnen
Sie aus den Motorola Handbchern  zu  den  jeweiligen Prozessoren
beziehen.

- Motorola MC68000/68010 16-bit Microprocessor Programmer's
  Reference Manual
- Motorola MC68020 32-bit Microprocessor User's Manual
- Motorola MC68030 32-bit Microprocessor User's Manual
- Motorola MC68040 32-bit Microprocessor User's Manual
- Motorola MC68851 Paged Memory Management Unit User's Manual
- Motorola MC68881 Floating Point Coprocessor User's Manual
\end

screen( "Optionen",
		"Kommandozeilenparameter",
		"Aufruf" )
Aufruf und Optionen
----------------------------------------------------------------------

Der Assembleraufruf erfolgt mit einer Kommandozeile der Form

    PASM [options] source[.extension]

Die Optionen werden durch ein vorangestelltes Minuszeichen
gekennzeichnet, beispielsweise -1. Falls Optionen keine
weiteren Argumente verlangen, k”nnen mehrere Optionen zusammen-
gefat werden, beispielsweise -1V. Nachstehende Tabelle enth„lt
eine Aufstellung aller Optionen, inklusive deren Beschreibung.
Als n„chstes folgt der Name der Quelldatei. Wenn der Name der
Quelldatei keine Extension enth„lt, geht der Assembler davon
aus, da es sich um die Extension .S handelt. Andernfalls mu
die Extension explizit angegeben werden. Die erzeugte Objektdatei
erh„lt den Namen der Quelldatei versehen mit der Extension .O.

Option           Bedeutung
----------------------------------------------------------------
-1               Diese Option w„hlt den Befehlssatz fr die
                 Prozessoren MC68010 und MC68012 aus. Vorein-
                 gestellt ist der Befehlssatz fr MC68000 und
                 MC68008.

-2               Mit dieser Option wird auf den Befehlssatz fr
                 den MC68020 umgeschaltet.

-3               Um den Befehlssatz des MC68030 zu aktivieren,
                 mssen Sie diesen Schalter angeben.

-4               Damit Sie die Befehle des MC68040 nutzen k”nnen,
                 mu die Kommandozeile diesen Schalter enthalten.

-5               Diese Option erlaubt die Benutzung der Befehle
                 des Coprozessors MC68851. Eine Coprozessor-ID
                 l„t sich fur den MC68851 nicht angeben, da er
                 wegen seiner hardwarem„igen Voreinstellung mit
                 der ID 0 betrieben werden mu.

-8[=ID]          Dieser Schalter gestattet den Gebrauch des
                 Befehlssatzes der Coprozessoren MC68881 und
                 MC68882. Der optionale Parameter ID spezifiziert
                 die Coprozessor-ID. Diese darf zwischen 0 und 7
                 liegen, voreingestellt ist 1.

-A               Wenn dieser Schalter zus„tzlich zum Schalter -P
                 gesetzt ist, wird jede expandierte Makrozeile in
                 die \#Listing-Datei\# aufgefhrt.

-B               Der Assembler erzeugt Objektdateien im DRI-Format,
                 wenn Sie diesen Schalter setzen. Standardm„ig
                 werden Objektdateien im Pure-Format angelegt.

-C               Wenn dieser Schalter zusammen mit der Option -P
                 angegeben ist, wird auch der Inhalt von Include-
                 Dateien in der \#Listing-Datei\# aufgefhrt.

-D=symbol=value  Wie mit der =-Direktive, so k”nnen Sie auch ber
                 die Kommandozeile Symbole definieren. Dazu geben
                 Sie den Symbolnamen symbol gefolgt von einem
                 Gleichheitszeichen = und dem Wert value, den das
                 Symbol erhalten soll, an.

-F               Wenn diese Option angegeben ist, werden alle Zeilen
                 innerhalb eines IF-ELSE-ENDIF-Blocks, die die
                 Bedingung nicht erfllen, im \#Listing\# unterdrckt.
                 Voraussetzung ist natrlich, da auch der Schalter
                 -P gesetzt wird. Normalerweise werden alle Zeilen
                 ausgegeben.

-I=path          šber diese Option k”nnen Sie einen Pfad angeben,
                 unter dem der Assembler die Include-Dateien suchen
                 soll.

-M               Wenn dieser Schalter zus„tzlich zum Schalter -P
                 gesetzt ist, werden in der \#Listing-Datei\# nur die
                 Makroaufrufe aufgefhrt, nicht jedoch der fr sie
                 erzeugte Code.

-N=outdir        Mit dieser Option k”nnen Sie spezifizieren, in
                 welches Verzeichnis die Ausgabedatei geschrieben
                 werden soll.

-O=file[.ext]    M”chten Sie der erzeugten Objektdatei einen anderen
                 Namen geben, so mssen Sie ihn mit dieser Option
                 spezifizieren. Lassen Sie die Extension weg, so
                 wird die Extension .O an den Dateinamen file geh„ngt.

-P               Die Wahl dieser Option fhrt zur Erzeugung einer
                 \#Listing-Datei\#. Diese erh„lt den Namen der Quelldatei,
                 versehen mit der Extension .LST.

-S               Diese Option fhrt dazu, da Sie auch die privile-
                 gierten Befehle in der Quelldatei benutzen drfen.

-U               Wenn Sie diesen Schalter angeben, behandelt der
                 Assembler alle nicht definierten Symbole als
                 externe Referenzen, statt eine Fehlermeldung
                 auszugeben.

-V               Dieser Schalter fhrt dazu, da der Assembler
                 zus„tzliche Informationen ber die Assemblierung
                 ausgibt.

-Y               Dieser Schalter veranlat die Erzeugung von Debug-
                 Information fr den Pure Debugger.
\end

screen( "Listing",
		"Listing-Datei" )
Listing
----------------------------------------------------------------------

Die Listing-Datei enth„lt neben dem Quelltext auch Angaben zum
Verlauf der Assemblierung. In ihr wird der erzeugte Maschinencode 
und die Adresse neben den entsprechenden Assemblerbefehlen aus-
gegeben. Darberhinaus werden Informationen zu den verwendeten
\link("Symbole")Symbolen und Labels\# gesammelt.
Um eine Listing-Datei zu erzeugen, mu man beim Aufruf des
Assemblers in der Kommandozeile den Schalter -P angeben. Es
wird dann eine Listing-Datei unter dem Namen der Quelldatei mit
der Dateierweiterung .LST angelegt.

Jede Seite der Listing-Datei beginnt mit einer speziellen
Kopfzeile. Diese enthalt die Versionsnummer des benutzten Pure
Assemblers und die fortlaufende Seitenzahl im Listing.
Das Listing besteht aus zwei Teilen, dem erweiterten Quelltext
und der Symboltabelle. 
Jede Zeile des ertweiterten Quelltexts hat folgendes Format:

<Zeile>   <Include>   <Adresse>   <Code>   <Makro>   <Quelltext>

Einzige Ausnahme von dieser Regel sind Zeilen, die Fehlermeldungen
oder Warnungen w„hrend der Assemblierung verursacht haben. Bei
ihnen fehlen die Informationen uber <Adresse> und <Code>.
Auerdem wird in der folgenden Zeile der Text der Meldung
wiederholt. Doch nun zur Beschreibung der einzelnen Komponenten
einer Zeile:

<Zeile>    enth„lt die Zeilennummer im Quelltext. Kopfzeilen und
           šberschriften gehen in die Zeilennummerierung nicht
           mit ein.
<Include>  wird mit einem Punkt (.) versehen, wenn gerade eine
           Include-Datei verarbeitet wird. Ansonsten befindet sich
           an dieser Stelle ein Leerzeichen.
<Adresse>  gibt die absolute Adresse oder den Offset innerhalb
           eines Segments oder Moduls fr die assemblierte Quell-
           textzeile an. Alle Adreangaben sind relativ zum Segment-
           bzw. Modulanfang.
<Code>     enth„lt den aus dem Quelltext erzeugten Maschinencode
           als Folge hexadezimaler Zahlen. Programmcode wird dabei
           aufgespalten in Befehlscode und Code fr Argumente
           (sofern sinnvoll).
           Bei Referenzen auf absolute externe Adressen wird an
           die Adreangabe im Code-Feld ein Asterisk (*) und bei 
           externen PC-relativen Referenzen ein Plus-Zeichen (+)
           angeh„ngt. Adressen im TEXT-, DATA und BSS-Segment werden
           durch verschiedene Arten von Anfhrungszeichen gekenn-
           zeichnet (', ', und "). Absolute Konstanten haben kein
           Suffix.
<Makro>    enth„lt ein Plus-Zeichen (+), wenn die betreffende Zeile
           aus einer Makroexpansion hervorgeht.
<Quelle>   beinhaltet die originale Quelltextzeile inklusive der
           Kommentare. Quelltextzeilen, die nur Kommentare enthalten,
           erzeugen keinen Code, so da das <Adresse>- und das
           <Code>-Feld leer bleiben.

Der zweite Teil der Listing-Datei beinhaltet die Symboltabelle.
Sie enth„lt, alphabetisch geordnet, Informationen zu allen im
Quelltext verwendeten Symbolen und Labels.
In der ersten Spalte, dem Feld Name befindet sich der Name des
Symbols bzw. des Labels. Im n„chsten Feld, Value, steht der
Initialwert des Symbols. Bei Labels, die sich auf Adressen beziehen,
wird diese angegeben. Im Feld Scope wird angegeben, ob ein Symbol
extern, global oder lokal ist. Das Feld Relocation base schlielich
gibt Auskunft darber, ob das Symbol relativ zu einem Segment oder
Modul definiert ist.
\end

screen( "Fehlermeldungen" )
Fehlermeldungen des Pure Assemblers
----------------------------------------------------------------------

Die Fehlermeldungen sind in die folgenden drei Kategorien
unterteilt:

\#Kommandozeilen-Fehler\#

\#Assemblierungsfehler\#

\#Fatale Fehler\#
\end

screen( "Fehler, Kommandozeilen-",
		"Kommandozeilen-Fehler" )
Kommandozeilen-Fehler
----------------------------------------------------------------------

Folgende Fehlermeldungen erhalten Sie, wenn in der \link("Optionen")Kommandozeile\#
die Parameter falsch angegeben werden.

*** Invalid coprocessor id
Die angegebene Coprozessor-ID ist ungltig. Sie mu im Bereich
zwischen 0 und 7 liegen.

*** Invalid option
Die angegebene \link("Optionen")Option\# existiert nicht.

*** Missing option character
Nach einem Minuszeichen mu ein \link("Optionen")Optionszeichen\# folgen.

*** Missing '-D' argument
Die Option -D verlangt als Argument einen Symbolnamen und einen
Wert. Mindestens eine der Angaben fehlt.

*** Missing '-I' argument
Die Option -I verlangt als Argument einen Verzeichnisnamen fr
die Suche von Include-Dateien. Dieser wurde nicht angegeben.

*** Missing '-N' argument
Die Option -O verlangt als Argument einen Verzeichnisnamen fr
die Ausgabedatei. Dieser wurde nicht angegeben.

*** Missing '-O' argument
Die Option -O verlangt als Argument einen Dateinamen fr die
Ausgabedatei. Dieser wurde nicht angegeben.

*** Missing source file name
In der Kommandozeile wurde nicht angegeben, welche Quelldatei
assembliert werden soll.

*** More than one source file name specified
Es wurde mehr als eine zu assemblierende Quelldatei angegeben, es
ist jedoch nur eine erlaubt.
\end

screen( "Assemblierungsfehler",
		"Fehler, Assemblierungs-",
		"Fehler im Quelltext" )
Assemblierungsfehler
----------------------------------------------------------------------

Diese Kategorie weist auf Fehler in den Quelltexten hin. Die
Assemblierung wird nach einem dieser Fehler nicht abgebrochen,
so da mehrere Fehler auf einmal gefunden werden k”nnen. Es wird
aber keine Objektdatei erzeugt.
Falls gleichzeitig eine \#Listing-Datei\# angelegt wird, werden die
Fehlermeldungen auch dort, in der Zeile unter der Fehlerstelle,
aufgefhrt.
Fr jeden Fehler wird der Name der Quelldatei und die Zeilennummer
der Fehlerstelle ausgegeben.

*** Addressing mode for MC68020 only
Es wurde eine \link("Adressierungsarten")Adressierungsart\# gew„hlt, die erst ab dem MC68020
zur Verfgung steht. Um sie zu benutzen, mssen Sie den ent-
sprechenden Befehlssatz w„hlen.

*** Backward assignment to location counter
Eine Zuweisung an den \#Positionsz„hler\# fhrte dazu, da dieser
verringert wurde. Es sind jedoch ausschlielich vorw„rtsge-
richtete Zuweisungen erlaubt.

*** Bad format in floating point number
Das Format der angegebenen Fliekommazahl entspricht nicht der
erlaubten \link("Fliekomma-Konstanten")Syntax\#.

*** Code generation in this segment not allowed
Es wurde unerlaubterweise versucht, im \#BSS\#- oder einem
\link("OFFSET")absoluten Segment\# Code zu erzeugen. Zugelassen sind ausschlielich
Label-Definitionen und Speicherzuweisungsdirektiven.

*** Code not aligned
In der betreffenden Zeile sollte Code erzeugt werden, der auf eine
Byte-Grenze zu liegen gekommen w„re. Sie k”nnen diesen Fehler durch
die Verwendung einer \#EVEN\#-Direktive beheben.

*** Constant too long
Dieser Fehler kann zwei Ursachen haben. Eine numerische Konstante
l„t sich nicht als 32-Bit-Wert darstellen oder eine Stringkonstante
ist langer als vier Zeichen.

*** Displacement out of range
Die Adredistanz der verwendeten \link("Adressierungsarten")Adressierungsart\# ist l„nger als
ein Byte oder ein Wort.

*** Division by zero
Bei der Auswertung eines Ausdrucks trat eine Division durch Null auf.

*** Duplicate register in register list
Ein Register wurde in einer Registerliste mehrmals aufgefhrt.

*** Duplicate global symbol(s)
Dieser Fehler kann nur auftreten, wenn Sie Objektdateien im DRI-
Format erzeugen. Bei diesem ist die L„nge an signifikanten Zeichen
fr Bezeichner auf 8 beschr„nkt. Pure Assembler verarbeitet Label-
namen bis zu 255 Zeichen L„nge, so kann er bespielsweise yourFunc1
und yourFunc2 unterscheiden. In einer DRI-Objektdatei ist dies
nicht mehr m”glich, da die beiden Labels erst im neunten Zeichen
differieren. Wenn Sie eine Objektdatei im Pure-Format erzeugen,
k”nnen Sie diese Schwierigkeiten umgehen.

*** Error direktive:
Es wurde mit der \#ERROR\#-Direktive eine Fehlermeldung erzeugt.

*** Expression must be constant
Eine Direktive erwartete einen absoluten, nicht relozierbaren Ausdruck.

*** Immediate data out of range
Die Konstante fr eine Immediate-Adressierung pat nicht in ein
Byte oder Wort.

*** Index register scale must be 1,2,4 or 8
Die Skalierung fr ein Indexregister darf nur einer der Faktoren
1, 2, 4 oder 8 sein.

*** Index register size must be word or longword
Als Gr”enspezifikation fr ein Indexregister sind nur die
Datenformate Wort oder Langwort zul„ssig.

*** Invalid control character in input line
In der betreffenden Zeile befindet sich ein Zeichen, dessen
ASCII-Code kleiner 32 und kein Zeilenvorschub ist.

*** Invalid conditional directive
Es wurde eine \#ELSE\#-, \#ENDIF\#- oder \#ENDC\#-Direktive ohne vorherige
\#IFcc\#-Direktive gefunden.

*** Invalid digit
In einer numerischen Konstante wurde eine ungltige Ziffer entdeckt,
beispielsweise in einer Bin„rzahl eine andere Ziffer als 0 oder 1.

*** Invalid instruction argument(s)
Der betreffende Befehl wurde mit zuviel oder zuwenig Argumenten
benutzt. M”glich ist auch, da eine nichtzugelassene Adressierungsart
fr ein Argument des Befehls verwendet wurde.

*** Invalid macro directive
Es wurde eine \#LOCAL\#-, \#ENDM\#- oder \#EXITM\#-Direktive ohne vorherige
\#Makrodefinition\# gefunden.

*** Label redefined
Das betreffende Label wurde bereits definiert. Die angegebene Stelle
ist der Ort der Redefinition.

*** Line overflow
Zeilen drfen maximal 512 Zeichen umfassen. Die betreffende Zeile
ist l„nger.

*** Macro name redefines opcode or directive
Makronamen drfen nicht mit denen von Befehlen oder Direktiven
bereinstimmen.

*** Missing argument
Fr die betreffende Direktive sind zu wenig Parameter vorhanden.

*** Missing 'endif'
Zu einer \#IFcc\#-Direktive existiert kein \#ENDIF\# oder \#ENDC\#. Dieser
Fehler wird erst am Ende eines Quelltextes erkannt.

*** Missing 'endm'
Zu einer \#MACRO\#-Direktive existiert kein \#ENDM\#. Diese Fehlermeldung
wird erst am Ende eines Quelltextes ausgegeben.

*** Opcode for 68010 only
*** Opcode for 68020 only
*** Opcode for 68030 only
*** Opcode for 68040 only
*** Opcode for 68851 only
*** Opcode for 68881 only
Der betreffende Befehl ist im gew„hlten \#Befehlssatz\# nicht vorhanden.
W„hlen Sie den angegebenen Befehlssatz, wenn Sie den Befehl trotzdem
verwenden wollen.

*** Operand size not allowed
Das gew„hlte Datenformat ist fr den Befehl nicht zugelassen.

*** Privileged instruction
Der betreffende Befehl ist privilegiert. Um ihn verwenden zu k”nnen,
mssen Sie den privilegierten Befehlssatz aktivieren.

*** Relative address out of range
Die Verzweigung geht ber eine Distanz, die sich nicht mehr in
einem Byte oder Wort darstellen l„t.

*** Relocation error
Der Typ eines \link("Ausdrcke")Ausdrucks\# ist in diesem Zusammenhang nicht zugelassen.

*** String literal exceeds one line
Eine Stringkonstante geht ber mehr als eine Zeile. Dies ist nicht
erlaubt.

*** Syntax error in argument(s)
Die Argumente eines Befehls oder einer Direktive enthalten einen
Syntaxfehler.

*** Syntax error in input line
Der Assembler kann die angegebene Zeile nicht interpretieren.

*** Syntax error in register list
Die Registerliste enth„lt einen Fehler.

*** Undefined symbols
Zu den nach dieser Meldung aufgefhrten Labels findet sich in der
Quelldatei keine Definition oder \#IMPORT\#-Direktive.

*** Unknown mnemonic
Es wurde ein Bezeichner gefunden, der weder ein Befehl, noch eine
Direktive oder ein Makroname ist.

*** Unknown size specification
Es wurde eine unbekannte Gr”enspezifikation verwendet.

*** Unterminated C-comment
Fr einen C-Kommentar konnte kein Kommentarende gefunden werden.
Diese Fehlermeldung tritt erst am Ende eines Quelltextes auf.

*** Value not allowed
Der Wert eines Ausdrucks liegt nicht in dem fr diesen Zusammenhang
zugelassenen Bereich.
\end

screen( "Fehler, Fatale",
		"Fatale Fehler" )
Fatale Fehler
----------------------------------------------------------------------

Nach einem fatalen Fehler mu die šbersetzung sofort abgebrochen
werden. Eine Objektdatei kann in solchen Fallen nicht erzeugt
werden.

*** Cannot close output file
Das Betriebssystem kann die erzeugte Datei nicht schlieen.

*** Cannot create output file
Die Zieldatei kann nicht erzeugt werden. M”glicherweise ist die
Zieldiskette schreibgeschtzt, eine gleichnamige schreibgeschtzte
Datei existiert bereits oder es ist kein Platz auf dem Ziellaufwerk
vorhanden.

*** Cannot open include file
Der Assembler kann die angegebene Include-Datei nicht finden.
Entweder ist Ihnen ein Schreibfehler unterlaufen oder der Pfadname
existiert nicht.

*** Cannot open file
Der Assembler kann die angegebene Datei nicht finden. Entweder ist
Ihnen ein Schreibfehler unterlaufen oder der Pfadname existiert
nicht.

*** Internal error
*** Unknown error
Falls einer dieser Fehler auftritt, schreiben Sie sofort an Pure
Software. Nach M”glichkeit legen Sie ein Beispiel und eine
Beschreibung bei, wie es zu diesem Fehler kam, damit wir ihn
beheben k”nnen.

*** Out of memory
Sie haben zu wenig Arbeitsspeicher frei. Entfernen Sie alle
residenten Programme und Accessories. Starten Sie den Assembler
dann vom Desktop und unternehmen Sie einen neuen Versuch.

*** Seek error on output file
W„hrend eines Suchvorgangs in der Zieldatei trat ein Fehler auf.
M”glicherweise ist die Datei fehlerhaft.

*** Write error on output file
In die Zieldatei konnte nicht geschrieben werden. M”glicherweise
ist kein Platz mehr auf dem Ziellaufwerk vorhanden.
\end

screen( "Zeichensatz" )
Zeichensatz
----------------------------------------------------------------------

Der Pure Assembler erkennt den folgenden Zeichensatz:

- Die Buchstaben: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
                  a b c d e f g h i j k l m n o p q r s t u v w x y z
- Die Zahlen:     0 1 2 3 4 5 6 7 8 9
- Die Zeichen:    ! " # $ % & ' ( ) * + , - . / : ; < = >
                  ? [ ] ^ _ ` { | } ~ @.

- Die unsichtbaren Zeichen Leerstelle ( $20 ) und Tab ( $09 ).
- Die unsichtbaren Kontrollzeichen Carriage-Return ( $0D )
  und Line-Feed ( $0A ).

Eine Zeile darf maximal 512 Zeichen lang sein.
\end

screen( "Priorit„ten der Operatoren",
		"Operatoren, Priorit„ten der" )
Priorit„ten der Operatoren
----------------------------------------------------------------------

Die Operatoren haben unterschiedliche Gewichtung fr die Reihen-
folge der Auswertung. Die un„ren Operatoren und die Klammern
werden aufgrund der h”chsten Priorit„t zuerst verarbeitet. Die
geringste Priorit„t besitzen die Vergleichsoperatoren. Ausdrucke
mit Operatoren derselben Priorit„t werden von links nach rechts
ausgewertet.

Operator                    Priorit„t
-------------------------------------------------------
+  -  !  (  )               hoch
*  /  %  &  ^  <<  >>
+  -  |
==  !=  >=  >  <  <=        niedrig
-------------------------------------------------------
\end

screen( "Identifier",
		"Bezeichner" )
Bezeichner
----------------------------------------------------------------------

Ein Bezeichner ist eine Folge von einem oder mehreren Zeichen.
Fr das erste Zeichen drfen

      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
      a b c d e f g h i j k l m n o p q r s t u v w x y z
      ? _ ~ .

verwendet werden, fr alle weiteren Zeichen zusatzlich ($) und
(@), sowie die Ziffern

      1 2 3 4 5 6 7 8 9 0

nicht dagegen der Punkt (.).
Bezeichner dienen der Spezifikation von Befehlen, Datentypen und
Registernamen, Direktiven, sowie Makronamen und \link("Symbole")Labels\# bzw.
Symbolen. Alle Zeichen eines Bezeichners sind signifikant.
Zwischen Gro- und Kleinschreibung wird unterschieden.
\end

screen( "Register-Spezifikationen" )
Register-Spezifikationen
----------------------------------------------------------------------

Die verschieden Prozessoren der Motorola-Familie kennen zwei
unterschiedliche Betriebszust„nde. Der "Usermode" ist fr
Anwenderprogramme, der "Supervisormode" ist dem Betriebssytem
vorbehalten.

Im Usermode sind folgende Register erreichbar:

\#Datenregister\# 
\#Adreregister\#
\#Statusregister\#               ( eingeschr„nkter Zugriff )
\#Stackpointer\#                 ( eingeschr„nkter Zugriff )
\#Fliekomma-Datenregister\#     ( nur mit \#MC68881\#/2       )
\#FPU-Kontrollregister\#         ( nur mit \#MC68881\#/2       )

Im Supervisormode sind zus„tzlich folgende Register erreichbar:

\#Statusregister\#               ( voller Zugriff )
\#Stackpointer\#                 ( voller Zugriff )
\#CPU-Kontrollregister\#
\#PMMU-Kontrollregister\#

Bei den Registernamen wird Gro- und Kleinschreibung unterschieden,
d.h. Vbr bezieht sich nicht auf das Vector Base Register. Sie
mssen also entweder VBR oder vbr schreiben. Mit den Registernamen
gleichlautende Labelnamen sind nicht zul„ssig.
\end

screen( "Lokale Labels",
		"Labels, Lokale" )
Lokale Labels
----------------------------------------------------------------------

Lokale Labels sind \#Symbole\# mit  beschr„nktem Gltigkeits-
bereich. Man benutzt lokale Labels, um sich nicht st„ndig neue
Namen fr h„ufig wiederkehrende Konstrukte ausdenken zu mssen.
Ein lokales Label beginnt mit einem Punkt (.), gefolgt von einem
Labelnamen. Der Gltigkeitsbereich eines lokalen Labels ist auf
den Bereich zwischen zwei normalen Labels begrenzt.
Wenn Sie nun einen Programmabschnitt mit mehreren Schleifen haben, 
k”nnen Sie mit lokalen Labels programmieren:

            ...
Routine1:
            ...
.loop:      add.w   d0,(a0)+
            bne     .loop
            rts
            ...
Routine2:
            ...
.loop:      tst.l   -(a0)
            bne     .loop
            rts
            ...
\end

screen( "Symbole",
		"Sprungziel",
		"Label" )
Labels ( Spungziele )
----------------------------------------------------------------------

Labels oder Symbole sind \#Bezeichner\#, die als Referenz fr
Konstanten und Adressen dienen. Sie sind gltig in dem Modul, in
dem sie definiert wurden. Falls ohne Module gearbeitet wird,
bezieht sich die Gltigkeit auf den gesamten Quelltext. Der
Gltigkeitsbereich \#Lokale Labels\# erstreckt sich auf den Bereich
zwischen zwei normalen Labels.
Soll auf ein Label Bezug genommen werden, das in einem anderen Modul
oder Quelltext definiert wurde, so mu dieses Label importiert bzw.
exportiert werden.
Fr die Namen von Labels ist die einzige Restriktion, da sie nicht
mit Registernamen bereinstimmen drfen.
Labels k”nnen mit den Zuweisungsdirektiven \#=\#, \#EQU\#, \#SET\# oder \#REG\#
definiert werden. Labels k”nnen aber auch in Leerzeilen oder vor
Befehlen und einigen Direktiven vereinbart werden. Folgende
Syntax gilt:

             label:[label:...]

So definierte Labels mssen stets mit einem Doppelpunkt abge-
schlossen werden. Vor einem Label drfen Leerzeichen oder
Tabulatoren stehen. Dem Label wird der aktuelle Wert des
\link("Positionsz„hler")Positionz„hlers\# zugewiesen. Erneute Zuweisung eines anderen Wertes
ist fr diese Labels nicht mehr erlaubt.
\end

screen( "Gr”en-Spezifikationen" )
Gr”en-Spezifikationen
----------------------------------------------------------------------

Die Datenformate oder Gr”en-Spezifikationen der MC68xxx-Familie
k”nnen mit den folgenden Namen spezifiziert werden:

Namen   Typ     Gr”e                           Gr”e in Bits
-----------------------------------------------------------------
.b      .B      Byte                            8 Bit
.w      .W      Word                            16 Bit
.l      .L      Longword                        32 Bit
.s      .S      Single Precision Binary Real    32 Bit
.d      .D      Double Precision Binary Real    64 Bit
.x      .X      Extended Precision Binary Real  96 Bit
.p      .P      Packed Decimal Real             64 Bit
-----------------------------------------------------------------
\end

screen( "Konstanten, Numerische",
		"Numerische Konstanten" )
Numerische Konstanten
----------------------------------------------------------------------

Numerische Konstanten k”nnen in bin„rer, oktaler, dezimaler oder
hexadezimaler Schreibweise angegeben werden. Numerische Konstanten
sind 32-Bit Werte.
Bin„re Zahlen beginnen mit einem Prozentzeichen (%), gefolgt von
den Ziffern 0 und 1. Das erste Zeichen einer oktalen Zahl ist der
Klammeraffe (@). Danach drfen die Ziffern 0 bis 7 stehen.
Dezimalzahlen werden in gewohnter Weise geschrieben. Hexadezimale
Zahlen werden durch ein Dollarzeichen ($), 0x oder 0X eingeleitet.
Die eigentliche Zahl setzt sich dann aus den Ziffern 0 bis 9 und
den Buchstaben a bis f bzw. A bis F zusammen.
Zur besseren Lesbarkeit darf innerhalb der Konstanten der Unterstrich
(_) benutzt werden, beispielsweise 1_000_000 fr eine Million.
\end

screen( "Konstanten, String-",
		"Stringkonstanten" )
Stringkonstanten
----------------------------------------------------------------------

Stringkonstanten bestehen aus einer Folge von ASCII-Zeichen, die
durch einfache oder doppelte Anfhrungszeichen begrenzt wird. Um
Anfhrungszeichen in die Stringkonstante aufzunehmen, mu das
entsprechende Zeichen doppelt geschrieben werden. Steuerzeichen,
also Zeichen, deren ASCII-Code kleiner als 32 ist, sind nicht
erlaubt.
Ist ein String Parameter einer \#DC\#-, \#ASCII\#-, \#ASCIIL\#- oder \#ASCIIZ\#-
Direktive, so wird fr jedes Zeichen (mit Ausnahme der Begrenzer)
ein Byte erzeugt. In allen anderen F„llen darf der String maximal
vier Zeichen lang sein. Ist der String krzer als vier Zeichen,
so wird die 32-Bit Konstante von links mit Nullen gefllt.
\end

screen( "Positionsz„hler" )
Der Positionsz„hler
----------------------------------------------------------------------

Auf den aktuellen Assemblierungs-Positionsz„hler wird mit dem
Asterisk (*) bezug genommen. Wenn (*) in einem Ausdruck bentzt
wird, repr„sentiert das Zeichen die Adresse des ersten Bytes
des gegenw„rtigen Statements. Da der Asterisk (*) gleichzeitig
auch als Begrenzer fr \#Kommentare\# verwendet wird, empfiehlt es
sich, das Zeichen in Klammern einzuschlieen, damit es vom
Assembler korrekt interpretiert wird.
\end

screen( "Adressierungsarten" )
Adressierungsarten
----------------------------------------------------------------------

Die MC68nnn-Mikroprozessorfamilie untersttzt eine Vielzahl von
Adressierungsarten. Die Syntax wird so akzeptiert, wie sie in den
Motorola User Manuals beschrieben ist. Die folgende Tabelle zeigt
die Syntax fr die unterschiedlichen Adressierungsarten:

Syntax  Modus
-----------------------------------------------------------------
\#dn\#                              Datenregister direkt
\#an\#                              Adreregister direkt
(\#an\#)                            Adreregister indirekt
(\#an\#)+                           Adreregister indirekt
                                mit Postincrement
-(\#an\#)                           Adreregister indirekt
                                mit Predecrement
(\#disp\#,\#an\#) od. \#disp\#(\#an\#)          Adreregister indirekt mit
                                Displacement
(\#disp\#,\#an\#,\#xn\#) od. \#disp\#(\#an\#,\#xn\#)    Adreregister indirekt mit
                                Index und Displacement
([\#disp\#,\#an\#],\#disp\#,\#xn\#)             Post-Indexed
([\#disp\#,\#an\#,\#xn\#],\#disp\#)             Speicher indirekt Pre-Indexed
(\#disp\#,\link("pc (Abk.)")pc\#) od. \#disp\#(\link("pc (Abk.)")pc\#)          Program Counter relativ mit
                                Displacement
(\#disp\#,\link("pc (Abk.)")pc\#,\#xn\#) od. \#disp\#(\link("pc (Abk.)")pc\#,\#xn\#)    Program Counter relativ mit
                                Index u. Displacement
([\#disp\#,\link("pc (Abk.)")pc\#],\#disp\#,\#xn\#)             Program Counter Speicher indirekt
                                Post-Indexed
([\#disp\#,\link("pc (Abk.)")pc\#,\#xn\#]\#disp\#)              Program Counter Speicher indirekt
                                Pre-Indexed
\#addr\#                            Absolute Adresse
#\#data\#                           Immediate Data

-----------------------------------------------------------------

Querverweis: \link("Beispiele der Adressierungsar")Beispiele der Adressierungsarten\#
\end

screen( "Beispiele der Adressierungsar" )
Beispiele fr Standard-Adressierungsarten
----------------------------------------------------------------------
2
\link("Adreregister")a6\#
(\link("Adreregister")a0\#)
(\link("Adreregister")a3\#)+
-(\link("Stackpointer")sp\#)
100(\link("Adreregister")a2\#)                         entspricht (100,a2)
5(\link("Adreregister")a3\#,\link("Datenregister")d2\#)                        entspricht (5,a3,d2.w*1)
var(\link("pc (Abk.)")pc\#)                         entspricht (var,pc)
10(pc,a2.l)                     entspricht (10,pc,a2.l*1)
$1fff0000
#1000


Beispiele fr erweiterte Adressierungsarten
----------------------------------------------------------------------
(1000,\link("Adreregister")a2\#,\link("Datenregister")d0\#.l*8)
(\link("Datenregister")d2\#.l)                  Displacement und Base-Register
                        unterdrckt
(\link("Adreregister")a2\#,\link("Datenregister")d7\#*4)               Displacement unterdrckt
([-44,\link("Stackpointer")sp\#],1000,\link("Datenregister")d3\#.l)
([4,a2,d7.w*4],10)
([4,sp])                ueres displacement und Indexregister
                        unterdrckt
([d2.l],4)              Inneres Displacement und Indexregister
                        unterdrckt
([$1000])               ueres Displacement, Base-Register und
                        Indexregister unterdrckt
(var,\link("pc (Abk.)")pc\#,\link("Datenregister")d1\#.w*2)
($400,\link("ZPC")zpc\#)              Programmz„hler und Indexregister
                        unterdrckt
([var,\link("pc (Abk.)")pc\#,\link("Adreregister")a2\#.l],4)
([var,\link("pc (Abk.)")pc\#],d2.l)         ueres Displacement unterdrckt
([\link("ZPC")zpc\#])                 Beide Displacements, Programmz„hler und
                        Indexregister unterdrckt
\end

screen( "xn" )
xn      Entweder  ein  Datenregister oder ein  Adreregister. Auf
        den Registernamen kann optional eine Gr”en-spezifikation
        und ein Skalierungswert  folgen. Die Gr”en-spezifikation
        kann .w ( .W )  fr  Word  oder  .l ( .L )  fr  Longword
        sein.   Wenn  keine  Gr”e  angegeben  wird,   wird  Word
        angenommen.    Der   Skalierungswert   wird   durch   den
        Multiplikationsoperator ( * )  spezifiziert,  auf den ein
        Ausdruck ( 1, 2, 4 oder 8 )  folgt.  Der  voreingestellte
        Skalierungswert ist 1.
\end

screen( "pc (Abk.)" )
pc      Entweder  \link("pc (Abk.)")pc\# ( Program Counter )  oder \link("ZPC")zpc\# ( Zero Program
        Counter ). Wenn zpc spezifiziert ist,  wird  die Addition
        des Programmz„hlers w„hrend der Berechnung der effektiven
        Adresse unterdrckt. In diesem Fall ist das  Displacement
        tats„chlich eine absolute Adresse im Programmbereich.
\end

screen( "disp" )
disp    Ein Ausdruck,   der  das  Displacement  angibt,   das zum
        Inhalt  des  Base-Registers  w„hrend  der  Berechnung der
        effektiven Adresse   addiert  wird.   Der  Ausdruck  kann
        absolut, segmentrelativ oder extern sein.
        Wenn die  Adressierungsart  Program  Counter relative ist
        und der Programmz„hler nicht  unterdrckt  wird,  mu ein
        Ausdruck relativ  zum  gegenw„rtigen  Segment  sein.   In
        diesem  Fall  wird  der  Wert  des  \#Positionsz„hler\#s  vom
        Displacement  subtrahiert,  um das endgltige \link("pc (Abk.)")pc\#-relative
        Displacement zu ermitteln.
\end

screen( "addr" )
addr    Ein  Ausdruck,  der eine absolute Adresse im Datenbereich
        angibt. Der Ausdruck  kann  absolut,  segmentrelativ oder
        extern sein.
\end

screen( "data" )
data    Ein   Ausdruck,  der  Immediate  Daten spezifiziert.  Der
        Ausdruck kann absolut,  segmentrelativ  oder extern sein.
        Die   Syntax   der   indirekten   Adressierungsarten  mit
        Displacement  wurde  in den Motorola User Manuals fr den
        MC68020 abweichend von der  Syntax  frherer  \#Prozessor\#en
        definiert.  Wie  schon  in  der  Tabelle gezeigt,  werden
        vom Assembler beide Modi akzeptiert.
        Bei den  MC68000/08/10/12  Mikroprozessoren stehen einige
        Adressierungsarten  nicht zur Verfgung. Dabei handelt es
        sich um die Modi Memory  Indirect  und  Indexed mit einem
        Skalierungswert   abweichend  von  1. Displacement.   Ein
        Displacement  darf  16 Bit nicht berschreiten, wenn kein
        Indexregister bentzt wird.  Andernfalls ist das maximale
        Displacement 8 Bit.

        Bei den MC68020/30/40 Prozessoren  und  den MC68851/81/82
        Coprozessoren  stehen  s„mtliche  Adressierungsarten  zur
        Verfgung.  Allerdings  werden  diese  Erweiterungen  nur
        akzeptiert,   wenn  in  der  Befehlszeile  die  Option -2
        gesetzt wird.   Die  im  MC68020 User Manual als "generic
        modes"  bezeichneten  Erweiterungen  werden  untersttzt.
        Diese   Erweiterungen   werden   generiert,   indem   das
        Base-Register   und/oder  ein  Displacement   unterdrckt
        werden.  Der Assembler w„hlt automatisch das  kompakteste
        Kodierungsverfahren.

Hinweis:   Wenn  ein  Datenregister fr Indirektion bentzt wird,
ist Vorsicht angebracht, da Datenregister immer als Indexregister
behandelt werden und ihre voreingestellte Gr”e Word ist.
\end

screen( "Ausdrcke",
		"Operatoren" )
Ausdrcke und Operatoren
----------------------------------------------------------------------

Ausdrcke sind auswertbare Kombinationen von Operanden und Opera-
toren. Operanden sind Konstanten oder Symbole. Bei Operatoren
unterscheidet man \link("Operatoren, Un„re")un„re Operatoren\#, die einen Operanden haben
und \link("Operatoren, Bin„re")bin„re Operatoren\#, die zwei Operanden ben”tigen. Die Syntax
fr Ausdrucke orientiert sich an der der Programmiersprache C.
\end

screen( "Operatoren, Un„re",
		"Un„re Operatoren" )
Un„re Operatoren
----------------------------------------------------------------------

Der Operand eines un„ren Operators mu ein absoluter Wert sein.
Das Resultat ist wiederum ein absoluter Wert.

Operator   Operation
----------------------------------------------------------------------
+          ergibt den positiven Wert des Operanden
-          ergibt den negativen Wert des Operanden (Zweierkomplement)
!          negiert den Operanden (Einerkomplement)
----------------------------------------------------------------------
\end

screen( "Operatoren, Bin„re",
		"Bin„re Operatoren" )
Bin„re Operatoren
----------------------------------------------------------------------

Das Resultat der Vergleichsoperatoren ist die Konstante 0, wenn
die Relation nicht erfllt ist, ansonsten -1. Das Resultat ist
also ein absoluter Wert, unabh„ngig von den Operanden. Als
Ergebnis erh„lt man 0, wenn beide Operanden nicht absolut sind
oder nicht relativ im selben Segment sind. Folglich gibt es zwei
Ursachen fur das Resultat 0; entweder k”nnen die beiden Werte
nicht verglichen werden oder die Vergleichsbedingung ist nicht
erfllt.
Der Operator (+) erwartet mindestens einen absoluten Operanden.
Das Resultat ist vom Typ des anderen Operanden.
Fr den Operator (-) gibt es zwei gltige Operandenkombinationen.
Erstens kann der linke Operand absolut, relativ oder extern sein
und der rechte absolut. Zweitens drfen beide Operanden relativ
im selben Segment sein. Das Ergebnis ist immer absolut.
Fr alle anderen Operatoren mssen die Operanden absolut sein.

Operator   Operation
----------------------------------------------------------------------
+          Addition der beiden Operanden
-          Subtraktion des zweiten vom ersten Operanden
*          Multiplikation der beiden Operanden
/          Integerdivision des ersten durch den zweiten Operanden
%          Rest der Integerdivision des ersten durch den zweiten
           Operanden
|          Bitweise logische ODER-Verknupfung beider Operanden
&          Bitweise logische UND-Verknupfung beider Operanden
^          Bitweise logische EXKLUSIV-ODER-Verknupfung beider
           Operanden
<<         Schiebt die Bits des ersten Operanden um die im zweiten
           Operanden angegebene Zahl an Positionen nach links.
           Rechts werden Nullen nachgeschoben.
>>         Schiebt die Bits des ersten Operanden um die im zweiten
           Operanden angegebene Zahl an Positionen nach rechts.
           Links werden Nullen nachgeschoben.
=, ==      Prfung auf Gleichheit der beiden Operanden
!=,<>,#    Prfung auf Ungleichheit der beiden Operanden
>=         Prfung, ob der erste Operand gr”er oder gleich dem
           zweiten ist
>          Prfung, ob der erste Operand gr”er als der zweite ist
<=         Prfung, ob der erste Operand kleiner oder gleich dem
           zweiten ist
<          Prfung, ob der erste Operand kleiner als der zweite ist
----------------------------------------------------------------------
\end

screen( "Fliekomma-Konstanten",
		"Operator, Fliekomma-",
		"Ausdrcke, Fliekomma-",
		"Konstanten, Fliekomma-",
		"Fliekomma-Ausdrcke",
		"Fliekomma Operatoren" )
Fliekomma-Ausdrcke
----------------------------------------------------------------------

Ausdrcke, in denen ein Operand eine Fliekommazahl ist oder
dessen Datenformat eine Fliekommazahl spezifiziert, werden
als Fliekommaausdrcke ausgewertet.
Fliekommakonstanten beginnen mit dem Integer-Anteil. Danach
kann ein durch einen Punkt abgetrennter Nachkommaanteil stehen.
Schlielich kann ein mit einem E bzw. e eingeleiteter Exponential-
teil folgen:

     digits[.digits][E|e[+|-]digits]

Fur alle Fliekommaformate gibt es die beiden un„ren Vorzeichen-
operatoren (+) und (-) und die bin„ren Operatoren (+), (-), (*)
und (/).
Die Berechnungen erfolgen per Software im Format extended precision
binary real. Kann das Zielformat das Ergebnis einer Ausdrucks-
auswertung nicht aufnehmen, so wird bei einem šberlauf Unendlich
und bei einem Unterlauf eine Null erzeugt. Bei ungltigen Opera-
tionen wird ein NAN (eine ungltige Zahl) generiert, aber keine
Fehlermeldung ausgegeben!
\end

screen( "Kommentare" )
Kommentare
----------------------------------------------------------------------

Der Pure Assembler kennt mehrere M”glichkeiten, Kommentare zu
kennzeichnen.
Der Asterisk (*) leitet einen Kommentar ein, wenn er direkt am
Zeilenanfang oder nach einem Leerzeichen oder Tabulator steht.
Auf den Asterisk darf kein Gleichheits-, Plus- oder Minuszeichen
folgen. Das Zeilenende beendet den Kommentar.
Findet der Assembler ein Semikolon (;), so fat er die restlichen
Zeichen der Zeile als Kommentar auf.
Mehrzeilige Kommentare erreicht man mit den in C blichen
Kommentarbegrenzern /* und */.
Schlielich werden Zeilen, die mit einem Doppelkreuz (#) beginnen,
als Kommentarzeilen interpretiert. Erlaubt ist auch, da zwischen
Zeilenanfang und Doppelkreuz Leerzeichen oder Tabulatoren stehen.
\end

screen( "Datenregister",
		"dn",
		sensitive("D4"),
		sensitive("D6"),
		sensitive("D3"),
		sensitive("D7"),
		sensitive("D2"),
		sensitive("D1"),
		sensitive("D0"),
		sensitive("R0"),
		sensitive("R1"),
		sensitive("R2"),
		sensitive("R3"),
		sensitive("R4"),
		sensitive("R5"),
		sensitive("R6"),
		sensitive("D5"),
		sensitive("R7") )
Datenregister
----------------------------------------------------------------------

Die Datenregister der CPU k”nnen durch die Bezeichnungen d0 - d7,
D0 - D7, r0 - r7 bzw. R0 - R7 spezifiziert werden. 

Jedes Datenregister ist 32 Bit breit.  Byte Operanden belegen die
unteren  8 Bit,   Word  Operanden  die  unteren  16 Bit, Longword
Operanden  die  gesamten  32 Bit.  Das  erste  Bit wird als Bit 0
( Null ) bezeichnet.

Querverweis: \#Register-Spezifikationen\#
\end

screen( "Adreregister",
		"an",
		sensitive("R8"),
		sensitive("R10"),
		sensitive("A3"),
		sensitive("A4"),
		sensitive("R14"),
		sensitive("R9"),
		sensitive("A0"),
		sensitive("A5"),
		sensitive("R13"),
		sensitive("A6"),
		sensitive("R12"),
		sensitive("A2"),
		sensitive("A1"),
		sensitive("R11") )
Adreregister
----------------------------------------------------------------------

Die Adreregister  der CPU k”nnen durch die Bezeichnungen a0 - a7,
A0 - A7, r8 - r16 bzw.  R8 - R16  spezifiziert werden.  Der Stack-
pointer \#A7\# kann auch durch \#SP\# bzw. \link("Stackpointer")sp\# spezifiziert werden.  

Adreregister  sind  32  Bit  breit. Adreregister  k”nnen  nicht
byteweise benutzt werden.  Wird  ein  Adreregister  als  Source-
operand verwendet ist davon also  entweder  das untere Word, oder
das  gesamte  Langwort betroffen.  Wenn  ein  Adreregister   als
Destination  benutzt  wird, ist  davon  immer  das ganze Register
betroffen.  Word  Operationen bewirken eine automatische Erweite-
rung  des Operanden auf 32 Bit, wobei die Erweiterung vorzeichen-
behaftet ist. Alle  Adreregister lassen sich  als  Indexregister
verwenden.

Querverweis: \#Register-Spezifikationen\#
\end

screen( "Stackpointer",
		sensitive("R15"),
		sensitive("SP"),
		sensitive("A7") )
SP - Stackpointer
----------------------------------------------------------------------

Der Stack ist ein Speicherbereich, der nach dem LIFO-prinzip or-
ganisiert  ist.  (LIFO = Last In  First Out).  Solche  Speicher-
bereiche  nennt  man auch "Stapel".  Diese Bereiche  werden  zur 
Zwischenspeicherung  von  Rcksprungadressen, lokalen  Variablen
etc. verwendet. 

Das \#Adreregister\# a7  bezeichnet den gerade aktiven Stackpointer.
Dieses Register kann auch mit  sp  oder  SP angesprochen  werden.
Alle auf Adreregister  anwendbaren Befehle lassen sich auch  auf
den  Stackpointer anwenden.  Der Stackpointer kann  immer nur auf 
eine gerade Adresse zeigen.  Das bedeutet, da bei den Postinkre-
ment oder Predekrement \#Adressierungsarten\#  auch bei Bytezugriffen
der Stackpointer um 2 erh”ht bzw. erniedrigt wird.

Die  CPUs der  MC680x0-familie  kennen  insgesamt 3  verschiedene 
Stackpointer wobei jedoch immer nur einer aktiv ist.  Im Usermode
(siehe \link("Statusregister")sr\#) hat  man nur  Zugriff auf  den gerade  aktiven SP.  Im
Supervisormode kann man alle Stackpointer ansprechen.

Querverweis: \link("Supervisor Stackpointer")ssp\#, \link("User Stack Pointer")usp\#, \link("Interrupt Stack Pointer")isp\#, \link("Master Stack Pointer")msp\#
\end

screen( "Statusregister",
		sensitive("SR") )
SR - Statusregister
----------------------------------------------------------------------

Das Statusregister ist 16 Bit breit und aufgeteilt in:

            System-Byte         und          User-Byte (\link("Condition Codes, CPU")ccr\#)
   15  14  13  12 |    11  10  9               4 | 3   2   1   0
 [-------------------------------|-------------------------------]
 | T0| T1| S |*M*|   | I2| I1| I0|   |   |   | X | N | Z | V | C |
 +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 |       | |   |     |           |             |   |   |   |   |
 +-----+-+ |   |     +-----+-----+             |   |   |   |   |
\#Trace\#--+   |   |           |                   |   |   |   |   |
\link("SUPER")Supervisor\#-+   |           |                   |   |   |   |   |
\link("SUPER")Master\#---------+           |                   |   |   |   |   |
\#Interruptmaske\#-------------+                   |   |   |   |   |
                                               |   |   |   |   |
                                               |   |   |   |   |
\link("Extend-Flag")Extension\#--------------------------------------+   |   |   |   |
\#Negativ\#--------------------------------------------+   |   |   |
\#Null\#---------------------------------------------------+   |   |
\#šberlauf\#---------------------------------------------------+   |
\#Carry\#----------------------------------------------------------+

*T* und *M* erst ab MC68020 verfgbar.

Die Zugriffsrechte unterscheiden sich je nach Betriebszustand und Typ 
der CPU:

               | \#MC68000\#/8               | \#MC68010\# und h”her
---------------+-------------------------+-------------------------
\#USER\#mode       | lesen SR, schreiben CCR | lesen/schreiben CCR
---------------+-------------------------+-------------------------
\#SUPER\#visormode | voller Zugriff          | voller Zugriff
---------------+-------------------------+-------------------------
\end

screen( "Condition Codes, CPU",
		sensitive("CCR") )
CCR - Condition Code Register
----------------------------------------------------------------------

Das CCR enth„lt die Condition Codes. Es ist derjenige Teil des
\link("Statusregister")Statusregisters\#, der die Bedingungen (gesetzte oder nicht gesetzte
Flags) beinhaltet, welche die \#Programmstruktur-Befehle\# vor einer
Verzweigung abfragen.

Mnemonic: | Bedeutung:       | Flags wie abgefragt:
----------+------------------+----------------------
T         | True             | 1
F         | False            | 0
HI        | Higher           | ~C ^ ~Z = 1
LS        | Lower Same       | C v Z = 1
CC(HS)    | Carry Clear      | C = 0
CS(LO)    | Carry Set        | C = 1
NE        | Not Equal        | Z = 0
EQ        | Equal            | Z = 1
PL        | Plus             | N = 0
MI        | Minus            | N = 1
          |                  |
VC        | Overflow Clear   | V = 0
VS        | Overflow Set     | V = 1
GE        | Greater or Equal | N ^ V v ~N ^ ~V = 1
LT        | Less Than        | N ^ ~V v ~N ^ V = 1
GT        | Greater Than     | N ^ V ^ ~Z v ~N ^ ~V ^ ~Z
LE        | Less or Equal    | Z v N ^ ~V v ~N ^ V
\end

screen( "Interruptmaske" )
Interruptmaske
----------------------------------------------------------------------

Die CPU kennt insgesamt 8 verschiedene Interuptpriorit„ten. Priorit„t
0 bedeutet kein Interrupt.  Priorit„t 7 ist ein NMI (Non Maskable In-
terrupt).  Wird von der externen Hardware ein  Interrupt angefordert,
wird von der CPU geprft, ob es sich um einen NMI oder um eine Inter-
ruptpriorit„t, die gr”er dem Wert in der  Interruptmaske des Status-
registers \#SR\# handelt.  Ist dies nicht der Fall, so wird der Interrupt
ignoriert.

Ist der Interrupt nun gltig,  wird der  Interrupt von der CPU best„-
tigt.  Nun mu nun die externe Hardware mitteilen,  um welchen Inter-
rupt es sich  handelt.  Dabei wird zwichen \#Autovektor-Interrupt\#s  und
\#Non-Autovektor-Interrupt\#s unterschieden.
\end

screen( "Trace" )
TRACE - Die Tracebits des Statusregisters
----------------------------------------------------------------------

Die Tracebits im \#Statusregister\# zeigen an, ob sich die CPU im Tracemode
befindet oder nicht.  Ist der Tracemode eingeschaltet,  wird nach jedem
Befehl oder wechsel des  Programmflues eine \#Exception\# mit der Nummer 9
ausgel”t.

Die m”glichen Bitkombinationen und ihre Bedeutung


     T0 | T1 | Tracemode
    ----+----+--------------------------------------------
      0 |  0 | Trace ist ausgeschaltet
      1 |  0 | Trace bei jedem Befehl
      0 |  1 | Trace bei jedem Wechsel des Programmflues 
      1 |  1 | reserviert
\end

screen( "M”gliche Ver„nderungen" )
Die m”glichen Ver„nderungen des \#CCR\# im \#Statusregister\# nach einer 
Operation:

"E": Dieses Flag wird Je nach Ergebnis der Operation ver„ndert
"-": Dieses Flag wird nicht ver„ndert
"?": Dieses Flag ist nach der Operation undefiniert
"0": Dieses Flag wird nach der Operation gel”scht
"1": Dieses Flag wird nach der Operation gesetzt
\end

screen( "Extend-Flag" )
Extend-Flag
----------------------------------------------------------------------

Das Extend-Flag des Statusregisters ( \#SR\# ) wird i.d.R. genauso ge-
setzt, wie das \#Carry\#flag. Jedoch wird es bei manchen Befehlen nicht 
ver„ndert.

Querverweis: \#M”gliche Ver„nderungen\#
\end

screen( "Negativ" )
Negativflag
----------------------------------------------------------------------

Das Negativflag des Statusregisters ( \#SR\# ) wird, wenn nichts anderes an-
gegeben ist, gesetzt, wenn das Ergebnis einer Operation Negativ ist.

Querverweis: \#M”gliche Ver„nderungen\#
\end

screen( "Null" )
Nullflag
----------------------------------------------------------------------

Das Nullflag des Statusregisters ( \#SR\# ) wird, wenn nichts anderes an-
gegeben ist, gesetzt, wenn das Ergebnis einer Operation 0 ist.

Querverweis: \#M”gliche Ver„nderungen\#
\end

screen( "šberlauf",
		"Overflow" )
šberlaufflag
----------------------------------------------------------------------

Das šberlaufflag des Statusregisters ( \#SR\# ) wird, wenn nichts anderes 
angegeben ist, gesetzt,  wenn das Ergebnis einer Operation nicht mehr
in den gleichen  Zahlenbereich pat. D.H.  wenn z.B. die Summe zweier
positive Zahlen  eine negative Zahl ergibt.  Es wird also fr vorzei-
chenbehaftete Arithmetik ben”tigt.

Querverweis: \#M”gliche Ver„nderungen\#
\end

screen( "Carry" )
Carryflag
----------------------------------------------------------------------

Das Carryflag des Statusregisters ( \#SR\# ) wird, wenn nichts anderes an-
gegeben ist,  gesetzt, wenn das Ergebnis einer  Operation nicht in den
gleichen Datentyp pat. D.H. wenn z.B. die Summe zweier Worte nicht in
ein Wort pat, also ein "Borgen" stattfand.

Querverweis: \#M”gliche Ver„nderungen\#
\end

screen( "User Stack Pointer",
		sensitive("USP") )
USP - User Stack Pointer
----------------------------------------------------------------------

Der USP ist der aktive Stackpointer ( \#A7\# ), wenn das S-Flag des,
Statusregisters ( \#SR\# )  gel”scht ist.  Der explizite Zugriff auf
das USP ist nur im Supervisormode erlaubt, da im Usermode die Regis-
terbezeichnungen A7 bzw. SP verwendet wird.
\end

screen( "Supervisor Stackpointer",
		sensitive("SSP") )
SSP - Supervisor Stackpointer
----------------------------------------------------------------------

Der SSP ist der aktive Stackpointer ( \#A7\# ), wenn das S-Flag des,
Statusregisters ( \#SR\# ) gesetzt ist.  Die Prozessoren ab MC68020
unterscheiden dabei zwischen dem \link("Master Stack Pointer")msp\# und dem \link("Interrupt Stack Pointer")isp\#
\end

screen( "Program Counter",
		sensitive("PC") )
PC - Program Counter
----------------------------------------------------------------------

Der Program Counter ist  32 Bit  breit und zeigt auf den  n„chsten
auszufhrenden Befehl.

Beim MC68000/10 sind jedoch nur 24 Bit auf den Addressbus gefhrt.
Es  steht also ein  16 Megabyte groer  Addressraum zur Verfgung.
Beim MC68008 sind es 20 Bit also ein  1 Megabyte Addressraum. Beim
MC68012 sind es 21 Bit also ein 2 Gigabyte groer Addressraum. Fr
die Prozessoren MC68020/30/40 gelten die Werte 32 Bit bzw. 4 Giga-
byte Addressraum.

Der PC darf nie auf eine ungerade Adresse zeigen.
\end

screen( "CPU-Kontrollregister",
		"Kontrollregister, CPU" )
Die Kontrollregister
----------------------------------------------------------------------

\link("User Stack Pointer")usp\#     USP     User Stack Pointer
\link("Vector Base")vbr\#     VBR     Vector Base Register;              ( MC68010 )
\link("Destination Function Code")dfc\#     DFC     Destination Function Code Register ( MC68010 )
\link("Source Function Code")sfc\#     SFC     Source Function Code Register      ( MC68010 )
\link("Cache Control")cacr\#    CACR    Cache Control Register             ( MC68020 )
\link("Cache Address")caar\#    CAAR    Cache Address Register             ( MC68020 )
\link("Interrupt Stack Pointer")isp\#     ISP     Interrupt Stack Pointer            ( MC68020 )
\link("Master Stack Pointer")msp\#     MSP     Master Stack Pointer               ( MC68020 )

Querverweis: \#MOVEC\#, \#Register-Spezifikationen\#
\end

screen( "Vector Base",
		sensitive("VBR") )
VBR - Vector Base Register                                     MC68010
----------------------------------------------------------------------

Das VBR enth„lt die  Startaddresse der \#Exceptiontabelle\#.  Damit kann
man in einem Multitaskingsystem fr jeden Proze eine eigene Tabelle 
anlegen.
\end

screen( "Source Function Code",
		sensitive("SFC") )
SFC - Source Function Code Register                            MC68010
----------------------------------------------------------------------

Enth„lt den \#Function Code\# fr den \#MOVES\#-befehl bei lesendem 
Zugriff auf den Arbeitsspeicher.
\end

screen( "Destination Function Code",
		sensitive("DFC") )
DFC - Destination Function Code Register                       MC68010
----------------------------------------------------------------------

Enth„lt den \#Function Code\# fr den \#MOVES\#-befehl bei schreibendem 
Zugriff auf den Arbeitsspeicher.
\end

screen( "Function Code" )
Function Code
----------------------------------------------------------------------

Mit den 3 \#Function Code\# Leitungen der CPU teilt diese dem Haupt-
speicher mit ber welchen Address Space die CPU auf den Speicher
zugreifen will. Normalerweise werden diese Leitungen automatisch
gesetzt, ab der MC68010 CPU  kann diese aber auch fr den \#MOVES\#-
Befehl  eingesellt  werden.  Hierzu  verfgt  die CPU  ber  ein
\#Source Function Code\# und ein \#Destination Function Code\# Register.

Der Function Code kann  aber auch zur  \#Adrebersetzung\# verwen-
det werden.

Folgende Function Codes sind definiert:

               FC | Address Space
           -------+-------------------------
                0 | reserviert
                1 | \#User Data Space\#
                2 | \#User Program Space\#
                3 | unbenutzt
                4 | reserviert
                5 | \#Supervisor Data Space\#
                6 | \#Supervisor Program Space\#
                7 | \#CPU Space\#

Die PMMU \#MC68881\# verfgt ber eine vierte Function Code Leitung.
Damit wird der PMMU mitgeteilt, da ein anderer Baustein als die
CPU den  Bus kontroliert ( z.B. ein  DMA-Controller ).  Ist dies
der Fall, wird als \#Root Pointer\# das \#DRP\# verwendet.
\end

screen( "Function Code Spezifikation" )
Function Code Spezifikation
----------------------------------------------------------------------

Die \#PMMU-Befehle\#, welche den \#Function Code\# als Parameter erwarten,
k”nnen diesen auf folgende Arten erhalten:

1. Immediate - Der Function Code ist im PMMU-Befehl spezifiziert
2. \link("Datenregister")Dn\#        - Datenregister
3. \#SFC\#       - Source Function Code Register
4. \#DFC\#       - Destination Function Code Register

Beim \#MC68030\# bzw. \#MC68040\#  sind dies maximal  3 Bits fr den Func-
tion Code,  beim \#MC68851\# sind dies maximal 4 Bits,  wenn der Func-
tion Code nicht ber einer der beiden Function Code Register ber-
geben wird.

Querverweis: \#PFLUSH\#, \#PLOAD\#, \#PTEST\#
\end

screen( "User Data Space" )
User Data Space
----------------------------------------------------------------------

Dieser \#Function Code\# zeigt an, da die CPU Userdaten ( sie befindet
sich also im Usermode ) schreibt oder liest.
\end

screen( "User Program Space" )
User Program Space
----------------------------------------------------------------------

Dieser \#Function Code\# zeigt an, da die CPU Userbefehle ( sie befindet
sich also im Usermode ) liest.
\end

screen( "Supervisor Data Space" )
Supervisor Data Space
----------------------------------------------------------------------

Dieser \#Function Code\# zeigt an, da die CPU Supervisordaten ( sie 
befindet sich also im Supervisormode ) schreibt oder liest.
\end

screen( "Supervisor Program Space" )
Supervisor Program Space
----------------------------------------------------------------------

Dieser \#Function Code\# zeigt an, da die CPU Supervisorbefehle ( sie
befindet sich also im Supervisormode ) liest.
\end

screen( "CPU Space" )
CPU Space
----------------------------------------------------------------------

Dieser \#Function Code\# zeigt an,  da die CPU von sich aus auf den Haupt-
speicher zugreift ( um z.B. die  Nummer eines \#Non-Autovektor-Interrupt\#s
zu holen ).
\end

screen( "Cache Address",
		sensitive("CAAR") )
CAAR - Cache Address Register                                  MC68020
----------------------------------------------------------------------

Das CAAR ist 32 Bit breit und enth„lt in den Bits 2 bis 7 den Index fr 
die  "Clear Cache Entry"  Funktion(en)  des \#CACR\#. Alle anderen Bit sind
fr zuknftige Versionen reserviert und sollten nicht ver„ndert werden.
\end

screen( "Cache Control",
		sensitive("CACR") )
CACR - Cache Control Register                                  MC68020
----------------------------------------------------------------------

Das CACR ist 32 Bit breit und hat folgenden Aufbau:

 31  14  13   12    11   10    9    8   7    5  4     3    2    1     0
+------+----+-----+----+-----+----+----+------+-----+----+-----+----+----+ 
|unused|*WA*|*DBE*|*CD*|*CED*|*FD*|*ED*|unused|*IBE*| CI | CEI | FI | EI |
+------+----+-----+----+-----+----+----+------+-----+----+-----+----+----+
         |    |     |    |     |    |           |     |    |     |    |
\link("Write Allocate")Write\#    |    |     |    |     |    |           |     |    |     |    |
\link("Write Allocate")Allocate\#-+    |     |    |     |    |           |     |    |     |    | 
\#Data Burst Enable\#   |    |     |    |           |     |    |     |    |
\#Clear Data Cache\#----+    |     |    |           |     |    |     |    |
\#Clear Entry in Data Cache\#+     |    |           |     |    |     |    |
\#Freeze Data Cache\#--------------+    |           |     |    |     |    |
\#Enable Data Cache\#-------------------+           |     |    |     |    |
\#Instruction Burst Enable\#------------------------+     |    |     |    |
\#Clear Instruction Cache\#-------------------------------+    |     |    |
\link("Clear Entry in Instruction Ca")Clear Entry in Instruction Cache\#---------------------------+     |    |
\#Freeze Instruction Cache\#-----------------------------------------+    |
\#Enable Instruction Cache\#----------------------------------------------+

Die mit * gekennzeichneten Bits sind erst ab MC68030 verfgbar.
\end

screen( "Write Allocate" )
Write Allocate Flag
----------------------------------------------------------------------

Das Write Allocate Flag des Cache Control Registers ( \#CACR\# ) gibt an,
ob das  Datencache auch bei Schreibzugriffen aktualisert  werden soll
oder nicht. Ist das Flag gel”scht wird das Datencache nur dann aktua-
lisert,  wenn ein Lesezugriff oder ein  Schreibzugriff auf eine Spei-
cherstelle, die sich im Cache befindet stattfindet.

Wenn es gesetzt ist, wird das Cache bei jedem Zugriff aktualisert. Es
sollte immer  dann gesetzt  werden,  wenn  unterschiedliche  logische
Adressen mit  der PMMU auf  gleiche physikalische Adressen  bersetzt 
werden.

Diese  Flag wird ignoriert,  wenn das  Datencache ausgeschaltet  oder
eingefroren ist.
\end

screen( "Data Burst Enable" )
Data Burst Enable Flag
----------------------------------------------------------------------

Ist das  Data Burst Enable Flag des  Cache Control Registers ( \#CACR\# )
gesetzt wird eine Zeile (16 Bytes) des Datencache auf einmal eingele-
sen.  Dies ist jedoch  nur dann  sinnvoll,  wenn der  Arbeitsspeicher
schnell genug ist.
\end

screen( "Clear Data Cache" )
Clear Data Cache Bit
----------------------------------------------------------------------

Wird das  Clear Data Cache  Bit des  Cache Control Registers ( \#CACR\# ) 
gesetzt,  so wird das komplette Datencache gel”scht.  Dieses Bit wird
immer als 0 gelesen.
\end

screen( "Clear Entry in Data Cache" )
Clear Entry in Data Cache Bit
----------------------------------------------------------------------

Wird das  Clear Entry in Data Cache  Bit des  Cache Control Registers
( \#CACR\# ) gesetzt,  so wird ein Eintrag,  der durch das  Cache Address 
Register ( \#CAAR\# ) spezifiziert wird, gel”scht.  Dieses Bit wird immer
als 0 gelesen.
\end

screen( "Freeze Data Cache" )
Freeze Data Cache Flag
----------------------------------------------------------------------

Wird das Freeze Data Cache Flag  des Cache Control Registers ( \#CACR\# )
gesetzt,  wird das Datencache eingefroren.  Dies bedeutet,  da keine
neuen Eintr„ge im Cache angelegt werden. Schreibzugriffe aktuallisie-
ren aber den Inhalt der Eintr„ge weiterhin.
\end

screen( "Enable Data Cache" )
Enable Data Cache Flag
----------------------------------------------------------------------

Wird das Enable Data Cache Flag  des Cache Control Registers ( \#CACR\# )
gesetzt,  wird das Datencache eingeschaltet.  Ist es gel”scht, erfol-
gen Zugriffe auf Daten immer ber das externe RAM.
\end

screen( "Instruction Burst Enable" )
Instruction Burst Enable Flag
----------------------------------------------------------------------

Ist das  Instruction Burst Enable  Flag des  Cache Control Registers
( \#CACR\# )  gesetzt wird  eine Zeile  (16 Bytes) des  Befehlscache auf
einmal  eingelesen.  Dies ist  jedoch  nur dann  sinnvoll,  wenn der
Arbeitsspeicher schnell genug ist.
\end

screen( "Clear Instruction Cache" )
Clear Instruction Cache Bit
----------------------------------------------------------------------

Wird das  Clear Instruction Cache  Bit des  Cache Control  Registers
( \#CACR\# ) gesetzt,  so wird das komplette Befehlscache gel”scht. Die-
ses Bit wird immer als 0 gelesen.
\end

screen( "Clear Entry in Instruction Ca" )
Clear Entry in Instruction Cache Bit
----------------------------------------------------------------------

Wird das Clear Entry in Instruction Cache  Bit des Cache Control Re-
gisters ( \#CACR\# ) gesetzt,  so wird ein Eintrag, der durch das  Cache
Address Register ( \#CAAR\# )  spezifiziert wird,  gel”scht.  Dieses Bit
wird immer als 0 gelesen.
\end

screen( "Freeze Instruction Cache" )
Freeze Instruction Cache Flag
----------------------------------------------------------------------

Wird das  Freeze Instruction Cache Flag  des Cache Control  Registers 
( \#CACR\# ) gesetzt,  wird das Befehlscache eingefroren.  Dies bedeutet,
da keine neuen Eintr„ge im Cache angelegt werden.
\end

screen( "Enable Instruction Cache" )
Enable Instruction Cache Flag
----------------------------------------------------------------------

Wird das Enable Instruction Cache Flag   des Cache Control Registers
( \#CACR\# ) gesetzt,  wird das  Befehlscache eingeschaltet.  Ist es ge-
l”scht, werden Befehle immer ber das externe RAM geholt.
\end

screen( "Interrupt Stack Pointer",
		sensitive("ISP") )
ISP - Interrupt Stack Pointer                                  MC68020
----------------------------------------------------------------------

Der ISP ist der aktive Stackpointer ( \#A7\# ), wenn das S-Flag gesetzt
und das M-Flag des Statusregisters ( \#SR\# ) gel”scht ist.  Das M-Flag
wird automatisch beim  Auftreten eines externen  Interupts gel”scht
und  nach Abarbeitung  der Interupt Service Routine  wieder restau-
riert.

Querveweis: \link("Master Stack Pointer")msp\#, \link("Supervisor Stackpointer")ssp\#
\end

screen( "Master Stack Pointer",
		sensitive("MSP") )
MSP - Master Stack Pointer                                     MC68020
----------------------------------------------------------------------

Der MSP ist der aktive Stackpointer ( \#A7\# ), wenn sowohl das S-Flag,
als auch das M-Flag des Statusregisters ( \#SR\# ) gesetzt ist.

Querverweis:  \link("Interrupt Stack Pointer")isp\#, \link("Supervisor Stackpointer")ssp\#
\end

screen( sensitive("ZPC") )
ZPC - Zero Program Counter                  \#MC68020\# Adressierungsmodus
----------------------------------------------------------------------

siehe auch: \link("pc (Abk.)")\#
\end

screen( "FPn",
		"Fliekomma-Datenregister",
		sensitive("FP6"),
		sensitive("FP5"),
		sensitive("FP2"),
		sensitive("FP4"),
		sensitive("FP0"),
		sensitive("FP7"),
		sensitive("FP1"),
		sensitive("FP3") )
FPn - Fliekomma-Datenregister                                 MC68881
----------------------------------------------------------------------

Die Datenregister der FPU k”nnen durch die Bezeichnungen fp0 - fp7,
bzw. FP0 - FP7 spezifiziert werden. 

Jedes Fliekomma-Datenregister ist 80 Bit breit.  Die Daten werden 
prinzipiel Extended gespeichert.  Berechnungen erfolegen ebenfalls
immer Extended.  Nur wenn Daten in den  Speicher bertragen werden
(\#FMOVE\#) erfolgt eine Umwandlung nach BYTE, WORD, LONGWORD, SINGLE,
oder DOUBLE.

Querverweis: \#Register-Spezifikationen\#
\end

screen( "FPU-Kontrollregister",
		"Kontrollregister, FPU" )
Neben den 8 Datenregister \#FPn\# enth„lt die  FPU
noch einige zus„tzliche Register:

\link("Fliekomma-Kontrollregister")fpcr\#    FPCR    Fliekomma-Kontrollregister
\link("Fliekomma-Statusregister")fpsr\#    FPSR    Fliekomma-Statusregister
\link("Fliekomma-Befehlsadreregist")fpiar\#   FPIAR   Fliekomma-Befehlsadreregister
 
Querverweis: \#FMOVE FPcr\#, \#FMOVEM FPcr\#, \#Register-Spezifikationen\#
\end

screen( "Fliekomma-Kontrollregister",
		sensitive("FPCR") )
FPCR Fliekomma-Kontrollregister                               MC68881
----------------------------------------------------------------------

Das Fliekomma-Kontrollregister ist 32 Bit breit und hat folgenden
Aufbau:

                                \#Exception Enable\#  \#Mode Control\#
                                       |               |
                                 <-------------> <------------->
+-------------------------------+---------------+---------------+
|   Unbenutzt (immer 0)         |x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|
+-------------------------------+---------------+---------------+
 |                               |               |             |
 31                              15              7             0

Das unbenutzte Wort dieses  Registers wird immer als 0 gelesen und
man sollte auch immer eine 0 reinschreiben, um fr zuknftige Ver-
sionen sicher kompatibel zu sein.
\end

screen( "Exception Enable" )
Exception Enable
----------------------------------------------------------------------

Mit  dem  Exception Enable  Byte des  \#Fliekomma-Kontrollregister\#s
k”nnen Sie jeden der 8 m”glichen Fliekomma-\#Exception\#s einzeln ein
(1) bzw. ausschalten (0).

Der Aufbau dieses Bytes ist folgender:

         15     14     13      12     11     10   9       8
        +------+------+-------+------+------+----+-------+-------+
        | BSUN | SNAN | OPERR | OVFL | UNFL | DZ | INEX2 | INEX1 |
        +------+------+-------+------+------+----+-------+-------+
          |      |      |       |      |      |    |       |
\link("BSUN")Branch\#----+      |      |       |      |      |    |       |
\link("BSUN")Set On\#           |      |       |      |      |    |       |
\link("BSUN")Unordered\#        |      |       |      |      |    |       |
\#Signaling NaN\# ---+      |       |      |      |    |       |
(Not a Number)          |       |      |      |    |       |
\#Operand Error\#-----------+       |      |      |    |       |
\#FPU overflow\#--------------------+      |      |    |       |
\#FPU underflow\#--------------------------+      |    |       |
\#Divide by Zero\#--------------------------------+    |       |
\#Inexact Result\#-------------------------------------+       |
\#Inexact Decimal Input\#--------------------------------------+
\end

screen( "Mode Control" )
Mode Control
----------------------------------------------------------------------

Mit dem Mode Control Byte des \#Fliekomma-Kontrollregister\#s k”nnen 
Sie festlegen, wie die FPU das Ergebnis einer Fliekommaoperation
runden soll.

Der Aufbau dieses Bytes ist folgender:

                7    6 5     4 3         0
               +------+-------+-----------+
               | PREC |  RND  | unbenutzt |
               +------+-------+-----------+
                |      |
Rounding Precision    Rounding Mode
 00 Extended           00 To Nearest
 01 Single             01 Toward Zero
 10 Double             10 Toward -ß
 11 Reserved           11 Toward +ß
\end

screen( "Fliekomma-Statusregister",
		sensitive("FPSR") )
FPSR - Fliekomma-Statusregister                               MC68881
----------------------------------------------------------------------

Das Fliekomma-Statusregister ist 32 Bit breit und hat folgenden
Aufbau:

 \#Condition Code\#     \#Quotient\#    \#Exception Status\# \#Accrued Exception\#
        |               |               |               |
 <-------------> <-------------> <-------------> <------------->
+---------------+---------------+---------------+---------------+
|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|
+---------------+---------------+---------------+---------------+
 |               |               |               |             |
 31              23              15              7             0
\end

screen( "Condition Code" )
Condition Code                                                 MC68881
----------------------------------------------------------------------

Das Condition Code Byte des \#Fliekomma-Statusregister\#s ent-
h„lt Flags,  welche bestimmte  Zust„nde des Ergebnis  einer
Fliekommaoperation anzeigt. Es entspricht dem \#CCR\# der CPU.
Diese  Flags werden fr die  \link("Condition Codes, FPU")Bedingungen\# der bedingten  Be-
fehle abgefragt.

Es hat folgenden Aufbau:

               31       28  27  26  25    24
              +-----------+---+---+---+-----+
              | unbenutzt | N | Z | I | NaN |
              +-----------+---+---+---+-----+
                           |   |   |   |
Negative-------------------+   |   |   |
Zero---------------------------+   |   |
ß (Inf)----------------------------+   |
Not a Number---------------------------+
or Unordered

NaN heit,  da das Ergebnis einer Fliekommaoperation undefiniert
ist. Unordered heit, da das Argument einer Funktion oder 1 Oper-
ator einer Operation NaN war.
\end

screen( "Condition Codes, FPU" )
IEEE Non-Aware Tests:
----------------------------------------------------------------------

Alle folgenden Tests (bis auf EQ und NE) l”sen eine \#BSUN\# Ex-
ception aus, wenn das NaN Bit im \#Condition Code\# Byte gesetzt
ist. 

Mnemonic: | Bedeutung:                    | Flags wie abgefragt:
----------+-------------------------------+-----------------------
EQ        | Equal                         | Z
NE        | Not Equal                     | ~Z
GT        | Greater Than                  | ~( NaN v Z v N )
NGT       | Not Greater Than              | NaN v Z v N
GE        | Greater or Equal              | Z v ~( NaN v N )
NGE       | Not( Greater or Equal )       | NaN v ( N ^ ~Z )
LT        | Less Than                     | N ^ ~( NaN v Z )
NLT       | Not Less Than                 | NaN v ( Z v ~N )
LE        | Less or Equal                 | Z v ( N ^ NaN )
NLE       | Not( Less or Equal )          | NaN v ~( N v Z )
GL        | Greater or Less               | ~( Nan v Z )
NGL       | Not ( Greater or Less )       | NaN v Z
GLE       | Greater, Less or Equal        | ~NaN
NGLE      | Not( Greater, Less or Equal ) | NaN


IEEE Aware Tests:
----------------------------------------------------------------------

Alle folgenden Tests setzen das BSUN-Bit unter gar keinen Umst„nden.

Mnemonic: | Bedeutung:                    | Flags wie abgefragt:
----------+-------------------------------+-----------------------
EQ        | Equal                         | Z
NE        | Not Equal                     | ~Z
OGT       | Ordered Greater Than          | ~( NaN v Z v N )
ULE       | Unordered or Less or Equal    | NaN v Z v N
OGE       | Ordered Greater or Equal      | Z v ~( NaN v N )
ULT       | Unordered or Less Than        | NaN v ( N ^ ~Z )
OLT       | Ordered Less Than             | N ^ ~( NaN v Z )
UGE       | Unordered or Gretaer or Equal | NaN v Z v N
OLE       | Ordered Less or Equal         | Z v ( N ^ ~NAN )
UGT       | Unordered or Greater Than     | NaN v ~( N v Z )
OGL       | Ordered Greater or Less       | ~( NaN v Z )
UEQ       | Unordered or Equal            | NaN v Z
OR        | Ordered                       | ~NaN
UN        | Unordered                     | NaN


Miscellaneous Tests:
----------------------------------------------------------------------

SF, ST, SEQ und SNE l”sen eine \#BSUN\# Exception aus, wenn  das 
NaN Bit im \#Condition Code\# Byte gesetzt ist. 

Mnemonic: | Bedeutung:                    | Flags wie abgefragt:
----------+-------------------------------+-----------------------
F         | False                         | 0
T         | True                          | 1
SF        | Signaling False               | 0
ST        | Signaling True                | 1
SEQ       | Signaling Equal               | Z
SNE       | Signaling Not Equal           | ~Z
\end

screen( "Quotient" )
Quotient Byte
----------------------------------------------------------------------

Das Quotient Byte des  \#Fliekomma-Statusregister\#s wird nach ei-
ner Modulo-operation ( \#FMOD\# oder \#FREM\# ) gesetzt und enth„lt den
Quotienten der dabei berechneten Division.

Es hat folgenden Aufbau:

                 23  22            16
                +---+----------------+
                | S |    Quotient    |
                +---+----------------+
                 |       |
Vorzeichen-------+       |
7 wenigst signifikante---+
Bits
\end

screen( "Exception Status" )
Exception Status
----------------------------------------------------------------------

Mit dem  Exception Status  Byte des \#Fliekomma-Statusregister\#s
wird angezeigt welche Ausnahmebedingung bei der letzten Flie-
kommaoperation auftrat.  Die einzelnen  Bits werden  auch dann
gesetzt, wenn das entsprechende Bit des \#Exception Enable\# Bytes
im \#Fliekomma-Kontrollregister\# gesetzt ist.

Der Aufbau dieses Bytes ist folgender:

         15     14     13      12     11     10   9       8
        +------+------+-------+------+------+----+-------+-------+
        | BSUN | SNAN | OPERR | OVFL | UNFL | DZ | INEX2 | INEX1 |
        +------+------+-------+------+------+----+-------+-------+
          |      |      |       |      |      |    |       |
\link("BSUN")Branch\#----+      |      |       |      |      |    |       |
\link("BSUN")Set On\#           |      |       |      |      |    |       |
\link("BSUN")Unordered\#        |      |       |      |      |    |       |
\#Signaling NaN\# ---+      |       |      |      |    |       |
(Not a Number)          |       |      |      |    |       |
\#Operand Error\#-----------+       |      |      |    |       |
\#FPU overflow\#--------------------+      |      |    |       |
\#FPU underflow\#--------------------------+      |    |       |
\#Divide by Zero\#--------------------------------+    |       |
\#Inexact Result\#-------------------------------------+       |
\#Inexact Decimal Input\#--------------------------------------+
\end

screen( "Accrued Exception" )
Accrued Exception
----------------------------------------------------------------------

Mit dem Accrued Exception  Byte des \#Fliekomma-Statusregister\#s
wird angezeigt welche Ausnahmebedingung seit dem letzten Reset
bzw. seit dem letzten l”schen dieses Bytes.

Der Aufbau dieses Bytes ist folgender:

             7     6     5      4    3      2         0
            +-----+-----+------+----+------+-----------+
            | IOP | OVL | UNFL | DZ | INEX | unbenutzt |    
            +-----+-----+------+----+------+-----------+
              |     |     |      |    |
\#Invalid Operation\#   |     |      |    |
\#FPU overflow\#--------+     |      |    |
\#FPU underflow\#-------------+      |    |
\#Divide by Zero\#-------------------+    |
\#Inexact Operation\#---------------------+

INEX wird auch bei einem  \#FPU overflow\# gesetzt.  UNFL wird nur
dann gesetzt, wenn \#FPU underflow\# und \#Inexact Result\# gleichzei-
tig auftraten.
\end

screen( "Invalid Operation" )
Invalid Operation
----------------------------------------------------------------------

Das IOP-Flag des \#Accrued Exception\# Bytes im Fliekomma-Status-
register ( \#FPSR\# )  wird dann gesetzt,  wenn eine Branch/Set on
Unordered-Bedingung ( \#BSUN\# ), ein ungltiges Ergebnis oder ein
\#Operandenfehler\# auftrat.
\end

screen( "Fliekomma-Befehlsadreregist",
		sensitive("FPIAR") )
FPIAR - Fliekomma-Befehlsadreregister                        MC68881
----------------------------------------------------------------------

Das   Fliekomma-Befehlsadreregister   ist  sozusagen der \#PC\#
(Programm Counter) der FPU. Der  Grund fr  das Vorhandensein 
dieses Registers ist, da die FPU  unabg„ngig von der CPU die
Befehle  ausfhren kann.  Tritt  nun eine  Exception auf,  so 
k”nnte man ohne dieses Register nicht feststellen, an welcher
Stelle der aktuelle Befehl der FPU steht.
\end

screen( "PMMU-Kontrollregister",
		"Kontrollregister, PMMU" )
Die Kontrolregister der PMMU
----------------------------------------------------------------------

\link("CPU Root Pointer")crp\#     CRP     CPU Root Pointer          ( MC68851, MC68030 )
\link("Supervisor Root Pointer")srp\#     SRP     Supervisor Root Pointer   ( MC68851, MC68030 )
\link("DMA Root Pointer")drp\#     DRP     DMA Root Pointer                   ( MC68851 )
-----------------------------------------------------------------
\link("Translation Control")tc\#      TC      Translation Control Reg.  ( MC68851, MC68030 )
\link("PMMU-Statusregister")psr\#     PSR     PMMU Statusregister       ( MC68851, MC68030 )
\link("PCSR")pcsr\#    PCSR    PMMU Cache Statusregister          ( MC68851 )
-----------------------------------------------------------------
\link("Current Access Level")cal\#     CAL     Current Access Level Register      ( MC68851 )
\link("Validate Access Level")val\#     VAL     Validate Access Level Register     ( MC68851 )
\link("Access Control")ac\#      AC      Access Control Register            ( MC68851 )
-----------------------------------------------------------------
\link("Transparent Translation")tt0\#     TT0     Transparent Translation Register 0 ( MC68030 )
\link("Transparent Translation")tt1\#     TT1     Transparent Translation Register 1 ( MC68030 )
-----------------------------------------------------------------
\link("Breakpoint Acknowledge Datenr")bad0\#    BAD0
\link("Breakpoint Acknowledge Datenr")bad1\#    BAD1
\link("Breakpoint Acknowledge Datenr")bad2\#    BAD2
\link("Breakpoint Acknowledge Datenr")bad3\#    BAD3    Breakpoint Acknowledge Datenregister
\link("Breakpoint Acknowledge Datenr")bad4\#    BAD4    ( MC68851 )
\link("Breakpoint Acknowledge Datenr")bad5\#    BAD5
\link("Breakpoint Acknowledge Datenr")bad6\#    BAD6
\link("Breakpoint Acknowledge Datenr")bad7\#    BAD7
-----------------------------------------------------------------
\link("Breakpoint Acknowledge Contro")bac0\#    BAC0
\link("Breakpoint Acknowledge Contro")bac1\#    BAC1
\link("Breakpoint Acknowledge Contro")bac2\#    BAC2
\link("Breakpoint Acknowledge Contro")bac3\#    BAC3    Breakpoint Acknowledge Control Register
\link("Breakpoint Acknowledge Contro")bac4\#    BAC4    ( MC68851 )
\link("Breakpoint Acknowledge Contro")bac5\#    BAC5
\link("Breakpoint Acknowledge Contro")bac6\#    BAC6
\link("Breakpoint Acknowledge Contro")bac7\#    BAC7
-----------------------------------------------------------------

Querverweis: \#PMOVE\#, \#Register-Spezifikationen\#
\end

screen( "CPU Root Pointer",
		sensitive("CRP") )
CRP - CPU Root Pointer                                MC68851, MC68030
----------------------------------------------------------------------

Der CPU \#Root Pointer\# wird zur \#Adrebersetzung\# verwendet, falls die 
CPU sich im Usermode  befindet oder der \#Supervisor Root Pointer\# aus-
geschaltet ist.
\end

screen( "Supervisor Root Pointer",
		sensitive("SRP") )
SRP - Supervisor Root Pointer                         MC68851, MC68030
----------------------------------------------------------------------

Der  Supervisor \#Root Pointer\# wird zur  \#Adrebersetzung\#  verwendet,
falls die CPU sich im Supervisormode befindet und das Register nicht mit
dem SRE Flag des  Translation Control Registers ( \#TC\# ) ausgeschaltet
ist.
\end

screen( "DMA Root Pointer",
		sensitive("DRP") )
DRP - DMA Root Pointer                                     Nur MC68851
----------------------------------------------------------------------

Der DMA \#Root Pointer\# wird zur \#Adrebersetzung\# verwendet, falls der
Bus gerade von einem anderen Baustein ( DMA ) gesetuert wird.
\end

screen( "Root Pointer" )
Root Pointer
----------------------------------------------------------------------

Die Root Pointer der PMMU ( \#CRP\#, \#SRP\# und \#DRP\# ) haben folgenden Aufbau:

 63  62     48 47        42  41  40        34 33  32 31         4 3      0
+---+---------+------------+----+------------+------+------------+--------+
|L/U|  Limit  | reserviert |*SG*| reserviert |  DT  |     TA     | unused |
+---+---------+------------+----+------------+------+------------+--------+
   |         |                |                  |         |
\#Limitflag\#    |                |                  |         |
\#Limitfield\#---+                |                  |         |
\#Shared Globaly\#----------------+                  |         |
\#Descriptor Type\#----------------------------------+         |
\#Table Address\#----------------------------------------------+

SG ist nur im MC68851 implementiert.
\end

screen( "Descriptor" )
Descriptor
----------------------------------------------------------------------

Descriptoren einer šbersetzungstabelle haben immer die gleiche Gr”e
von 4 oder 8 Byte.  Wie Gro nun die Eintr„ge einer  šbersetzungsta-
belle sind, wird vom \#Descriptor Type\# der vorherigen Knotens des šber-
setzungsbaums festgelegt.

Querverweis: \#Adrebersetzung\#
\end

screen( "Limitflag" )
Limitflag
----------------------------------------------------------------------

Das Limitflag der \#Descriptor\#en zeigt an, ob das \#Limitfield\# der Descrip-
toren eine obere ( gel”scht ) oder untere ( gesetzt ) Grenze darstellt.
\end

screen( "Limitfield" )
Limitfield
----------------------------------------------------------------------

Das  Limitfield  der  \#Descriptor\#en  enth„lt die  obere (  \#Limitflag\# ge-
l”scht ) bzw.  untere Grenze  der n„chsten  Descriptortabelle,  auf die
\#Table Address\# zeigt.
\end

screen( "Descriptor Type" )
Descriptor Type
----------------------------------------------------------------------

Das Descriptor Type Field enth„lt die Art des aktuellen \#Descriptor\# oder
die  Gr”e der  Eintr„ge der  n„chsten Tabelle,  auf die  \#Table Address\#
zeigt.

Die m”glichen Werte sind:
$0 INVALID
   Der aktuelle Descriptor ist ungltig. Erh„lt einer der \#Root Pointer\#
   diesen Wert, so wird ein \#PMMU-Fehler\# ausgel”st. Findet die PMMU bei
   der   \#Adrebersetzung\#  einen  solchen  Descriptor,  so  wird  ein 
   \#Busfehler\# ausgel”st. Ein Betriebssytem kann dies dazu ausnutzen, um
   nicht den kompletten šbersetzungsbaum im Speicher halten zu mssen.
$1 PAGE DESCRIPTOR
   Der aktuelle Descriptor ist ein Page Descriptor. \#Table Address\# ent-
   h„lt die fr die \#Adrebersetzung\# notwendige  Physikalische Adres-
   se.
$2 VALID 4-Byte
   Die  Eintr„ge in der  Tabelle, auf die  \#Table Address\# zeigt,  haben
   eine Gr”e von 4 Byte.
$3 VALID 8-Byte
   Die  Eintr„ge in der  Tabelle, auf die  \#Table Address\# zeigt,  haben
   eine Gr”e von 8 Byte.
\end

screen( "Table Address" )
Table Address
----------------------------------------------------------------------

Das  Table Address Field  der \link("Descriptor")Descriptoren\#  enth„lt die  Physikalische 
Adresse der n„chsten šbersetzungstabelle.  Ist der aktuelle Descriptor
ein \#Page Descriptor\#, so enth„lt dieses Feld eine Physikalische Adresse
fr die \#Adrebersetzung\#.
\end

screen( "Translation Control",
		sensitive("TC") )
TC - Translation Control Register                     MC68851, MC68030
----------------------------------------------------------------------

Das Register ist 32 Bit breit und hat folgenden Aufbau:

     31    30    26  25   24    23 20 19 16 15 12 11  8 7   4 3   0
    +-----+--------+-----+-----+-----+-----+-----+-----+-----+-----+
    |  E  | unused | SRE | FCL |  PS |  IS | TIA | TIB | TIC | TID |
    +-----+--------+-----+-----+-----+-----+-----+-----+-----+-----+
       |             |     |      |     |    |     |     |     |
\#PMMU-Enable\#          |     |      |     |    |     |     |     |
\#SRP Enable\#-----------+     |      |     |    |     |     |     | 
\#Function Code Lookup Enable\#+      |     |    |     |     |     |
\#Page Size\#-------------------------+     |    |     |     |     |
\#Initial Shift\#---------------------------+    |     |     |     |
A, B, C, D \#Table Indices\#---------------------+-----+-----+-----+
\end

screen( "PMMU-Enable" )
PMMU-Enable 
----------------------------------------------------------------------

Das PMMU-Enable Bit des \#Translation Control\# Registers schaltet die 
\#PMMU\# ein ( Bit gesetzt ) bzw. aus.
\end

screen( "SRP Enable",
		"Supervisior Root Pointer Enab" )
Supervisior Root Pointer Enable
----------------------------------------------------------------------

Das Supervisior Root Pointer Enable Bit des \#Translation Control\#
Registers schaltet den \#SRP\# ein ( Bit gesetzt ) bzw. aus.
\end

screen( "Function Code Lookup Enable" )
Function Code Lookup Enable
----------------------------------------------------------------------

Das Function Code Lookup Enable Bit des \#Translation Control\# Registers
gibt an,  ob die erste  Schachtelungstiefe,  des \#šbersetzungsbaum\# fr
die \#Adrebersetzung\# mit dem \#Function Code\# der logischen Adresse ge-
bildet  wird ( FCL gesetzt ).  Ist dies der Fall wird das  \#Limitfield\#
des \#Root Pointer\#s ignoriert.
\end

screen( "Page Size" )
Page Size
----------------------------------------------------------------------

Das Page Size Field des Translation Control Registers gibt codiert
die Gr”e einer Speicherseite an. Fr jede Speicherseite existiert
ein Page Descriptor im šbersetzungsbaum.

Folgende Werte fr Page Size sind m”glich:

      PS | Gr”e einer Seite
     ----+-------------------
       8 | 256 Bytes
       9 | 512   "
      10 |  1K   "
      11 |  2K   "
      12 |  4K   "
      13 |  8K   "
      14 | 16K   "
      15 | 32L   "

Alle  anderen  Werte  l”sen  einen  \#PMMU-Fehler\#  aus.  Siehe  auch
\#Initial Shift\#, \#Table Indices\#.
\end

screen( "Initial Shift" )
Initial Shift
----------------------------------------------------------------------

Das Initial Shift Field des \#Translation Control\# Register gibt an,
wieviele Bits einer logischen Adresse, bei der \#Adrebersetzung\#
erst einmal ignoriert werden sollen.

Es ist zu beachten,  da die Summe aus \#Page Size\#,  Initial Shift
und  \#Table Indices\# 32 sein mu.  Ansonsten wird ein  \#PMMU-Fehler\#
ausgel”st.
\end

screen( "Table Indices",
		"TIx" )
Table Indices TIx
----------------------------------------------------------------------

Die Table Indices TIA, TIB, TIC, TID des \#Translation Control\# Registers
geben an welche  Bits der  logischen Adresse fr welche Schachtelungs-
tiefe im \#šbersetzungsbaum\#  als Index  fr die  entsprechende  šberset-
zungstabelle verwendet werden soll.

Dabei sind folgende Regeln zu beachten:
- TIx wird ignoriert, wenn einer oder mehrere der vorherigen Table In-
  dices den Wert 0 enth„lt.
- TIA darf nicht den Wert 0 enthalten.
- TIA mu mindestens 2 sein, wenn TIB den Wert 0 hat.
- Die  Summe aus Initial Shift,  Page Size und den gltigen  Table In-
  dices mu 32 sein.
Wird eine der drei vorherigen Regeln verletzt, so wird ein \#PMMU-Fehler\#
ausgel”st.
\end

screen( "PMMU-Statusregister",
		sensitive("PSR") )
PSR - PMMU-Statusregister                             MC68851, MC68030
----------------------------------------------------------------------

Das PMMU-Statusregister enth„lt Flags, welche bestimmte Zust„nde des
Ergebnis  einer Adreberstezung anzeigt.  Es entspricht dem \#CCR\# der
CPU. Diese  Flags werden fr  die  \link("Condition Codes, FPU")Bedingungen\# der bedingten  Befehle
abgefragt.


Das Statusregister der PMMU hat folgenden Aufbau:

          15  14  13  12  11  10  9   8   7   6   5    3 2   0
         +---+---+---+---+---+---+---+---+---+---+------+-----+
         | B | L | S | A | W | I | M | G | C | T |unused|  N  |
         +---+---+---+---+---+---+---+---+---+---+------+-----+
           |   |   |   |   |   |   |   |   |   |           | 
Bus Error--+   |   |   |   |   |   |   |   |   |           |
Limit Violation+   |   |   |   |   |   |   |   |           |
Privilegsverletzung+   |   |   |   |   |   |   |           |
Access Level Violation-+   |   |   |   |   |   |           |
Schreibschutz--------------+   |   |   |   |   |           |
Ungltig-----------------------+   |   |   |   |           |
Ver„ndert--------------------------+   |   |   |           |
Gate-( nur MC68851 )-------------------+   |   |           |
Globaly Sharable-( nur MC68851 )-----------+   |           |
Transparent Access-( nur MC68030 )-------------+           |
Anzahl der Levels------------------------------------------+
\end

screen( "Condition Codes, PMMU" )
Die Bedingungen werden an Hand der Flags im \#PMMU-Statusregister\# gebildet.
Folgende \#MC68851\#-Bedinungen sind erlaubt:

       Mnemonic   |      Flags      |   Mnemonic   |      Flags
    --------------+-----------------+--------------+-----------------
          BS      |    B gesetzt    |      BC      |    B gel”scht
          LS      |    L    "       |      LC      |    L    "
          SS      |    S    "       |      SC      |    S    "
          AS      |    A    "       |      AC      |    A    "
          WS      |    W    "       |      WC      |    W    "
          IS      |    I    "       |      IC      |    I    "
          GS      |    G    "       |      GC      |    B    "
          CS      |    C    "       |      CC      |    C    "
\end

screen( sensitive("PCSR") )
PCSR - PMMU-Cache-Statusregister                           Nur MC68851
----------------------------------------------------------------------

Das PCSR ist ein 16-Bit readonly Register, welches immer dann ver„ndert
wird,  wenn in  das \#CRP\#  mittels \#PMOVE\# oder \#PRESTORE\#  geschrieben
wird.

Es hat folgenden Aufbau:

                      15  14  13        3 2    0
                   +----+----+-----------+------+
                   |  F | LW | unbenutzt |  TA  |
                   +----+----+-----------+------+
                      |    |                 |
Flush ----------------+    |                 |
Lock Warning --------------+                 |
Task Aliases --------------------------------+
\end

screen( "Current Access Level",
		sensitive("CAL") )
CAL - Current Access Level Register                            MC68851
----------------------------------------------------------------------

Das CAL-Register bestimmt das Zugriffsrecht eines Tasks. CAL ist
8 Bit breit. Die oberen 3 Bits enthalten das Zugriffsrecht, das
durch die Befehle \#PMOVE\# oder \#PRESTORE\# gesetzt wird. Beim
MC68020 wird CAL automatisch durch \#CALLM\# und \#RTM\# gesetzt.
\end

screen( "Validate Access Level",
		sensitive("VAL") )
VAL - Validate Access Level Register                           MC68851
----------------------------------------------------------------------

Das VAL-Register enth„lt das Zugriffsrecht eines Tasks. VAL ist
8 Bit breit. Die oberen 3 Bits enthalten das Zugriffsrecht, das
automatisch mit dem Wert aus dem \link("Current Access Level")Control Access Level Register\#
geladen wird.
\end

screen( "Access Control",
		sensitive("AC") )
AC - Access Control Register                               Nur MC68851
----------------------------------------------------------------------

Das Access Control Register wird benutzt, um die zahlreichen Zu-
griffskontrollen des MC68851 zu konfigurieren, wie besipielsweise
die Zugriffsrechte, deren Anzahl oder die Gr”e eines Mudule
Descriptors.
\end

screen( "Transparent Translation",
		sensitive("TT1"),
		sensitive("TT0") )
TTn - Transparent Translation Register 0 bzw. Register 1       MC68030
----------------------------------------------------------------------

Die  PMMU prft bei der  \#Adrebersetzung\#  zuerst,  ob die  logische 
Adresse ber die  Transparent Translation  Register zu einer physica-
lischen Adresse "bersetzt" werden kann.  Die "šbersetzung" kann dann
stattfinden, wenn alle Tests,  die durch die Flags in diesem Register
spezifiziert  wurden  positiv  verlaufen.  In diesem  Falle wird  die
logische Adresse als physicalische verwendet.  Damit lassen sich z.B.
max. 2 ( fr TT0  und TT1)  mindestens 16  MB groe  Speicherbereiche
als jeweils ein groer Block verwenden, fr den keine Adrebersetz-
ung notwendig ist.

Das TT0 und das TT1 sind 32 Bit breit und haben folgenden Aufbau:

        31 24 23 16 15  14    10   9     8    7  6   4  3  2   0
       +-----+-----+---+--------+-----+-----+---+-----+---+-----+
       | LAB | LAM | E | unused | R/W | RWM | 0 | FCB | 0 | FCM |
       +-----+-----+---+--------+-----+-----+---+-----+---+-----+
         |     |     |            |     |         |         |
\link("Logical Address Base")Logical\#  |     |     |            |     |         |         | 
\link("Logical Address Base")Address\#  |     |     |            |     |         |         | 
\link("Logical Address Base")Base\#-----+     |     |            |     |         |         |      
\#Logical Address Mask\# |            |     |         |         | 
\#Enable TTn\#-----------+            |     |         |         | 
\#Read/Write\#------------------------+     |         |         |
\#Read/Write Mask\#-------------------------+         |         |
\#Function Code Base\#--------------------------------+         |
\#Function Code Mask\#------------------------------------------+
\end

screen( "Logical Address Base",
		"Logical Address Mask" )
Logical Address Base / Mask
----------------------------------------------------------------------

Die oberen 8 Bits einer logischen Adresse,  welche durch die Logical
Address Mask ( das jeweilige Bit  in der Maske ist gel”scht ) spezi-
fiziert werden,  werden mit den  Bits der Logical Address  Base der
\#Transparent Translation\# Register verglichen.
\end

screen( "Enable TTn" )
Enable Transparent Translation
----------------------------------------------------------------------

Mit dem  Enable Transparent  Translation Flag der  \link("Transparent Translation")TTn\# Register wird
die Transparent Translation  fr das jeweilige Register ein- ( Flag
gesetzt ) bzw. ausgeschaltet ( Flag gel”scht ).
\end

screen( "Read/Write",
		"Read/Write Mask" )
Read/Write (Mask)
----------------------------------------------------------------------

Ist die Read/Write Mask eines \#Transparent Translation\# Registers ge-
setzt, so werden  alle Speicherzugriffe transparent  bersetzt. An-
sonsten  werden  nur  Schreibzugriffe  ( Read/Write-Flag gel”scht ) 
oder Lesezugriffe ( Read/Write-Flag gesetzt ) transparen šbersetzt.
\end

screen( "Function Code Base",
		"Function Code Mask" )
Function Code Base / Mask
----------------------------------------------------------------------

Die 3 Bits eines \#Function Code\#,  welche durch die Function Code Mask
( das jeweilige Bit in der Maske ist gel”scht ) spezifiziert werden,
werden mit den  Bits der Function Code Base der Transparent Transla-
tion Register ( \link("Transparent Translation")TTn\# verglichen.
\end

screen( "PMMU",
		"Adrebersetzung" )
Adrebersetzung mit der PMMU
----------------------------------------------------------------------

Die Adrebersetzung mit Hilfe der PMMU (Paged Memory Management 
Unit) auf dem \#MC68030\# oder dem \#MC68851\# unterscheidet sich nur ge-
ringfgig.  Sie  dient  dazu logische  Adressen zu  physikalische
Adressen  umzusetzen.  Will  z.B.  ein Programm  auf die  Adresse
$10000 zugreifen, so mu diese nun nicht unbedingt mit der physi-
kalischen Adresse bereinstimmen.

Die  Vorgehensweise der CPU bzw. PMMU l„t sich  dabei durch fol-
gendes  Fludiagramm  darstellen,  LA  steht  dabei  fr logische
Adresse, PA fr physikalische Adresse:

+===============================================================+
| LA im \#Cache\# ?                                                 |
|                                                               |
| Ja                                                     | Nein |
+--------------------------------------------------------+------+
| Schreibzugriff ?                                       |      |
|                                                        |      |
| Nein       |                                        Ja |      |
+------------+-------------------------------------------+------+
|            | Kann PA aus \link("Transparent Translation")TTn\# berechnet werden ? ( \#MC68030\# )   |
|            |                                                  |
|            | Nein                                  |       Ja |
|            +---------------------------------------+----------+
|            | Ist PA im \#ATC\# ?                       | PA = LA  |
|            |                                       |          |
|            | Nein                        |      Ja |          |
|            +-----------------------------+---------+          |
|            | Bestimme aktuellen          | Hole PA |          |
|            | \#Root Pointer\#                | aus ATC |          |   
|            +-----------------------------+         |          |
|            | Durchsuche                  |         |          |
|            | \#šbersetzungsbaum\#            |         |          |
|            +-----------------------------+         |          |
|            | Wurde \#Page Descriptor\#       |         |          |
|            | gefunden ?                  |         |          |
|            |                             |         |          |
|            | Nein      |              Ja |         |          |
|            +-----------+-----------------+         |          |
|            |           | Berechne PA     |         |          |
|            |           | mit             |         |          |
|            |           | \#Table Address\#.  |         |          |
|            |           +-----------------+         |          |
|            |           | Trage PA ins    |         |          |
|            | L”se      | ATC ein.        |         |          |
| Hole Wert  | \#Exception\# +-----------------+---------+----------+ 
| aus Cache. | aus.      | Verwende PA zum Speicherzugriff      |
+============+===========+======================================+
\end

screen( "ATC",
		"Address Translation Cache" )
ATC - Address Translation Cache
------ ----------------------------------------------------------------

Das Address Translation Cache ist ein PMMU-interner Speicherbereich,
der die letzten \link("PMMU")Adrebersetzungen\# enth„lt. Dadurch werden die
Speicherzugriffe zur Adrebersetzung minimiert. Auf das ATC haben
Sie nur ber die \#PLOAD\# und \#PFLUSH\# Befehle zugriff. Es enh„lt
folgende Felder und Flags:

Krzel | Gr”e   | Bezeichnung
       | in Bits |
-------+---------+------------------------------
     V |       1 | Valid
    FC |       3 | \#Function Code\#
     B |       1 | Bus Error
    CI |       1 | Cache Inhibit
    WP |       1 | Write Protection
     M |       1 | Modified
    SG |       1 | \#Shared Globaly\# ( MC68851 )
    LA |      24 | Logical Address
    PA |      24 | Physical Address

V signalisiert die Gltigkeit des Eintrags. B wird gesetzt, wenn
w„hrend der Adrebersetzung ein Bus-Fehler, ein ungltiger Des-
kriptor, eine Privileg-Verletzung oder eine Limit-Verletzung
vorkamen. CI ist gesetzt, wenn es im zugeh”rigen \#Page Descriptor\#
ebenfalls gesetzt ist. WP bedeutet, das auf den zugeh”rigen
Speicher ausschlielich lesender Zugriff gestattet ist. M besagt,
da der Speicherinhalt ver„ndert wurde.
\end

screen( "šbersetzungsbaum" )
šbersetzungsbaum
----------------------------------------------------------------------

Der šbersetzungsbaum enth„lt alle \#šbersetzungstabelle\#n, die zur  Adre-
bersetzung durch die \#PMMU\# notwendig sind.  Je nachdem welche Felder im
\#Translation Control\# Register  gesetzt sind,  hat er eine Schachtelungs-
tiefe von 0 ( der \#Root Pointer\#  enth„lt schon  einen  \#Page Descriptor\# )
bis 5 ( FCL und alle TIx-Felder sind gltig ).

Der šbersetzungsbaum im Hauptspeicher hat folgenden Aufbau:

Root Pointer | šbersetzungstabellen 1 .... šbersetzungstabellen 5


CRP----------->Descriptor----------------->Page Descriptor
                                              ...
                  ...                      Page Descriptor   
                     
               Descriptor----------------->Page Descriptor
                                              ...
                                           Page Descriptor

SRP----------->Descriptor----------------->Page Descriptor
                                              ...
                  ...                      Page Descriptor   
                     
               Descriptor----------------->Page Descriptor
                                              ...
                                           Page Descriptor

DRP----------->Descriptor----------------->Page Descriptor
                                              ...
                  ...                      Page Descriptor   
                     
               Descriptor----------------->Page Descriptor
                                              ...
                                           Page Descriptor
\end

screen( "šbersetzungstabelle" )
šbersetzungstabelle
----------------------------------------------------------------------

Eine šbersetzungstabelle ist eine Liste von \#Descriptor\#en, die
je nach \#Descriptor Type\# entweder  Page Descriptoren sind oder
auf eine neue  šbersetzungstabelle zeigen.  Alle Descriptoren
einer Tabelle  haben die gleiche Gr”e  von entweder 4 oder 8
Byte.  Wie  Gro  diese  Descriptoren  sind,  wird  durch den
Descriptor Type  desjenigen  Descriptor  festgelegt,  der auf
diese Tabelle zeigt. Die Anzahl der Descriptoren einer Tabel-
le wird durch das  Limitfield des auf diese Tabelle zeigenden
Descriptors festgelegt.

Welcher  Descriptor der  Tabelle  fr  die  \#Adrebersetzung\#
verwendet wird, h„ngt vom den verschiedenen Kombinationen aus
aktuelle  Schachtelungstiefe im \#šbersetzungsbaum\#, FCL und TIx
des \#Translation Control\# Registers, dem \#Function Code\#  und den
Adress Bits der logischen Adresse ab.
\end

screen( "Page Descriptor" )
----------------------------------------------------------------------

Ein Page Descriptor beschreibt den Zustand einer 4K bzw. 8K groen
Speicherseite oder ist ein Zeiger auf einen anderen Page Descriptor,
also ein indirekter Descriptor:

        31    12 11 10  9  8 7 6 5 4 3 2 1 0
       +--------+--+--+--+--+-+---+-+-+-+---+
8K     | PA     |UR|G |U1|U0|S|CM |M|U|W|PDT|
       +--------+--+--+--+--+-+---+-+-+-+---+

        31 13 12 11 10  9  8 7 6 5 4 3 2 1 0
       +-----+--+--+--+--+--+-+---+-+-+-+---+
4K     | PA  |UR|UR|G |U1|U0|S|CM |M|U|W|PDT|
       +-----+--+--+--+--+--+-+---+-+-+-+---+

        31                             2 1 0
       +--------------------------------+---+
Ind.   | Descriptor Address             |PDT|
       +--------------------------------+---+


Krzel |Bezeichnung
-------+---------------------
PA     | Physical Address
UR     | User Reserved
G      | Global
U0,U1  | User Page Attribute
S      | Supervisor Protected
CM     | Cache Mode
M      | Modified
U      | Used
W      | Write Protected
PDT    | Page Descriptor Type
\end

screen( "Exceptions, PMMU" )
Exceptions bei der Adrebersetzung
----------------------------------------------------------------------

Wird bei der \#Adrebersetzung\#  ein ungltiger Descriptor gefunden,
ein indirect Descriptor, der nicht auf einen Page Descriptor zeigt,
gefunden oder ein Tabellen  Index das Limit  bersteigt bzw. unter-
schreitet, wird ein \#Busfehler\# ausgel”st.
\end

screen( "Breakpoint Acknowledge Datenr",
		sensitive("BAD2"),
		sensitive("BAD7"),
		sensitive("BAD4"),
		sensitive("BAD5"),
		sensitive("BAD6"),
		sensitive("BAD1"),
		sensitive("BAD0"),
		sensitive("BAD3") )
BADn - Breakpoint Acknowledge Datenregister                Nur MC68851
----------------------------------------------------------------------

BADn ( 0 <= n <= 7 )

Wenn der Prozessor bei der Programmausfhrung auf einen der acht
\#BKPT\#-Befehle trifft, wird eine Ausnahmebehandlung eingeleitet.
Danach wird der Inhalt des zum BKPT-Befehl korrespondierenden
BAD-Registers mit diesem ausgetauscht und mit diesem Befehl
fortgefahren. D.h. ein BAD-Register sollte einen sinnvollen
Opcode enthalten.

Querverweis:   \link("Breakpoint Acknowledge Contro")Breakpoint Acknowledge Control Register\#
\end

screen( "Breakpoint Acknowledge Contro",
		sensitive("BAC2"),
		sensitive("BAC6"),
		sensitive("BAC7"),
		sensitive("BAC0"),
		sensitive("BAC1"),
		sensitive("BAC5"),
		sensitive("BAC3"),
		sensitive("BAC4") )
BACn - Breakpoint Acknowledge Control Register             Nur MC68851
----------------------------------------------------------------------

BACn ( 0 <= n <= 7 )

Die BAC-Register korrespondieren mit den entsprechenden \link("Breakpoint Acknowledge Datenr")BAD\#-
Registern. Wenn das oberste Bit (15) nicht gesetzt ist, wird beim
Ausl”sen eines Breakpoints mittels des \#BKPT\#-Befehls ein Bus-Fehler
generiert. Die unteren 8 Bits geben an, nach dem wievieltem Male 
nach dem Treffen auf einen BKPT-Befehl die Ausnahmebehandlung
begonnen werden soll (Voraussetzung: Bit 15 gesetzt).

Querverweis:   \link("Breakpoint Acknowledge Datenr")Breakpoint Acknowledge Datenregister\#
\end

screen( "Exception",
		"Exceptiontabelle" )
Die Exceptiontabelle der Motorola CPUs
----------------------------------------------------------------------

Die Exceptiontabelle ist eine Liste von Exceptionvektoren,  die der CPU
anzeigen, wo sie mit der Programmausfhrung fortfahren soll, falls eine
bestimmte Bedingung bzw. Ereignis aufgetreten ist. Die Tabelle f„ngt ab
der Adresse 0 an,  kann jedoch ab der  MC68010 CPU mit dem \#VBR\# an einer 
anderen Adresse anfangen.

Vektor | Offset  | Bedeutung
-------+---------+---------------------------------------------------------
     0 |       0 | \#SSP\# nach Reset
     1 |       4 | \#PC\# nach Reset
     2 |       8 | \#Busfehler\#
     3 |      12 | \#Adressfehler\#
     4 |      16 | \#Illegaler Befehl\#
     5 |      20 | \#Division durch 0\#
     6 |      24 | \#CHK\#-, \#CHK2\#-Befehle
     7 |      28 | \#TRAPV\#-, \link("TRAPCC")TRAPcc\#, \#FTRAPcc\#, \#PTRAPcc\#-Befehle
     8 |      32 | \link("SUPER")Privilegsverletzung\#
     9 |      36 | \#Trace\#
    10 |      40 | \#Line-A-Vektor\#
    11 |      44 | \#Line-F-Vektor\#
    12 |      48 | reserviert
    13 |      52 | \#Coprozessor-Protokoll\#                    ( MC68020 )
    14 |      56 | \#Formatfehler\#                             ( MC68010 )
    15 |      60 | \#Falscher Interrupt Vektor\#
 16-23 |   64-92 | reserviert
    24 |      96 | \#Spurious Interrupt\#
 25-31 | 100-124 | \#Autovektor-Interrupt\#, Level 1 bis Level 7
 32-47 | 128-188 | \#TRAP\#-Befehle 0 - 15
    48 |     192 | \#Branch/Set on Unordered\#                ( MC68881/2 )
    49 |     196 | \#Inexact Operation\#                      ( MC68881/2 )
    50 |     200 | \#Division durch 0.0\#                     ( MC68881/2 )
    51 |     204 | \#FPU underflow\#                          ( MC68881/2 )
    52 |     208 | \#Operandenfehler\#                        ( MC68881/2 )
    53 |     212 | \#FPU overflow\#                           ( MC68881/2 )
    54 |     216 | Ungltiges Ergebnis                    ( MC68881/2 )
    55 |     220 | reserviert
    56 |     224 | \#PMMU-Fehler\#                     ( MC68851, MC68030 )
    57 |     228 | \#PMMU-Illegale Operation\#                  ( MC68851 )
    58 |     232 | \#PMMU-Zugriffsverletzung\#                  ( MC68851 )
 59-63 | 236-252 | reserviert
64-255 |256-1020 | \link("Benutzerreservierte Exception")Benutzerreservierte Exceptions\#
\end

screen( "Busfehler" )
Busfehler
----------------------------------------------------------------------

Bei einem Busfehler wird eine \#Exception\# mit der Nummer 2 ausgel”st. Der
Busfehler wir von auen ber die BERR-Leitung der CPU erzeugt.  Er wird
dazu benutzt, um Zugriffe auf  nicht vorhandenen oder geschtzten Spei-
cher, der nur im Supervisorlevel erreichbar ist, zu verhindern.

Ein \#Busfehler\# wird  auch von der \#PMMU\# erzeugt,  falls bei einer  Adre-
bersetzung ein ungltiger \#Descriptor\# gefunden wurde.  Die Adresse die-
ses Descriptors  kann die  Busfehlerroutine mit dem  \#PTEST\#-Befehl fest-
stellen.
\end

screen( "Adressfehler" )
Adressfehler
----------------------------------------------------------------------

Bei einem  Adressfehler wird eine \#Exception\# mit der Nummer 3 ausgel”st. 
Der Adressfehler wird ausgel”st,  wenn eine Wort-, Langwort- oder Quad-
wortzugriff auf eine ungerade Adresse auszufhren.
\end

screen( "Illegaler Befehl" )
Illegaler Befehl
----------------------------------------------------------------------

Trifft die CPU auf einen Befehl, der ihr unbekannt ist, so wird eine
\#Exception\# mit der Nummer 4 ausgel”st. Der einzige Opcode, der garant-
iert (also auch bei zuknftigen CPUs) diese Exception ausl”st, ist 
der des "\#ILLEGAL\#"-Befehls.
\end

screen( "Division durch 0" )
Division durch 0
----------------------------------------------------------------------

Wird versucht eine Division durch 0 auszufhren, so l”st  die CPU eine
\#Exception\# mit der Nummer 5 aus. (siehe auch \#DIVSL\#, \#DIVS\#, \#DIVU\#, \#DIVUL\#).
\end

screen( "Line-A-Vektor" )
Line-A-Vektor
----------------------------------------------------------------------

Trifft die CPU auf einen  Befehl, dessen Opcode mit der Bitkombination
1010 (das ist HEX A)  anf„ngt,  so wird eine \#Exception\#  mit der Nummer
10 ausgel”st. Einen solchen Befehl, k”nnen Sie mit der Direktive \#ALINE\#
erzeugen.
\end

screen( "Line-F-Vektor" )
Line-F-Vektor
----------------------------------------------------------------------

Trifft die CPU auf einen  Befehl, dessen Opcode mit der Bitkombination
1111 (das ist HEX F)  anf„ngt,  so wird eine \#Exception\#  mit der Nummer
11 ausgel”st. Einen solchen Befehl, k”nnen Sie mit der Direktive \#FLINE\#
erzeugen.

Bevor allerdings die  Exception ausgel”st wird,  versuchen die CPUs ab 
MC68020 den  gefundenen Opcode an  einem  Coprozessor  (FPU oder PMMU) 
weiterzureichen. Erst wenn das nicht klappt (weil kein Coprozessor in-
staliert ist) wird die Exceotion ausgel”t.
\end

screen( "Coprozessor-Protokoll" )
Coprozessor-Protokoll
----------------------------------------------------------------------

Tritt bei der  Kommunikation zwischen der CPU ( MC68020 ) und einem
Coprozessor ein Protokollfehler auf, so wird eine \#Exception\# mit der
Nummer 13 ausgel”st. Dieser Fehler sollte eigentlich nie auftreten,
da er nur auf defekte Hardware schlieen l„t.
\end

screen( "Formatfehler" )
Formatfehler
----------------------------------------------------------------------

In einigen F„llen prft die CPU oder ein Coprozessor Daten im Speicher
auf ihre Gltigkeit.  Entdeckt der Prozessor falsche Daten,  wird eine
\#Exception\# mit der Nummer 14 ausgel”st. Dieser Test wird bei den Befeh-
len \#CALLM\#, \#FRESTORE\#, \#PRESTORE\#, \#RTE\#, \#RTM\# durchgefhrt.
\end

screen( "Falscher Interrupt Vektor" )
Falscher Interrupt Vektor
----------------------------------------------------------------------

Wird ein \#Non-Autovektor-Interrupt\# ausgel”st, der (noch) nicht initia-
lisert ist, ausgel”st, so wird eine  \#Exception\# mit der Nummer 15 aus-
gel”st.
\end

screen( "Spurious Interrupt" )
Spurious Interrupt
----------------------------------------------------------------------

Wird ein Interrupt ausgel”st, dessen Ursache nicht feststellbar ist,
so wird eine  \#Exception\# mit der  Nummer 24 ausgel”st.  Dieser Fehler
sollte  eigentlich nie auftreten,  da er  nur auf  defekte  Hardware
schlieen l„t.
\end

screen( "Autovektor-Interrupt" )
Autovektor-Interrupt
----------------------------------------------------------------------

Autovektor-Interrupts sind  Interruptanforderungen externer Hardware,
bei der sich die CPU den \#Exception\#vektor selbst aus der Interruptpri-
orit„t ( siehe "Interruptmaske" ) bestimmt.
\end

screen( "Non-Autovektor-Interrupt" )
Non-Autovektor-Interrupt
----------------------------------------------------------------------

Non-Autovektor-Interrupts sind Interruptanforderungen externer Hard-
ware, bei der die CPU den \#Exception\#vektor von der externen  Hardware
anfordert.  Non-Autovektor-Interrupts  werden  dazu  benutzt  um die
\link("Benutzerreservierte Exception")Benutzerreservierte Exceptions\# zu erzeugen.

Querverweis: \#Falscher Interrupt Vektor\# \#Interruptmaske\# 
             \#Autovektor-Interrupt\#
\end

screen( "BSUN",
		"Branch/Set on Unordered" )
Branch/Set on Unordered                               MC68881, MC68040
----------------------------------------------------------------------

Einige \link("Condition Codes, FPU")Fliekommabedingungen\#  l”sen eine \#Exception\# mit der  Nummer 48
aus, wenn das NAN-Bit im \#Condition Code\# Byte des Fliekomma-Statusre-
gister ( \#FPSR\# ) gesetzt ist.

Das Auftreten dieser Exception kann mit dem \#Exception Enable\# Byte des
Fliekomma-Kontrollregisters ( \#FPCR\# ) ein- bzw. ausgeschaltet  werden. 
Es  wird  aber  auf  jeden  Fall  im  \#Exception Status\#  Byte  und  im 
\#Accrued Exception\#  Byte des  Fliekommastatusregisters ( \#FPSR\# ) ange-
zeigt.
\end

screen( "Inexact Result",
		"Inexact Operation",
		"Inexact Decimal Input" )
Inexact Result/Decimal Input                          MC68881, MC68040
----------------------------------------------------------------------

Konnte das Ergebnis der letzten Fliekommaoperation nicht hinreichend
genau bestimmt werden oder war ein oder mehrere Operanden der letzten
Fliekommaoperation  nicht hinreichend genau,  so wird eine \#Exception\#
mit der Nummer 49 ausgel”st.

Das Auftreten dieser Exception kann mit dem \#Exception Enable\# Byte des
Fliekomma-Kontrollregisters ( \#FPCR\# ) ein- bzw. ausgeschaltet  werden. 
Es  wird  aber  auf  jeden  Fall  im  \#Exception Status\#  Byte  und  im 
\#Accrued Exception\#  Byte des  Fliekommastatusregisters ( \#FPSR\# ) ange-
zeigt.
\end

screen( "Division durch 0.0",
		"Divide by Zero" )
Division durch 0.0                                    MC68881, MC68040
----------------------------------------------------------------------

Wird versucht eine Division durch 0.0 auszufhren, so l”st  die FPU eine
\#Exception\# mit der Nummer 50 aus. (siehe auch \#FDIV\#, \#FREM\#, \#FSGLDIV\# )

Das Auftreten dieser Exception kann mit dem \#Exception Enable\# Byte des
Fliekomma-Kontrollregisters ( \#FPCR\# ) ein- bzw. ausgeschaltet  werden. 
Es  wird  aber  auf  jeden  Fall  im  \#Exception Status\#  Byte  und  im 
\#Accrued Exception\#  Byte des  Fliekommastatusregisters ( \#FPSR\# ) ange-
zeigt.
\end

screen( "FPU underflow" )
FPU underflow                                         MC68881, MC68040
----------------------------------------------------------------------

Ist ein von 0.0 verschiedenes Ergebnis einer  Fliekommaoperation zu 
klein,  als da es  korrekt dargestellt  werden kann,  so wird  eine 
\#Exception\# mit der Nummer 51 ausgel”st.

Das Auftreten dieser Exception kann mit dem \#Exception Enable\# Byte des
Fliekomma-Kontrollregisters ( \#FPCR\# ) ein- bzw. ausgeschaltet  werden. 
Es  wird  aber  auf  jeden  Fall  im  \#Exception Status\#  Byte  und  im 
\#Accrued Exception\#  Byte des  Fliekommastatusregisters ( \#FPSR\# ) ange-
zeigt.
\end

screen( "Operandenfehler",
		"Operand Error" )
Operandenfehler                                       MC68881, MC68040
----------------------------------------------------------------------

Sind ein oder mehrere  Operanden einer  Fliekommaoperation ungltig,
so wird eine \#Exception\# mit der Nummer 42 ausgel”st.

Das Auftreten dieser Exception kann mit dem \#Exception Enable\# Byte des
Fliekomma-Kontrollregisters ( \#FPCR\# ) ein- bzw. ausgeschaltet  werden. 
Es  wird  aber  auf  jeden  Fall  im  \#Exception Status\#  Byte  und  im 
\#Accrued Exception\#  Byte des  Fliekommastatusregisters ( \#FPSR\# ) ange-
zeigt.
\end

screen( "FPU overflow" )
FPU overflow                                          MC68881, MC68040
----------------------------------------------------------------------

Ist das Ergebnis einer  Fliekommaoperation zu gro,  als da es kor-
rekt dargestellt werden kann,  so wird eine \#Exception\#  mit der Nummer
53 ausgel”st.

Das Auftreten dieser Exception kann mit dem \#Exception Enable\# Byte des
Fliekomma-Kontrollregisters ( \#FPCR\# ) ein- bzw. ausgeschaltet  werden. 
Es  wird  aber  auf  jeden  Fall  im  \#Exception Status\#  Byte  und  im 
\#Accrued Exception\#  Byte des  Fliekommastatusregisters ( \#FPSR\# ) ange-
zeigt.
\end

screen( "PMMU-Fehler" )
PMMU-Fehler                                           MC68851, MC68030
----------------------------------------------------------------------

Wird die  PMMU von der Systemsoftware falsch initialisiert, so wird
eine  \#Exception\#  mit der Nummer  56 ausgel”st.  Ein solcher  Fehler
tritt auf, wenn \#CRP\#, \#SRP\# oder \#DRP\# ungltige Deskriptoren zugewiesen
bekommen, wenn die  Felder TIx, IS  und PS  des Translation Control
Registers ( \#TC\# ) ungltige Werte erhalten.
\end

screen( "PMMU-Illegale Operation" )
PMMU-Illegale Operation                               MC68851, MC68030
----------------------------------------------------------------------

Wird  bei ausgeschalteter  PMMU ( MC68851 ) versucht,  einen \#PLOAD\#
oder \#PTEST\# Befehl auszufhren, so wird eine \#Exception\# mit der Num-
mer 57 ausgel”st.
\end

screen( "PMMU-Zugriffsverletzung" )
PMMU-Zugriffsverletzung                               MC68851, MC68030
----------------------------------------------------------------------

Wenn ein \#PVALID\#-Test einen Zeiger zurckweist, wird eine \#Exception\#
mit der Nummer 58 ausgel”st.
\end

screen( "Benutzerreservierte Exception" )
Benutzerreservierte Exceptions
----------------------------------------------------------------------

Die CPU kennt insgesamt 192  Benutzerreservierte \#Exception\#s. Diese
Exceptions  haben die Nummern 64 - 255.  Sie k”nnen vom jeweiligen
Betriebssytem fr eigene Zwecke verwendet werden. Die Exceptionnum-
mern werden ber die \#Non-Autovektor-Interrupt\#s erzeugt.

Das Betriebssystem des Atari ST  kennt folgende Benutzerreservierte
Exceptions:

Vektor | Adresse | Bedeutung
-------+---------+---------------------------------------------------------
    64 |     256 | BUSY Interrupt
    65 |     260 | DCD Interrupt ( "Carrier detect" )
    66 |     264 | CTS Interrupt ( "Clear to send" )
    67 |     268 | GPU Done ( "Graphic Processing Unit" = Blitter )
    68 |     272 | Baudratengenerator ( Timer D der MFP )
    69 |     276 | 200 Hz System Timer ( Timer C )
    70 |     280 | IKBD/MIDI
    71 |     284 | FDC/ACSI
    72 |     288 | Display Enable Signal ( Timer B )
    73 |     292 | RS-232 Sendefehler
    74 |     296 | RS-232 Sendepuffer leer
    75 |     300 | RS-232 Empfangsfehler
    76 |     304 | RS-232 Empfangspuffer voll
    77 |     308 | Timer A ( steht dem Anwenderprogramm zur Verfgung )
    78 |     312 | Monochrom Monitor Detect
    
Die Vektoren 79 bis 223 werden auf dem ST nicht benutzt. Die Vektoren
224 - 255 werden fr andere Zwecke verwendet.
\end

screen( "Abkrzungen" )
Erkl„rung der Abkrzungen
----------------------------------------------------------------------

ea       Spezifikation einer Adressierungsart ( Effective Address ).
dn       Datenregister ( Data Register n ).
an       Adreregister ( Address Register n ).
xn       Adre- oder Datenregister n.
data     Adressierungsart die Daten unmittelbar spezifiziert.
         ( Immediate Data ).
label    Sprungmarke.
cr       Kontroll-Register des 680x0 Prozessors.
fc       \#Function Code\# beim Speicherzugriff.
reglist  Spezifikation einer Registerliste.
offs     Datenregister oder Immediate Data, um  einen  Bitfeld-
         Offset zu spezifizieren.
width    Datenregister oder Immediate Data,  um  eine  Bitfeld-
         Breite zu spezifizieren.
.x       \#Gr”en-Spezifikationen\# fr Byte, Word oder Longword.
.a       Gr”en-Spezifikation fr Word oder Longword.
fpn      Fliekomma-Datenregister
fpcr     Fliekomma-Kontrollregister
fdlist   Liste von Fliekomma-Datenregistern
fclist   Liste von Fliekomma-Kontrollregistern
.p       Gr”en-Spezifikation fr Byte, Word, Longword,
         Single Precision Real, Double Precision Real,
         Extended Precision Real
.f       Gr”en-Spezifikation fr Byte, Word, Longword,
         Single Precision Real, Double Precision Real,
         Extended Precision Real oder Packed Decimal Real
cc       Condition Code. Je nach Befehl steht dies fr eine 
         Bedingung der \link("Condition Codes, CPU")CPU\#, \link("Condition Codes, FPU")FPU\# oder \#PMMU\#.
\end

screen( "Codeoptimierung" )
Codeoptimierung
----------------------------------------------------------------------

Bei einigen Befehlen der MC680x0-Prozessoren kann man durch
Verwendung alternativer Befehle die Codegr”e verringern oder
die Ausfhrungsgeschwindigkeit vergr”ern.

Befehl              Optimierung         Voraussetzung
----------------------------------------------------------------------
ADD.X   #data,ea    ADDQ.X  #data,ea    1 <= data <= 8
ADDA.X  #data,ea    ADDQ.X  #data,ea
ADDI.X  #data,ea    ADDQ.X  #data,ea
SUB.X   #data,ea    SUBQ.X  #data,ea
SUBA.X  #data,ea    SUBQ.X  #data,ea
SUBI.X  #data,ea    SUBQ.X  #data,ea

CMP.X   #0,ea       TST.X   ea          ea ist kein An
CMPI.X  #0,ea       TST.X   ea

MOVE.L  #data,Dn    MOVEQ   #data,Dn    -128 <= data <= 127

MOVEA.L #data,An    MOVEA.W #data,An    -32768 <= data <= 32767
ADDA.L  #data,An    ADDA.W  #data,An
CMPA.L  #data,An    CMPA.W  #data,An
SUBA.L  #data,An    SUBA.W  #data,An

MOVE.X  #0,Dn       CLR.X   Dn

MOVEM.A #0,ea       nichts
MOVEM.A ea,#0       nichts

Die Befehle MOVE.X #0,ea werden nicht zu CLR.X ea optimiert,
weil sich der CLR-Befehl auf einigen frheren Prozessoren
aufgrund eines Fehlers im Mikrocode anders verh„lt als bei
neueren Typen, bei denen der Fehler behoben ist.

Fr die absolute Adressierung gibt es eine kurze Form, bei der
sich die Adresse als Wort darstellen l„t. Liegt eine Adresse
zwischen -32768 und 32767, so w„hlt Pure Assembler automatisch
die kurze Form.
Die Adressierungsart Adreregister indirekt mit Adredistanz wird
zu Adreregister indirekt reduziert, wenn die Adredistanz Null ist.
Die erweiterten Adressierungsarten ab dem MC68020 werden nur dann
erzeugt, wenn Speicherindirektion benutzt oder das Basisregister
unterdrckt wird. 
Die Gr”e fur das Basisregister beziehungsweise die „uere
Adredistanz wird ebenfalls optimiert.

Die Verzweigungsbefehle \#BRA\#, \link("BMI")Bcc\# und \#BSR\# werden immer optimiert,
wenn es sich um vorw„rtsgerichtete Referenzen handelt, es sei
denn, es wurde eine Gr”e spezifiziert oder das Sprungziel liegt
in einem anderen Modul. Verzweigt ein BRA- oder Bcc-Befehl auf
den n„chstfolgenden Befehl, so wird fr den Verzweigungsbefehl
kein Code generiert.
\end

screen( "Signaling NaN" )
Signaling NaN
----------------------------------------------------------------------

Mittels Signaling NaN wird der FPU mitgeteilt, da ein benutzer-
definierter Datentyp benutzt wird. Die FPU kann niemals Signaling
NaN erzeugen.
\end

screen( "Shared Globaly" )
Shared Globaly
----------------------------------------------------------------------

Das SG-Bit besagt, da Teile des logischen Adreraums von allen
Tasks im System gemeinsam benutzt wird.
\end

screen( "Cache" )
Cache
----------------------------------------------------------------------

Mit einem Cachespeicher wird versucht die zeitintensiven Buszugriffe
zu minimieren. Beim MC68020 gab es nur einen Befehlscache. Seit dem
MC68030 sind die Motorula CPUs sowohl mit Befehls- als auch mit
Datencaches ausgestattet.
\end

screen( "Direktiven" )
Pure Assembler Direktiven
----------------------------------------------------------------------

Die Direktiven drfen gro oder klein geschrieben werden. Allen
Direktiven, mit Ausnahme von = und *=, darf ein Punkt vorangestellt
werden.

\#=\#                    \#ENDM\#                 \#MODULE\#
\#*=\#                   \#ENDMOD\#               \#NOLIST\#
\#ALIGN\#                \#EQU\#                  \#OFFSET\#
\#ALINE\#                \#ERROR\#                \#ORG\#
\#ASCII\#                \#EVEN\#                 \#PAGE\#
\#ASCIIL\#               \#EXITM\#                \#PRINT\#
\#ASCIIZ\#               \#EXPORT\#               \#REG\#
\#BSS\#                  \#FLINE\#                \#REPT\#
\#COMM\#                 \#GLOBL\#                \#SET\#
\#DATA\#                 \#IFcc\#                 \#SUPER\#
\#DC\#                   \#IMPORT\#               \#TEXT\#
\#DCB\#                  \#INCLUDE\#              \#TTL\#
\#DS\#                   \#LCOMM\#                \#USER\#
\#ELSE\#                 \#LIST\#                 \#XDEF\#
\#END\#                  \#LOCAL\#                \#XREF\#
\#ENDC\#                 \#MACRO\#
\#ENDIF\#                \#MC68nnn\#
\end

screen( "Makros" )
Die Benutzung von Makros im šberblick
----------------------------------------------------------------------
 
\#Makrodefinition\#
 
\#Parameterbewertung\#
 
\#Parametersubstitution\#
 
\#Rekursive Makroaufrufe\#
 
\link("Verschachtelung von Makrodefi")Verschachtelung von Makrodefinitionen\#
 
\#Redefinieren von Makros\#
\end

screen( sensitive("EQU") )
Name            Equate - Zuweisen eines Wertes

Syntax          label EQU expression
                EQU label,expression

Beschreibung    Mittels der EQU-Direktive wird einem Label ein
                Wert zugewiesen, der durch den Ausdruck expression
                bestimmt wird. Zu beachten ist, da der Ausdruck
                nicht relativ zu einer externen Referenz sein
                darf. Statt des Ausdrucks darf auch ein Register-
                name zugewiesen werden. Dieser wird dann als Syno-
                nym benutzt.
                Ein einmal mit EQU zugewiesener Wert darf in der
                Folge nicht mehr ver„ndert werden. Die Zuweisung
                mit EQU hat Konstanten-Charakter.
                Beachten Sie, da hinter label kein Doppelpunkt
                stehen darf!

Beispiel        cr EQU $d
                EQU lf,$a

                EQU lf,$a     ; erneute Zuweisung verursacht einen
                              ; Fehler!

Querverweis     \#=\#, \#SET\#
\end

screen( sensitive("SET") )
Name            Set value - Zuweisen eines Wertes

Syntax          SET label,expression
                label SET expression

Beschreibung    Die SET-Direktive weist dem Symbol label den Wert
                des Ausdrucks expression zu. Mit SET definierte
                Symbole haben Variablen-Charakter, das heit, der
                Wert des Symbols darf durch erneute Zuweisung
                ge„ndert werden. Der zugewiesene Ausdruck darf
                auch eine Registerbezeichnung sein. Das Symbol
                wird dann als Synonym fr das Register benutzt.
                Beachten Sie, da hinter label kein Doppelpunkt
                stehen darf!

Beispiel        Count SET 3      ; alter Wert
                SET Count,5      ; neuer Wert

                Parameter SET D0 ; Register sind auch erlaubt

Querverweis     \#=\#, \#EQU\#
\end

screen( sensitive("=") )
Name            = - Zuweisen eines Wertes an ein Symbol

Syntax          symbol = expression

Beschreibung    Dem Symbol symbol wird der Wert des Ausdrucks
                expression zugewiesen. Mit der =-Direktive
                definierte Symbole haben Variablen-Charakter,
                das heit, der Wert des Symbols darf durch
                erneute Zuweisung ge„ndert werden.
                Der zugewiesene Ausdruck darf auch eine Register-
                bezeichnung sein. Das Symbol wird dann als Synonym
                fr das Register benutzt.

Beispiel        COUNT = 0
                ...
                COUNT = COUNT + 1

                Parameter = D0
                move.w  Parameter,-(sp)

Querverweis     \#EQU\#, \#SET\#
\end

screen( sensitive("REG") )
Name            Define Register List - Registerliste erzeugen

Syntax          label REG registerlist
                label REG 0
                REG label,registerlist
                REG label,0

Beschreibung    Die REG-Direktive stellt eine Registerliste fr
                die "move multiple"-Befehle der Prozessoren
                zusammen. Der Wert einer Registerliste darf
                ver„ndert werden. Eine leere Registerliste wird
                durch REG label,0 oder label REG 0 erzeugt.

Beispiel        SavedRegs REG A2-A4/D3
                ...

                ; -----------------------------------
                ; Beachten Sie die erweiterte Syntax:
                ; -----------------------------------

                movem.l  #SavedRegs,-(sp)
                ...
                movem.l  (sp)+,#SavedRegs ; <- kein Druckfehler!
\end

screen( sensitive("DC") )
Name            Define Constant - Definieren konstanter Daten

Syntax          [label:] DC[.size] expression[,expression...]

Beschreibung    Die DC-Direktive dient der Initialisierung des
                Speichers mit konstanten Werten. Die Werte
                ergeben sich aus der Liste von Ausdrucken
                (expression). Das Datenformat kann ber den
                Parameter size eingestellt werden, wobei alle
                Datenformate zugelassen sind, die auch fr die
                Assemblerbefehle gltig sind. 
                Wird size nicht angegeben, wird angenommen, da
                es sich bei den Daten um Worte handelt.
                Als expression darf auch ein String angegeben
                werden. Die Zeichen des Strings werden unabh„ngig
                vom angegebenen Datenformat als Bytes abge-
                speichert. Ist das Datenformat nicht Byte, so
                wird gegebenfalls mit Nullen aufgefllt, bis der
                Positionsz„hler auf das entsprechende Datenformat
                wieder ausgerichtet ist.

Beispiel        dc.b "Hello!"       ; erzeugt $48656C6C6F21
                dc.l "Hello!"       ;         $48656C6C6F210000
                dc   -1,0,1            ;         $FFFF00000001
                dc.x 1.0            ;         $3FFF00008000000000000000

Querverweis     \#ASCII\#, \#ASCIIL\#, \#ASCIIZ\#, \#DCB\#, \#DS\#
\end

screen( sensitive("DCB") )
Name            Define Constant Block - Definiere einen Block
                konstanter Daten

Syntax          [label:] DCB[.size] expr1[,expr2...]

Beschreibung    DCB initialisiert einen Speicherblock der durch
                size und expr1 spezifizierten Gr”e mit Konstanten.
                size gibt das Datenformat an. Voreingestellt ist
                Wort-Format. expr1 gibt die Anzahl an Einheiten
                der Gr”e size an, aus denen der Speicherblock 
                besteht. Die Konstante wird durch einen oder
                mehrere Ausdrcke (expr2) angegeben.

Beispiel        dcb.l 2,-2       ; erzeugt $FFFFFFFEFFFFFFFE
                dcb.w 2,3,4      ;         $0003000400030004
                dcb.b 3,"ABC"    ;         $414243414243414243

Querverweis     \#DC\#
\end

screen( sensitive("ASCII") )
Name            Generate ASCII-Characters - ASCII-Zeichen erzeugen

Syntax          [Label:] ASCII string[,string...]

Beschreibung    Die ASCII-Direktive dient dem Anlegen von Strings
                in DATA- und TEXT-Segmenten. Beachten Sie, da
                ASCII keine Stringendemarkierung erzeugt.

Beispiel        HelloText:    ASCII "Hello World!"
                              ASCII "Another", " Text"

Querverweis     \#ASCIIL\#, \#ASCIIZ\#, \#DC\#
\end

screen( sensitive("ASCIIL") )
Name            Generate Length Byte And ASCII-Characters -
                L„ngenbyte und ASCII-Zeichen erzeugen

Syntax          [Label:] ASCIIL string[,string...]

Beschreibung    ASCIIL legt die Strings, „hnlich wie ASCII, im
                aktuellen Segment ab. Zus„tzlich wird als erstes
                Byte fr jeden String dessen L„nge abgespeichert
                (Pascal-Strings).

Beispiel        HelloText:    ASCIIL "Hello World!"

                ; entspricht

                              DC.B  12
                              ASCII "Hello World!"

Querverweis     \#ASCII\#, \#ASCIIZ\#, \#DC\#
\end

screen( sensitive("ASCIIZ") )
Name            Generate ASCII-Characters And Zero Byte -
                ASCII-Zeichen und Null-Byte erzeugen

Syntax          [Label:] ASCIIZ string[,string...]

Beschreibung    Mit ASCIIZ kann man Strings gem„ C-Konvention
                erzeugen, das heit, das Stringende wird mit einem
                zus„tzlichen Null-Byte markiert. Ansonsten arbeitet
                ASCIIZ wie ASCII.

Beispiel        HelloText:      ASCIIZ "Hello World!"

                ; entspricht

                                ASCII "Hello World!"
                                DC.B  0

Querverweis     \#ASCII\#, \#ASCIIL\#, \#DC\#
\end

screen( sensitive("DS") )
Name            Define Storage - Speicher reservieren

Syntax          [label:] DS[.size] expression

Beschreibung    Die DS-Direktive reserviert Speicher im aktuellen
                Segment. Ist dieses das Text- oder Datensegment,
                so wird der Speicher mit Nullen initialisiert.
                Die Gr”e des Speicherbereichs berechnet sich aus
                expression Einheiten des Datenformats size. Falls
                size nicht angegeben wird, bezieht sich die
                Direktive auf das Wort-Format.

Beispiel        ds.b $100        ; reserviert  256 Bytes
                ds.w $100        ;             512
                ds   $100        ;             512
                ds.l $100        ;            1024
                ds.s $100        ;            1024
                ds.p $100        ;            3072

Querverweis        \#COMM\#, \#DC\#
\end

screen( sensitive("ORG") )
Name            Origin - \#Positionsz„hler\# setzen

Syntax          ORG expression

Beschreibung    Die ORG-Direktive setzt den Positionsz„hler
                auf den durch den Ausdruck expression angegebenen
                Wert. Dieser mu absolut sein. Der Positions-
                z„hler darf nicht auf Stellen zurckgesetzt 
                werden, fr die bereits Code erzeugt wurde.

Beispiel        ORG  $100 ; setzt den Positionsz„hler auf 256 Byte

Querverweis     \#*=\#
\end

screen( sensitive("*=") )
Name            *= - \#Positionsz„hler\# setzen

Syntax          *= expression

Beschreibung    *= setzt den Positionsz„hler auf den durch den
                Ausdruck expression angebenen Wert. Dieser mu
                absolut sein. Der Positionsz„hler darf nicht auf
                Stellen zurckgesetzt werden, fr die bereits
                Code erzeugt wurde.
                Zwischen dem Asterisk (*) und dem Gleichheits-
                zeichen = darf kein Leerzeichen stehen, da sonst
                die Zeile fr einen Kommentar gehalten wrde.

Beispiel        *= $100 ; setzt den Positionsz„hler auf 256 Byte

                * = $100 ; gesamte Zeile ist ein Kommentar!

Querverweis     \#ORG\#
\end

screen( sensitive("ALIGN") )
Name            Align Position Counter - \#Positionsz„hler\# ausrichten

Syntax          ALIGN [expression]

Beschreibung    Die ALIGN-Direktive erh”ht den Positionsz„hler
                soweit, da sein Wert durch den angegebenen
                Ausdruck expression teilbar wird. Der Wert von
                expression mu gr”er Null sein. Falls fr
                expression nichts angegeben wurde, wird der
                voreingestellte Wert 2 genommen.

Beispiel                   bra    prgStart
                           ASCII  "Copyright 1991 by ..."
                           ALIGN  256
                prgStart:  ...             ; beginnt auf Offset 256

Querverweis     \#EVEN\#
\end

screen( sensitive("EVEN") )
Name            Align To Even Address - \#Positionsz„hler\# auf gerade
                Adresse ausrichten

Syntax          EVEN

Beschreibung    Der Positionsz„hler des aktuellen Segments wird
                mittels der EVEN-Direktive auf eine gerade Adresse
                ausgerichtet. Die Wirkung von EVEN entspricht
                somit der von ALIGN 2. Die Verwendung von EVEN
                empfiehlt sich stets nach der Defintion von
                Daten im Byte-Format und Strings.

Beispiel        Bytes:  ds.b   13  ; Vorsicht, ungerade Gr”e!

                EVEN               ; jetzt wieder gerade Adresse!

                Words: ds.w   12

Querverweis     \#ALIGN\#
\end

screen( sensitive("TEXT") )
Name            Select Text Segment - Ausw„hlen des Textsegments

Syntax          TEXT [expression]
                TEXT "name"

Beschreibung    Die TEXT-Direktive w„hlt das Textsegment aus.
                Dieses dient der Aufnahme von Programmcode.
                Mittels des optionalen Ausdrucks expression kann
                eines von vier Subsegmenten mit den Nummern 0 bis
                3 gew„hlt werden. Statt einer Nummer kann auch ein
                Name fr ein Subsegmentes angegeben werden.
                Ist weder eine Nummer noch ein Name eines
                Subsegmentes angegeben, so wird das Subsegment 0
                genommen. Beim Linken werden alle Subsegmente zu
                einem einzigen Textsegment zusammengefat.

Querverweis     \#BSS\#, \#DATA\#
\end

screen( sensitive("DATA") )
Name            Data Segment - Auswahl des Datensegments

Syntax          DATA [expression]
                DATA "name"

Beschreibung    Die Direktive DATA w„hlt das Datensegment aus.
                Dieses dient der Aufnahme von Daten jeglicher Art.
                Mittels des optionalen Ausdrucks expression kann
                eines von vier Subsegmenten mit den Nummern 0 bis
                3 gew„hlt werden. Statt einer Nummer kann auch ein
                Name fr ein Subsegmentes angegeben werden.
                Ist weder eine Nummer noch ein Name eines Sub-
                segmentes angegeben, so wird das Subsegment 0
                genommen. Beim Linken werden alle Subsegmente zu
                einem einzigen Datensegment zusammengefat.

Querverweis     \#BSS\#, \#TEXT\#
\end

screen( sensitive("BSS") )
Name            Block Storage - Auswahl des BSS-Segments

Syntax          BSS [ expression ]
                BSS "name"

Beschreibung    Die BSS-Direktive w„hlt das BSS-Segment aus.
                Dieses dient ausschlielich der Reservierung von
                nicht initialisiertem Speicher. Mittels des
                optionalen Ausdrucks expression kann eines von
                vier Subsegmenten mit den Nummern 0 bis 3 gew„hlt
                werden. Statt einer Nummer kann auch ein Name fr
                ein Subsegmentes angegeben werden. Ist weder eine
                Nummer noch ein Name eines Subsegmentes angegeben,
                so wird das Subsegment 0 genommen. Beim Linken
                werden alle Subsegmente zu einem einzigen BSS-
                Segment zusammengefat.

Querverweis     \#DATA\#, \#TEXT\#
\end

screen( sensitive("OFFSET") )
Name            Offset - Absolutes Segment ausw„hlen

Syntax          OFFSET [expression]

Beschreibung    Die OFFSET-Direktive w„hlt ein absolutes Segment
                aus. In einem absolutem Segment kann man keinen
                Code erzeugen. Man darf nur Labels definieren und
                Speicherzuweisungen treffen. Somit sind absolute
                Segmente dazu geeignet, die Offsets von Struktur-
                elementen oder Stackframes zu definieren. Der
                optionale Parameter expression gibt einen Start-
                offset an. Fehlt er, beginnt das Segment bei Null.

Beispiel        # -------------------------------------------
                # Folgendes absolutes Segment entspricht
                # der C-Struktur
                #
                # struct  list
                # {
                #      struct list   *next;
                #      char          name[20];
                # };
                # -------------------------------------------

                OFFSET

                next:    ds.l  1
                name:    ds.b 20

                EVEN

                TEXT

                ...

                move.l   next(a0),a0
                lea.l    name(a0),a1

                ...
\end

screen( sensitive("LCOMM") )
Name            Local Common - Speicher im BSS-Segment zuweisen

Syntax          LCOMM label,expression

Beschreibung    Die LCOMM-Direktive reserviert unter dem Namen
                label expression Bytes im BSS-Segment. expression
                mu gr”er als Null sein. 

Beispiel        LCOMM  buffer,$1000 ; 4 KByte groen Buffer anlegen

Querverweis     \#COMM\#, \#BSS\#
\end

screen( sensitive("GLOBL") )
Name            Global Symbol - Globales Symbol definieren

Syntax          GLOBL label[,label...]

Beschreibung    Die GLOBL-Direktive definiert das bzw. die
                angegebenen Labels als global. Das heit, wenn
                ein gleichnamiges Label in dem betreffenden
                Modul definiert worden ist, so wird dieses
                exportiert, andernfalls importiert.

Beispiel        GLOBL   impLabel, expLabel

                ...
                expLabel: ...  ; expLabel wird exportiert!

                ...
                pea.l impLabel ; impLabel mu importiert werden
                ...

Querverweis     \#EXPORT\#, \#IMPORT\#, \#XDEF\#, \#XREF\#
\end

screen( sensitive("XREF") )
Name            Extern Reference - Referenz auf externes Symbol

Syntax          XREF label,[label...]

Beschreibung    Die Direktive XREF macht ein oder mehrere globale
                Symbole in einem Modul sichtbar. Das heit, da
                ein aus einem anderen Modul exportiertes Symbol
                nach der Definition mit XREF im aktuellen Modul
                benutzt werden darf.

Beispiel        XREF  yourLabel
                ...
                lea.l   yourLabel,a0
                ...

Querverweis     \#EXPORT\#, \#GLOBL\#, \#IMPORT\#, \#XDEF\#
\end

screen( sensitive("XDEF") )
Name            Extern Definition - Definition fur externes Symbol

Syntax          XDEF label,[label...]

Beschreibung    Die Direktive XDEF exportiert ein oder mehrere
                Labels, so da diese auch in anderen Modulen
                verwendet werden k”nnen. Die Labels werden somit
                global gltig.

Beispiel        XDEF  myLabel
                ...
                myLabel:   ...

Querverweis     \#EXPORT\#, \#GLOBL\#, \#IMPORT\#, \#XREF\#
\end

screen( sensitive("COMM") )
Name            Common - Variable in der Common Section definieren

Syntax          COMM label,expression

Beschreibung    Die COMM-Direktive definiert ein Label (label) und
                reserviert unter diesem Speicher im BSS-Segment.
                Die Gr”e des reservierten Speichers ergibt sich
                aus dem Wert von expression, der gr”er Null sein
                mu. 

Beispiel        COMM   buffer,$1000  ; 4 KByte groen Buffer 
                                     ; reservieren
                ...
                lea.l  buffer,a0

Querverweis     \#DS\#, \#LCOMM\#
\end

screen( sensitive("ALINE") )
Name            Generate $A-Line Opcode - Line-A Befehlscode erzeugen

Syntax          ALINE #expression

Beschreibung    Mittels der ALINE-Direktive kann man ein
                Befehlswort erzeugen, dessen Bits 12..15 den
                Wert $A enthalten. In die Bits 0..11 wird der
                Wert des Ausdrucks expression eingetragen, der
                zwischen $000 und $FFF liegen darf. Trifft der
                Prozessor auf einen Line-A-Opcode, wird eine
                spezielle Exception-Routine zur Auswertung dieser
                Befehle aufgerufen.

Beispiel        ALINE  #16    ; erzeugt den Opcode $A010

Querverweis     \#FLINE\#
\end

screen( sensitive("FLINE") )
Name            Generate $F-Line Opcode - Line-F Befehlscode erzeugen

Syntax          FLINE #expression

Beschreibung    Mittels der FLINE-Direktive kann man ein
                Befehlswort erzeugen, dessen Bits 12..15 den
                Wert $F enthalten. In die Bits 0..11 wird der
                Wert des Ausdrucks expression eingetragen, der
                zwischen $000 und $FFF liegen mu. Trifft der
                Prozessor auf einen Line-F-Opcode, wird eine
                spezielle Exception-Routine zur Auswertung
                dieser Befehle aufgerufen.

Beispiel        FLINE  #256   ; erzeugt den Opcode $F100

Querverweis     \#ALINE\#
\end

screen( "Befehlssatz",
		"MC68nnn",
		sensitive("MC68010"),
		sensitive("MC68030"),
		sensitive("MC68851"),
		sensitive("MC68020"),
		sensitive("MC68040"),
		sensitive("MC68000"),
		sensitive("MC68881") )
Name            Select Instruction Set - Ausw„hlen des Befehlssatzes

Syntax          MC68000
                MC68010
                MC68020
                MC68030
                MC68040
                MC68851
                MC68851 -
                MC68881 [expression]
                MC68881 -

Beschreibung    Die MC68nnn-Direktiven w„hlen den Befehlssatz fr
                einen spezifischen Prozessor aus.
                Mit MC68000 wird der Befehlssatz fr die
                Prozessoren MC68000 und MC68008 aktiviert. Die
                MC68010-Direktive selektiert die Befehle fr die
                Prozessortypen MC68010 und MC68012. Die Direktiven
                MC68020 und MC68030, sowie MC68040 w„hlen den
                Befehlssatz fr die gleichnamigen Prozessoren aus.
                Ein Befehlssatz bleibt solange aktiv, bis ein
                neuer ausgew„hlt wird.
                Um den Befehlssatz des Coprozessors MC68551 zu
                aktivieren, nehmen Sie die Direktive MC68851 in
                Ihren Quelltext auf. Wenn Sie den Befehlssatz fr
                einen Fliekommakoprozessor ben”tigen, so geschieht
                dies durch die Direktive MC68881. Diese erh„lt als
                Parameter die Coprozessor-Id. Fehlt der Parameter,
                so wird als Id 1 angenommen. Die Befehlss„tze fr
                Coprozessoren werden deaktiviert, indem die ent-
                sprechende Direktive mit nachgestelltem Minus-
                Zeichen aufgerufen wird.

Querverweis     \#Cache\#, \#Fliekomma-Befehle\#, \#PMMU-Befehle\#
                \#USER\#, \#SUPER\#
\end

screen( sensitive("SUPER") )
Name            Select Privileged Instruction Set - Ausw„hlen
                des Befehlssatzes fr den Supervisor-Modus

Syntax          SUPER

Beschreibung    Mit der Direktive SUPER kann man den privile-
                gierten Befehlssatz fr den Supervisor-Modus
                des aktuellen Prozessors ausw„hlen. Voreinge-
                stellt ist der nicht-privilegierte Befehlssatz.

Querverweis     \#MC68nnn\#, \#USER\#
\end

screen( sensitive("USER") )
Name            Select Nonprivileged Instruction Set - Ausw„hlen
                des Befehlssatzes fr den User-Modus

Syntax          USER

Beschreibung    Mit der USER-Direktive kann man auf den nicht-
                privilegierten Befehlssatz fr den User-Modus
                des aktuellen Prozessors zurckschalten.

Querverweis     \#MC68nnn\#, \#SUPER\#
\end

screen( sensitive("INCLUDE") )
Name            Include File - Datei einbinden

Syntax          INCLUDE "filename"
                INCLUDE 'filename'

Beschreibung    Die INCLUDE-Direktive bindet die angegebene
                Datei in den Quelltext ein. INCLUDE-Direktiven
                k”nnen beliebig tief verschachtelt werden.

Beispiel        INCLUDE "macro.inc"
                INCLUDE 'INCLUDE\\string.mac'
\end

screen( sensitive("PRINT") )
Name            Print Message - Meldung ausgeben

Syntax          PRINT ["message"]

Beschreibung    Die PRINT-Direktive gibt den Text message
                w„hrend der Assemblierung aus. Ist kein Text
                angegeben, fhrt PRINT nur einen Zeilenvorschub
                aus.

Beispiel        PRINT "Dies sind ""Anfhrungszeichen"", alles klar?"

Querverweis     \#ERROR\#
\end

screen( sensitive("TTL") )
Name            Title - Untertitel fr Listing

Syntax          TTL "titel"

Beschreibung    Die TTL-Direktive erlaubt die Definition eines
                Untertitels fr die Seiten eines Listings. Es
                drfen in einer Quelltextdatei mehrere Untertitel
                vereinbart werden. Durch die Variable %f im Titel
                title kann der Name der Quelldatei in den Unter-
                titel mitaufgenommen werden. Voreingestellt ist
                Source File: %f.

Beispiel        ...
                TTL "Beispiel fr einen Untertitel"
                ...
                TTL "Beispiel mit Filenamen: %f"
                ...

Querverweis     \#LIST\#, \#NOLIST\#, \#PAGE\#
\end

screen( sensitive("PAGE") )
Name            Set Page Size - Setzen der Seitenl„nge fr Listings

Syntax          PAGE [expression]

Beschreibung    Mit der PAGE-Direktive wird die Seitenl„nge
                fr Listings festgelegt. Wenn der optionale
                Parameter expression fehlt, erzwingt die
                Direktive einen sofortigen Seitenumbruch.
                Andernfalls gibt expression die neue Seiten-
                l„nge an. Voreingestellt sind 59 Zeilen pro
                Seite.

Beispiel        ; Dieser Text steht auf der alten Seite ...

                PAGE

                ; und dieser auf einer neuen Seite!

                PAGE 70   ; ab jetzt sind Seiten 70 Zeilen lang

Querverweis     \#LIST\#, \#NOLIST\#, \#TTL\#
\end

screen( sensitive("LIST") )
Name            List - Text im Listing auffhren

Syntax          LIST

Beschreibung    Die LIST-Direktive aktiviert die Ausgabe in die
                Listing-Datei. Damit diese erzeugt wird, mu
                beim Assembleraufruf der P-Schalter gesetzt
                werden. Die Ausgabe in die Listing-Datei ist
                voreingestellt. Deshalb macht die LIST-Direktive
                nur Sinn, wenn zuvor mit NOLIST die Ausgabe
                unterdrckt wurde.

Beispiel        LIST
                ... ; ab hier steht alles im Listing!

Querverweis     \#NOLIST\#, \#PAGE\#, \#TTL\#
\end

screen( sensitive("NOLIST") )
Name            Do not List - Text im Listing unterdrcken

Syntax          NOLIST

Beschreibung    Mit der NOLIST-Direktive kann die Aufnahme von
                Quelltext in eine Listing-Datei unterdrckt
                werden. Mit LIST wird die Ausgabe wieder aktiviert.

Beispiel        ; Diese Zeile steht im Listing.

                NOLIST

                ; Diese Zeile nicht!

                LIST

                ; Aber diese wieder!

Querverweis     \#LIST\#, \#PAGE\#, \#TTL\#
\end

screen( "IFcc",
		sensitive("IFNB"),
		sensitive("IF1"),
		sensitive("IF2"),
		sensitive("IFLT"),
		sensitive("IFLE"),
		sensitive("IFEQ"),
		sensitive("IFNE"),
		sensitive("IFF"),
		sensitive("IFGE"),
		sensitive("IFB"),
		sensitive("IFGT"),
		sensitive("IF") )
Name            If Condition - Bedingte Assemblierung

Syntax          IFcc expression
                    <statement list1>
                [ELSE
                    <statement list2>]
                ENDIF

Beschreibung    Die IFcc-Direktiven leiten eine bedingte
                Assemblierung ein. Ist die Bedingung expression
                erfllt, so werden die Anweisungen unter
                statement list1 assembliert. Andernfalls, sofern
                eine ELSE-Direktive vorhanden ist, werden die
                Anweisungen statement list2 bersetzt. Das
                Konstrukt zur bedingten Assemblierung wird durch
                ENDIF oder ENDC abgeschlossen.
                Die folgende Tabelle zeigt die m”glichen Bedin-
                gungen fr IFcc-Direktiven:

                Syntax             Bedingung erfllt, falls
                -------------------------------------------------
                IF expression      expression != 0
                IFF expression     expression == 0
                IFB argument       argument ist nicht vorhanden
                IFNB argument      argument ist vorhanden
                IF1                1.Assemblerlauf
                IF2                2.Assemblerlauf
                IFEQ expression    expression == 0
                IFNE expression    expression != 0
                IFLE expression    expression <= 0
                IFLT expression    expression < 0
                IFGE expression    expression >= 0
                IFGT expression    expression > 0
                -------------------------------------------------

                Die Direktiven IF1 und IF2 sind lediglich aus
                Grnden der Kompatibilit„t implementiert, da
                Pure Assembler ein One-Pass-Assembler ist, d.h.
                er bersetzt die Quellen in einem Durchlauf.
                Konstrukte, die auf mehr als einem Assemblerlauf
                beruhen, sind also mit Vorsicht zu genieen.
                Die IFB- und IFNB-Direktiven werden im Zusammenhang
                mit Makros ben”tigt. Durch sie ist es m”glich,
                zu prfen, ob ein aktueller Parameter leer ist,
                also nicht angegeben wurde.

Beispiel        IF value = 0     ; oder IFEQ value
                    PRINT "value == 0"
                ENDIF

                ...
                \#MACRO\# whatever parameter

                    IFB parameter
                        ERROR "missing parameter"
                        EXITM
                     ENDIF
                ...
                ENDM

Querverweis     \#ELSE\#, \#ENDC\#, \#ENDIF\#
\end

screen( sensitive("ELSE") )
Name            ELSE - Einleiten einer Alternative fr die
                bedingte Assemblierung

Syntax          IFcc expression
                    <statement list>
                [ELSE
                    <statement list>]
                ENDIF

Beschreibung    Die ELSE-Direktive wird im Zusammenhang mit der
                bedingten Assemblierung benutzt. Sie leitet einen
                Block zur alternativen Ausfhrung ein, falls die
                Bedingung der IFcc-Direktive nicht erfllt ist.
                Die Verwendung der ELSE-Direktive bei der beding-
                ten Assemblierung ist optional.

Beispiel        IF expression
                    PRINT "expression != 0"
                ELSE
                    PRINT "expression == 0"
                ENDIF

Querverweis     \#IFcc\#, \#ENDC\#, \#ENDIF\#
\end

screen( sensitive("ENDIF") )
Name            End IF-Construction - Beenden einer IF-Konstruktion

Syntax          IFcc expression
                    <statement list>
                [ELSE
                    <statement list>]
                ENDIF

Beschreibung    Die ENDIF-Direktive schliet ein Konstrukt zur
                bedingten Assemblierung ab. ENDIF ist „quivalent
                zur ENDC-Direktive.

Beispiel        IF expression
                    PRINT "expression != 0"
                ENDIF

Querverweis     \#IFcc\#, \#ENDC\#
\end

screen( sensitive("ENDC") )
Name            End Conditional Assembling - Beenden der bedingten 
                Assemblierung

Syntax          IFcc expression
                    <statement list>
                [ELSE
                    <statement list>]
                ENDC

Beschreibung    Die Direktive ENDC beendet ein Konstrukt zur
                bedingten Assemblierung. ENDC bewirkt dasselbe
                wie die ENDIF-Direktive.

Beispiel        IF expression
                    PRINT "expression != 0"
                ENDC

Querverweis     \#IFcc\#, \#ENDIF\#
\end

screen( sensitive("END") )
Name            End Assembling - Beenden der Assemblierung

Syntax          END

Beschreibung    Text nach der END-Direktive in einer Quelltext-
                datei wird vom Assembler ignoriert. Die Verwendung
                von END am Ende eines Quelltextes ist nicht
                unbedingt erforderlich.

Beispiel        ...
                .END

                Was hier steht, interessiert den Assembler nicht 
                mehr!
\end

screen( "Makrodefinition",
		sensitive("MACRO") )
Name            Define Macro - Makrodefinition

Syntax          MACRO name[.formal0] [[formal1],formal2...]
                    <statement list>
                ENDM

Beschreibung    Mit der MACRO-Direktive kann man Sequenzen von
                Anweisungen einen Namen zuordnen. Wird dieser
                Name bei der Assemblierung gefunden, wird er
                durch die Anweisungssequenz ersetzt. Makros
                k”nnen auch Parameter besitzen. Die formalen
                Parameter werden bei der Makroexpansion durch
                die aktuellen Parameter substituiert. Abge-
                schlossen werden Makrodefintionen durch die
                ENDM-Direktive.
                Beim Aufruf werden die aktuellen Parameter des
                Makros durch Kommata getrennt. Ist fr das Makro
                der optionale, formale Parameter formal0 definiert,
                so wird dieser beim Makroaufruf, durch einen Punkt
                abgetrennt, an den Makronamen angeh„ngt. Danach
                mu mindestens ein Leerzeichen vor den restlichen
                Parametern stehen:

                MACRO test.size param1, param2
                    ...
                ENDM

                ...
                test.l "First parameter", 2
                ...

                Der formale Parameter formal0 ist fr die Angabe
                von Gr”enoperationen gedacht. Fehlt er beim Aufruf,
                so wird er bei der Makroexpansion durch einen
                Leerstring substituiert. Fhrt dies dazu, da ein
                einzelner Punkt dastehen wrde, so wird der Punkt
                unterdrckt:

                MACRO Push.size parameter
                    move.size parameter,-(sp)
                ENDM

                ...
                Push.l  d0    ; wird zu move.l d0,-(sp) expandiert
                Push d0       ; wird zu move d0,-(sp)
                ...

                Werden beim Aufruf mehr aktuelle Parameter ange-
                geben, als formale definiert sind, werden die
                berzahligen ignoriert. Sollten dagegen zu wenig
                aktuelle Parameter bergeben werden, werden die
                fehlenden Parameter durch Leerstrings erg„nzt.
                Alle Zeichen innerhalb von Strings und Klammer-
                paaren gelten als zum Parameter geh”rig. Dies ist
                notwendig, damit Parameter Kommata enthalten
                drfen:

                MACRO anotherTest param1, param2
                    ...
                ENDM

                ...

                ; 1.Parameter: "Hello, here I am!"
                ; 2.Parameter: 20(a0,d0)
                ; --------------------------------

                anotherTest "Hello, here I am!", 20(a0,d0)

                ...

Querverweis     \#ENDM\#, \#LOCAL\#
\end

screen( sensitive("REPT") )
Name            Repeat - Wiederholung

Syntax          REPT expression
                    <statement list>
                ENDM

Beschreibung    Mit Hilfe der REPT-Direktive kann man eine
                Sequenz von Anweisungen expression-mal wieder-
                holen. expression mu gr”er gleich Null sein,
                wobei fr Null die Anweisungsfolge unterdrckt
                wird. Beendet wird die Sequenz durch die ENDM-
                Direktive.

Beispiel        DISP = 0
                REPT 16

                    move.b   DISP(a0),(a1)+
                    DISP = DISP + 80

                ENDM

Querverweis     \#ENDM\#
\end

screen( sensitive("ENDM") )
Name            End Macro or Repetition - Beenden eines Makros oder
                einer Wiederholung

Syntax          ENDM

Beschreibung    ENDM beendet eine Makrodefinition oder eine
                Wiederholungsanweisung.

Beispiel        Counter = 1
                REPT 10
                    dc.w   Counter
                     Counter = Counter + 1
                ENDM

                ...
                MACRO PushRegister RegNum
                    move.l   r&RegNum,-(sp)
                ENDM

Querverweis     \#MACRO\#, \#REPT\#
\end

screen( sensitive("EXITM") )
Name            Exit Macro - Verlassen eines Makros

Syntax          EXITM

Beschreibung    Trifft der Assembler auf die EXITM-Direktive, so
                wird die Bearbeitung des aktuellen Makros sofort
                abgebrochen. Somit kann in Verbindung mit der
                bedingten Assemblierung beispielsweise die
                Erzeugung von unntzem Code durch Makros abgefangen
                werden.

Beispiel        MACRO xyz value1 value2

                    IFEQ value1 - value2
                        EXITM

                ...

Querverweis     \#MACRO\#
\end

screen( sensitive("LOCAL") )
Name            Local Label - Lokale Labeldefintion fr Makros

Syntax          LOCAL label[,label...]

Beschreibung    Wenn innerhalb von Makros \link("Symbole")Labels\# ben”tigt
                werden, sollten diese mittels der LOCAL-
                Direktive definiert werden. Andernfalls
                wrden bei wiederholter Makroexpansion die
                Labels mehrfach erzeugt und somit Fehler
                verursacht. LOCAL sorgt dafr, da die Labels
                des Makros bei der Expansion durch Labels
                der Form ____XXXX ersetzt werden, wobei XXXX
                eine Dezimalzahl aus dem Bereich von 0000 bis
                9999 ist. Verwenden Sie deshalb selber keine
                Labels dieser Art in Ihren Quellen.

Beispiel        MACRO ABSOLUTE

                    LOCAL  end

                         tst.w   d0
                         bge     end
                         neg.w   d0
                    end:

                ENDM

                ...
                ABSOLUTE     ; erzeugt fur end ____0000

                ABSOLUTE     ; erzeugt fur end ____0001
                ...

Querverweis     \#MACRO\#
\end

screen( sensitive("IMPORT") )
Name            Import Symbol Definition - Symboldefinition importieren

Syntax          IMPORT label[,label...]

Beschreibung    Die IMPORT-Direktive macht ein oder mehrere globale
                Symbole in einem Modul sichtbar. Das heit, da ein
                aus einem anderen Modul exportiertes Symbol nach
                dem Importieren im aktuellen Modul bentzt werden
                darf.

Beispiel        IMPORT  yourLabel

                ...
                lea.l   yourLabel,a0
                ...

Querverweis     \#EXPORT\#, \#GLOBL\#, \#XDEF\#, \#XREF\#
\end

screen( sensitive("EXPORT") )
Name            Export Symbol Definition - Exportieren einer Symbol-
                definition

Syntax          EXPORT label[,label...]

Beschreibung    Die EXPORT-Direktive exportiert ein oder mehrere
                Labels, so da diese auch in anderen Modulen
                verwendet werden k”nnen. Die Labels werden somit
                global gltig.

Beispiel        EXPORT  myLabel

                ...

                myLabel:   ...

Querverweis     \#GLOBL\#, \#IMPORT\#, \#XDEF\#, \#XREF\#
\end

screen( sensitive("MODULE") )
Name            Begin new Module - Neues Modul beginnen

Syntax          MODULE label

Beschreibung    Mit MODULE kann man ein neues Modul beginnen.
                Nach der Direktive mu der Name des Moduls
                stehen. Dieser wird als Label fr die erste
                codeerzeugende Zeile des Moduls verwendet.
                Innerhalb des Moduls sind alle definierten
                Labels fr den Modulbereich lokal. Ein Segment-
                wechsel ist innerhalb eines Moduls nicht m”glich.
                Die gleichzeitige Verwendung von Moduln und
                \link("Lokale Labels")lokalen Labels\# ist nicht m”glich.
                Beim Linken werden nur die tats„chlich benutzten
                Module zum fertigen Programm gebunden.

Beispiel        TEXT

                MODULE example

                moveq.l  #0,d0       ; auf dieser Zeile ist das
                                     ; Label example definiert!
                ...
                bne      example

                ; -------------------------------------------
                ; Das folgende Label ist Modul-lokal. Soll es
                ; global sein, mu es explizit mit EXPORT
                ; anotherEntryPoint exportiert werden!
                ; -------------------------------------------

                anotherEntryPoint:
                ...
                ENDMOD

Querverweis     \#ENDMOD\#
\end

screen( sensitive("ENDMOD") )
Name            End Module - Beenden eines Moduls

Syntax          ENDMOD

Beschreibung    ENDMOD beendet ein durch MODULE eingeleitetes
                Modul. Bevor ein neues Modul begonnen werden kann,
                mu das aktuelle Modul zuvor durch ENDMOD abge-
                schlossen werden.

Querverweis     \#MODULE\#
\end

screen( sensitive("ERROR") )
Name            Generate Error Message - Fehlermeldung erzeugen

Syntax          ERROR "message"

Beschreibung    Mit der ERROR-Direktive kann man eine Fehler-
                meldung erzeugen. Zus„tzlich wird der Text
                message ausgegeben.

Beispiel        IF value < 0
                    ERROR "value < 0"
                ENDIF

Querverweis     \#PRINT\#
\end

screen( "Parameterbewertung" )
Parameterbewertung in Makros
----------------------------------------------------------------------

Beginnt ein aktueller Parameter mit einem Gleichheitszeichen (=),
einem Dollarzeichen ($) oder einem Klammeraffen (@) und als zweitem
Zeichen einer offnenden Klammer ((), so werden die darauffolgenden
Zeichen bis zur schlieenden Klammer ()) als Ausdruck fr einen
Long-Wert betrachtet. Der Ausdruck wird nach der Auswertung in
einen String umgewandelt. War das erste Zeichen ein Gleichheits-
zeichen, so erh„lt man einen Dezimalstring, fr das Dollarzeichen
einen Hexadezimal- und fr den Klammeraffen einen Oktalstring.

        MACRO test3 parameter
        ...
        ENDM

        ; $(3*9) ergibt "$1b"
        ; -------------------

        test3 $(3*3)
        ...
\end

screen( "Parametersubstitution" )
Parametersubstitution in Makros
----------------------------------------------------------------------

Innerhalb von Strings findet normalerweise keine Parameter-
substituierung statt. Soll trotzdem eine Substituierung erfolgen,
so ist der entsprechende formale Parameter in dem String durch
ein vorangestelltes kaufm„nnisches Additionszeichen (&) zu
kennzeichnen. Dies gilt auch fr nicht eindeutige Substitutionen
im brigen Makrotext:

         MACRO PushRegister RegNumber
             move.l  R&RegNumber,-(sp)
         ENDM

Das Ergebnis einer Parametersubstitution wird nicht weiter sub-
stituiert. So werden ungewollte, nicht terminierende Substitutions-
rekursionen vermieden.
\end

screen( "Makrorekursion",
		"Rekursive Makroaufrufe" )
Rekursive Makroaufrufe
----------------------------------------------------------------------

Ein Makro kann sich selbst aufrufen oder ein Aufruf von einem
anderen Makro aus kann schlielich zum ursprnglich aufrufenden
Makro zurckfhren. Diese direkte oderindirekte Rekursion ist
nur dann sinnvoll, wenn durch eine bedingte Direktive eine
unendliche Rekursion verhindert wird.
\end

screen( "Verschachtelung von Makrodefi" )
Verschachtelung von Makrodefinitionen
----------------------------------------------------------------------

Eine Makrodefinition darf weitere Makrodefinitionen enthalten.
Die inneren Makros werden dann erst nach der ersten Expansion
des „ueren Makros definiert.
Wenn beispielsweise ein Makro eine Initialisierung ben”tigt, so
kann damit sichergestellt werden, da vor dem ersten Makroaufruf
die Initialisierung stattfand.

         MACRO Init
             ...
             MACRO DoWhatYouLike
             ...
             ENDM
         ENDM

         ...
         DoWhatYouLike      ; hier gibt es eine Fehlermeldung!
         ...

         Init
         DoWhatYouLike      ; jetzt geht's!
         ...
\end

screen( "Redefinieren von Makros" )
Redefinieren von Makros
----------------------------------------------------------------------

Makros kann man unter demselben Namen, aber mit anderem Makro-
k”rper redefinieren. Im Extremfall kann sich ein Makro sogar
selbst redefinieren.
Hierbei macht man sich \link("Verschachtelung von Makrodefi")verschachtelte Definition\# zunutze. Sinnvoll
sind solche Redefinitionen besonders im Zusammenhang mit
Intialisierungen. Ben”tigt ein Makro ein Unterprogramm, so kann
dieses beim ersten Makroaufruf erzeugt werden. Danach redefiniert
sich das Makro mit dem Text, den man eigentlich von der Expansion
erwartet und ruft sich schlielich selbst nochmals auf.
Das folgende Beispiel zeigt das Makro BlockMove, das zun„chst
ein Unterprogramm zum Verschieben von Bl”cken erzeugt und sich
dann redefiniert, so da es Aufrufe fr das Unterprogramm
generieren kann.

       MACRO BlockMove source, destination, size
           TEXT 3
           BlckMv:
                   bra    .test
           .loop:  move.b  (a0)+,(a1)+
           .test:  dbra    d0,.loop
                   rts

           MACRO BlockMove src, dst, siz
                   move.w  siz,d0
                   lea.l   src,a0
                   lea.l   dst,a1
                   jsr     BlckMv
           ENDM

           TEXT

           BlockMove source, destination, size

       ENDM
\end

screen( "Befehlsbersicht" )
Pure Assembler Befehlsbersicht
----------------------------------------------------------------------

\#Transfer-Befehle\#
 
\#Arithmetische Befehle\#
 
\#Logische Befehle\#
 
\#Bit-Befehle\#
 
\#Bitschiebe- und Rotierbefehle\#
 
\#Programmstruktur-Befehle\#
 
\#Fliekomma-Befehle\#

\#PMMU-Befehle\#
\end

screen( "Befehle, Transfer-",
		"Transfer-Befehle" )
Transfer-Befehle im šberblick
----------------------------------------------------------------------

\#CAS\#       Vergleiche und Tausche                             ( MC68020 )
\#CAS2\#      Vergleiche und Tausche doppelt                     ( MC68020 )|
\#EXG\#       Vertausche Registerinhalte
\#PEA\#       Lege Adresse auf den Stack
\#LEA\#       Lade Adresse in ein Adreregister
\#LINK\#      Lege neuen Stackbereich an
\#MOVE\#      šbertrage Daten
\#MOVE16\#    šbertrage 16-Byte-Block                            ( MC68040 )
\#MOVEA\#     šbertrage Daten in ein Adreregister
\#MOVEC\#     šbertrage Kontrollregister                         ( MC68010 )
\#MOVEM\#     šbertrage mehrere Register
\#MOVEP\#     šbertrage Daten fr die Peripherie
\#MOVEQ\#     šbertrage Konstante schnell in ein Datenregister
\#MOVES\#     šbertrage Register via SFC oder DFC                ( MC68010 )
\#PACK\#      Packe BCD-Zahlen                                   ( MC68020 )
\#SWAP\#      Tausche Registerh„lften
\#UNLK\#      Hole den Stackpointer zurck
\#UNPK\#      Entpacke BCD-Zahlen                                ( MC68020 )
\end

screen( "Arithmetische Befehle",
		"Befehle, Arithmetische" )
Arithmetische Befehle im šberblick
----------------------------------------------------------------------

\#ABCD\#      Addition von BCD-Zahlen
\#ADD\#       Bin„re Addition
\#ADDA\#      Bin„re Addition mit Adreregister als Ziel
\#ADDI\#      Bin„re Addition mit Konstante als Quelle
\#ADDQ\#      Bin„re Addition (schnell)
\#ADDX\#      Bin„re Addition mit Extendbit
\#CLR\#       L”sche den Inhalt des Operanden
\#CMP\#       Vergleiche zwei Operanden
\#CMPA\#      Vergleiche zwei Operanden mit Adreregister als Ziel
\#CMPI\#      Vergleiche zwei Operanden mit Konstante als Quelle
\#CMPM\#      Vergleiche zwei Speicherzellen
\#CMP2\#      Vergleiche Datenregister mit 2 Grenzen             ( MC68020 )
\#DIVS\#      Division mit Vorzeichen
\#DIVU\#      Division ohne Vorzeichen
\#EXT\#       Vorzeichenrichtige Erweiterung eines Datenregisters
\#MULS\#      Multiplikation mit Vorzeichen
\#MULU\#      Multiplikation ohne Vorzeichen
\#NBCD\#      Negation von BCD-Zahlen
\#NEG\#       Bin„re Negation
\#NEGX\#      Bin„re Negation mit Extendbit
\#SBCD\#      Subtraktion von BCD-Zahlen
\#SUB\#       Bin„re Subtraktion
\#SUBA\#      Bin„re Subtraktion mit Adreregister als Ziel
\#SUBI\#      Bin„re Subtraktion mit Konstante als Quelle
\#SUBQ\#      Bin„re Subtraktion (schnell)
\#SUBX\#      Bin„re Subtraktion mit Extendbit
\#TST\#       Prfe Inhalt des Operanden
\end

screen( "Logische Befehle",
		"Befehle, Logische" )
Logische Befehle im šberblick
----------------------------------------------------------------------

\#AND\#     Logisches UND
\#ANDI\#    Logisches UND mit einer Konstanten  
\#EOR\#     Logisches Exklusiv-ODER
\#EORI\#    Logisches Exklusiv-ODER mit einer Konstanten
\#NOT\#     Logisches Komplement
\#OR\#      Logisches ODER
\#ORI\#     Logisches ODER mit einer Konstanten
\end

screen( "Einzelbit-Befehle",
		"Bit-Befehle",
		"Befehle, Einzelbit-" )
Bit-Befehle im šberblick
----------------------------------------------------------------------

\#BCHG\#    Prfe ein Bit und „ndere es     
\#BCLR\#    Prfe ein Bit und setze es auf 0     
\#BFCHG\#   Prfe Bitfield und „ndere es                         ( MC68020 )
\#BFCLR\#   Prfe Bitfield und setze es auf 0                    ( MC68020 )
\#BFEXTS\#  Extrahiere signed Bitfield                           ( MC68020 )
\#BFEXTU\#  Extrahiere unsigned Bitfield                         ( MC68020 )
\#BFFFO\#   Suche in Bitfield                                    ( MC68020 )
\#BFINS\#   Fge Daten in ein Bitfield ein                       ( MC68020 )
\#BFSET\#   Prfe Bitfield und setze es auf 1                    ( MC68020 )
\#BFTST\#   Prfe Bitfield                                       ( MC68020 )
\#BSET\#    Prfe ein Bit und setze es auf 1    
\#BTST\#    Prfe ein Bit    
\#TAS\#     Prfe und setzte ein Bit im Zieloperanden
\end

screen( "Rotierbefehle",
		"Bitschiebe- und Rotierbefehle",
		"Befehle, Bitschiebe-",
		"Befehle, Rotier-" )
Bitschiebe- und Rotierbefehle im šberblick
----------------------------------------------------------------------

\#ASL\#     Arithmetische Verschiebung nach links
\#ASR\#     Arithmetische Verschiebung nach rechts
\#LSL\#     Logische Verschiebung nach links
\#LSR\#     Logische Verschiebung nach rechts
\#ROL\#     Rotiere links
\#ROR\#     Rotiere rechts
\#ROXL\#    Rotiere links unter Einbeziehung des X-Flags
\#ROXR\#    Rotiere rechts unter Einbeziehung des X-Flags
\end

screen( "Befehle, Programmstruktur-",
		"Programmstruktur-Befehle" )
Programmstruktur-Befehle im šberblick
----------------------------------------------------------------------

\link("BMI")Bcc\#     Bedingte Verzweigung
\#BKPT\#    Breakpoint                                           ( MC68010 )
\#BRA\#     Verzweige immer
\#BSR\#     Verzweige zu Unterprogramm
\#BT\#      Verzweige immer
\#CALLM\#   Springe zu Modul                                 ( nur MC68020 )
\#CHK\#     Prfe Datenregister gegen obere Grenze
\#CHK2\#    Prfe Datenregister gegen zwei Grenzen               ( MC68020 )
\link("DBMI")DBcc\#    Prfe Bedingung, dekrementiere und verzweige
\#DBF\#     Dekrementiere und verzweige
\#DBRA\#    Dekrementiere und verzweige
\#ILLEGAL\# Unzul„ssiger Opcode
\#JMP\#     Sringe zu Adresse
\#JSR\#     Springe zu Unterprogramm
\#NOP\#     Keine Operationm
\#RESET\#   Setze Peripherie zurck
\#RTD\#     Rckkehr aus Unterprogramm mit Aufr„umen des Stacks  ( MC68010 )
\#RTE\#     Rckkehr aus einer Exception
\#RTM\#     Rckkehr aus Modul                               ( nur MC68020 )
\#RTS\#     Rckkehr aus Unterprogramm
\#RTR\#     Rckkehr aus Exception ohne Ver„ndern des Systembyte
\link("SGT")Scc\#     Setze ein Byte in Anh„ngigkeit von einer Bedingung
\#STOP\#    Lade Status Register und stoppe Programmausfhrung
\#TRAP\#    Gehe in Ausnahmebehandlung
\link("TRAPCC")TRAPcc\#  Trap bei Bedingung                                   ( MC68020 )
\#TRAPV\#   Trap bei šberlauf
\end

screen( "Fliekomma-Befehle",
		"Befehle, Fliekomma" )
Fliekomma-Befehle im šberblick ( MC68040, MC68881 )
----------------------------------------------------------------------

Arithmetische Befehle:
\#FABS\#     Absolutwert
\#FDABS\#    Absolutwert mit doppelter Genauigkeit               ( MC68040 )
\#FSABS\#    Absolutwert mit einfacher Genauigkeit               ( MC68040 )
\#FADD\#     Addition
\#FDADD\#    Addition mit doppelter Genauigkeit                  ( MC68040 )
\#FSADD\#    Addition mit einfacher Genauigkeit                  ( MC68040 )
\#FCMP\#     Vergleiche zwei Operanden
\#FDIV\#     Division
\#FDDIV\#    Division mit doppelter Genauigkeit                  ( MC68040 )
\#FSDIV\#    Division mit einfacher Genauigkeit                  ( MC68040 )
\#FGETEXP\#  Exponent des Operanden                              ( MC68881 )
\#FGETMAN\#  Mantisse des Operanden                              ( MC68881 )
\#FINT\#     Integerteil des Operanden                           ( MC68881 )
\#FINTRZ\#   Integerteil des Operanden, gerundet auf 0           ( MC68881 )
\#FMOD\#     Modulorest                                          ( MC68881 )
\#FMUL\#     Multiplikation
\#FDMUL\#    Multiplikation mit doppelter Genauigkeit            ( MC68040 )
\#FSMUL\#    Multiplikation mit einfacher Genauigkeit            ( MC68040 )
\#FNEG\#     Negation
\#FDNEG\#    Negation mit doppelter Genauigkeit                  ( MC68040 )
\#FSNEG\#    Negation mit einfacher Genauigkeit                  ( MC68040 )
\#FREM\#     IEEE-Rest                                           ( MC68881 )
\#FSCALE\#   Skaliere Exponent                                   ( MC68881 )
\#FSGLDIV\#  Division mit einfacher Genauigkeit                  ( MC68881 )
\#FSGLMUL\#  Multiplikation mit einfacher Genauigkeit            ( MC68881 )
\#FSUB\#     Substraktion
\#FDSUB\#    Substraktion mit doppelter Genauigkeit              ( MC68040 )
\#FSSUB\#    Substraktion mit einfacher Genauigkeit              ( MC68040 )

Potenzen und Logarithmen:
\#FETOX\#    Exponentialfunktion e^x                             ( MC68881 )
\#FETOXM1\#  Exponentialfunktion e^x-1                           ( MC68881 )
\#FLOGN\#    Natrlicher Logarithmus                             ( MC68881 )
\#FLOGNP1\#  Natrlicher Logarithmus von x+1                     ( MC68881 )
\#FLOG10\#   Dekadischer Logarithmus                             ( MC68881 )
\#FLOG2\#    Logarithmus zur Basis 2                             ( MC68881 )
\#FSQRT\#    Quadratwurzel
\#FDSQRT\#   Quadratwurzel mit doppelter Genauigkeit             ( MC68040 )
\#FSSQRT\#   Quadratwurzel mit einfacher Genauigkeit             ( MC68040 )
\#FTENTOX\#  Zehnerpotenz                                        ( MC68881 )
\#FTWOTOX\#  Zweierpotenz                                        ( MC68881 )

Trigonometrie:
\#FACOS\#    Arcus Cosinus                                       ( MC68881 )
\#FASIN\#    Arcus Sinus                                         ( MC68881 )
\#FATAN\#    Arcus Tangens                                       ( MC68881 )
\#FCOS\#     Cosinus                                             ( MC68881 )
\#FSIN\#     Sinus                                               ( MC68881 )
\#FSINCOS\#  Sinus und Cosinus gleichzeitig                      ( MC68881 )
\#FTAN\#     Tangens                                             ( MC68881 )

Hyperbelfunktionen:
\#FATANH\#   Arcus Tangens Hyperbolicus                          ( MC68881 )
\#FCOSH\#    Cosinus Hyperbolicus                                ( MC68881 )
\#FSINH\#    Sinus Hyperbolicus                                  ( MC68881 )
\#FTANH\#    Tangens Hyperbolicus                                ( MC68881 )

Transfer- und Strukturbefehle:
\#FBcc\#     Bedingte Verzweigung
\#FDBcc\#    Prfe Bedingung, dekrementiere und verzweige
\#FMOVE\#    šbertrage Daten
\#FDMOVE\#   šbertrage Daten und runde auf doppelte Genauigkeit  ( MC68040 )
\#FSMOVE\#   šbertrage Daten und runde auf einfache Genauigkeit  ( MC68040 )
\#FMOVECR\#  Hole Konstante aus dem ROM der FPU                  ( MC68881 )
\#FMOVEM\#   šbertrage mehrere Register
\#FNOP\#     Keine Operation
\#FRESTORE\# Wiederherstellung des Prozessorzustandes
\#FSAVE\#    Retten des Prozessorzustandes
\#FScc\#     Setze ein Byte in Anh„ngigkeit von einer Bedingung
\#FTRAPcc\#  Trap bei Bedingung
\#FTST\#     Prfe Inhalt des Operanden
\end

screen( "PMMU-Befehle",
		"Befehle, Memory Managment" )
PMMU-Befehle im šberblick ( MC68030, MC68851 )
----------------------------------------------------------------------

Alle PMMU-Befehle sind privilegiert. D.h. sie drfen nur im Supervisor-
mode verwendet werden.

\#PBcc\#     Bedingte Verzweigung                            ( nur MC68851 )
\#PDBcc\#    Prfe Bedingung, dekrementiere und verzweige    ( nur MC68851 )
\#PFLUSH\#   L”sche Address Translation Cache
\#PLOAD\#    Lade Address Translation Cache
\#PMOVE\#    šbertrage Daten von und zu einem PMMU-Register
\#PRESTORE\# Wiederherstellung des Prozessorzustandes        ( nur MC68851 )
\#PSAVE\#    Retten des Prozessorzustandes                   ( nur MC68851 )
\#PScc\#     Setze ein Byte in Anh„ngigkeit von einer Bedingung
                                                         ( nur MC68851 )
\#PTEST\#    Prfe logische Adresse
\#PTRAPcc\#  Trap bei Bedingung                              ( nur MC68851 )
\#PVALID\#   Prfe Zeiger                                    ( nur MC68851 )
\end

screen( "privileged-Befehlssatz" )
Supervisor Mode: Privilegierter Befehlssatz
----------------------------------------------------------------------

Aus dem Supervisior Mode sind alle \link("Register-Spezifikationen")Register\# der CPU und eventuel vorhandener
Coprozessoren erreichbar.

Auerdem sind zus„tzlich folgende Befehle erlaubt:

\#ANDI to SR\#, \#EORI to SR\#,  \#FRESTORE\#, \#FSAVE\#, Alle \#PMMU-Befehle\#,  \#MOVE to SR\#,
\#MOVE from SR\# (ist erst ab MC68010 privilegiert), \#MOVEC\#, \#MOVES\#, \#ORI to SR\#,
\#RTE\#, \#RESET\#, \#STOP\#.

Befindet sich die CPU im Usermode und wird versucht ein Befehl auszufh-
ren oder auf ein  Register zuzugreifen,  welches nur im Supervisor Mode 
erlaubt ist, wird eine \#Exception\# mit der Vektornummer 8 ausgefhrt.

Wenn Sie einen dieser Befehle oder Register verwenden wollen, mssen Sie
dies dem Assembler mit der Direktive \#SUPER\# anzeigen.
\end

screen( "Befehlsl„nge",
		"Verarbeitungszeit" )
Die Verarbeitungszeit ist, wenn nichts anderes angegeben ist, die Anzahl 
der Taktzyklen fr das Holen der Operanden, Ausfhrung des Befehls, Ablegen 
des Ergebnisses und Holen des n„chsten Opcodes. Sie gelten nur fr den 
MC68000 und k”nnen bei den anderen Prozessoren differieren.

Die Befehlsl„nge ist die Anzahl der Bytes im Speicher fr diesen Befehl.

Ein Tabelleneintrag hat folgenden Aufbau:

  t/t,b/b
  | | | |
  | | | +-- Anzahl der Bytes bei Langwortverarbeitung 
  | | |     (nur falls es differiert)
  | | +---- Anzahl der Bytes bei Byte- und Wortverarbeitung
  | +------ Anzahl der Taktzyklen bei Langwortverarbeitung
  +-------- Anzahl der Taktzyklen bei Byte- und Wortverarbeitung

oder

  */b/b
  |
  +----- Diese Adresierungsart ist nicht fr den MC68000 oder MC68008
         verfgbar.
\end

screen( sensitive("ABCD") )
ABCD - Addition von BCD-Zahlen
----------------------------------------------------------------------

Assembler Syntax: ABCD Dy,Dx
                  ABCD -(Ay),-(Ax)
Beschreibung:
Addiere dezimal kodierte  Nibbles  mit  Extended  Bit.  ( Binary
Coded Decimal )

Gr”e: Byte

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | ? | * | ? | E    <=  \#M”gliche Ver„nderungen\#
 |       |
 |       +-------- Dieses Flag wird gel”scht, wenn das Ergebnis ungleich 0 
 |                 ist, ansonsten bleibt es unver„ndert. Es empfielt sich 
 |                 daher das Z-Flag vorher zu setzen, wenn man das Ergebnis 
 |                 auf 0 prfen will.
 +---------------- Wie das C-Bit.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle  |   Ziel
        +--------------
        | Dn   | -(An)
--------+------+-------
Dn      | 6,2  |
-(An)   |      | 18,2

Gruppe: \#Arithmetische Befehle\#
\end

screen( sensitive("ADD") )
ADD - Bin„re Addition
----------------------------------------------------------------------

Assembler Syntax: ADD <ea>,Dn
                  ADD Dn,<ea>
Beschreibung:
Addiert den Source Operanden auf den Destination Operanden.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | E    <=  \#M”gliche Ver„nderungen\#
 |
 +----------------- Wie das C-Bit.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    |   Ziel
          +----------+---------+---------+---------+----------
          | Dn       | (An)    | (An)+   | -(An)   | d(An)
----------+----------+---------+---------+---------+----------
Dn        | 4/6,2    | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 
An        | 4/8,2    |
(An)      | 8/14,2   |
(An)+     | 8/14,2   |
-(An)     | 10/16,2  |
d(An)     | 12/18,4  |
d(An,Rx)  | 14/20,4  | 
$xxxx     | 12/18,4  |
$xxxxxxxx | 16/22,6  |
d(PC)     | 12/18,4  |
d(PC,Rx)  | 14/20,4  |
#         | 8/14,4/6 |

Quelle |   Ziel
       +----------+--------+-----------
       | d(An,Rx) | $xxxx  | $xxxxxxxx
-------+----------+--------+-----------
Dn     | 18/26,4  |16/24,4 | 20/28,6

Hinweise:
ADD.x <ea>,An wird automatisch zu \#ADDA\# bersetzt.
ADD.x #<data>, <ea>  wird automatisch zu \#ADDI\# bersetzt.
ADD.x #<data>, Rn wird automatisch zu \#ADDQ\# bersetzt, wenn der Quell-
operand im Bereich 0 bis 8 liegt.

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#ADDA\#, \#ADDI\#, \#ADDQ\#, \#ADDX\#
\end

screen( sensitive("ADDA") )
ADDA - Bin„re Addition mit Adreregister als Ziel
----------------------------------------------------------------------

Assembler Syntax: ADDA <ea>,An

Beschreibung:
Addiert den Source Operanden auf ein Destination Adreregister. 
Die Gr”enspezifikation betrifft nur den Quelloperanden, dieser 
wird bei Wortverabeitung Vorzeichenrichtig erweitert und dann
erst zum Adreregister aufadiert.


Gr”e:  Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    |   Ziel
          +-----------
          | An        
----------+-----------
Dn        | 8/6,2
An        | 8/8,2
(An)      | 12/14,2
(An)+     | 12/14,2
-(An)     | 14/16,2
d(An)     | 16/18,4
d(An,Rx)  | 18/20,4 
$xxxx     | 16/18,4
$xxxxxxxx | 20/22,6
d(PC)     | 18/20,4
d(PC,Rx)  | 12/20,4
#         | 8/14,4/6

Hinweis: 
ADDA #..., An wird automatisch zu \#ADDQ\# bersetzt, wenn der Quell-
operand im Bereich von 0 bis 8 liegt.

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#ADD\#, \#ADDI\#, \#ADDQ\#, \#ADDX\#
\end

screen( sensitive("ADDI") )
ADDI - Bin„re Addition mit Konstante als Quelle
----------------------------------------------------------------------

Assembler Syntax: ADDI #<data>,<ea>

Beschreibung:
Addiert Immediate Daten auf den Destination Operanden.

Gr”e:  Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | E    <=  \#M”gliche Ver„nderungen\#
 |
 +----------------- Wie das C-Bit.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +----------+-----------+-----------+-----------+----------
       | Dn       | (An)      | (An)+     | -(An)     | d(An)
-------+----------+-----------+-----------+-----------+----------
#      | 8/16,4/6 | 16/28,4/6 | 16/28,4/6 | 18/30,4/6 | 20/32,6/8

Quelle |   Ziel
       +-----------+-----------+------------
       | d(An,Rx)  | $xxxx     | $xxxxxxxx
-------+-----------+-----------+------------
#      | 22/34,6/8 | 20/32,6/8 | 24/36,8/10

Hinweis: ADDI wird automatisch zu \#ADDQ\# bersetzt, wenn der Quell-
operand im Bereich von 0 bis 8 liegt.

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#ADD\#, \#ADDA\#, \#ADDQ\#, \#ADDX\#
\end

screen( sensitive("ADDQ") )
ADDQ - Bin„re Addition (schnell)
----------------------------------------------------------------------

Assembler Syntax: ADDQ #<data>,<ea>

Beschreibung:
Addiert Immediate Daten auf den Destination Operanden. Der
Wertebereich der Immediate Daten kann im Bereich von 1 bis 8
liegen.

Gr”e:  Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | E    <=  \#M”gliche Ver„nderungen\#
 |
 +----------------- Wie das C-Bit.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +--------+-------+---------+---------+---------
       | Dn     | An    | (An)    | (An)+   | -(An)
-------+--------+-------+---------+---------+---------
#      | 4/8,2  | 8/8,2 | 12/20,2 | 12/20,2 | 14/22,2 

Quelle |   Ziel
       +---------+----------+---------+-----------
       | d(An)   | d(An,Rx) | $xxxx   | $xxxxxxxx
-------+---------+----------+---------+-----------
#      | 16/24,4 | 18/26,4  | 16/24,4 | 20/28,6

Hinweis: ADDQ #...,An arbeitet immer mit Langwortverarbeitung.

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#ADD\#, \#ADDA\#, \#ADDI\#, \#ADDX\#
\end

screen( sensitive("ADDX") )
ADDX - Bin„re Addition mit Extend-Bit
----------------------------------------------------------------------

Assembler Syntax: ADDX Dy,Dx
                  ADDX -(Ay),-(Ax)

Beschreibung:
Addiert den Source Operanden auf den Destination Operanden
zusammen mit dem Extended Bit.

Gr”e: Byte, Word, Long

 X | N | Z | V | C
---+---+---+---+---
 * | E | * | E | E    <=  \#M”gliche Ver„nderungen\#
 |       |
 |       +--------- Dieses Flag wird gel”scht, wenn das Ergebnis ungleich 
 |                  0 ist, ansonsten bleibt es unver„ndert. Es empfielt 
 |                  sich daher das Z-Flag vorher zu setzen, wenn man das 
 |                  Ergebnis auf 0 prfen will.
 +----------------- Wie das C-Bit.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle  |   Ziel
        +-------+---------
        | Dn    | -(An)
--------+-------+---------
Dn      | 4/8,2 |
-(An)   |       | 18/30,2

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#ADD\#, \#ADDA\#, \#ADDI\#, \#ADDQ\#
\end

screen( sensitive("AND") )
AND - Logisches UND
----------------------------------------------------------------------

Assembler Syntax: AND <ea>,Dn
                  AND Dn,<ea>

Beschreibung: Logisches UND.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+--- -
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    |   Ziel
          +----------+---------+---------+---------+---------
          | Dn       | (An)    | (An)+   | -(An)   | d(An)
----------+----------+---------+---------+---------+---------
Dn        | 4/6,2    | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 
(An)      | 8/14,2   |
(An)+     | 8/14,2   |
-(An)     | 10/16,2  |
d(An)     | 12/18,4  |
d(An,Rx)  | 14/20,4  | 
$xxxx     | 12/18,4  |
$xxxxxxxx | 16/22,6  |
d(PC)     | 12/18,4  |
d(PC,Rx)  | 14/20,4  |
#         | 8/14,4/6 |

Quelle |   Ziel
       +----------+--------+-----------
       | d(An,Rx) | $xxxx  | $xxxxxxxx
-------+----------+--------+-----------
Dn     | 18/26,4  |16/24,4 | 20/28,6

Hinweis:
AND #<data>, <ea> wird automatisch zu \#ANDI\# bersetzt.

Gruppe: \#Logische Befehle\#

Querverweis: \#ANDI\#, \#ANDI to CCR\#, \#ANDI to SR\#
\end

screen( sensitive("ANDI") )
ANDI - Logisches UND mit einer Konstanten
----------------------------------------------------------------------

Assembler Syntax: ANDI #<data>,<ea>
                 
Beschreibung: Logisches UND Immediate.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+--- -
 | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +----------+-----------+-----------+-----------+----------
       | Dn       | (An)      | (An)+     | -(An)     | d(An)
-------+----------+-----------+-----------+-----------+----------
#      | 8/16,4/6 | 16/28,4/6 | 16/28,4/6 | 18/30,4/6 | 20/32,6/8

Quelle |   Ziel
       +-----------+-----------+------------
       | d(An,Rx)  | $xxxx     | $xxxxxxxx
-------+-----------+-----------+------------
#      | 22/34,6/8 | 20/32,6/8 | 24/36,8/10

Gruppe: \#Logische Befehle\#

Querverweis: \#AND\#, \#ANDI to CCR\#, \#ANDI to SR\#
\end

screen( "ANDI to CCR" )
ANDI to CCR - Logisches UND mit einer Konstanten und dem CCR
----------------------------------------------------------------------

Assembler Syntax: ANDI #<data>,CCR
                 
Beschreibung: Logisches UND Immediate mit dem Condition Code Register.
              Dieser Befehl dient dazu gezielt Flags des CCR zu l”schen
              oder unberhrt zu lassen.

Gr”e: Byte (es k”nnen nur die unteren 5 Bit des \#CCR\# ver„ndert werden).

Verarbeitungszeit: 20
Befehlsl„nge     :  4

Gruppe: \#Logische Befehle\#

Querverweis: \#AND\#, \#ANDI\#, \#ANDI to SR\#
\end

screen( "ANDI to SR" )
ANDI to SR - Logisches UND mit einer Konstanten und dem SR
----------------------------------------------------------------------

Assembler Syntax: ANDI #<data>,SR
                 
Beschreibung: Logisches UND Immediate mit dem Status Register.
              Dieser Befehl dient dazu gezielt Flags des SR zu l”schen
              oder unberhrt zu lassen.

Gr”e: Word (es k”nnen nur einige Bit des \#SR\# ver„ndert werden).

Verarbeitungszeit: 20
Befehlsl„nge     :  4

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.
          
Gruppe: \#Logische Befehle\#

Querverweis: \#AND\#, \#ANDI\#, \#ANDI to CCR\#
\end

screen( sensitive("LSL"),
		sensitive("ASL") )
ASL - Arithmetische Verschiebung nach links
LSL - Logische Verschiebung nach links
----------------------------------------------------------------------
 
Assembler Syntax: ASL Dx,Dy
                  ASL #<data>,Dy
                  ASL <ea>

                  LSL Dx,Dy
                  LSL #<data>,Dy
                  LSL <ea>

(Beide Befehle sind bis auf den Opcode v”lig identisch)

Beschreibung:
Der Zieloperand wird um die angegebene Anzahl von Bit nach links 
verschoben. In die "frei"-werdenden Bit werden Nullen reingeschrieben. 
Ein Speicherinhalt  kann  nur um jeweils 1 ( Ein ) Bit geschoben 
werden und ist auf Size Word beschr„nkt. Der m”gliche Bereich fr 
<data> liegt von 1 bis 8.

Gr”e: Byte, Word, Long (Byte und Long nur wenn das Ziel ein Datenregister
                         ist).

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | * | *    <=  \#M”gliche Ver„nderungen\#
 |           |   |
 |           |   +--- Wird entsprechend dem letzten aus dem Ziel 
 |           |        geschobenem Bit gesetzt. Falls die Anzahl der Bit
 |           |        0 ist wird das Flag gel”scht. 
 |           +------- Wird auf 1 gesetzt falls w„hrend des Schiebens 
 |                    irgendwann ein Vorzeichenwechsel stattfand.
 +------------------- Wird wie C behandelt nur mit dem Unterschied, da das
                      Flag unberhrt bleibt, falls die Anzahl der Bit 0 
                      ist.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +-------------+------+-------+-------+-------+----------+-------
       | Dn          | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx 
-------+-------------+------+-------+-------+-------+----------+-------
Dn     | 6+2n/8+2n,2 |      |       |       |       |          |
#      | 6+2n/8+2n,2 |      |       |       |       |          |
1      |             | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4   

Quelle |   Ziel
       +-----------
       | $xxxxxxxx
-------+-----------
1      | 20,6

Hinweis: n ist die Anzahl der Bit, um die verschoben werden soll.

Gruppe: \#Bitschiebe- und Rotierbefehle\#

Querverweis: \#ASR\#, \#LSR\#
\end

screen( sensitive("ASR") )
ASR - Arithmetische Verschiebung nach rechts
----------------------------------------------------------------------
 
Assembler Syntax: ASR Dx,Dy
                  ASR #<data>,Dy
                  ASR <ea>

Beschreibung:
Der Zieloperand wird um die angegebene Anzahl von Bit nach rechts 
verschoben. Das Vorzeichen bleibt dabei unberhrt. Ein Speicherinhalt kann
nur um jeweils 1 ( Ein ) Bit geschoben werden und ist auf Size Word 
beschr„nkt. Der m”gliche Bereich fr <data> liegt von 1 bis 8.

Gr”e: Byte, Word, Long (Byte und Long nur wenn das Ziel ein Datenregister
                         ist).

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | 0 | *    <=  \#M”gliche Ver„nderungen\#
 |               |
 |               +--- Wird entsprechend dem letzten aus dem Ziel 
 |                    geschobenem Bit gesetzt. Falls die Anzahl der Bit
 |                    0 ist wird das Flag gel”scht. 
 +------------------- Wird wie C behandelt nur mit dem Unterschied, da das
                      Flag unberhrt bleibt, falls die Anzahl der Bit 0 
                      ist.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +-------------+------+-------+-------+-------+----------+-------
       | Dn          | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx 
-------+-------------+------+-------+-------+-------+----------+-------
Dn     | 6+2n/8+2n,2 |      |       |       |       |          |
#      | 6+2n/8+2n,2 |      |       |       |       |          |
1      |             | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4   

Quelle |   Ziel
       +-----------
       | $xxxxxxxx
-------+-----------
1      | 20,6

Hinweis: n ist die Anzahl der Bit, um die verschoben werden soll.

Gruppe: \#Bitschiebe- und Rotierbefehle\#

Querverweis: \#ASL\#, \#LSL\#, \#LSR\#
\end

screen( sensitive("BMI"),
		sensitive("BVS"),
		sensitive("BCC"),
		sensitive("BGT"),
		sensitive("BEQ"),
		sensitive("BLS"),
		sensitive("BLT"),
		sensitive("BVC"),
		sensitive("BGE"),
		sensitive("BCS"),
		sensitive("BNE"),
		sensitive("BLE"),
		sensitive("BHI"),
		sensitive("BPL") )
Bcc - Bedingte Verzweigung
----------------------------------------------------------------------

Assembler Syntax: B\link("Condition Codes, CPU")cc\# <label>

Beschreibung:

Falls die Bedingung ( \link("Condition Codes, CPU")cc\# ) erfllt ist wird das Programm an der
Adresse weitegefhrt, fr die label steht.

Gr”e: Byte, Word, Long ( MC68020 )

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

\#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Bedingung  | Gr”e
           | Byte | Word 
-----------+------+------
erfllt    | 10,2 | 10,4  
nicht erf. | 8,2  | 12,4

Hinweis: Der Assembler verwendet automatisch den krzeren Befehl, wenn die
Adredistanz zwischen -128 und +127 liegt.

Gruppe: \#Programmstruktur-Befehle\#

Querverweis:  \#BT\#, \#BRA\#, \link("DBMI")DBcc\#, \#DBRA\#, \#DBF\#, \#JMP\#
\end

screen( sensitive("BCHG") )
BCHG - Prfe ein Bit und „ndere es
----------------------------------------------------------------------

Assembler Syntax: BCHG <Dn>,<ea>
                  BCHG #<data>,<ea>

Beschreibung: Testet und invertiert ein Bit.

Gr”e: Byte (Nur Speicher als Ziel), Long (Nur Datenregister als Ziel)

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | * | - | -    <=  \#M”gliche Ver„nderungen\#
         |
         +--- 1 falls das Bit vorher Null war, ansonsten 0.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle | Ziel
       +-------+------+-------+-------+-------+----------+-------+-----------
       | Dn    | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
-------+-------+------+-------+-------+-------+----------+-------+-----------
Dn     | <8,2  | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4  | 20,6
#      | <12,4 | 16,4 | 16,4  | 18,4  | 20,6  | 22,6     | 20,6  | 24,8

Hinweis: Die Zeiten sind die Anzahl der Taktzyklen fr die Ausfhrung der
Operation.

Gruppe: \#Bit-Befehle\#

Querverweis: \#BCLR\#, \#BSET\#, \#BTST\#
\end

screen( sensitive("BCLR") )
BCLR - Prfe ein Bit und setze es auf 0
----------------------------------------------------------------------

Assembler Syntax: BCLR <Dn>,<ea>
                  BCLR #<data>,<ea>

Beschreibung: Testet und l”scht ein Bit.

Gr”e: Byte (Nur Speicher als Ziel), Long (Nur Datenregister als Ziel)

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | * | - | -    <=  \#M”gliche Ver„nderungen\#
         |
         +--- 1 falls das Bit vorher Null war, ansonsten 0.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle | Ziel
       +-------+------+-------+-------+-------+----------+-------+-----------
       | Dn    | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
-------+-------+------+-------+-------+-------+----------+-------+-----------
Dn     | <12,2 | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4  | 20,6
#      | <14,4 | 16,4 | 16,4  | 18,4  | 20,6  | 22,6     | 20,6  | 24,8

Hinweis: Die Zeiten sind die Anzahl der Taktzyklen fr die Ausfhrung der
Operation.

Gruppe: \#Bit-Befehle\#

Querverweis: \#BCHG\#, \#BSET\#, \#BTST\#
\end

screen( sensitive("BFCHG") )
BFCHG - Prfe Bitfield und „ndere es                           MC68020
----------------------------------------------------------------------

Assembler Syntax: BFCHG <ea>{offs:width}

Beschreibung:
Invertiere ein Bit Field.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#
 
Gruppe: \#Bit-Befehle\#

Querverweis: \#BFCLR\#, \#BFSET\#, \#BFTST\#
\end

screen( sensitive("BFCLR") )
BFCLR - Prfe Bitfield und setze es auf 0                      MC68020
----------------------------------------------------------------------

Assembler Syntax: BFCLR <ea>{offs:width}

Beschreibung:
Setze ein Bit Field auf 0 ( Null ).

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Gruppe: \#Bit-Befehle\#

Querverweis: \#BFCHG\#, \#BFSET\#, \#BFTST\#
\end

screen( sensitive("BFEXTS") )
BFEXTS - Extrahiere signed Bitfield                            MC68020
----------------------------------------------------------------------

Assembler Syntax: BFEXTS <ea>{offs:width},Dn

Beschreibung:
Extrahiere ein Bit Field signed 

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Gruppe: \#Bit-Befehle\#

Querverweis: \#BFEXTU\#, \#BFFFO\#, \#BFINS\#
\end

screen( sensitive("BFEXTU") )
BFEXTU - Extrahiere unsigned Bitfield                          MC68020
----------------------------------------------------------------------

Assembler Syntax: BFEXTU <ea>{offs:width},Dn

Beschreibung:
Extrahiere ein Bit Field unsigned 

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Gruppe: \#Bit-Befehle\#

Querverweis: \#BFEXTS\#, \#BFFFO\#, \#BFINS\#
\end

screen( sensitive("BFFFO") )
BFFFO - Suche in Bitfield                                      MC68020
----------------------------------------------------------------------

Assembler Syntax: BFFFO <ea>{offs:width},Dn

Beschreibung:
Sucht das h”chste gesetzte Bit in einem Bit Field.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Gruppe: \#Bit-Befehle\#

Querverweis: \#BFEXTS\#, \#BFEXTU\#, \#BFINS\#
\end

screen( sensitive("BFINS") )
BFINS - Fge Daten in ein Bitfield ein                         MC68020
----------------------------------------------------------------------

Assembler Syntax: BFINS Dn,<ea>{offs:width}

Beschreibung:
Bewegt die untersten Bits eines Datenregisters in ein Bit Field
der spezifizierten Adresse.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Gruppe: \#Bit-Befehle\#

Querverweis: \#BFEXTS\#, \#BFEXTU\#, \#BFFFO\#
\end

screen( sensitive("BFSET") )
BFSET - Prfe Bitfield und setze es auf 1                      MC68020
----------------------------------------------------------------------

Assembler Syntax: BFSET <ea>{offs:width}

Beschreibung:
Setzt alle Bits eines Bit Fields.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Gruppe: \#Bit-Befehle\#

Querverweis: \#BFCHG\#, \#BFCLR\#, \#BFTST\#
\end

screen( sensitive("BFTST") )
BFTST - Prfe Bitfield                                         MC68020
----------------------------------------------------------------------

Assembler Syntax: BFTST <ea>{offs:width}

Beschreibung:
Extrahiert ein Bit Field und setzt die entsprechenden Flags.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Gruppe: \#Bit-Befehle\#

Querverweis: \#BFCHG\#, \#BFCLR\#, \#BFSET\#
\end

screen( sensitive("BKPT") )
BKPT - Breakpoint                                              MC68010
----------------------------------------------------------------------

Assembler Syntax: BKPT #<data>

Beschreibung: 
Ausfhrung eines Breakpoint Acknowledge Bus Zyklus.

Gr”e: Ohne Gr”enspezifikation

Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \#ILLEGAL\#
\end

screen( sensitive("BRA"),
		sensitive("BT") )
BRA - Verzweige immer
BT
----------------------------------------------------------------------

Assembler Syntax: BRA <label>
                  BT  <label>

Beschreibung: Verzweige auf PC + 16 Bit Displacement ( label ).

Gr”e: Byte, Word, Long (MC68020)

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Verarbeitungszeit: 10
Befehlsl„nge     : 2 (Byte) 4 (Word) 6 (Long)

Hinweis: Der Assembler verwendet automatisch den krzeren Befehl, wenn die
Adredistanz zwischen -128 und +127 liegt.

Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \link("BMI")Bcc\#, \link("DBMI")DBcc\#, \#JMP\#
\end

screen( sensitive("BSET") )
BSET - Prfe ein Bit und setze es auf 1
----------------------------------------------------------------------

Assembler Syntax: BSET Dn,<ea>
                  BSET #<data>,<ea>

Beschreibung:
Ein Bit wird getestet und das Zero-Flag entsprechend gesetzt.
Anschlieend wird das spezifizierte Bit gesetzt.

Gr”e: Byte (Nur Speicher als Ziel), Long (Nur Datenregister als Ziel)

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | * | - | -    <=  \#M”gliche Ver„nderungen\#
         |
         +--- 1 falls das Bit vorher Null war, ansonsten 0.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle | Ziel
       +-------+------+-------+-------+-------+----------+-------+-----------
       | Dn    | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
-------+-------+------+-------+-------+-------+----------+-------+-----------
Dn     | <8,2  | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4  | 20,6
#      | <12,4 | 16,4 | 16,4  | 18,4  | 20,6  | 22,6     | 20,6  | 24,8

Hinweis: Die Zeiten sind die Anzahl der Taktzyklen fr die Ausfhrung der
Operation.

Querverweis: \#BCHG\#, \#BCLR\#, \#BTST\#
\end

screen( sensitive("BSR") )
BSR - Verzweige zu Unterprogramm
----------------------------------------------------------------------

Assembler Syntax: BSR <label>

Beschreibung:
Die Adresse  des  auf  den BSR-Befehl folgenden Befehls wird auf
den Stack abgelegt. Darauf wird der PC um die angegebene Distanz
ver„ndert und das Program an der Stelle fortgefhrt  auf die der
PC nun zeigt.

Gr”e: Byte, Word, Long ( MC68020 )

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Verarbeitungszeit: 18
Befehlsl„nge     : 2 (Byte) 4 (Word) 6 (Long)

Hinweis: Der Assembler verwendet automatisch den krzeren Befehl, wenn die
Adredistanz zwischen -128 und +127 liegt.

Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \#JSR\#, \#RTS\#
\end

screen( sensitive("BTST") )
BTST - Prfe ein Bit
----------------------------------------------------------------------

Assembler Syntax: BTST Dn,<ea>
                  BTST #<data>,ea

Beschreibung:
Testet spezifiziertes Bit und setzt das Zero-Flag entsprechend.

Gr”e: Byte (Nur Speicher als Ziel), Long (Nur Datenregister als Ziel)

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | * | - | -    <=  \#M”gliche Ver„nderungen\#
         |
         +--- 1 falls das Bit vorher Null war, ansonsten 0.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle | Ziel
       +------+------+-------+-------+-------+----------+-------+-----------
       | Dn   | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
-------+------+------+-------+-------+-------+----------+-------+-----------
Dn     | 6,2  | 8,2  | 8,2   | 10,2  | 12,4  | 14,4     | 12,4  | 16,6
#      | 10,4 | 12,4 | 12,4  | 14,4  | 16,6  | 18,6     | 16,6  | 20,8

Quelle | Ziel
       +------+-----------+------
       | d(PC) | d(PC,Rx) | #
-------+-------+----------+------
Dn     | 12,4  | 14,4     | 10,4
#      | 16,6  | 18,6     |

Hinweis: Die Zeiten sind die Anzahl der Taktzyklen fr die Ausfhrung der
Operation.

Querverweis: \#BCHG\#, \#BCLR\#, \#BSET\#
\end

screen( sensitive("CALLM") )
CALLM - Springe zu Modul                                   Nur MC68020
----------------------------------------------------------------------

Assembler Syntax: CALLM #<data>,<ea>

Beschreibung:
Bewirkt einen Modulaufruf,   wobei  die  effektive Adresse auf
einen Moduldeskriptor zeigt und data die Anzahl der zu berge-
benden Parameter in Bytes angibt. Der  momentane  Modulzustand 
wird auf dem Stack abgelegt und der neue Modulzustand wird aus
der spezifizierten Adresse bernommen.

Gr”e: Ohne Gr”enspezifikation

Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \#RTM\#
\end

screen( sensitive("CAS") )
CAS - Vergleiche und tausche                                   MC68020
----------------------------------------------------------------------

Assembler Syntax: CAS Dc,Du,<ea>

Beschreibung:  
Es wird ein  Vergleich auf das  Vergleichs-Datenregister  Du mit  
dem durch die effektive Adresse  spezifizierten Operanden ausge-
fhrt.  Im Falle der  Gleichheit wird die  effektive Adresse mit 
dem  Wert des  Registers Du geladen.  Im Falle der  Ungleichheit 
wird das  Register Dc mit dem  Inhalt der effektiven Adresse ge-
laden. Dieser Befehl l„t sich wie der \#TAS\#- oder der \#CAS2\#-Befehl
nicht unterbrechen und  eignet sich dadurch hervoragend zur Syn-
chronisation in einem Mehrprozessorsystem.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | E    <=  \#M”gliche Ver„nderungen\#

Querverweis: \#CAS2\#

Gruppe: \#Transfer-Befehle\#
\end

screen( sensitive("CAS2") )
CAS2 - Vergleiche und tausche doppelt                          MC68020
----------------------------------------------------------------------

Assembler Syntax: CAS2 Dc1:Dc2,Du1:Du2,(Rn1):(Rn2)

Beschreibung:  
Es wird ein Vergleich auf die  Vergleichs-Datenregister Du1 und
Du2 mit den  durch die Register  Rn1 bzw. Rn2 indirekt spezifi-
zierte Operanden ausgefhrt. Im Falle der Gleichheit werden die
Vergleichsoperanden im Speicher mit den Werten der Register Du1
bzw. Du2 geladen. Im Falle der Ungleichheit werden die Register
Dc1 bzw. Dc2 mit diesen Vergleichsoperanden geladen. Dieser Be-
fehl  l„t sich  wie der \#TAS\#- oder  der \#CAS\#-Befehl nicht unter-
brechen und eignet sich dadurch hervoragend zur Synchronisation
in einem Mehrprozessorsystem.

Gr”e:  Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | E    <=  \#M”gliche Ver„nderungen\#

Querverweis: \#CAS\#

Gruppe: \#Transfer-Befehle\#
\end

screen( sensitive("CHK") )
CHK - Prfe Datenregister gegen obere Grenze
----------------------------------------------------------------------

Assembler Syntax: CHK <ea>,Dn

Beschreibung: Der Wert eines Registers wird darauf untersucht
ob er innerhalb zweier Grenzen liegt. Wenn der Wert < 0  oder
gr”er als der Inhalt von <ea> ist wird eine  \#Exception\#  ber
den Vektor Nummer 6 ausgel”st.

Gr”e: Word, Long ( MC68020 )

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | * | ? | ? | ?    <=  \#M”gliche Ver„nderungen\#
     |
     +------------- 1 falls Dn < 0, 0 falls Dn > Quelle, ansonsten ?

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    | Ziel        Die Zeiten enthalten die Anzahl der Taktzyklen fr
          +------       die Ausfhrung des Befehls, wenn KEINE Exception
          | Dn          ausgel”st wird. Eine Exception ben”tigt noch einmal
----------+------       30 Taktzyklen.
Dn        | 10,2
(An)      | 14,2
(An)+     | 14,2
-(An)     | 16,2
d(An)     | 18,4
d(An,Rx)  | 20,4
$xxxx     | 18,4
$xxxxxxxx | 22,6
d(PC)     | 18,4
d(PC,Rx)  | 20,4
#         | 14,4

Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \#CHK2\#
\end

screen( sensitive("CHK2") )
CHK2 - Prfe Datenregister gegen zwei Grenzen                  MC68020
----------------------------------------------------------------------

Assembler Syntax: CHK2 <ea>,Rn

Beschreibung:
Der Wert eines Registers wird darauf untersucht ob er innerhalb
zweier Grenzen liegt. Wenn der Wert des Adre- oder  Datenregi-
sters innerhalb der durch die effektive  Adresse spezifizierten
Grenze liegt werden lediglich die  entsprechenden Flags gesetzt.  
Andernfalls wird eine  \#Exception\# ber den  Vektor Nummer  6 aus-
gel”st.

Beispiel:
        \#MC68020\#     ; allow MC68020 instruction set
test:               ; checks D0 for bounds
                    ; returns if value is ok
                    ; otherwise trap
        CHK2.W      bounds, D0
        \#RTS\#
        
bounds: \#DC\#.w    20, 100

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | ? | E | ? | E    <=  \#M”gliche Ver„nderungen\#

Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \#CHK\#, \#CMP2\#
\end

screen( sensitive("CLR") )
CLR - L”sche den Inhalt des Operanden
----------------------------------------------------------------------

Assembler Syntax: CLR <ea>

Beschreibung:
Der Inhalt der effektiven Adresse wird auf 0 ( Null ) gesetzt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | 0 | 1 | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

 Ziel
------+---------+---------+---------+---------+----------+---------
 Dn   | (An)    | (An)+   | -(An)   | d(An)   | d(An,Rx) | $xxxx   
------+---------+---------+---------+---------+----------+---------
4/6,2 | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 | 18/26,4  | 16/24,4 

 Ziel
-----------
 $xxxxxxxx
-----------
20/28,6

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#MOVE\#
\end

screen( sensitive("CMP") )
CMP - Vergleiche zwei Operanden
----------------------------------------------------------------------

Assembler Syntax: CMP <ea>,Dn

Beschreibung:
Es werden zwei Operanden verglichen. Fr den Vergleich wird der
Quell- vom Zieloperand subtrahiert.  Das Resultat  wird  jedoch
nicht geschrieben,  lediglich  die  Flags  werden  entsprechend
gesetzt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | E    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    |   Ziel
          +----------
          | Dn       
----------+----------
Dn        | 4/6,2    
An        | 4/8,2    
(An)      | 8/14,2   
(An)+     | 8/14,2   
-(An)     | 10/16,2  
d(An)     | 12/18,4  
d(An,Rx)  | 14/20,4   
$xxxx     | 12/18,4  
$xxxxxxxx | 16/22,6  
d(PC)     | 12/18,4  
d(PC,Rx)  | 14/20,4  
#         | 8/14,4/6 

Hinweise:
CMP <ea>, An wird automatisch zu \#CMPA\# bersetzt.
CMP #..., <ea> wird automatisch zu \#CMPI\# bersetzt.
CMP (Ax)+, (Ay)+ wird automatisch zu \#CMPM\# bersetzt.
CMP #0, D0 bzw. CMP #0, <ea> wird automatisch zu \#TST\#  bersetzt.

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#CMPA\#, \#CMPI\#, \#CMPM\#, \#CMP2\#
\end

screen( sensitive("CMPA") )
CMPA - Vergleiche zwei Operanden mit Adreregister als Ziel
----------------------------------------------------------------------

Assembler Syntax: CMPA <ea>,An

Beschreibung: Es wird die Differenz zwischen  Ziel- und Quell-
openand berechnet. Das Ergeniss wird nicht geschrieben sondern
lediglich die entsprechenden Flags gesetzt.

Gr”e: Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | E    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    |   Ziel
          +----------
          | An       
----------+----------
Dn        | 6/6,2    
An        | 6/6,2    
(An)      | 10/14,2   
(An)+     | 10/14,2   
-(An)     | 12/16,2  
d(An)     | 14/18,4  
d(An,Rx)  | 16/20,4   
$xxxx     | 14/18,4  
$xxxxxxxx | 18/22,6  
d(PC)     | 14/18,4  
d(PC,Rx)  | 16/20,4  
#         | 8/18,4/6 

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#CMP\#, \#CMPI\#, \#CMPM\#, \#CMP2\#
\end

screen( sensitive("CMPI") )
CMPI - Vergleiche zwei Operanden mit Konstante als Quelle
----------------------------------------------------------------------

Assembler Syntax: CMPI #<data>,<ea>

Beschreibung:
Immediate Daten werden mit dem Zieloperanden  verglichen.  Dazu
wird der Ouelloperand vom Zieloperand subtrahiert. Das Resultat
wird nicht  geschrieben,  lediglich  die  entsprechenden  Flags
werden gesetzt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | E    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +----------+-----------+-----------+-----------+----------
       | Dn       | (An)      | (An)+     | -(An)     | d(An)
-------+----------+-----------+-----------+-----------+----------
#      | 8/14,4/6 | 12/20,4/6 | 12/20,4/6 | 14/22,4/6 | 16/24,6/8

Quelle |   Ziel
       +-----------+-----------+------------
       | d(An,Rx)  | $xxxx     | $xxxxxxxx
-------+-----------+-----------+------------
#      | 18/26,6/8 | 16/24,6/8 | 20/28,8/10

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#CMP\#, \#CMPA\#, \#CMPM\#, \#CMP2\#
\end

screen( sensitive("CMPM") )
CMPM - Vergleiche zwei Speicherzellen
----------------------------------------------------------------------

Assembler Syntax: CMPM (Ay)+,(Ax)+

Beschreibung:
Es wird die Differenz  zweier  Speicherinhalte  gebildet.  Das
Ergebnis wird nicht geschrieben, lediglich die entsprechenden
Flags werden gesetzt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | E    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle | Ziel
       +---------
       | (An)+     
-------+--------- 
(An)+  | 12/20,2 

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#CMP\#, \#CMPA\#, \#CMPI\#, \#CMP2\#
\end

screen( sensitive("CMP2") )
CMP2 - Vergleiche Datenregister mit 2 Grenzen                  MC68020
----------------------------------------------------------------------

Assembler Syntax: CMP2 <ea>,Rn

Beschreibung:
Es wird der Wert eines Adre- oder Datenregister mit den Werten
die ber die effektive Adresse spezifiziert sind auf Grenzen hin
untersucht. Die untere Grenze wird durch den Wert bestimmt der
direkt ber die effektive Adresse angegeben wurde.
Der obere Grenzwert liegt an der effektiven Adresse plus den Wert
der Operandengr”e.

Beispiel:
        \#MC68020\#     ; allow MC68020 instruction set
test:               ; checks D0 for bounds
                    ; returns TRUE if value is ok
                    ; otherwise FALSE
        CMP2.W      bounds, D0
        \#SCC\#         D0
        \#RTS\#
        
bounds: \#DC\#.w    20, 100

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | ? | * | ? | *    <=  \#M”gliche Ver„nderungen\#
         |       |
         |       +-- 1, wenn Rn auserhalb der Grenzen liegt, 
         |           ansonsten 0.
         +---------- 1, wenn Rn auf einer der beiden Grenzen
                     liegt, ansonsten 0.

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#CMP\#, \#CMPA\#, \#CMPI\#, \#CMPM\#
\end

screen( sensitive("DBMI"),
		sensitive("DBVS"),
		sensitive("DBLT"),
		sensitive("DBNE"),
		sensitive("DBCC"),
		sensitive("DBPL"),
		sensitive("DBLS"),
		sensitive("DBEQ"),
		sensitive("DBLE"),
		sensitive("DBT"),
		sensitive("DBHI"),
		sensitive("DBVC"),
		sensitive("DBCS"),
		sensitive("DBGE"),
		sensitive("DBGT") )
DBcc - Prfe Bedingung, dekrementiere und verzweige
----------------------------------------------------------------------

Assembler Syntax: DB\link("Condition Codes, CPU")cc\# Dn,<label>

Beschreibung:
Diese Befehl erm”glich es eine einfache Schleife zu programmieren.
Zuerst wird die  ber  \link("Condition Codes, CPU")cc\#  spezifizierte  Bedingung  geprft um
festzustellen ob die Abbruchsbedingung  fr  die Schleife erreicht
ist. Wenn dies der Fall ist wird keine weitere Aktion vorgenommen.
Wenn die Abbruchsbedingung nicht erfllt ist,  werden  die unteren
16 Bit ( Achtung: Word ) um 1  ( Eins )  dekrementiert.  Wenn  das
Ergebnis -1 (Achtung:  Minus Eins) ist, wird die Schleife  beendet.
Andernfalls wird auf die durch label  spezifizierte  Adresse  ver-
zweigt.

Gr”e: Word, Long (MC68020)

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#
 
Verarbeitungszeiten: 
                
cc nicht erfllt, Dn=-1 : 14 (Sprung findet nicht statt)
cc erfllt              : 12 (   "     "      "     "  )
cc nicht erfllt, Dn>-1 : 10 (Sprung findet statt)

Befehlsl„nge: immer 4

Hinweis:
DBT Dn,<label> tut nichts, da die Bedingung immer erfllt ist. Man
kann deshalb auf diesen Befehl verzichten.
   
Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \link("BMI")Bcc\#, \#BRA\#, \#DBRA\#, \#JMP\#
\end

screen( sensitive("DBF"),
		sensitive("DBRA") )
DBRA - Dekrementiere und verzweige
DBF
----------------------------------------------------------------------

Assembler Syntax: DBRA Dn,<label>
                  DBF  Dn,<label>

Beschreibung:
Die unteren 16 Bit ( Achtung: Word )  werden um 1  ( Eins ) dekre-
mentiert.  Wenn  das Ergebnis -1 ( Achtung: Minus Eins ) ist, wird
die  Schleife beendet. Andernfalls wird auf die durch label spezi-
fizierte Adresse verzweigt.

Gr”e: Word, Long ( MC68020 )

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#
 
Verarbeitungszeiten: 
                
Dn=-1 : 14 (Sprung findet nicht statt)
Dn>-1 : 10 (Sprung findet statt)

Befehlsl„nge: immer 4

Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \link("BMI")Bcc\#, \#BRA\#, \link("DBMI")DBcc\#, \#JMP\#
\end

screen( sensitive("DIVS"),
		sensitive("DIVSL") )
DIVS - Division mit Vorzeichen
----------------------------------------------------------------------

Assembler Syntax: DIVS.W <ea>,Dn      32/16 -> 16r:16q
                  DIVS.L <ea>,Dq      32/32 -> 32q     ( MC68020 )
                  DIVS.L <ea>,Dr:Dq   64/32 -> 32r:32q ( MC68020 )
                  DIVSL.L <ea>,Dr:Dq  32/32 -> 32r:32q ( MC68020 )

Beschreibung:
Es wird  eine Division des Zieloperanden durch den  Ouelloperanden
unter  Beachtung des Vorzeichens ausgefhrt.  Das Resultat wird im
Zieloperanden  als 32 Bit Wert abgelegt, wobei im unteren Wort des
Registers der  Ouotient steht und im oberen  Wort  der  Divisions-
rest.    Der  Divisionsrests  hat  das  selbe  Vorzeichen  wie der
Dividend.   Der  Zieloperand   kann  auf  einem   MC68020   gr”er
als 16  Bit  sein.   Bei  einer  Division  durch  Null  wird  eine
\#Exception\# ber den Vektor Nummer 5 ausgel”st.

Gr”e: Word, Long ( MC68020 )

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | 0    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    | Ziel
          +-------
          | Dn       
----------+-------
Dn        | 158,2 Bei der Anzahl der Taktzyklen handelt es sich dabei   
(An)      | 162,2 um einen Maximalwert.  
(An)+     | 162,2   
-(An)     | 164,2  
d(An)     | 166,4  
d(An,Rx)  | 168,4   
$xxxx     | 166,4  
$xxxxxxxx | 170,6  
d(PC)     | 166,4  
d(PC,Rx)  | 168,4  
#         | 162,4 

Hinweis: Oft ist es ratsam, diesen Befehl durch andere Operationen zu 
         ersetzen. So bewirkt z.B DIVS #2,Dn das gleiche wie 
         \#ASR\#.L #1, Dn

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#DIVU\#, \#MULS\#, \#MULU\#
\end

screen( sensitive("DIVUL"),
		sensitive("DIVU") )
DIVU - Division ohne Vorzeichen
----------------------------------------------------------------------

Assembler Syntax: DIVU.W <ea>,Dn      32/16 -> 16r:16q
                  DIVU.L <ea>,Dq      32/32 -> 32q     ( MC68020 )
                  DIVU.L <ea>,Dr:Dq   64/32 -> 32r:32q ( MC68020 )
                  DIVUL.L <ea>,Dr:Dq  32/32 -> 32r:32q ( MC68020 )

Beschreibung:
Es wird  eine Division des Zieloperanden durch den  Ouelloperanden
ohne  Beachtung  des Vorzeichens ausgefhrt.  Das Resultat wird im
Zieloperanden  als 32 Bit Wert abgelegt, wobei im unteren Wort des
Registers der  Ouotient steht und im oberen  Wort  der  Divisions-
rest.   Der   Divisionsrests  hat  das  selbe  Vorzeichen  wie der
Dividend.   Der  Zieloperand   kann  auf  einem   MC68020   gr”er
als  16  Bit  sein.  Bei  einer  Division  durch  Null  wird  eine
\#Exception\# ber den Vektor Nummer 5 ausgel”st.

Gr”e: Word, Long ( MC68020 )

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | 0    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    | Ziel
          +------
          | Dn       
----------+------
Dn        | 140,2 Bei der Anzahl der Taktzyklen handelt es sich dabei   
(An)      | 144,2 um einen Maximalwert.  
(An)+     | 144,2   
-(An)     | 146,2  
d(An)     | 148,4  
d(An,Rx)  | 150,4   
$xxxx     | 148,4  
$xxxxxxxx | 152,6  
d(PC)     | 148,4  
d(PC,Rx)  | 150,4  
#         | 144,4 

Hinweis: Oft ist es ratsam, diesen Befehl durch andere Operationen zu 
         ersetzen. So bewirkt z.B DIVU #2,Dn das gleiche wie 
         \#LSR\#.L #1, Dn

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#DIVS\#, \#MULS\#, \#MULU\#
\end

screen( sensitive("EOR") )
EOR - Logisches Exklusiv-ODER
----------------------------------------------------------------------

Assembler Syntax: EOR Dn,<ea>

Beschreibung:
Logische Exclusive-Oder-Verkpfung.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    |   Ziel
          +----------+---------+---------+---------+---------
          | Dn       | (An)    | (An)+   | -(An)   | d(An)
----------+----------+---------+---------+---------+---------
Dn        | 4/8,2    | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 

Quelle |   Ziel
       +----------+--------+-----------
       | d(An,Rx) | $xxxx  | $xxxxxxxx
-------+----------+--------+-----------
Dn     | 18/26,4  |16/24,4 | 20/28,6

Hinweis:
EOR #...,<ea> wird automatisch zu \#EORI\# bersetzt.

Gruppe: \#Logische Befehle\#

Querverweis: \#EORI\#, \#EORI to CCR\#, \#EORI to SR\#
\end

screen( sensitive("EORI") )
EOR - Logisches Exklusiv-ODER mit einer Konstanten
----------------------------------------------------------------------

Assembler Syntax: EORI #<data>,<ea>
                 
Beschreibung:
Logische Exclusive-Oder-Verknpfung von konstanten Daten auf den
Zieloperanden.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +----------+-----------+-----------+-----------+---------
       | Dn       | (An)      | (An)+     | -(An)     | d(An)
-------+----------+-----------+-----------+-----------+---------
#      | 8/16,4/6 | 16/28,4/6 | 16/28,4/6 | 18/30,4/6 | 20/32,6/8

Quelle |   Ziel
       +------------+----------+------------
       | d(An,Rx)   | $xxxx    | $xxxxxxxx
-------+------------+----------+------------
#      | 22/34,6/8  |20/32,6/8 | 24/36,8/10

Gruppe: \#Logische Befehle\#

Querverweis: \#EOR\#, \#EORI to CCR\#, \#EORI to SR\#
\end

screen( "EORI to CCR" )
EORI to CCR - Logisches Exklusiv-ODER mit einer Konstanten und dem CCR
----------------------------------------------------------------------

Assembler Syntax: EORI #<data>,CCR
                 
Beschreibung:
Logische Exclusive-Oder-Verknpfung von konstanten Daten auf das
Condition Code Register.

Gr”e: Byte (es k”nnen nur die unteren 5 Bit des \#CCR\# ver„ndert werden).

Verarbeitungszeit: 20
Befehlsl„nge     :  4

Gruppe: \#Logische Befehle\#

Querverweis: \#EOR\#, \#EORI\#, \#EORI to SR\#
\end

screen( "EORI to SR" )
EORI to SR - Logisches Exklusiv-ODER mit einer Konstanten und dem SR
----------------------------------------------------------------------

Assembler Syntax: EORI #<data>,SR
                 
Beschreibung:
Logische Exclusive-Oder-Verknpfung von konstanten Daten auf das
Status Register.

Gr”e: Word (es k”nnen nur einige Bit des \#SR\# ver„ndert werden).

Verarbeitungszeit: 20
Befehlsl„nge     :  4

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.
          
Gruppe: \#Logische Befehle\#

Querverweis: \#EOR\#, \#EORI\#, \#EORI to SR\#
\end

screen( sensitive("EXG") )
EXG - Vertausche Registerinhalte
----------------------------------------------------------------------

Assembler Syntax: EXG Rx,Ry

Beschreibung:
Der Inhalt zweier Register wird vertauscht.

Gr”e: Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +-----+-----
       | Dn  | An
-------+-----+-----
Dn     | 6,2 | 6,2
An     | 6,2 | 6,2

Gruppe: \#Transfer-Befehle\#
\end

screen( sensitive("EXT"),
		sensitive("EXTB") )
EXT - Vorzeichenrichtige Erweiterung eines Datenregisters
----------------------------------------------------------------------

Assembler Syntax: EXT.W Dn   Erweitere Byte zu Word
                  EXT.L Dn   Erweitere Word zu Long
                  EXTB.L Dn  Erweitere Byte zu Longword ( MC68020 )
Beschreibung:
Das Vorzeichen-Bit wird je nach  Gr”enspezifikation  auf  jeweils
8, 16 oder 32 h”herwertige Bits bertragen.

Gr”e: Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Verarbeitungszeit: 4
Befehlsl„nge     : 2

Gruppe: \#Arithmetische Befehle\#
\end

screen( sensitive("ILLEGAL") )
ILLEGAL - Unzul„ssiger Opcode
----------------------------------------------------------------------

Assembler Syntax: ILLEGAL

Beschreibung:
Wird dieser Befehl von der CPU entdeckt, wird eine \#Exception\# ber
den Vektor Nummer 4 ausgel”st.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Verarbeitungszeit: 34 Anzahl der Taktzyklen bis sich die CPU im 
                      Exceptionhandler befindet.
Befehlsl„nge     : 2

Hinweis: Der Opcode mit der Nummer $4AFC ist von Motorola fr diesen
         Befehl reserviert. Damit lassen sich einfach Breakpoints 
         setzen.

Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \#BKPT\#
\end

screen( sensitive("JMP") )
JMP - Sringe zu Adresse
----------------------------------------------------------------------

Assembler Syntax: JMP <ea>

Beschreibung:
Das Program wird an der durch die effektive Adresse angegebenen
Stelle fortgesetzt.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

 Ziel (Die Anzahl der Taktzyklen gelten fr die Ausfhrung des Befehls)
------+-------+----------+-------+-----------+-------+----------
 (An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx | d(PC) | d(PC,Rx)
------+-------+----------+-------+-----------+-------+----------
 8,2  | 10,4  | 14,4     | 10,4  | 12,6      | 10,4  | 14,4

Gruppe: \#Programmstruktur-Befehle\#

Querverweis:  \#BRA\#, \link("BMI")Bcc\#, \link("DBMI")DBcc\#
\end

screen( sensitive("JSR") )
JSR - Springe in Unterprogramm
----------------------------------------------------------------------

Assembler Syntax: JSR <ea>

Beschreibung:
Die Adresse des auf den JSR-Befehl folgenden  Befehls  wird  auf
den Stack abgelegt. Darauf wird der PC auf die angegebene Adresse
ver„ndert und das Program an der Stelle fortgefhrt auf die  der
PC nun zeigt.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

 Ziel (Die Anzahl der Taktzyklen gelten fr die Ausfhrung des Befehls)
------+-------+----------+-------+-----------+-------+----------
 (An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx | d(PC) | d(PC,Rx)
------+-------+----------+-------+-----------+-------+----------
 16,2 | 18,4  | 22,4     | 18,4  | 20,6      | 18,4  | 22,4

Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \#BSR\#, \#RTS\#
\end

screen( sensitive("LEA") )
LEA - Lade Adresse in ein Adreregister
----------------------------------------------------------------------

Assembler Syntax: LEA <ea>,An

Beschreibung:
Die effektive Adresse wird in das spezifizierte Adreregister
geladen. Im Gegensatz zu \#MOVEA\# wird nicht der Quelloperand 
zum Adreregister geladen sondern dessen Adresse.

Gr”e: Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    | Ziel
          +------
          | An
----------+------
(An)      | 4,2
d(An)     | 8,4
d(An,Rx)  | 12,4
$xxxx     | 8,4
$xxxxxxxx | 12,6
d(PC)     | 8,4
d(PC,Rx)  | 12,4

Hiweis:
LEA d(An), An sollte durch \#ADDQ\# #d, An ersetzt werden, wenn das
Displacement im Bereich von 0 bis 7 liegt.

Gruppe: \#Transfer-Befehle\#
\end

screen( sensitive("LINK") )
LINK - Lege neuen Stackbereich an
----------------------------------------------------------------------
 
Assembler Syntax: LINK.W An,#<displacement>
                  LINK.L An,#<displacement> ( MC68020 )
Beschreibung:
Das spezifizierte Adreregister wird auf den Stack abgelegt.
Danach wird das Adreregister mit dem neuen Stackpointer geladen.
Zuletzt wird das displacement auf das Adreregister addiert.
Um einen lokalen Stack aufzubauen wird ein negatives Displacement
angegeben.

Zur Veranschaulichung soll hier ein alternativer Code angegeben
werden:

\#PEA\#     (An)
\#MOVEA\#.L A7, An
\#ADDA\#.L  #<displacement>, A7

Gr”e: Word, Long ( MC68020 )

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Verarbeitungszeit: 18 
Befehlsl„nge     : 4

Gruppe: \#Transfer-Befehle\#

Querverweis: \#UNLK\#
\end

screen( sensitive("LSR") )
LSR - Logische Verschiebung nach rechts
----------------------------------------------------------------------
 
Assembler Syntax: LSR Dx,Dy
                  LSR #<data>,Dy
                  LSR <ea>

Beschreibung:
Der Zieloperand wird um die angegebene Anzahl von Bit nach rechts 
verschoben. Die "frei"-werdenden Stellen werden mit 0 gefllt. Ein 
Speicherinhalt kann nur um jeweils 1 ( Ein ) Bit geschoben werden und 
ist auf Size Word beschr„nkt. Der m”gliche Bereich fr <data> liegt von 1 bis 8.

Gr”e: Byte, Word, Long (Byte und Long nur wenn das Ziel ein Datenregister
                         ist).

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | * | *    <=  \#M”gliche Ver„nderungen\#
 |           |   |
 |           |   +--- Wird entsprechend dem letzten aus dem Ziel 
 |           |        geschobenem Bit gesetzt. Falls die Anzahl der Bit
 |           |        0 ist wird das Flag gel”scht. 
 |           +------- Wird auf 1 gesetzt falls w„hrend des Schiebens 
 |                    ein Vorzeichenwechsel stattfand.
 +------------------- Wird wie C behandelt nur mit dem Unterschied, da das
                      Flag unberhrt bleibt, falls die Anzahl der Bit 0 
                      ist.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +-------------+------+-------+-------+-------+----------+-------
       | Dn          | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx 
-------+-------------+------+-------+-------+-------+----------+-------
Dn     | 6+2n/8+2n,2 |      |       |       |       |          |
#      | 6+2n/8+2n,2 |      |       |       |       |          |
1      |             | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4   

Quelle |   Ziel
       +-----------
       | $xxxxxxxx
-------+-----------
1      | 20,6

Hinweis: n ist die Anzahl der Bit, um die verschoben werden soll.

Gruppe: \#Bitschiebe- und Rotierbefehle\#

Querverweis: \#ASL\#, \#ASR\#, \#LSL\#
\end

screen( sensitive("MOVE") )
MOVE - šbertrage Daten
----------------------------------------------------------------------

Assembler Syntax: MOVE <ea>,<ea>

Beschreibung:
Der Inhalt des Source Operanden wird zum Ziel bewegt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0   <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    |   Ziel
          +----------+-----------+-----------+-----------+-----------
          | Dn       | (An)      | (An)+     | -(An)     | d(An)
----------+----------+-----------+-----------+-----------+-----------
Dn        | 4/4,2    | 8/12,2    | 8/12,2    | 8/14,2    | 12/16,4
An        | 4/4,2    | 8/12,2    | 8/12,2    | 8/14,2    | 12/16,4
(An)      | 8/12,2   | 12/20,2   | 12/20,2   | 12/20,2   | 16/24,4
(An)+     | 8/12,2   | 12/20,2   | 12/20,2   | 12/20,2   | 16/24,4
-(An)     | 10/14,2  | 14/22,2   | 14/22,2   | 14/22,2   | 18/26,4
d(An)     | 12/16,4  | 16/24,4   | 16/24,4   | 16/24,4   | 20/28,6
d(An,Rx)  | 14/18,4  | 18/26,4   | 18/26,4   | 18/26,4   | 22/30,6
$xxxx     | 12/16,4  | 16/24,4   | 16/24,4   | 16/24,4   | 20/28,6
$xxxxxxxx | 16/20,6  | 20/28,6   | 20/28,6   | 20/28,6   | 24/32,8
d(PC)     | 12/16,4  | 16/24,4   | 16/24,4   | 16/24,4   | 20/28,6
d(PC,Rx)  | 14/18,4  | 18/26,4   | 18/26,4   | 18/26,4   | 22/30,6
#         | 8/12,4/6 | 12/20,4/6 | 12/20,4/6 | 12/20,4/6 | 16/24,6/8

Quelle    |   Ziel
          +-----------+-----------+------------
          | d(An,Rx)  | $xxxx     | $xxxxxxxx
----------+-----------+-----------+------------
Dn        | 14/18,4   | 12/16,4   | 16/20,6
An        | 14/18,4   | 12/16,4   | 16/20,6
(An)      | 18/26,4   | 16/24,4   | 20/28,6
(An)+     | 18/26,4   | 16/24,4   | 20/28,6
-(An)     | 20/28,4   | 18/26,4   | 22/30,6
d(An)     | 22/30,6   | 20/28,6   | 24/32,8
d(An,Rx)  | 24/32,6   | 22/30,6   | 26/34,8
$xxxx     | 22/30,6   | 20/28,6   | 24/32,8
$xxxxxxxx | 26/34,8   | 24/32,8   | 28/36,10
d(PC)     | 22/30,6   | 20/28,6   | 24/32,8
d(PC,Rx)  | 24/32,6   | 22/30,6   | 26/34,8
#         | 18/26,6/8 | 16/24,6/8 | 20/28,8/10

Hinweis:
MOVE   <ea>,An    wird automatisch zu \#MOVEA\# bersetzt.
MOVE.L #<data>,Dn wird automatisch zu \#MOVEQ\# bersetzt, wenn <data> im 
Bereich von -128 bis +127 liegt.
Fr MOVE #0,Dn sollte man besser \#CLR\# Dn verwenden.

Gruppe: \#Transfer-Befehle\#

Querverweis: \#MOVE to CCR\#, \#MOVE from CCR\#, \#MOVE to SR\#, \#MOVE from SR\#,
             \#MOVE from USP\#, \#MOVE to USP\#, \#MOVEA\#, \#MOVEC\#, \#MOVEM\#, 
             \#MOVEP\#, \#MOVEQ\#, \#MOVES\#, \#MOVE16\#
\end

screen( sensitive("MOVE16") )
MOVE16 - šbertrage 16-Byte-Block                               MC68040
----------------------------------------------------------------------

Assembler Syntax: MOVE16 <ea>,<ea>

Beschreibung:
MOVE16 bewegt einen auf einer 16-Byte-Grenze beginnenden 16 Byte
groen Block zur ebenfalls ausgerichteten Zieladresse. Dieser
Befehl arbeitet nur im Speicher, d.h. Register k”nnen mit ihm
nicht geladen werden.

Gr”e: Auf 16-Byte-Grenze ausgerichteter 16 Byte-Block.

Gruppe: \#Transfer-Befehle\#

Querverweis: \#MOVE\#
\end

screen( "MOVE to CCR" )
MOVE to CCR - šbertrage ein Datum ins Condition Code Register
----------------------------------------------------------------------

Assembler Syntax: MOVE.W <ea>,ccr

Beschreibung:
Der Inhalt des Source Operanden wird zum CCR bewegt.

Gr”e: Word (es k”nnen nur einige Bit des \#CCR\# ver„ndert werden).

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    | Ziel
          +------
          | CCR
----------+------
Dn        | 12,2
(An)      | 16,2
(An)+     | 16,2
-(An)     | 18,2
d(An)     | 20,4
d(An,Rx)  | 22,4
$xxxx     | 20,4
$xxxxxxxx | 24,6
d(PC)     | 20,4
d(PC,Rx)  | 22,4
#         | 16,4

Gruppe: \#Transfer-Befehle\#

Querverweis: \#MOVE\#, \#MOVE from CCR\#, \#MOVE to SR\#, \#MOVE from SR\#,
             \#MOVE from USP\#, \#MOVE to USP\#, \#MOVEA\#, \#MOVEC\#, \#MOVEM\#, 
             \#MOVEP\#, \#MOVEQ\#, \#MOVES\#
\end

screen( "MOVE from CCR" )
MOVE from CCR - šbertrage Datum aus Condition Code Register    MC68010
----------------------------------------------------------------------

Assembler Syntax: MOVE.W CCR,<ea>

Beschreibung:
Der Inhalt des CCR wird zum Ziel bewegt. Es werden jedoch nur einige Bit 
des \#CCR\# bertragen, die brigen werden auf 0 gesetzt.

Gr”e: Word 

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -   <=  \#M”gliche Ver„nderungen\#

Gruppe: \#Transfer-Befehle\#

Querverweis: \#MOVE\#, \#MOVE to CCR\#, \#MOVE to SR\#, \#MOVE from SR\#,
             \#MOVE from USP\#, \#MOVE to USP\#, \#MOVEA\#, \#MOVEC\#, \#MOVEM\#, 
             \#MOVEP\#, \#MOVEQ\#, \#MOVES\#
\end

screen( "MOVE to SR" )
MOVE to SR - šbertrage ein Datum ins Status Register
----------------------------------------------------------------------

Assembler Syntax: MOVE.W <ea>,SR

Beschreibung:
Der Inhalt des Source Operanden wird zum SR bewegt.

Gr”e: Word (es k”nnen nur einige Bit des \#SR\# ver„ndert werden).

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    | Ziel
          +------
          | SR
----------+------
Dn        | 12,2
(An)      | 16,2
(An)+     | 16,2
-(An)     | 18,2
d(An)     | 20,4
d(An,Rx)  | 22,4
$xxxx     | 20,4
$xxxxxxxx | 24,6
d(PC)     | 20,4
d(PC,Rx)  | 22,4
#         | 16,4

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.

Gruppe: \#Transfer-Befehle\#

Querverweis: \#MOVE\#, \#MOVE to CCR\#, \#MOVE from CCR\#, \#MOVE from SR\#,
             \#MOVE from USP\#, \#MOVE to USP\#, \#MOVEA\#, \#MOVEC\#, \#MOVEM\#, 
             \#MOVEP\#, \#MOVEQ\#, \#MOVES\#
\end

screen( "MOVE from SR" )
MOVE from SR - šbertrage ein Datum aus dem Status Register
----------------------------------------------------------------------

Assembler Syntax: MOVE.W SR,<ea>

Beschreibung:
Der Inhalt des SR wird zum Ziel bewegt. Es werden jedoch nur einige Bit 
des \#CCR\# bertragen, die brigen werden auf 0 gesetzt.

Gr”e: Word 

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -   <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle | Ziel
       +-----+------+-------+-------+-------+----------+-------+-----------
       | Dn  | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
-------+-----+------+-------+-------+-------+----------+-------+-----------
SR     | 6,2 | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4  | 20,6

Achtung: Dieser Befehl ist bei den CPUs ab 68010 privilegiert, d.h. diese 
         Prozessororen mssen sich im Supervisormode befinden, um ihn 
         korrekt ausfhren zu k”nnen. Sie sollten ihn auch auf 68000er Sys-
         temen nur im Supervisermode verwenden um kompatibel zu bleiben.

Gruppe: \#Transfer-Befehle\#

Querverweis: \#MOVE\#, \#MOVE to CCR\#, \#MOVE from CCR\#, \#MOVE to SR\#, 
             \#MOVE from USP\#, \#MOVE to USP\#, \#MOVEA\#, \#MOVEC\#, \#MOVEM\#, 
             \#MOVEP\#, \#MOVEQ\#, \#MOVES\#
\end

screen( "MOVE to USP",
		"MOVE from USP" )
MOVE USP - šbertrage Inhalt des User Stack Pointers
----------------------------------------------------------------------

Assembler Syntax: MOVE USP,An
                  MOVE An,USP

Beschreibung:
Der Inhalt des User Stack Pointers wird in ein Adreregister bertragen 
oder der Inhalt eines Adreregisters wird zum \#USP\# bertragen.

Gr”e: Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -   <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle | Ziel
       +-----+-----
       | USP | An
-------+-----+-----
USP    |     | 4/2
An     | 4/2 |

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.

Gruppe: \#Transfer-Befehle\#

Querverweis: \#MOVE\#, \#MOVE to CCR\#, \#MOVE from CCR\#, \#MOVE to SR\#, 
             \#MOVE from SR\#, \#MOVEA\#, \#MOVEC\#, \#MOVEM\#, \#MOVEP\#, \#MOVEQ\#, \#MOVES\#
\end

screen( sensitive("MOVEA") )
MOVEA - šbertrage Daten in ein Adreregister
----------------------------------------------------------------------

Assembler Syntax: MOVEA <ea>,An

Beschreibung:
Der Inhalt des Source Operanden wird zu einem Adreregister bewegt. 
Die Gr”enspezifikation ist auf  Word und  Long beschr„nkt. Ist die 
Word Gr”e spezifiziert, wird vor  der Operation  automatisch  eine
Wandlung des Source Operanden auf 32 Bit unter Beachtung des Vor-
zeichens vorgenommen.

Gr”e: Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    | Ziel
          +----------
          | An
----------+----------
Dn        | 4/4,2
An        | 4/4,2
(An)      | 8/12,2
(An)+     | 8/12,2
-(An)     | 10)14,2
d(An)     | 12/16,4
d(An,Rx)  | 14/18,4
$xxxx     | 12/16,4
$xxxxxxxx | 16/20,6
d(PC)     | 12/16,4
d(PC,Rx)  | 14/18,4
#         | 8/12,4/6 

Gruppe: \#Transfer-Befehle\#

Querverweis: \#MOVE\#, \#MOVE to CCR\#, \#MOVE from CCR\#, \#MOVE to SR\#, \#MOVE from SR\#,
             \#MOVE from USP\#, \#MOVE to USP\#, \#MOVEC\#, \#MOVEM\#, \#MOVEP\#, 
             \#MOVEQ\#, \#MOVES\#
\end

screen( sensitive("MOVEC") )
MOVEC - šbertrage Kontrolregister                MC68010, privilegiert
----------------------------------------------------------------------

Assembler Syntax: MOVEC cr,Rn
                  MOVEC Rn,cr

Beschreibung:
Kopiert den Inhalt des angegebenen \#CPU-Kontrollregister\#s in ein
allgemeines Register und umgekehrt.

Gr”e: Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.

Gruppe: \#Transfer-Befehle\#

Querverweis: \#MOVE\#, \#MOVE to CCR\#, \#MOVE from CCR\#, \#MOVE to SR\#, \#MOVE from SR\#,
             \#MOVE from USP\#, \#MOVE to USP\#, \#MOVEA\#, \#MOVEM\#, \#MOVEP\#, 
             \#MOVEQ\#, \#MOVES\#
\end

screen( sensitive("MOVEM") )
MOVEM - šbertrage mehrere Register
----------------------------------------------------------------------

Assembler Syntax: MOVEM reglist,<ea>
                  MOVEM <ea>,reglist
Beschreibung:
Die durch  reglist  bezeichneten  Register  werden  an  der durch
die effektive Adresse angegebenen Speicherstelle  abgelegt,  bzw.
aus dem Speicher  in  die  Register  geschrieben.  Dieser  Befehl
erm”glicht das schnelle Retten und Wiederherstellen von Register-
inhalten. Wenn Sie Gr”e Word angeben und das Ziel die  Register-
liste ist, werden die  Worddaten vorzeichenrichtig auf 32 Bit er-
weitert und dann in das Register geschrieben.

Gr”e: Word, Long

Ablagereihenfolge:

Register -> Speicher (Ziel: -(An))
A7 A6 A5 A4 A3 A2 A1 A0 D7 D6 D5 D4 D3 D2 D1 D0
---------------------------------------------->

Speicher -> Register (Quelle: (An)+)
D0 D1 D2 D3 D4 D5 D6 D7 A0 A1 A2 A3 A4 A5 A6 A7
---------------------------------------------->

Alle anderen F„lle
D0 D1 D2 D3 D4 D5 D6 D7 A0 A1 A2 A3 A4 A5 A6 A7
---------------------------------------------->

Gr”e: Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    | Ziel
          +---------------+-------------+-------------+---------------
          | Dn/An         | (An)        | -(An)       | d(An)
----------+---------------+-------------+-------------+---------------
Dn/An     |               | 8+4n/8+8n,4 | 8+4n/8+8n,4 | 12+4n/12+8n,6
(An)      | 12+4n/12+8n,4 | 
(An)+     | 12+4n/12+8n,4 | 
d(An)     | 16+4n/16+8n,6 | 
d(An,Rx)  | 18+4n/18+8n,6 | 
$xxxx     | 16+4n/16+8n,6 | 
$xxxxxxxx | 20+4n/20+8n,8 | 
d(PC)     | 16+4n/16+8n,6 | 
d(PC,Rx)  | 18+4n/18+8n,6 | 

Quelle    | Ziel
          +---------------+---------------+---------------
          | d(An,Rx)      | $xxxx         | -(An)
----------+---------------+---------------+---------------
Dn/An     | 14+4n/14+8n,6 | 12+4n/12+8n,6 | 16+4n/16+8n,8

Hinweis:
n ist die Anzahl der Register.

Gruppe: \#Transfer-Befehle\#

Querverweis: \#MOVE\#, \#MOVE to CCR\#, \#MOVE from CCR\#, \#MOVE to SR\#, \#MOVE from SR\#,
             \#MOVE from USP\#, \#MOVE to USP\#, \#MOVEA\#, \#MOVEC\#, \#MOVEP\#, 
             \#MOVEQ\#, \#MOVES\#
\end

screen( sensitive("MOVEP") )
MOVEP - šbertrage Daten fr die Peripherie
----------------------------------------------------------------------

Assembler Syntax: MOVEP Dx,dist((Ay)
                  MOVEP dist(Ay),Dx
Beschreibung:
Es werden  Register-Daten  in  den  Speicher  bzw. vom Speicher
in ein Register bewegt. Dabei wird die Speicheradresse nicht wie
blich per Byte um Eins erh”ht,  sondern  um Zwei.  Dies hat zur
Folge, da der Byte Transfer sich  entweder  ausschlielich  auf
den  unteren  oder  den  oberen 8 Bit eines 16 Bit breiten Buses
abspielen kann.

Dieser Befehl dient haupts„chlich zur Erleichterung  des  Daten-
transfers von und zu 8-Bit Peripherieger„ten.

Der MOVEP-Befehl ist der einzige, der Wort- bzw. Langwortdaten an 
einer ungeraden Adresse bertragen kann.

Gr”e: Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle | Ziel
       +---------+---------
       | Dn      | d(An)
-------+---------+---------
Dn     |         | 16/24,4
d(An)  | 16/24,4 |

Gruppe: \#Transfer-Befehle\#

Querverweis: \#MOVE\#, \#MOVE to CCR\#, \#MOVE from CCR\#, \#MOVE to SR\#, \#MOVE from SR\#,
             \#MOVE from USP\#, \#MOVE to USP\#, \#MOVEA\#, \#MOVEC\#, \#MOVEM\#,
             \#MOVEQ\#, \#MOVES\#
\end

screen( sensitive("MOVEQ") )
MOVEQ - šbertrage Konstante schnell in ein Datenregister
----------------------------------------------------------------------

Assembler Syntax: MOVEQ #<data>,Dn

Beschreibung:
Bewegt konstante Daten in ein Datenregister.  Der Wertebereich
der konstanten Daten kann 8-Bit gro sein und reicht damit von
-127 bis +128. 

Gr”e: Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+--- 
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle | Ziel
       +-----
       | Dn
-------+-----
#      | 4,2

Gruppe: \#Transfer-Befehle\#

Querverweis: \#MOVE\#, \#MOVE to CCR\#, \#MOVE from CCR\#, \#MOVE to SR\#, \#MOVE from SR\#,
             \#MOVE from USP\#, \#MOVE to USP\#, \#MOVEA\#, \#MOVEC\#, \#MOVEM\#,
             \#MOVEP\#, \#MOVES\#
\end

screen( sensitive("MOVES") )
MOVES - šbertrage Register via DFC oder SFC      MC68010, privilegiert
----------------------------------------------------------------------

Assembler Syntax: MOVES Rn,<ea>
                  MOVES <ea>,Rn

Beschreibung:
Bewegt den Inhalt des allgemeinen  Register Rn an  die angege-
bene effektive Addresse und  benutzt dabei den im  Destination
Function Code Register (\#DFC\#)  spezifizierten Funktionscode. Im
umgekehrten Fall wird der im \#Source Function Code\# Register ge-
speicherte Funktionscode verwendet.  Der Funktionscode wird im
Normalfall automatisch von der CPU gesetzt  und dient dazu der
externen  Harware  mitzuteilen,  ob sich z.B der  Prozessor im 
Supervisormode befindet.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#
 
Gruppe: \#Transfer-Befehle\#

Querverweis: \#MOVE\#, \#MOVE to CCR\#, \#MOVE from CCR\#, \#MOVE to SR\#, \#MOVE from SR\#,
             \#MOVE from USP\#, \#MOVE to USP\#, \#MOVEA\#, \#MOVEC\#, \#MOVEM\#,
             \#MOVEP\#, \#MOVEQ\#
\end

screen( sensitive("MULS") )
MULS - Multiplikation mit Vorzeichen
----------------------------------------------------------------------

Assembler Syntax: MULS.W <ea>,Dn    16*16->32
                  MULS.L <ea>,Dl    32*32->32   ( MC68020 )
                  MULS.L <ea>,Dh:Dl 32*32->64   ( MC68020 )

Beschreibung:
Zwei  Operanden  werden  unter  Beachtung  des  Vorzeichens
miteinander multipliziert.

Gr”e: Word, Long (MC68020)

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | 0    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    | Ziel
          +-------
          | Dn       
----------+-------
Dn        | 70,2  Bei der Anzahl der Taktzyklen handelt es sich dabei  
(An)      | 74,2  um einen Maximalwert.
(An)+     | 74,2   
-(An)     | 76,2  
d(An)     | 78,4  
d(An,Rx)  | 80,4   
$xxxx     | 78,4  
$xxxxxxxx | 82,6  
d(PC)     | 78,4  
d(PC,Rx)  | 80,4  
#         | 74,4 

Hinweis: Oft ist es ratsam, diesen Befehl durch andere Operationen zu 
         ersetzen. So kann man eine Multiplikation mit einer Potenz
         von 2 leicht auf eine Verschiebung mit \#ASL\# oder \#LSL\#
         zurckfhren.

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#DIVS\#, \#DIVU\#, \#MULU\#
\end

screen( sensitive("MULU") )
MULU - Multiplikation ohne Vorzeichen
----------------------------------------------------------------------

Assembler Syntax: MULU.W <ea>,Dn    16*16->32
                  MULU.L <ea>,Dl    32*32->32   ( MC68020 )
                  MULU.L <ea>,Dh:Dl 32*32->64   ( MC68020 )

Beschreibung:
Zwei  Operanden  werden  ohne  Beachtung  des  Vorzeichens
miteinander multipliziert.

Gr”e: Word, Long ( MC68020 )

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | 0    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    | Ziel
          +-------
          | Dn       
----------+-------
Dn        | 70,2  Bei der Anzahl der Taktzyklen handelt es sich dabei  
(An)      | 74,2  um einen Maximalwert.
(An)+     | 74,2   
-(An)     | 76,2  
d(An)     | 78,4  
d(An,Rx)  | 80,4   
$xxxx     | 78,4  
$xxxxxxxx | 82,6  
d(PC)     | 78,4  
d(PC,Rx)  | 80,4  
#         | 74,4 

Hinweis: Oft ist es ratsam, diesen Befehl durch andere Operationen zu 
         ersetzen. So kann man eine Multiplikation mit einer Potenz
         von 2 leicht auf eine Verschiebung mit \#ASL\# oder \#LSL\#
         zurckfhren.

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#DIVS\#, \#DIVU\#, \#MULS\#
\end

screen( sensitive("NBCD") )
NBCD - Negation von BCD-Zahlen
----------------------------------------------------------------------

Assembler Syntax: NBCD <ea>
                 
Beschreibung: Dieser Befehl dient zur Bildung des 10er- bzw. 9er-komplement.
Ist das X-Flag vorher 0, wird das 10er-komplement gebildet im anderen Falle
das 9er-komplement.

Gr”e: Byte

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | ? | * | ? | E    <=  \#M”gliche Ver„nderungen\#
 |       |
 |       +-------- Dieses Flag wird gel”scht, wenn das Ergebnis ungleich 0 
 |                 ist, ansonsten bleibt es unver„ndert. Es empfielt sich 
 |                 daher das Z-Flag vorher zu setzen, wenn man das Ergebnis 
 |                 auf 0 prfen will.
 +---------------- Wie das C-Bit.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

 Ziel
-----+------+-------+-------+-------+----------+-------+-----------
 Dn  | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
-----+------+-------+-------+-------+----------+-------+-----------
 6,2 | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4  | 20,6

Gruppe: \#Arithmetische Befehle\#
\end

screen( sensitive("NEG") )
NEG - Bin„re Negation
----------------------------------------------------------------------

Assembler Syntax: NEG <ea>

Beschreibung:
Der unter der effektiven Adresse angegebene Wert wird negiert.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | E    <=  \#M”gliche Ver„nderungen\#
 |
 +---------------- Wie das C-Bit.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

 Ziel
-------+---------+---------+---------+---------+----------+---------
 Dn    | (An)    | (An)+   | -(An)   | d(An)   | d(An,Rx) | $xxxx
-------+---------+---------+---------+---------+----------+---------
 4/6,2 | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 | 18/26,4  | 16/24,4

 Ziel
-----------
 $xxxxxxxx
-----------
 20/28,6
 
Gruppe: \#Arithmetische Befehle\#
 
Querverweis: \#NEGX\#
\end

screen( sensitive("NEGX") )
NEGX - Bin„re Negation mit Extend-Bit
----------------------------------------------------------------------

Assembler Syntax: NEGX <ea>

Beschreibung:
Der unter der effektiven Adresse angegebene Wert wird unter
Beachtung des Extended Bits negiert.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | *    <=  \#M”gliche Ver„nderungen\#
 |               |
 |               +-- Auf 1 gesetzt, falls das Ergebnis ungleich 0 ist, 
 |                   asonsten auf 0.
 +------------------ Wie das C-Bit.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

 Ziel
-------+---------+---------+---------+---------+----------+---------
 Dn    | (An)    | (An)+   | -(An)   | d(An)   | d(An,Rx) | $xxxx
-------+---------+---------+---------+---------+----------+---------
 4/6,2 | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 | 18/26,4  | 16/24,4

 Ziel
-----------
 $xxxxxxxx
-----------
 20/28,6

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#NEG\#
\end

screen( sensitive("NOP") )
NOP - Keine Operation
----------------------------------------------------------------------

Assembler Syntax: NOP

Beschreibung: Keine Operation. Dieser Befehl bekommt z.B. im
Zusammenhang mit Verz”gerungsschleifen einen Sinn.

Gr”e: Keine Gr”enspezifikation.

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Ausfhrungszeit: 4
Befehlsl„nge   : 2

Gruppe: \#Programmstruktur-Befehle\#
\end

screen( sensitive("NOT") )
NOT - Logisches Komplement
----------------------------------------------------------------------

Assembler Syntax: NOT <ea>

Beschreibung:
Von dem durch die effektive Adresse spezifizierten Wert wird
das Einerkomplement gebildet.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

 Ziel
-------+---------+---------+---------+---------+----------+---------
 Dn    | (An)    | (An)+   | -(An)   | d(An)   | d(An,Rx) | $xxxx
-------+---------+---------+---------+---------+----------+---------
 4/6,2 | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 | 18/26,4  | 16/24,4

 Ziel
-----------
 $xxxxxxxx
-----------
 20/28,6
 
Gruppe: \#Logische Befehle\#
\end

screen( sensitive("OR") )
OR - Logisches ODER
----------------------------------------------------------------------

Assembler Syntax: OR <ea>,Dn
                  OR dn,<ea>

Beschreibung:
Logische Inclusiv ODER-Verknpfung des Source Operanden mit dem
Zielinhalt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    |   Ziel
          +----------+---------+---------+---------+---------
          | Dn       | (An)    | (An)+   | -(An)   | d(An)
----------+----------+---------+---------+---------+---------
Dn        | 4/6,2    | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 
(An)      | 8/14,2   |
(An)+     | 8/14,2   |
-(An)     | 10/16,2  |
d(An)     | 12/18,4  |
d(An,Rx)  | 14/20,4  |
$xxxx     | 12/18,4  |
$xxxxxxxx | 16/22,6  |
d(PC)     | 12/18,4  |
d(PC,Rx)  | 14/20,4  |
#         | 8/14,4/6 |

Quelle |   Ziel
       +----------+--------+-----------
       | d(An,Rx) | $xxxx  | $xxxxxxxx
-------+----------+--------+-----------
Dn     | 18/26,4  |16/24,4 | 20/28,6

Hinweis:
OR #<data>, <ea> wird automatisch zu \#ORI\# bersetzt.

Gruppe: \#Logische Befehle\#

Querverweis: \#ORI\#, \#ORI to CCR\#, \#ORI to SR\#
\end

screen( sensitive("ORI") )
ORI - Logisches ODER mit einer Konstanten
----------------------------------------------------------------------

Assembler Syntax: ORI #<data>,<ea>
                 
Beschreibung:
Logische Inclusiv ODER-Verknpfung konstanter Daten mit dem
Zielinhalt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +----------+-----------+-----------+-----------+----------
       | Dn       | (An)      | (An)+     | -(An)     | d(An)
-------+----------+-----------+-----------+-----------+----------
#      | 8/16,4/6 | 16/28,4/6 | 16/28,4/6 | 18/30,4/6 | 20/32,6/8

Quelle |   Ziel
       +-----------+-----------+------------
       | d(An,Rx)  | $xxxx     | $xxxxxxxx
-------+-----------+-----------+------------
#      | 22/34,6/8 | 20/32,6/8 | 24/36,8/10

Gruppe: \#Logische Befehle\#

Querverweis: \#OR\#, \#ORI to CCR\#, \#ORI to SR\#
\end

screen( "ORI to CCR" )
ORI to CCR - Logisches ODER mit einer Konstanten und dem CCR
----------------------------------------------------------------------

Assembler Syntax: ORI #<data>, CCR
                 
Beschreibung: Logisches ODER Immediate mit dem Condition Code Register.
              Dieser Befehl dient dazu gezielt Flags des CCR zu l”schen
              oder unberhrt zu lassen.

Gr”e: Byte (es k”nnen nur die unteren 5 Bit des \#CCR\# ver„ndert werden).

Verarbeitungszeit: 20
Befehlsl„nge     :  4

Gruppe: \#Logische Befehle\#

Querverweis: \#OR\#, \#ORI\#, \#ORI to SR\#
\end

screen( "ORI to SR" )
ORI to SR - Logisches ODER mit einer Konstanten und dem SR
----------------------------------------------------------------------

Assembler Syntax: ORI #<data>, SR
                 
Beschreibung: Logisches ODER Immediate mit dem Status Register.
              Dieser Befehl dient dazu gezielt Flags des SR zu l”schen
              oder unberhrt zu lassen.

Gr”e: Word (es k”nnen nur einige Bit des \#SR\# ver„ndert werden).

Verarbeitungszeit: 20
Befehlsl„nge     :  4

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.
          
Gruppe: \#Logische Befehle\#

Querverweis: \#OR\#, \#ORI\#, \#ORI to CCR\#
\end

screen( sensitive("PACK") )
PACK - Packe BCD-Zahlen                                        MC68020
----------------------------------------------------------------------

Assembler Syntax: PACK -(Ax),-Ay),#<adjustment>
                  PACK Dx,Dy,-(am),#<adjustment>

Beschreibung:
Zwei in verschiedenen Bytes abgelegte BCD Zahlen ( Binary Coded
Decimal ) werden in ein einziges Byte gepackt.

Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#
 
Gruppe: \#Transfer-Befehle\#

Querverweis: \#UNPK\#
\end

screen( sensitive("PEA") )
PEA - Lege Adresse auf den Stack
----------------------------------------------------------------------

Assembler Syntax: PEA <ea>

Beschreibung:
Die angegebene effektive Adresse wird auf dem Stack abgelegt.

Gr”e: Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    | Ziel ist immer -(A7)
----------+----------------------
(An)      | 12,2
d(An)     | 16,4
d(An,Rx)  | 20,4
$xxxx     | 16,4
$xxxxxxxx | 20,6
d(PC)     | 16,4
d(PC,Rx)  | 20,4

Gruppe: \#Transfer-Befehle\#
\end

screen( sensitive("RESET") )
RESET - Setze Peripherie zurck                           privilegiert
----------------------------------------------------------------------

Assembler Syntax: RESET

Beschreibung:
Die Reset Leitung wird aktiviert und damit ein Reset  fr  alle
pheripheren Ger„te ausgel”st. Der Zustand des Prozessors „ndert
sich nicht und das Program wird  nach  dem  Reset beim n„chsten
Befehl fortgefhrt.

Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Verarbeitungszeit: 132
Befehlsl„nge     :   2

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.

Gruppe: \#Programmstruktur-Befehle\#
\end

screen( sensitive("ROL") )
ROL - Rotiere links
----------------------------------------------------------------------

Assembler Syntax: ROL Dx,Dy
                  ROL #<data>,Dy
                  ROL <ea>

Beschreibung:
Der Zieloperand wird um die angegeben Anzahl von Bits nach links
rotiert.   Wird  ein  konstanter  Wert  fr  die Anzahl der Bits
angegeben,  liegt  der  m”gliche  Wertebereich zwischen 1 und 8.
Wird  ein  Datenregister  spezifiziert,  wird der Rotation Count
des Registers verwendet.  Im  Speicher  kann  nur um jeweils ein
Bit rotiert werden und  die Gr”enspezifikation  ist  auf   Word
beschr„nkt.

Gr”e: Byte, Word, Long (Byte und Long nur wenn das Ziel ein Datenregister
                         ist).

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | *    <=  \#M”gliche Ver„nderungen\#
                 |
                 +-- Enth„lt das letzte aus dem Ziel geschobene Bit. Falls
                     der Rotationsz„hler 0 ist, wird das Flag auf 0 gesetzt.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +-------------+------+-------+-------+-------+----------+-------
       | Dn          | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx 
-------+-------------+------+-------+-------+-------+----------+-------
Dn     | 6+2n/8+2n,2 |      |       |       |       |          |
#      | 6+2n/8+2n,2 |      |       |       |       |          |
1      |             | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4   

Quelle |   Ziel
       +-----------
       | $xxxxxxxx
-------+-----------
1      | 20,6

Hinweis: n ist die Anzahl der Bit, um die verschoben werden soll.

Gruppe: \#Bitschiebe- und Rotierbefehle\#

Querverweis: \#ROR\#, \#ROXL\#, \#ROXR\#
\end

screen( sensitive("ROR") )
ROR - Rotiere rechts
----------------------------------------------------------------------

Assembler Syntax: ROR Dx,Dy
                  ROR #<data>,Dy
                  ROR <ea>

Beschreibung:
Der Zieloperand wird um die angegeben Anzahl von Bits nach rechts
rotiert.   Wird  ein  konstanter  Wert  fr  die Anzahl der  Bits
angegeben,  liegt  der  m”gliche  Wertebereich zwischen  1 und 8.
Wird  ein  Datenregister  spezifiziert,  wird der  Rotation Count
des Registers verwendet.  Im  Speicher  kann  nur um jeweils  ein
Bit rotiert werden und  die  Gr”enspezifikation  ist  auf   Word
beschr„nkt.

Gr”e: Byte, Word, Long (Byte und Long nur wenn das Ziel ein Datenregister
                         ist).

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | *    <=  \#M”gliche Ver„nderungen\#
                 |
                 +-- Enth„lt das letzte aus dem Ziel geschobene Bit. Falls
                     der Rotationsz„hler 0 ist, wird das Flag auf 0 gesetzt.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +-------------+------+-------+-------+-------+----------+-------
       | Dn          | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx 
-------+-------------+------+-------+-------+-------+----------+-------
Dn     | 6+2n/8+2n,2 |      |       |       |       |          |
#      | 6+2n/8+2n,2 |      |       |       |       |          |
1      |             | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4   

Quelle |   Ziel
       +-----------
       | $xxxxxxxx
-------+-----------
1      | 20,6

Hinweis: n ist die Anzahl der Bit, um die verschoben werden soll.

Gruppe: \#Bitschiebe- und Rotierbefehle\#

Querverweis: \#ROL\#, \#ROXL\#, \#ROXR\#
\end

screen( sensitive("ROXL") )
ROXL - Rotiere links unter Einbeziehung des Extend-Bits
----------------------------------------------------------------------

Assembler Syntax: ROXL Dx,Dy
                  ROXL #<data>,Dy
                  ROXL <ea>

Beschreibung:
Der Zieloperand wird um  die  angegeben  Anzahl  von  Bits  unter
Bercksichtigung des Extended Bits nach links  rotiert.  Wird ein
konstanter  Wert  fr  die Anzahl der  Bits angegeben,  liegt der
m”gliche  Wertebereich zwischen  1 und 8. Wird ein  Datenregister
spezifiziert, wird der Rotation Count des Registers ( Modulo 32 )
verwendet.  Im  Speicher  kann  nur um jeweils  ein  Bit  rotiert
werden und die  Gr”enspezifikation  ist  auf  Word  beschr„nkt.

Gr”e: Byte, Word, Long (Byte und Long nur wenn das Ziel ein Datenregister
                         ist).

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | 0 | *    <=  \#M”gliche Ver„nderungen\#
 |               |
 |               +-- Enth„lt das letzte aus dem Ziel geschobene Bit. Falls
 |                   der Rotationsz„hler 0 ist, wird das Flag auf 0 gesetzt.
 +------------------ Enth„lt das letzte aus dem Ziel geschobene Bit. Falls
                     der Rotationsz„hler 0 ist, bleibt das Flag unberhrt.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +-------------+------+-------+-------+-------+----------+-------
       | Dn          | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx 
-------+-------------+------+-------+-------+-------+----------+-------
Dn     | 6+2n/8+2n,2 |      |       |       |       |          |
#      | 6+2n/8+2n,2 |      |       |       |       |          |
1      |             | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4   

Quelle |   Ziel
       +-----------
       | $xxxxxxxx
-------+-----------
1      | 20,6

Hinweis: n ist die Anzahl der Bit, um die verschoben werden soll.

Gruppe: \#Bitschiebe- und Rotierbefehle\#

Querverweis: \#ROL\#, \#ROR\#, \#ROXR\#
\end

screen( sensitive("ROXR") )
ROXR - Rotiere rechts unter Einbeziehung des Extend-Bits
----------------------------------------------------------------------

Assembler Syntax: ROXR Dx,Dy
                  ROXR #<data>,Dy
                  ROXR <ea>

Beschreibung:
Der Zieloperand wird um  die  angegeben  Anzahl  von  Bits  unter
Bercksichtigung des Extended Bits nach rechts rotiert.  Wird ein
konstanter  Wert  fr  die Anzahl der  Bits angegeben,  liegt der
m”gliche  Wertebereich zwischen  1 und 8. Wird ein  Datenregister
spezifiziert, wird der Rotation Count des Registers ( Modulo 64 )
verwendet.  Im  Speicher  kann  nur um jeweils  ein  Bit  rotiert
werden und die Gr”enspezifikation ist auf Word beschr„nkt.

Gr”e: Byte, Word, Long (Byte und Long nur wenn das Ziel ein Datenregister
                         ist).

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | 0 | *    <=  \#M”gliche Ver„nderungen\#
 |               |
 |               +-- Enth„lt das letzte aus dem Ziel geschobene Bit. Falls
 |                   der Rotationsz„hler 0 ist, wird das Flag auf 0 gesetzt.
 +------------------ Enth„lt das letzte aus dem Ziel geschobene Bit. Falls
                     der Rotationsz„hler 0 ist, bleibt das Flag unberhrt.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +-------------+------+-------+-------+-------+----------+-------
       | Dn          | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx 
-------+-------------+------+-------+-------+-------+----------+-------
Dn     | 6+2n/8+2n,2 |      |       |       |       |          |
#      | 6+2n/8+2n,2 |      |       |       |       |          |
1      |             | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4   

Quelle |   Ziel
       +-----------
       | $xxxxxxxx
-------+-----------
1      | 20,6

Hinweis: n ist die Anzahl der Bit, um die verschoben werden soll.

Gruppe: \#Bitschiebe- und Rotierbefehle\#

Querverweis: \#ROL\#, \#ROR\#, \#ROXL\#
\end

screen( sensitive("RTD") )
RTD - Unterprogrammrckkehr mit Aufr„umen des Stacks    Nur MC68010/20
----------------------------------------------------------------------

Assembler Syntax: RTD #<displacement>

Beschreibung:
Die Return-Adresse wird vom Stack geholt, das  displacement  unter
Beachtung des Vorzeichens auf 32 Bit erweitert und  auf  den Stack
addiert. Anschlieend wird das Programm mit dem auf die Subroutine
folgenden Befehl fortgefhrt.


Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \#RTE\#, \#RTM\#, \#RTR\#, \#RTS\#
\end

screen( sensitive("RTE") )
RTE - Rckkehr aus einer Exception                        privilegiert
----------------------------------------------------------------------

Assembler Syntax: RTE

Beschreibung:
Dieser Befehl beendet die Behandlung einer Exception-Routine.

Die Informationen ber den Zustand des Prozessors vor dem Ein-
tritt  in  die  Exception  werden  vom Stack geholt und in die
Register des  Prozessors  bernommen.  Anschlieend  wird  das
Programm mit dem  auf  die  Subroutine folgenden Befehl fortge-
fhrt.

Gr”e: Ohne Gr”enspezifikation.

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | * | * | * | *    <=  \#M”gliche Ver„nderungen\#
 |   |   |   |   |
 +---+---+---+---+--- Entsprechend dem Stackinhalt.

Verarbeitungszeit: 20
Befehlsl„nge     :  2

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.
          
Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \#TRAP\#, \#TRAPV\#, \link("TRAPCC")TRAPcc\#, \#RTD\#, \#RTM\#, \#RTR\#, \#RTS\#
\end

screen( sensitive("RTM") )
RTM - Rckkehr aus Modul                                   Nur MC68020
----------------------------------------------------------------------

Assembler Syntax: RTM

Beschreibung:
Die Informationen ber den Zustand eines Moduls werden vom
Stack geholt.

Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | * | * | * | *    <=  \#M”gliche Ver„nderungen\#
 |   |   |   |   |
 +---+---+---+---+--- Entsprechend dem Stackinhalt.

Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \#CALLM\#, \#RTD\#, \#RTE\#, \#RTR\#, \#RTS\#
\end

screen( sensitive("RTR") )
RTR - Rckkehr aus Exception ohne Ver„ndern des Systembyte
----------------------------------------------------------------------

Assembler Syntax: RTR
                 
Beschreibung:
Die Return-Adresse und das Condition Code Register werden vom
Stack geholt.  Anschlieend wird das Programm mit dem auf die
Subroutine folgenden Befehl fortgefhrt.

Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | * | * | * | *    <=  \#M”gliche Ver„nderungen\#
 |   |   |   |   |
 +---+---+---+---+--- Entsprechend dem Stackinhalt.

Verarbeitungszeit: 20
Befehlsl„nge     :  2

Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \#RTD\#, \#RTE\#, \#RTM\#, \#RTS\#
\end

screen( sensitive("RTS") )
RTS - Rckkehr aus Unterprogramm
----------------------------------------------------------------------

Assembler Syntax: RTS
      
Beschreibung:
Rcksprung von einer Subroutine zu der Stelle, von der aus zu der
Subroutine verzweigt  wurde.   Der  neue  \#PC\#  wird  vom  Stack
geholt, der alte \#PC\# geht verloren.

Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Verarbeitungszeit: 16
Befehlsl„nge     :  2

Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \#BSR\#, \#JSR\#, \#RTD\#, \#RTE\#, \#RTM\#, \#RTR\#
\end

screen( sensitive("SBCD") )
SBCD - Subtraktion von BCD-Zahlen
----------------------------------------------------------------------

Assembler Syntax: SBCD Dx,Dy
                  SBCD -(Ax),-(Ay)

Beschreibung:
Der dezimal kodierte Ouelloperanden wird vom  dezimal  kodierten
Zieloperanden subtrahiert. Das Resultat steht nach der Operation
im Zielregister.

Gr”e: Byte

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | ? | * | ? | E    <=  \#M”gliche Ver„nderungen\#
 |       |
 |       +-------- Dieses Flag wird gel”scht, wenn das Ergebnis ungleich 0 
 |                 ist, ansonsten bleibt es unver„ndert. Es empfielt sich 
 |                 daher das Z-Flag vorher zu setzen, wenn man das Ergebnis 
 |                 auf 0 prfen will.
 +---------------- Wie das C-Bit.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle  |   Ziel
        +--------------
        | Dn   | -(An)
--------+------+-------
Dn      | 6,2  |
-(An)   |      | 18,2

Gruppe: \#Arithmetische Befehle\#
\end

screen( sensitive("SGT"),
		sensitive("SVC"),
		sensitive("SCS"),
		sensitive("SEQ"),
		sensitive("SGE"),
		sensitive("SHI"),
		sensitive("SCC"),
		sensitive("SLE"),
		sensitive("SMI"),
		sensitive("SF"),
		sensitive("SLT"),
		sensitive("ST"),
		sensitive("SPL"),
		sensitive("SLS"),
		sensitive("SVS"),
		sensitive("SNE") )
Scc - Setze ein Byte in Anh„ngigkeit von einer Bedingung
----------------------------------------------------------------------

Assembler Syntax: S\link("Condition Codes, CPU")cc\# <ea>

Beschreibung:
Setzt ein Byte in Abh„ngigkeit vom Zustand der jeweiligen Flags
des Condition Code Registers.
 
Gr”e: Byte

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Beding. |   Ziel
        +-----+------+-------+-------+-------+----------+-------+-----------
        | Dn  | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
--------+-----+------+-------+-------+-------+----------+-------+-----------
erfllt | 6,2 | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4  | 20,6
n. erf. | 4,2 | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4  | 20,6

Gruppe: \#Programmstruktur-Befehle\#
\end

screen( sensitive("STOP") )
STOP - Stoppe Programmausfhrung                          privilegiert
----------------------------------------------------------------------

Assembler Syntax: STOP #<data>

Beschreibung:
Wenn sich der Prozessor im Supervisor State  befindet  wird das
Status Register  mit  den  konstanten  Daten  geladen  und  der
Prozessor in den Halt Zustand  versetzt.  Dieser  Zustand  wird
solange  beibehalten  bis  entweder ein Interrupt auftritt, ein
Reset  ausgel”st  wurde  oder   bis   eine Exception  auftritt.
Letzteres kann z.B. der Fall sein, wenn das Trace Bit im Status
Register gesetzt war als der Stop Befehl ausgefhrt wurde.  Ein
Interrupt kann den Haltezustand  nur  aufheben  wenn  er  h”her
priorisiert ist als das gltige Interrupt Level.

Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | * | * | * | *     <=  \#M”gliche Ver„nderungen\#
 |   |   |   |   |
 +---+---+---+---+--- Entsprechend den kostanten Daten.

Verarbeitungszeit: 4
Befehlsl„nge     : 4

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich 
         sowohl vor als nach Ausfhrung des Befehls im Supervisormode 
         befinden, um ihn korrekt ausfhren zu k”nnen.

Gruppe: \#Programmstruktur-Befehle\#
\end

screen( sensitive("SUB") )
SUB - Bin„re Subtraktion
----------------------------------------------------------------------

Assembler Syntax: SUB <ea>,Dn
                  SUB Dn,<ea>

Beschreibung:
Der Quelloperand wird vom Zieloperanden subtrahiert und das
Ergebnis in dem unter effektiver Adresse spezifizierten Ziel
abgelegt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | E    <=  \#M”gliche Ver„nderungen\#
 |
 +----------------- Wie das C-Bit.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    |   Ziel
          +----------+---------+---------+---------+----------
          | Dn       | (An)    | (An)+   | -(An)   | d(An)
----------+----------+---------+---------+---------+----------
Dn        | 4/6,2    | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 
An        | 4/8,2    |
(An)      | 8/14,2   |
(An)+     | 8/14,2   |
-(An)     | 10/16,2  |
d(An)     | 12/18,4  |
d(An,Rx)  | 14/20,4  | 
$xxxx     | 12/18,4  |
$xxxxxxxx | 16/22,6  |
d(PC)     | 12/18,4  |
d(PC,Rx)  | 14/20,4  |
#         | 8/14,4/6 |

Quelle |   Ziel
       +----------+--------+-----------
       | d(An,Rx) | $xxxx  | $xxxxxxxx
-------+----------+--------+-----------
Dn     | 18/26,4  |16/24,4 | 20/28,6

Hinweise:
SUB.x <ea>,An wird automatisch zu \#SUBA\# bersetzt.
SUB.x #<data>, <ea>  wird automatisch zu \#SUBI\# bersetzt.
SUB.x #<data>, Rn wird automatisch zu \#SUBQ\# bersetzt, wenn der Quell-
operand im Bereich 0 bis 8 liegt.

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#SUBA\#, \#SUBI\#, \#SUBQ\#, \#SUBX\#
\end

screen( sensitive("SUBA") )
SUBA - Bin„re Subtraktion mit Adreregister als Ziel
----------------------------------------------------------------------

Assembler Syntax: SUBA <ea>,An

Beschreibung:
Der Quelloperand wird von einem Adreregister subtrahiert  und
das Ergebnis in das  Adreregister  geschrieben.  Dieser Befehl
ist nur im Word oder Long Format gltig. Ein SUBA.W Befehl wird
automatisch unter Beachtung des Vorzeichens auf 32 Bit  vor der
Operation erweitert.

Gr”e: Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle    |   Ziel
          +-----------
          | An        
----------+-----------
Dn        | 8/6,2
An        | 8/8,2
(An)      | 12/14,2
(An)+     | 12/14,2
-(An)     | 14/16,2
d(An)     | 16/18,4
d(An,Rx)  | 18/20,4 
$xxxx     | 16/18,4
$xxxxxxxx | 20/22,6
d(PC)     | 18/20,4
d(PC,Rx)  | 12/20,4
#         | 8/14,4/6

Hinweis: 
SUBA #..., An wird automatisch zu \#SUBQ\# bersetzt, wenn der Quell-
operand im Bereich von 0 bis 8 liegt.

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#SUB\#, \#SUBI\#, \#SUBQ\#, \#SUBX\#
\end

screen( sensitive("SUBI") )
SUBI - Bin„re Subtraktion mit Konstante als Quelle
----------------------------------------------------------------------

Assembler Syntax: SUBI #<data>,<ea>

Beschreibung:
Die konstanten Daten werden vom Zieloperanden subtrahiert und das
Ergebnis  in dem durch die effektive Adresse spezifizierten  Ziel
abgelegt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | E    <=  \#M”gliche Ver„nderungen\#
 |
 +----------------- Wie das C-Bit.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +----------+-----------+-----------+-----------+----------
       | Dn       | (An)      | (An)+     | -(An)     | d(An)
-------+----------+-----------+-----------+-----------+----------
#      | 8/16,4/6 | 16/28,4/6 | 16/28,4/6 | 18/30,4/6 | 20/32,6/8

Quelle |   Ziel
       +-----------+-----------+------------
       | d(An,Rx)  | $xxxx     | $xxxxxxxx
-------+-----------+-----------+------------
#      | 22/34,6/8 | 20/32,6/8 | 24/36,8/10

Hinweis: SUBI wird automatisch zu \#SUBQ\# bersetzt, wenn der Quell-
operand im Bereich von 0 bis 8 liegt.

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#SUB\#, \#SUBA\#, \#SUBQ\#, \#SUBX\#
\end

screen( sensitive("SUBQ") )
SUBQ - Bin„re Subtraktion (schnell)
----------------------------------------------------------------------

Assembler Syntax: SUBQ #<data>,<ea>

Beschreibung:
Konstante Daten im Wertebereich zwischen 1 und 8 werden vom
Zieloperanden subtrahiert.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | E    <=  \#M”gliche Ver„nderungen\#
 |
 +----------------- Wie das C-Bit.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle |   Ziel
       +--------+-------+---------+---------+---------
       | Dn     | An    | (An)    | (An)+   | -(An)
-------+--------+-------+---------+---------+---------
#      | 4/8,2  | 8/8,2 | 12/20,2 | 12/20,2 | 14/22,2 

Quelle |   Ziel
       +---------+----------+---------+-----------
       | d(An)   | d(An,Rx) | $xxxx   | $xxxxxxxx
-------+---------+----------+---------+-----------
#      | 16/24,4 | 18/26,4  | 16/24,4 | 20/28,6

Hinweis: SUBQ #...,An arbeitet immer mit Langwortverarbeitung.

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#SUB\#, \#SUBA\#, \#SUBI\#, \#SUBX\#
\end

screen( sensitive("SUBX") )
SUBX - Bin„re Subtraktion mit Extend-Bit
----------------------------------------------------------------------

Assembler Syntax: SUBX Dx,Dy
                  SUBX -(Ax),-(Ay)

Beschreibung:
Der  Quelloperand  wird  vom  Zieloperand  unter Bercksichtigung
des Extend Bit subtrahiert. Zwei \#Adressierungsarten\# sind m”glich:
Datenregister/Datenregister und Speicher/Speicher.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | * | E | E    <=  \#M”gliche Ver„nderungen\#
 |       |
 |       +--------- Dieses Flag wird gel”scht, wenn das Ergebnis ungleich 
 |                  0 ist, ansonsten bleibt es unver„ndert. Es empfielt 
 |                  sich daher das Z-Flag vorher zu setzen, wenn man das 
 |                  Ergebnis auf 0 prfen will.
 +----------------- Wie das C-Bit.

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

Quelle  |   Ziel
        +-------+---------
        | Dn    | -(An)
--------+-------+---------
Dn      | 4/8,2 |
-(An)   |       | 18/30,2

Gruppe: \#Arithmetische Befehle\#

Querverweis: \#SUB\#, \#SUBA\#, \#SUBI\#, \#SUBQ\#
\end

screen( sensitive("SWAP") )
SWAP - Tausche Registerh„lften
----------------------------------------------------------------------

Assembler Syntax: SWAP Dn

Beschreibung:  Es  werden  die zwei 16 Bit H„lften eines 32 Bit
Datenregisters vertauscht.

Gr”e: Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Verarbeitungszeit: 4
Befehlsl„nge:      2

Gruppe: \#Transfer-Befehle\#
\end

screen( sensitive("TAS") )
TAS - Prfe und setzte ein Bit im Zieloperanden
----------------------------------------------------------------------

Assembler Syntax: TAS <ea>

Beschreibung:
Das durch die effektive Adresse spezifizierte Byte wird getestet
und und das Ergebnis im CCR abgelegt. Anschlieend wird das obeste
Bit des Zieloperanden gesetzt. Die Operation wird in einem einzigen 
Read-Modify-Write Speicherzyklus ausgefhrt um Prozesskommunikation  
ber Semaphoren sicherzustellen.

Gr”e: Byte

Anwendungsbeispiel:

try_again:
        TAS     semaphore
        \#BEQ\#     do_it
        \#BCLR\#.B  #7, semaphore
        \#BRA\#     try_again
do_it:
        \#ORI\#.B   #$FF, semaphore
; Begin der kritischen Zone
; Hier k”nnen keine zwei Prozesse gleichzeitig reinkommen
; Beachten Sie, da das Problem von DEADLOCKS nicht gel”st ist
        ...........................
; Ende der kritischen Zone
        \#CLR\#.B   semaphore
                
Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

 Ziel
-----+------+-------+-------+-------+----------+-------+-----------
 Dn  | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
-----+------+-------+-------+-------+----------+-------+-----------
 4,2 | 14,2 | 14,2  | 16,2  | 18,4  | 20,4     | 18,4  | 22,6

Querverweis: \#CAS\#, \#CAS2\#

Gruppe: \#Bit-Befehle\#
\end

screen( sensitive("TRAP") )
TRAP - Gehe in Ausnahmebehandlung
----------------------------------------------------------------------

Assembler Syntax: TRAP #<vector>

Beschreibung:
Durch  diesen  Befehl  wird  die  durch  vector  spezifizierte
\#Exception\# Behandlung initialisiert. Es stehen 16 TRAP Vektoren
zur Verfgung ( 0 - 15 ).
 
Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Verarbeitungszeit: 38
Befehlsl„nge     :  2

Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \#RTE\#, \link("TRAPCC")TRAPcc\#, \#TRAPV\#
\end

screen( sensitive("TRAPCC"),
		sensitive("TRAPGT"),
		sensitive("TRAPLT"),
		sensitive("TRAPMI"),
		sensitive("TRAPGE"),
		sensitive("TRAPLS"),
		sensitive("TRAPEQ"),
		sensitive("TRAPT"),
		sensitive("TRAPVS"),
		sensitive("TRAPHI"),
		sensitive("TRAPVC"),
		sensitive("TRAPNE"),
		sensitive("TRAPCS"),
		sensitive("TRAPPL"),
		sensitive("TRAPLE") )
TRAPcc - Trap bei Bedingung                                    MC68020
----------------------------------------------------------------------

Assembler Syntax: TRAP\link("Condition Codes, CPU")cc\#
                  TRAP\link("Condition Codes, CPU")cc\#.W #<data>
                  TRAP\link("Condition Codes, CPU")cc\#.L #<data>

Beschreibung:
Wenn die spezifizierte Bedingung erfllt ist, wird die Behandlung
der \#Exception\# mit Vektor Nummer 7 eingeleitet. Wird die Bedingung
nicht   erfllt,   wird  der  auf  den  TRAPcc   folgende  Befehl
abgearbeitet.

Gr”e: Keine Gr”enspezifikation oder Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Hinweis:
TRAPF tut nichts und sollte deshalb weggelassen werden.

Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \#RTE\#, \#TRAP\#, \#TRAPV\#
\end

screen( sensitive("TRAPV") )
TRAPV - Trap bei šberlauf
----------------------------------------------------------------------

Assembler Syntax: TRAPV

Beschreibung:
Wenn  das  Overflow  Flag  im  Condition  Coder  Register gesetzt
ist, wird die Behandlung der \#Exception\# mit Vektor Nummer 7 einge-
leitet.  Ansonsten  wird  der  auf  den  TRAPV   folgende  Befehl
abgearbeitet.

Gr”e: Keine Gr”enspezifikation oder Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Verarbeitungszeit: 4 (Trap nicht ausgefhrt) 38 (Trap ausgefhrt)
Befehlsl„nge     : 2
          
Gruppe: \#Programmstruktur-Befehle\#

Querverweis: \#RTE\#, \#TRAP\#, \link("TRAPCC")TRAPcc\#
\end

screen( sensitive("TST") )
TST - Prfe Inhalt des Operanden
----------------------------------------------------------------------

Assembler Syntax: TST <ea>

Beschreibung:
Testet einen Operanden und setzt die entsprechenden Flags im
Condition Code Register.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  \#M”gliche Ver„nderungen\#

Erlaubte \#Adressierungsarten\#, \#Verarbeitungszeit\# und \#Befehlsl„nge\#:

 Ziel
-----+--------+--------+---------+---------+----------+---------+-----------
 Dn  | (An)   | (An)+  | -(An)   | d(An)   | d(An,Rx) | $xxxx   | $xxxxxxxx
-----+--------+--------+---------+---------+----------+---------+-----------
 4,2 | 8/12,2 | 8/12,2 | 10/14,2 | 12/16,4 | 14/18,4  | 12/16,4 | 16/20,6

Gruppe: \#Arithmetische Befehle\#

Querverweis \#CMP\#
\end

screen( sensitive("UNLK") )
UNLNK - Hole den Stackpointer zurck
----------------------------------------------------------------------

Assembler Syntax: UNLK An

Beschreibung:
Der  Stackpointer  wird  mit  dem  spezifizierten Adreregister
geladen,  vom  Stack  wird  dann  ein Langwort geholt und in das
Adreregister geschrieben.

Zur Veranschaulichung soll hier ein alternativer Code angegeben
werden:

\#MOVEA\#.L An, A7
\#MOVEA\#.L (A7)+, An

Gr”e: Keine Gr”enspezifikation.

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Verarbeitungszeit: 12 
Befehlsl„nge     :  2

Gruppe: \#Transfer-Befehle\#

Querverweis: \#LINK\#
\end

screen( sensitive("UNPK") )
UNPK - Entpacke BCD-Zahlen                                     MC68020
----------------------------------------------------------------------

Assembler Syntax: UNPK Dx,Dy,#<adjustment>
                  UNPK -(Ax),-(Ay),#<adjustment>

Beschreibung:
Zwei dezimal kodierte und in ein Byte gepackte Zahlen werden  aus
einem Byte in zwei Bytes aufgel”st. Dabei werden die Bits 7 bis 3
in die Bits 11 bis 8 des so entstehenden Wortes kopiert  und  die
oberen  Nibbels   auf  0  ( Null )  gesetzt.   Anschlieend  wird
adjustment auf den entstandenen Wert addiert.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im \#CCR\# ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  \#M”gliche Ver„nderungen\#

Gruppe: \#Transfer-Befehle\#

Querverweis: \#PACK\#
\end

screen( "Wertemenge",
		"Definitionsmenge" )
Definitions- und Wertemenge
----------------------------------------------------------------------

Die  Definitionsmenge D  einer Funktion ist  die Untermenge von 
R (Menge der reellen Zahlen) in der die Funktion definiert ist. 
In der Menge R \\ D ( R ohne D ) ist das  Funktionsergebnis  NaN
(Not a number). Im  Gegensatz zur  Mathematik kann bei den FPUs 
MC 68881/2 das Argument einer Funktion ñß ( unendlich ) sein.

Analog zur  Definitionsmenge ist  die  Wertemenge die  kleinste 
Untermenge von R,  die alle m”glichen  Ergebnisse der  Funktion
enth„lt. Auch hier kann ñß Element dieser Menge sein.
\end

screen( sensitive("FABS") )
FABS - Absolutwert                                    MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FABS.f <ea>,FPn
                  FABS.X FPm,FPn
                  FABS.X FPn

Beschreibung:
Der Absolutwert des Arguments wird berechnet und in das Zielregister
geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-ß,+ß], W = [0,+ß]

Querverweis: \#FSABS\#, \#FDABS\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FSABS"),
		sensitive("FDABS") )
FDABS - Absolutwert                                            MC68040
FSABS
----------------------------------------------------------------------

Assembler Syntax: FDABS.f <ea>,FPn
                  FDABS.X FPm,FPn
                  FDABS.X FPn
                  FSABS.f <ea>,FPn
                  FSABS.X FPm,FPn
                  FSABS.X FPn

Beschreibung:
Der Absolutwert des Arguments wird berechnet und in das Zielregister
geschrieben. FDABS rundet das Resultat auf doppelte und FSABS auf
einfache Genauigkeit.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-ß,+ß], W = [0,+ß]

Querverweis: \#FABS\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FACOS") )
FACOS - Arcus Cosinus                                          MC68881
----------------------------------------------------------------------

Assembler Syntax: FACOS.f <ea>,FPn
                  FACOS.x FPm,FPn
                  FACOS.x FPn
Beschreibung:
Es wird der Arcus Cosinus des Arguments berechnet und in das Ziel-
register geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-1,+1], W=[0,ã]

Umkehrfunktion: \#FCOS\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FADD") )
FADD - Fliekommaaddition                             MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FADD.f <ea>,FPn
                  FADD.x FPm,FPn

Beschreibung:
Es wird die Summe aus dem Quelloperanden und dem Zieloperanden berechnet
und in das Zielregister geschrieben.

Querverweis: \#FSUB\#, \#FDADD\#, \#FSADD\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FDADD"),
		sensitive("FSADD") )
FSADD - Fliekommaaddition                                     MC68040
FDADD
----------------------------------------------------------------------

Assembler Syntax: FSADD.f <ea>,FPn
                  FSADD.X FPm,FPn
                  FDADD.f <ea>,FPn
                  FDADD.X FPm,FPn

Beschreibung:
Es wird die Summe aus dem Quelloperanden und dem Zieloperanden
berechnet und in das Zielregister geschrieben. Dabei wird bei FSADD
das Resultat auf einfache Genauigkeit gerundet und bei FDADD auf
doppelte Genauigkeit.

Querverweis: \#FADD\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FASIN") )
FASIN - Arcus Sinus                                            MC68881
----------------------------------------------------------------------

Assembler Syntax: FASIN.f <ea>,FPn
                  FASIN.x FPm,FPn
                  FASIN.x FPn

Beschreibung:
Es wird der Arcus Sinus des Arguments berechnet und in das Ziel-
register geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-1,+1], W=[-ã/2,+ã/2]

Umkehrfunktion: \#FSIN\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FATAN") )
FATAN - Arcus Tangens                                          MC68881
----------------------------------------------------------------------

Assembler Syntax: FATAN.f <ea>,FPn
                  FATAN.x FPm,FPn
                  FATAN.x FPn

Beschreibung:
Es wird der Arcus Tangens des Arguments berechnet und in das Ziel-
register geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-ß,+ß], W=[-ã/2,+ã/2]

Umkehrfunktion: \#FTAN\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FATANH") )
FATANH - Arcus Tangens Hyperbolicus                            MC68881
----------------------------------------------------------------------

Assembler Syntax: FATANH.f <ea>,FPn 
                  FATANH.x FPm,FPn
                  FATANH.x FPn

Beschreibung:
Es wird der Arcus Tangens Hyperbolicus des Arguments berechnet und 
in das Zielregister geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-1,+1], W=[-ß,+ß]

Umkehrfunktion: \#FTANH\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( "FBcc",
		sensitive("FBOLE"),
		sensitive("FBNLE"),
		sensitive("FBNGT"),
		sensitive("FBNLT"),
		sensitive("FBNGLE"),
		sensitive("FBOGE"),
		sensitive("FBNGL"),
		sensitive("FBOGL"),
		sensitive("FBNGE"),
		sensitive("FBOGT"),
		sensitive("FBNE"),
		sensitive("FBOLT"),
		sensitive("FBLT"),
		sensitive("FBUN"),
		sensitive("FBLE"),
		sensitive("FBSEQ"),
		sensitive("FBGT"),
		sensitive("FBSF"),
		sensitive("FBGLE"),
		sensitive("FBSNE"),
		sensitive("FBGL"),
		sensitive("FBST"),
		sensitive("FBGE"),
		sensitive("FBT"),
		sensitive("FBF"),
		sensitive("FBOR"),
		sensitive("FBEQ"),
		sensitive("FBUEQ"),
		sensitive("FBUGE"),
		sensitive("FBUGT"),
		sensitive("FBULT"),
		sensitive("FBULE") )
FBcc - Bedingte Verzweigung                           MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FB\link("Condition Codes, CPU")cc\# <label>

Beschreibung:

Falls die Bedingung ( \link("Condition Codes, CPU")cc\# ) erfllt ist wird das Programm an der
Adresse weitegefhrt, fr die label steht.

Gr”e: Word, Long

Querverweis: \#FDBcc\#
 
Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FCMP") )
FCMP - Vergleiche zwei Operanden                      MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FCMP.f <ea>,FPn
                  FCMP.x FPm,FPn

Beschreibung:
Es werden zwei Operanden verglichen. Fr den Vergleich wird der
Quell- vom Zieloperand subtrahiert.  Das Resultat  wird  jedoch
nicht geschrieben,  lediglich  die  Flags  werden  entsprechend
gesetzt.

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FCOS") )
FCOS - Cosinus                                                 MC68881
----------------------------------------------------------------------

Assembler Syntax: FCOS.f <ea>,FPn
                  FCOS.x FPm,FPn
                  FCOS.x FPn
Beschreibung:
Es wird der Cosinus des Arguments berechnet und in das Zielregister 
geschrieben.  Je gr”er der  Absolutwert des  Arguments ist,  desto 
gr”er ist die Ungenauigkeit des Ergebnisses.

\#Definitionsmenge\# und \#Wertemenge\#:

D = ]-ß,+ß[, W=[-1,+1] (Hinweis: D sollte [-2ã,+2ã] sein.)  

Umkehrfunktion: \#FACOS\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FCOSH") )
FCOSH - Cosinus Hyperbolicus                                   MC68881
----------------------------------------------------------------------

Assembler Syntax: FCOSH.f <ea>,FPn 
                  FCOSH.x FPm,FPn
                  FCOSH.x FPn

Beschreibung:
Es wird der Cosinus Hyperbolicus des Arguments berechnet und in das 
Zielregister geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-ß,+ß], W=[-ã/2,+ã/2]

Umkehrfunktion: \#FTANH\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( "FDBcc",
		sensitive("FDBGL"),
		sensitive("FDBOR"),
		sensitive("FDBOLT"),
		sensitive("FDBOLE"),
		sensitive("FDBSEQ"),
		sensitive("FDBEQ"),
		sensitive("FDBSF"),
		sensitive("FDBOGT"),
		sensitive("FDBSNE"),
		sensitive("FDBOGL"),
		sensitive("FDBST"),
		sensitive("FDBOGE"),
		sensitive("FDBT"),
		sensitive("FDBNLT"),
		sensitive("FDBUEQ"),
		sensitive("FDBNLE"),
		sensitive("FDBUGE"),
		sensitive("FDBNGT"),
		sensitive("FDBUGT"),
		sensitive("FDBNGLE"),
		sensitive("FDBNGL"),
		sensitive("FDBULE"),
		sensitive("FDBNGE"),
		sensitive("FDBULT"),
		sensitive("FDBNE"),
		sensitive("FDBUN"),
		sensitive("FDBLT"),
		sensitive("FDBLE"),
		sensitive("FDBF"),
		sensitive("FDBGE"),
		sensitive("FDBGT"),
		sensitive("FDBGLE") )
FDBcc - Prfe Bedingung, dekrementiere und verzweige  MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FDB\link("Condition Codes, CPU")cc\# Dn,<label>

Beschreibung:
Diese Befehl erm”glich es eine einfache Schleife zu programmieren.
Zuerst  wird  die  ber  \link("Condition Codes, CPU")cc\#  spezifizierte  Bedingung  geprft um
festzustellen ob die Abbruchsbedingung  fr  die Schleife erreicht
ist. Wenn dies der Fall ist wird keine weitere Aktion vorgenommen.
Wenn die Abbruchsbedingung nicht erfllt ist,  werden  die unteren
16 Bit ( Achtung: Word ) um 1  ( Eins )  dekrementiert.  Wenn  das
Ergebnis -1 (Achtung: Minus Eins) ist, wird die Schleife  beendet.
Andernfalls  wird  auf  die durch label spezifizierte Adresse ver-
zweigt.

Gr”e: Word

Querverweis: \#FBcc\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FDIV") )
FDIV - Division                                       MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FDIV.f <ea>,FPn
                  FDIV.x FPm,FPn

Beschreibung:
Es wird  eine Division des Zieloperanden durch den  Ouelloperanden
ausgefhrt und das Ergebnis in das Zielregister geschrieben. Wenn 
beide Operanden 0 sind  oder beide +/-ß sind wird als Ergebnis NaN
( Not a number ) zurckgeliefert.

Querverweis: \#FMUL\#, \#FSGLDIV\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FSDIV"),
		sensitive("FDDIV") )
FSDIV - Division                                               MC68040
FDDIV
----------------------------------------------------------------------

Assembler Syntax: FDDIV.f <ea>,FPn
                  FDDIV.X FPm,FPn
                  FSDIV.f <ea>,FPn
                  FSDIV.X FPm,FPn


Beschreibung:
Es wird  eine Division des Zieloperanden durch den  Ouelloperanden
ausgefhrt und das Ergebnis in das Zielregister geschrieben. Wenn 
beide Operanden 0 sind  oder beide +/-ß sind wird als Ergebnis NaN
( Not a number ) zurckgeliefert. Bei FSDIV wird das Resultat auf
einfache Genauigkeit und bei FDDIV auf doppelte Genauigkeit ge-
rundet.

Querverweis: \#FDIV\#, \#FSGLDIV\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FETOX") )
FETOX - Exponentialfunktion e^x                                MC68881
----------------------------------------------------------------------

Assembler Syntax: FETOX.f <ea>,FPn
                  FETOX.x FPm,FPn
                  FETOX.x FPn

Beschreibung:
Es wird die Exponentialfunktion e^x (e hoch x) des Arguments berechnet
und in das Zielregister geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-ß,+ß], W=[0,+ß]

Umkehrfunktion: \#FLOGN\#

Querverweis: \#FETOXM1\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FETOXM1") )
FETOXM1 - Exponentialfunktion e^x-1                            MC68881
----------------------------------------------------------------------

Assembler Syntax: FETOXM1.f <ea>,FPn
                  FETOXM1.x FPm,FPn
                  FETOXM1.x FPn

Beschreibung:
Es wird die Exponentialfunktion e^x-1 (e hoch x) des Arguments berech-
net und in das Zielregister geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-ß,+ß], W=[-1,+ß]

Umkehrfunktion: \#FLOGNP1\#

Querverweis: \#FETOX\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FGETEXP") )
FGETEXP - Exponent des Operanden                               MC68881
----------------------------------------------------------------------

Assembler Syntax: FGETEXP.f <ea>,FPn
                  FGETEXP.x FPm,FPn
                  FGETEXP.x FPn
Beschreibung:
Berechnet den bin„ren Exponenten des Quelloperanden und schreibt 
das Ergebnis in das Zielregister.

\#Definitionsmenge\# und \#Wertemenge\#:

D = ]-ß,+ß[, W=[-16383,+16384], W c N

Querverweis: \#FGETMAN\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FGETMAN") )
FGETMAN - Mantisse des Operanden                               MC68881
----------------------------------------------------------------------

Assembler Syntax: FGETMAN.f <ea>,FPn
                  FGETMAN.x FPm,FPn
                  FGETMAN.x FPn
Beschreibung:
Berechnet die Mantisse des Quelloperanden und schreibt das 
Ergebnis in das Zielregister.

\#Definitionsmenge\# und \#Wertemenge\#:

D = ]-ß,+ß[, W = [1.0,+2.0[ u {0.0}

Querverweis: \#FGETEXP\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FINT") )
FINT - Integerteil des Operanden                               MC68881
----------------------------------------------------------------------

Assembler Syntax: FINT.f <ea>,FPn
                  FINT.x FPm,FPn
                  FINT.x FPn
Beschreibung:
Berechnet den Integerteil des Quelloperanden und schreibt das 
Ergebnis in das Zielregister.  Bei der Rundung wird der Wert
des \#Mode Control\# Bytes im \#Fliekomma-Kontrollregister\# berck-
sichtigt.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-ß,+ß], W = [-ß,+ß]

Querverweis: \#FINTRZ\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FINTRZ") )
FINTRZ - Integerteil des Operanden, gerundet auf 0             MC68881
----------------------------------------------------------------------

Assembler Syntax: FINTRZ.f <ea>,FPn
                  FINTRZ.x FPm,FPn
                  FINTRZ.x FPn
Beschreibung:
Es wird der Quelloperand nach 0 gerundet gerundet und das Ergebnis
in das Zielregister geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-ß,+ß], W = [-ß,+ß]

Querverweis: \#FINT\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FLOGN") )
FLOGN - Natrlicher Logarithmus                                MC68881
----------------------------------------------------------------------

Assembler Syntax: FLOGN.f <ea>,FPn
                  FLOGN.x FPm,FPn
                  FLOGN.x FPn

Beschreibung:
Es wird der natrliche Logarithmus des Arguments berechnet und in das
Zielregister geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [0,+ß], W = [-ß,+ß]

Umkehrfunktion: \#FETOX\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FLOGNP1") )
FLOGNP1 - Natrlicher Logarithmus von x+1                      MC68881
----------------------------------------------------------------------

Assembler Syntax: FLOGNP1.f <ea>,FPn
                  FLOGNP1.x FPm,FPn
                  FLOGNP1.x FPn

Beschreibung:
Es wird der natrliche Logarithmus des Arguments +1 berechnet und in 
das Zielregister geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-1,+ß], W = [-ß,+ß]

Umkehrfunktion: \#FETOXM1\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FLOG10") )
FLOG10 - Dekadischer Logarithmus                               MC68881
----------------------------------------------------------------------

Assembler Syntax: FLOG10.f <ea>,FPn
                  FLOG10.x FPm,FPn
                  FLOG10.x FPn

Beschreibung:
Es wird der dekadischer Logarithmus des Arguments berechnet und in das
Zielregister geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [0,+ß], W = [-ß,+ß]

Umkehrfunktion: \#FTENTOX\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FLOG2") )
FLOG2 - Logarithmus zur Basis 2                                MC68881
----------------------------------------------------------------------

Assembler Syntax: FLOG2.f <ea>,FPn
                  FLOG2.x FPm,FPn
                  FLOG2.x FPn

Beschreibung:
Es wird der Logarithmus zur Basis 2 des Arguments berechnet und in das
Zielregister geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [0,+ß], W = [-ß,+ß]

Umkehrfunktion: \#FTWOTOX\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FMOD") )
FMOD - Modulorest                                              MC68881
----------------------------------------------------------------------

Assembler Syntax: FMOD.f <ea>,FPn
                  FMOD.x FPm,FPn

Beschreibung:
Es wird der Modulorest aus Quelle und Ziel berechnet und das Ergebnis
in das Zielregister geschrieben. Der Modulorest ist definiert als:

                  FPn * ( Quelle * N )
wobei gilt:
                  N = INT( FPn / Quelle ) (round to zero mode)

Das Ergebnis dieser Division  steht anschlieend im  \#Quotient\# Byte des
\link("Fliekomma-Statusregister")Fliekomma-Statusregisters\#.

Querverweis: \#FREM\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FMOVE") )
FMOVE - šbertrage Daten                               MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FMOVE.f <ea>,FPn
                  FMOVE.f FPm,FPn
                  FMOVE.p FPm,<ea>{Dn}
                  FMOVE.p FPm,<ea>{#data}

Beschreibung:
Der Inhalt des Source Operanden wird zum Ziel bewegt.

Querverweis: \#FMOVE FPcr\#, \#FMOVECR\#, \#FMOVEM\#, \#FMOVEM FPcr\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FDMOVE"),
		sensitive("FSMOVE") )
FSMOVE - šbertrage Daten und runde                             MC68040
FDMOVE
----------------------------------------------------------------------

Assembler Syntax: FSMOVE.X FPm,FPn
                  FSMOVE.X <ea>,FPn
                  FDMOVE.p FPm,FPn
                  FDMOVE.p <ea>,FPn

Beschreibung:
Der Inhalt des Source Operanden wird zum Ziel bewegt. Dabei rundet
FSMOVE das Resultat auf einfache Genauigkeit und FDMOVE auf doppelte
Genauigkeit.

Querverweis: \#FMOVE\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( "FMOVE FPcr" )
FMOVE FPcr - šbertrage Daten in/aus ein FPU-Kontrollregister
                                                      MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FMOVE.l <ea>,FPcr
                  FMOVE.l FPcr,<ea>

Beschreibung:
Der Inhalt  eines \#FPU-Kontrollregister\#s wird von oder nach einer 
effektiven  Adresse  geschrieben.  Dabei ist  zu  beachten,  da 
nicht  definierte Bit  beim Lesen  aus einem Register  0 ergeben
und beim Schreiben in ein Register 0 sein sollten, um kompatibel
mit zuknftigen Versionen zu sein.

Querverweis: \#FMOVE\#, \#FMOVECR\#, \#FMOVEM\#, \#FMOVEM FPcr\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FMOVECR") )
FMOVECR - Hole Konstante aus dem ROM der FPU                   MC68881
----------------------------------------------------------------------

Assembler Syntax: FMOVECR.x #<data>,FPn

Beschreibung:
Es wird eine Konstante aus dem ROM des  Fliekommaprozessors in ein
Fliekommaregister bertragen. Je nach dem, welcher Wert fr <data>
angegeben wurde, wird eines von 22 m”glichen Konstanten geschrieben.

<data>      Konstante
----------------------
$00         ã (3.14159265358979323846)
$0B         \#FLOG10\#(2)
$0C         e (2.71828182845904523536)
$0D         \#FLOG2\#(e)
$0E         \#FLOG10\#(e)
$0F         0.0
$30         1n(2)
$31         1n(10)
$32         1.0
$33         10.0
$34         100.0
$35         10000.0
$36         1.0e8
$37         1.0e16
$38         1.0e32
$39         1.0e64
$3A         1.0e128
$3B         1.0e256
$3C         1.0e512
$3D         1.0e1024
$3E         1.0e2048
$3F         1.0e4096

Querverweis: \#FMOVE\#, \#FMOVE FPcr\#, \#FMOVEM\#, \#FMOVEM FPcr\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FMOVEM") )
FMOVEM - šbertrage mehrere Register                   MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FMOVEM.x <fdlist>,<ea>
                  FMOVEM.x Dn,<ea>
                  FMOVEM.x <ea>,<fdlist>
                  FMOVEM.x <ea>,Dn

Beschreibung:
Die spezifizierte Registerliste wird in den Speicher šbertragen 
oder aus dem  Speicher geholt.  Die Registerliste kann entweder 
direkt  angegeben  werden oder ber  ein Datenregister der  CPU 
spezifiziert werden.

Querverweis: \#FMOVE\#, \#FMOVE FPcr\#, \#FMOVECR\#, \#FMOVEM FPcr\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( "FMOVEM FPcr" )
FMOVEM FPcr - šbertrage mehrere Fliekomma-Kontrollregister    MC68881
----------------------------------------------------------------------

Assembler Syntax: FMOVEM.l <fclist>,<ea>   
                  FMOVEM.l <ea>,fclist

Beschreibung:
Die angegebenen \#FPU-Kontrollregister\# werden in den Speicher bertragen
oder aus diesem gelesen.
 
Querverweis: \#FMOVE\#, \#FMOVE FPcr\#, \#FMOVECR\#, \#FMOVEM\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FMUL") )
FMUL - Multiplikation                                 MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FMUL.f <ea>,FPn
                  FMUL.X FPm,FPn

Beschreibung:
Es wird das Produkt aus dem Quelloperanden und dem Zieloperanden 
berechnet und in das Zielregister geschrieben.

Querverweis: \#FDIV\#, \#FSGLMUL\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FDMUL"),
		sensitive("FSMUL") )
FDMUL - Multiplikation                                         MC68040
FSMUL
----------------------------------------------------------------------

Assembler Syntax: FDMUL.f <ea>,FPn
                  FDMUL.X FPm,FPn
                  FSMUL.f <ea>,FPn
                  FSMUL.X FPm,FPn

Beschreibung:
Es wird das Produkt aus dem Quelloperanden und dem Zieloperanden 
berechnet und in das Zielregister geschrieben.

Querverweis: \#FMUL\#, \#FSGLMUL\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FNEG") )
FNEG - Fliekomma Negation                            MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FNEG.f <ea>,FPn
                  FNEG.X FPm,FPn
                  FNEG.X FPm

Beschreibung:
Es wird der negative Wert des Arguments berechnet und in das Ziel-
register geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-ß,+ß], W = [-ß,+ß]

Umkehrfunktion: FNEG

Querverweis: \#FDNEG\#, \#FSNEG\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FSNEG"),
		sensitive("FDNEG") )
FDNEG - Negation                                               MC68040
FSNEG
----------------------------------------------------------------------

Assembler Syntax: FDNEG.f <ea>,FPn
                  FDNEG.X FPm,FPn
                  FDNEG.X FPm
                  FSNEG.f <ea>,FPn
                  FSNEG.X FPm,FPn
                  FSNEG.X FPm

Beschreibung:
Es wird der negative Wert des Arguments berechnet und in das Ziel-
register geschrieben. FDNEG rundet das Resultat auf einfache Ge-
nauigkeit und FDNEG auf doppelte Genauigkeit.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-ß,+ß], W = [-ß,+ß]

Querverweis: \#FNEG\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FNOP") )
FNOP - Keine Operation                                MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FNOP

Beschreibung: 
Keine Operation. Dieser Befehl dient haupts„chlich zur 
Synchronistation von CPU und FPU.

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FREM") )
FREM - IEEE-Rest                                               MC68881
----------------------------------------------------------------------

Assembler Syntax: FREM.f <ea>,FPn
                  FREM.X FPm,FPn

Beschreibung:
Es wird der IEEE-Rest aus Quelle und Ziel berechnet und das Ergebnis
in das Zielregister geschrieben. Der Modulorest ist definiert als:

                  FPn - ( Quelle * N )
wobei gilt:
                  N = INT( FPn / Quelle ) (round to nearest mode)

Das Ergebnis dieser Division  steht anschlieend im \#Quotient\# Byte des
\#Fliekomma-Statusregister\#s.

Querverweis: \#FMOD\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FRESTORE") )
FRESTORE - Wiederherstellung des Prozessorzustandes   MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FRESTORE <ea>

Beschreibung:
Dieser Befehl stellt den Zustand der FPU wieder her, der vorher mit
\#FSAVE\# gerettet wurde:

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich 
         sowohl vor als nach Ausfhrung des Befehls im Supervisormode 
         befinden, um ihn korrekt ausfhren zu k”nnen.

Querverweis: \#FSAVE\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FSAVE") )
FSAVE - Retten des Prozessorzustandes                 MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FSAVE <ea>

Beschreibung:
Dieser Befehl dient dazu,  den aktuellen Zustand der FPU zu retten, 
um  ihn  sp„ter  mit  \#FRESTORE\#  wiederherstellen  zu  k”nnen.  <ea> 
spezifiziert den Speicherbereich,  wo der  Zustand abgelegt  werden 
soll. Der Speicherbereich mu folgende Daten aufnehmen k”nnen:

Zustand     |  MC68881       |  MC68882/MC68040
------------+----------------+-----------------
NULL        |   6 Bytes      |   6 Bytes
IDLE        |  30 Bytes      |  62 Bytes
BUSY        | 186 Bytes      | 218 Bytes

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich 
         sowohl vor als nach Ausfhrung des Befehls im Supervisormode 
         befinden, um ihn korrekt ausfhren zu k”nnen.

Querverweis: \#FRESTORE\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FSCALE") )
FSCALE - Skaliere Exponent                                     MC68881
----------------------------------------------------------------------

Assembler Syntax: FSCALE.f <ea>,FPn
                  FSCALE.X FPm,FPn

Beschreibung:
Der Quelloperand wird zu einem Integer umgewandelt und auf den 
Exponenten des Zielregister aufaddiert. Das Ergebnis ist das 
gleiche. Das Ergebnis entpricht folgendem Term:

                 Fpn * 2^<Quelle>

Gruppe: \#Fliekomma-Befehle\#
\end

screen( "FScc",
		sensitive("FSST"),
		sensitive("FSUN"),
		sensitive("FSULT"),
		sensitive("FSULE"),
		sensitive("FSUGT"),
		sensitive("FSOGL"),
		sensitive("FSUGE"),
		sensitive("FSUEQ"),
		sensitive("FSNLT"),
		sensitive("FSOLE"),
		sensitive("FST"),
		sensitive("FSSNE"),
		sensitive("FSOGT"),
		sensitive("FSEQ"),
		sensitive("FSF"),
		sensitive("FSGE"),
		sensitive("FSGL"),
		sensitive("FSNGT"),
		sensitive("FSGLE"),
		sensitive("FSNLE"),
		sensitive("FSGT"),
		sensitive("FSOGE"),
		sensitive("FSOLT"),
		sensitive("FSOR"),
		sensitive("FSLE"),
		sensitive("FSLT"),
		sensitive("FSSF"),
		sensitive("FSNE"),
		sensitive("FSSEQ"),
		sensitive("FSNGL"),
		sensitive("FSNGE"),
		sensitive("FSNGLE") )
FScc - Setze Byte in Anh„ngigkeit von Bedingung       MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FS\link("Condition Codes, CPU")cc\# <ea>

Beschreibung:
Setzt ein Byte in Abh„ngigkeit vom Zustand der jeweiligen Flags
des Condition Code der FPU.

Falls die Bedingung zutrifft, das BSUN Bit des \#Exception Enable\#
Byte und das NAN Bit des \#Condition Code\# gesetzt ist,  wird eine
\#Exception\# mit der Nummer 48 ausgel”st.

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FSGLDIV") )
FSGLDIV - Division mit einfacher Genauigkeit                   MC68881
----------------------------------------------------------------------

Assembler Syntax: FSGLDIV.f <ea>,FPn
                  FSGLDIV.X FPm,FPn

Beschreibung:
Es wird eine Division des Zieloperanden durch den Ouelloperanden
ausgefhrt und das Ergebnis in das Zielregister geschrieben. Wenn 
beide Operanden 0 sind oder beide +/-ß sind wird als Ergebnis NaN
( Not a number ) zurckgeliefert. Im Gegensatz zu FDIV wird nur 
mit einfacher Genaugikeit gerechnet.

Querverweis: \#FDIV\#, \#FSGLMUL\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FSGLMUL") )
FSGLMUL - Multiplikation mit einfacher Genauigkeit             MC68881
----------------------------------------------------------------------

Assembler Syntax: FSGLMUL.f <ea>,FPn
                  FSGLMUL.X FPm,FPn

Beschreibung:
Es wird das Produkt aus dem Quelloperanden und dem Zieloperanden 
berechnet und in das Zielregister geschrieben. Im Gegensatz zu  
FMUL wird nur mit einfacher Genaugikeit gerechnet.

Querverweis: \#FMUL\#, \#FSGLDIV\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FSIN") )
FSIN - Sinus                                                   MC68881
----------------------------------------------------------------------

Assembler Syntax: FSIN.f <ea>,FPn
                  FSIN.x FPm,FPn
                  FSIN.x FPn

Beschreibung:
Es wird der Sinus  des  Arguments berechnet und in das Zielregister 
geschrieben.  Je gr”er der  Absolutwert des  Arguments ist,  desto 
gr”er ist die Ungenauigkeit des Ergebnisses.

\#Definitionsmenge\# und \#Wertemenge\#:

D = ]-ß,+ß[, W=[-1,+1] (Hinweis: D sollte [-2ã,+2ã] sein.)  

Umkehrfunktion: \#FASIN\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FSINCOS") )
FSINCOS - Sinus und Cosinus gleichzeitig                       MC68881
----------------------------------------------------------------------

Assembler Syntax: FSINCOS.f <ea>,FPc:FPs
                  FSINCOS.x FPm,fpc:fps

Beschreibung:
Er wird sowohl der Sinus als auch der Cosinus des Quelloperanden 
berechnet und in die  beiden Zielregister geschrieben. Der Sinus 
steht anschlieend im Register FPs, der Cosinus im Register FPc.

\#Definitionsmenge\# und \#Wertemenge\#:

D = ]-ß,+ß[, W=[-1,+1] (Hinweis: D sollte [-2ã,+2ã] sein.)  

Querverweis: \#FSIN\#, \#FCOS\#

Umkehrfunktionen: \#FASIN\#, \#FACOS\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FSINH") )
FSINH - Sinus Hyperbolicus                                     MC68881
----------------------------------------------------------------------

Assembler Syntax: FSINH.f <ea>,FPn
                  FSINH.x FPm,FPn
                  FSINH.x FPn

Beschreibung:
Es wird der Sinus Hyperbolicus des  Arguments berechnet und in das 
Zielregister geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-ß,+ß], W = [-ß,+ß]

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FSQRT") )
FSQRT - Quadratwurzel                                 MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FSQRT.f <ea>,FPn
                  FSQRT.X FPm,FPn
                  FSQRT.X FPm

Beschreibung:
Es wird die Quadratwurzel des Arguments berechnet und in das Ziel-
register geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [0,+ß], W = [0,+ß]

Querverweis: \#FDSQRT\#, \#FSSQRT\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FSSQRT"),
		sensitive("FDSQRT") )
FDSQRT - Quadratwurzel                                         MC68040
FSSORT
----------------------------------------------------------------------

Assembler Syntax: FDSQRT.f <ea>,FPn
                  FDSQRT.X FPm,FPn
                  FDSQRT.X FPm
                  FSSQRT.f <ea>,FPn
                  FSSQRT.X FPm,FPn
                  FSSQRT.X FPm

Beschreibung:
Es wird die Quadratwurzel des Arguments berechnet und in das Ziel-
register geschrieben. FSSQRT berechnet die Quadratwurzel mit ein-
facher und FDSQRT mit doppelter Genauigkeit.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [0,+ß], W = [0,+ß]

Querverweis: \#FSQRT\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FSUB") )
FSUB - Substraktion                                   MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FSUB.f <ea>,FPn
                  FSUB.X FPm,FPn

Beschreibung:
Es wird die Differenz des Zieloperanden minus Ouelloperanden aus-
gefhrt und das Ergebnis in das Zielregister geschrieben. 

Querverweis: \#FADD\#, \#FDSUB\#, \#FSSUB\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FDSUB"),
		sensitive("FSSUB") )
FDSUB - Substraktion                                           MC68040
FSSUB
----------------------------------------------------------------------

Assembler Syntax: FDSUB.f <ea>,FPn
                  FDSUB.X FPm,FPn
                  FSSUB.f <ea>,FPn
                  FSSUB.X FPm,FPn

Beschreibung:
Es wird die Differenz des Zieloperanden minus Ouelloperanden aus-
gefhrt und das Ergebnis in das Zielregister geschrieben. FSSUB
berechnet das Ergebnis mit einfacher Genauigkeit, FDSUB mit
doppelter.

Querverweis: \#FSUB\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FTAN") )
TAN - Tangens                                                  MC68881
----------------------------------------------------------------------

Assembler Syntax: FTAN.f <ea>,FPn
                  FTAN.x FPm,FPn
                  FTAN.x FPn

Beschreibung:
Es wird der Tangens des Arguments berechnet und in das Zielregister 
geschrieben.  Je gr”er der  Absolutwert des  Arguments ist,  desto 
gr”er ist die Ungenauigkeit des Ergebnisses.

\#Definitionsmenge\# und \#Wertemenge\#:

D = ]-ß,+ß[, W=[-ß,+ß] (Hinweis: D sollte [-2ã,+2ã] sein.)  

Umkehrfunktion: \#FATAN\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FTANH") )
FTANH - Tangens Hyperbolicus                                   MC68881
----------------------------------------------------------------------

Assembler Syntax: FTANH.f <ea>,FPn
                  FTANH.x FPm,FPn
                  FTANH.x FPn

Beschreibung:
Es wird der Tangens Hyperbolicus des Arguments berechnet und in das 
Zielregister geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-ß,+ß], W = [-1.0,+1.0]

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FTENTOX") )
FTENTOX - Zehnerpotenz                                         MC68881
----------------------------------------------------------------------

Assembler Syntax: FTENTOX.f <ea>,FPn
                  FTENTOX.x FPm,FPn
                  FTENTOX.x FPm

Beschreibung:
Es wird die Zehnerpotenz (10^x) des Arguments berechnet und in das Ziel-
register geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-ß,+ß], W = [0,+ß]

Umkehrfunktion: \#FLOG10\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( "FTRAPcc",
		sensitive("FTRAPOR"),
		sensitive("FTRAPOLT"),
		sensitive("FTRAPNGLE"),
		sensitive("FTRAPUN"),
		sensitive("FTRAPULT"),
		sensitive("FTRAPULE"),
		sensitive("FTRAPUGT"),
		sensitive("FTRAPUGE"),
		sensitive("FTRAPUEQ"),
		sensitive("FTRAPT"),
		sensitive("FTRAPST"),
		sensitive("FTRAPSNE"),
		sensitive("FTRAPSF"),
		sensitive("FTRAPEQ"),
		sensitive("FTRAPF"),
		sensitive("FTRAPGE"),
		sensitive("FTRAPGL"),
		sensitive("FTRAPGLE"),
		sensitive("FTRAPGT"),
		sensitive("FTRAPLE"),
		sensitive("FTRAPLT"),
		sensitive("FTRAPNE"),
		sensitive("FTRAPNGE"),
		sensitive("FTRAPNGL"),
		sensitive("FTRAPSEQ"),
		sensitive("FTRAPNGT"),
		sensitive("FTRAPNLE"),
		sensitive("FTRAPNLT"),
		sensitive("FTRAPOGE"),
		sensitive("FTRAPOGL"),
		sensitive("FTRAPOLE"),
		sensitive("FTRAPOGT") )
FTRAPcc - Trap bei Bedingung                          MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FTRAP\link("Condition Codes, CPU")cc\#
                  FTRAP\link("Condition Codes, CPU")cc\#.W #<data>
                  FTRAP\link("Condition Codes, CPU")cc\#.L #<data>

Beschreibung:
Wenn die spezifizierte Bedingung erfllt ist, wird die Behandlung
der \#Exception\# mit Vektor Nummer 7 eingeleitet. Wird die Bedingung
nicht   erfllt,   wird  der  auf  den  FTRAPcc  folgende  Befehl
abgearbeitet.

Das dem Befehl folgende Wort oder Langwort wird von der CPU ber-
gangen und kann vom Trap-Handler ausgewertet werden.

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FTST") )
FTST - Prfe Inhalt des Operanden                     MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FTST.f <ea>
                  FTST.X FPm

Beschreibung:
Testet einen Operanden und setzt die entsprechenden Flags im
Condition Code Register der FPU.

Gruppe: \#Fliekomma-Befehle\#
\end

screen( sensitive("FTWOTOX") )
FTWOTOX - Zweierpotenz                                         MC68881
----------------------------------------------------------------------

Assembler Syntax: FTWOTOX.f <ea>,FPn
                  FTWOTOX.x FPm,FPn
                  FTWOTOX.x FPm

Beschreibung:
Es wird die Zweierpotenz (2^x) des Arguments berechnet und in das Ziel-
register geschrieben.

\#Definitionsmenge\# und \#Wertemenge\#:

D = [-ß,+ß], W = [0,+ß]

Umkehrfunktion: \#FLOG2\#

Gruppe: \#Fliekomma-Befehle\#
\end

screen( "PBcc",
		sensitive("PBAC"),
		sensitive("PBLS"),
		sensitive("PBWC"),
		sensitive("PBLC"),
		sensitive("PBWS"),
		sensitive("PBIS"),
		sensitive("PBSS"),
		sensitive("PBIC"),
		sensitive("PBSC"),
		sensitive("PBGS"),
		sensitive("PBGC"),
		sensitive("PBCS"),
		sensitive("PBCC"),
		sensitive("PBBS"),
		sensitive("PBAS"),
		sensitive("PBBC") )
PBcc - Bedingte Verzweigung                                    MC68851
----------------------------------------------------------------------

Assembler Syntax: PB\link("Condition Codes, CPU")cc\# <label>

Beschreibung:
Falls die Bedingung ( \link("Condition Codes, CPU")cc\# ) erfllt ist wird das Programm an der
Adresse weitegefhrt, fr die label steht.

Gr”e: Word, Long

Hinweis: Der Assembler verwendet automatisch den krzeren Befehl, wenn die
Adredistanz zwischen -32768 und +32767 liegt.

Gruppe: \#PMMU-Befehle\#
\end

screen( "PDBcc",
		sensitive("PDBGC"),
		sensitive("PDBBS"),
		sensitive("PDBIC"),
		sensitive("PDBIS"),
		sensitive("PDBGS"),
		sensitive("PDBLC"),
		sensitive("PDBLS"),
		sensitive("PDBSC"),
		sensitive("PDBSS"),
		sensitive("PDBAC"),
		sensitive("PDBAS"),
		sensitive("PDBCS"),
		sensitive("PDBWC"),
		sensitive("PDBBC"),
		sensitive("PDBCC"),
		sensitive("PDBWS") )
PDBcc - Prfe Bedingung, dekrementiere und verzweige           MC68851
----------------------------------------------------------------------

Assembler Syntax: PDB\link("Condition Codes, CPU")cc\# Dn,<label>

Beschreibung:
Diese Befehl erm”glich es eine einfache Schleife zu programmieren.
Zuerst  wird die  ber  \link("Condition Codes, CPU")cc\#  spezifizierte  Bedingung  geprft um
festzustellen ob die Abbruchsbedingung  fr  die Schleife erreicht
ist. Wenn dies der Fall ist wird keine weitere Aktion vorgenommen.
Wenn die Abbruchsbedingung nicht erfllt ist,  werden  die unteren
16 Bit ( Achtung: Word ) um 1  ( Eins )  dekrementiert.  Wenn  das
Ergebnis -1 (Achtung: Minus Eins) ist, wird die Schleife  beendet.
Andernfalls  wird  auf  die durch label spezifizierte Adresse ver-
zweigt.

Gr”e: Word, Long

Hinweis: Der Assembler verwendet automatisch den krzeren Befehl, wenn die
Adredistanz zwischen -32768 und +32767 liegt.

Gruppe: \#PMMU-Befehle\#
\end

screen( sensitive("PFLUSH.N"),
		sensitive("PFLUSHA.N"),
		sensitive("PFLUSHA"),
		sensitive("PFLUSH"),
		sensitive("PFLUSHS") )
PFLUSH - L”sche Address Translation Cache              MC68030/MC68851
----------------------------------------------------------------------

Assembler Syntax: PFLUSHA
                  PFLUSHA.N                        ( nur MC68040 )
                  PFLUSH   <fc>, #<mask>
                  PFLUSH   <fc>, #<mask>, <ea>
                  PFLUSH.N (An)                    ( nur MC68040 )
                  PFLUSHS  <fc>, #<mask>           ( nur MC68851 )
                  PFLUSHS  <fc>, #<mask>, <ea>     ( nur MC68851 )

Beschreibung:
L”scht alle (PFLUSHA), nicht globale (PFLUSH.N, PFLUSHA.N) oder
bestimmte (PFLUSH, PFLUSHS) Eintr„ge im Address Translation
Cache ( \#ATC\# ). 

<fc>    bezeichnet den \#Function Code\#.
<mask>  beschreibt die Bits,  welche im <fc>-Parameter bercksich-
        tigt werden sollen.
<ea>    Ist  die logische Adresse,  fr die die  Eintr„ge gel”scht
        werden sollen.

Die MC68851-PMMU l”scht nur Eintr„ge, bei denen das \#Shared Globaly\#
Flag NICHT gesetzt ist. Hierzu ist PFLUSHS notwendig.

Gruppe: \#PMMU-Befehle\#
\end

screen( "PLOAD",
		sensitive("PLOADR"),
		sensitive("PLOADW") )
PLOAD - Lade Address Translation Cache                 MC68030/MC68851
----------------------------------------------------------------------

Assembler Syntax: PLOADR  <fc>, <ea>
                  PLOADW  <fc>, <ea>

Beschreibung:
Durchsucht die šbersetzungstabelle, nach einen Eintrag fr die ange-
gebene Adresse ( <ea> )  und den \#Function Code\# ( <fc> ).  Konnte die
zugeh”rige physikalische Adresse ermittelt werden,  wird ein Eintrag
im Address Translation Cache ( \#ATC\# ) angelegt. PLOADR setzt dann das
Used-Bit. PLOADW setzt zus„tlich das Modified-Bit.

Ist der  \#MC68851\#-PMMU ausgeschaltet,  so wird eine \#Exception\# mit der
Nummer 57 ausgel”st. ( \#PMMU-Illegale Operation\# )

Querverweis: \#PFLUSH\#

Gruppe: \#PMMU-Befehle\#
\end

screen( sensitive("PMOVEFD"),
		sensitive("PMOVE") )
PMOVE - šbertrage Daten in/aus einem PMMU-Register     MC68030/MC68851
----------------------------------------------------------------------

Assembler Syntax: PMOVE   <PMMU Register>, <ea>
                  PMOVE   <ea>, <PMMU Register>
                  PMOVEFD <ea>, <PMMU Register>  ( MC68030 )

Beschreibung:
Der Inhalt eines \#PMMU-Kontrollregister\#s wird von oder nach einer 
effektiven  Adresse  geschrieben.  Dabei ist  zu  beachten,  da 
nicht  definierte Bit  beim Lesen  aus einem Register  0 ergeben
und beim Schreiben in ein Register 0 sein sollten, um kompatibel
mit zuknftigen Versionen zu sein. PMOVEFD bewirkt,  da das \#ATC\#
NICHT gel”scht wird ( flush disable ).
                  
Gruppe: \#PMMU-Befehle\#
\end

screen( sensitive("PRESTORE") )
PRESTORE - Wiederherstellung des Prozessorzustandes            MC68851
----------------------------------------------------------------------

Assembler Syntax: PRESTORE <ea>

Beschreibung:
Dieser Befehl stellt den Zustand der PMMU wieder her, der vorher mit
\#PSAVE\# gerettet wurde:

***Achtung***:
Erh„lt  eines der  \#Root Pointer\# Register  durch diesen  Befehl einen
ungltigen  \#Descriptor Type\#,  so ist das weitere  Verhalten der PMMU 
undefiniert.

Querverweis: \#PSAVE\#

Gruppe: \#PMMU-Befehle\#
\end

screen( sensitive("PSAVE") )
PSAVE - Retten des Prozessorzustandes                          MC68851
----------------------------------------------------------------------

Assembler Syntax: PSAVE <ea>

Beschreibung:
Dieser Befehl dient dazu, den aktuellen Zustand der PMMU zu retten, 
um  ihn  sp„ter  mit  \#PRESTORE\#  wiederherstellen  zu  k”nnen.  <ea> 
spezifiziert den Speicherbereich,  wo der  Zustand abgelegt  werden 
soll. Der Speicherbereich mu folgende Daten aufnehmen k”nnen:

     Zustand  | Anzahl der Bytes       
    ----------+-------------------
     NULL     | 36 Bytes
     IDLE     | 44 Bytes
     BUSY     | 76 Bytes

Querverweis: \#PRESTORE\#

Gruppe: \#PMMU-Befehle\#
\end

screen( "PScc",
		sensitive("PSBS"),
		sensitive("PSSS"),
		sensitive("PSSC"),
		sensitive("PSCS"),
		sensitive("PSAS"),
		sensitive("PSLS"),
		sensitive("PSWC"),
		sensitive("PSLC"),
		sensitive("PSWS"),
		sensitive("PSIS"),
		sensitive("PSCC"),
		sensitive("PSIC"),
		sensitive("PSAC"),
		sensitive("PSGS"),
		sensitive("PSGC"),
		sensitive("PSBC") )
PScc - Setze ein Byte in Anh„ngigkeit von einer Bedingung      MC68851
----------------------------------------------------------------------

Assembler Syntax: PS\link("Condition Codes, CPU")cc\# <ea>

Beschreibung:
Setzt ein Byte in Abh„ngigkeit vom Zustand der jeweiligen Flags
des Condition Code der PMMU.

Gruppe: \#PMMU-Befehle\#
\end

screen( "PTEST",
		sensitive("PTESTR"),
		sensitive("PTESTW") )
PTEST - Prfe logische Adresse                         MC68030/MC68851
----------------------------------------------------------------------

Assembler Syntax: PTESTR <fc>,<ea>,#<level>
                  PTESTR <fc>,<ea>,#<level>, An
                  PTESTW <fc>,<ea>,#<level>
                  PTESTW <fc>,<ea>,#<level>, An

Beschreibung:
PTEST prft eine logische Adresse spezifiziert durch \#Function Code\#
( <fc> ) und <ea> auf einen Eintrag in der \#šbersetzungstabelle\# bis
zur Suchtiefe <level>.  Das  Ergebnis dieser Prfung wird im PMMU-
Statusregister ( \#PSR\# ) abgelegt. PTESTR setzt die Flags im PSR fr
einen Lesezugriff, PTESTW entsprechend einen Schreibzugriff.  Wird
noch ein Adreregister angegeben, so wird die Adresse des letzten
untersuchten \#Descriptor\#s in diesem Register angelegt.

Eine Suchtiefe  von 0 bedeutet,  da nur das  Address  Translation
Cache ( \#ATC\# ) und beim \#MC68030\# bzw. \#MC68040\# auch die beiden Trans-
parent Translation  Register ( \link("Transparent Translation")TTn\# ) durchsucht werden. Eine Such-
tiefe ungleich 0 durchsucht nur die \#šbersetzungstabelle\#.

Ist der \#MC68851\#-PMMU ausgeschaltet, so wird eine \#Exception\# mit der
Nummer 57 ausgel”st. ( \#PMMU-Illegale Operation\# )

Dieser  Befehl  ist z.B.  sinnvoll,  falls eine  \#Busfehler\#-Routine
feststellen soll, ob der Busfehler durch einen ungltigen Descrip-
tor verursacht wurde.

Gruppe: \#PMMU-Befehle\#
\end

screen( "PTRAPcc",
		sensitive("PTRAPWS"),
		sensitive("PTRAPBS"),
		sensitive("PTRAPBC"),
		sensitive("PTRAPCC"),
		sensitive("PTRAPGS"),
		sensitive("PTRAPAS"),
		sensitive("PTRAPCS"),
		sensitive("PTRAPSS"),
		sensitive("PTRAPLS"),
		sensitive("PTRAPGC"),
		sensitive("PTRAPAC"),
		sensitive("PTRAPIC"),
		sensitive("PTRAPWC"),
		sensitive("PTRAPLC"),
		sensitive("PTRAPSC"),
		sensitive("PTRAPIS") )
PTRAPcc - Trap bei Bedingung                                   MC68851
----------------------------------------------------------------------

Assembler Syntax: PTRAP\link("Condition Codes, CPU")cc\#
                  PTRAP\link("Condition Codes, CPU")cc\#.W #<data>
                  PTRAP\link("Condition Codes, CPU")cc\#.L #<data>

Beschreibung:
Wenn die spezifizierte Bedingung erfllt ist, wird die Behandlung
der \#Exception\# mit Vektor Nummer 7 eingeleitet. Wird die Bedingung
nicht   erfllt,   wird  der  auf  den  PTRAPcc  folgende  Befehl
abgearbeitet.

Das dem Befehl folgende Wort oder Langwort wird von der CPU ber-
gangen und kann vom Trap-Handler ausgewertet werden.

Gruppe: \#PMMU-Befehle\#
\end

screen( sensitive("PVALID") )
PVALID - Prfe Zeiger                            MC68851, privilegiert
----------------------------------------------------------------------

Assembler Syntax: PVALID VAL,<ea>
                  PVALID An,<ea>

Beschreibung:
PVALID vergleicht die oberen Bits des Quelloperanden mit den oberen
Bits des Zieloperanden. Die Anzahl der zu vergleichenden Bits ist
im ALC-Feld des \#AC\#-Registers festgelegt. Wenn die oberen Bits
des Quelloperanden einen numerische gr”eren Wert enthalten als
die des Zieloperanden, d.h. weniger privilegiert sind, wird eine
MMU Access Level Exception ausgel”st. Andernfalls wird die Programm-
ausfhrung fortgesetzt.
Der Inhalt des Statusregisters \#PSR\# bleibt unver„ndert.

Gruppe: \#PMMU-Befehle\#
\end
