

screen( "Copyright" )
LIB.HLP wurde bersetzt am 20.M„rz 1993.

(c) 1990 Borland International, Inc.
\end

screen( "Index" )
Index der verfgbaren Schlsselw”rter:

     \#A..\#       \#B..\#       \#C..\#      \#D..\#

     \#E..\#       \#F..\#       \#G..\#      \#H..\#

     \#I..\#       \#J..\#       \#K..\#      \#L..\#

     \#M..\#       \#N..\#       \#O..\#      \#P..\#

     \#Q..\#       \#R..\#       \#S..\#      \#T..\#

     \#U..\#       \#V..\#       \#W..\#      \#X..\#

     \#Y..\#       \#Z..\#

     \#Sonstiges\#
\end

screen( capsensitive("OBJECT"),
		capsensitive("ob_height"),
		capsensitive("ob_next"),
		capsensitive("ob_spec"),
		capsensitive("ob_state"),
		capsensitive("ob_tail"),
		capsensitive("ob_head"),
		capsensitive("ob_type"),
		capsensitive("ob_width"),
		capsensitive("ob_x"),
		capsensitive("ob_flags"),
		capsensitive("ob_y") )
Die Objektstruktur:
===================

OBJECT ist in AES.H wie folgt definiert:

typedef struct
{
        int             ob_next;   /* das n„chste Objekt            */
        int             ob_head;   /* erstes Kind                   */
        int             ob_tail;   /* letztes Kind                  */
        unsigned int    ob_type;   /* \#Objektart\#                     */
        unsigned int    ob_flags;  /* \#Manipulationsflags\#            */
        unsigned int    ob_state;  /* \#Objektstatus\#                  */
        \#OBSPEC\#          ob_spec;   /* mehr unter \#Objektart\#          */
        int             ob_x;      /* x-Koordinate des Objekts      */
        int             ob_y;      /* y-Koordinate des Objekts      */
        int             ob_width;  /* Breite des Objekts            */
        int             ob_height; /* H”he des Objekts              */
} OBJECT;
\end

screen( capsensitive("te_thickness"),
		capsensitive("TEDINFO"),
		capsensitive("te_txtlen"),
		capsensitive("te_tmplen"),
		capsensitive("te_color"),
		capsensitive("te_font"),
		capsensitive("te_junk1"),
		capsensitive("te_junk2"),
		capsensitive("te_just"),
		capsensitive("te_ptext"),
		capsensitive("te_pvalid"),
		capsensitive("te_ptmplt") )
Die Tedinfostruktur:
====================

Die TEDINFO-Struktur ist wie die Objektstruktur eine C-Datenstruktur,
die benutzt wird, um ein Textobjekt n„her zu beschreiben.

Hier die C-Deklaration in AES.H:

typedef struct
{
    char    *te_ptext;         /* Zeiger auf einen String          */
    char    *te_ptmplt;        /* Zeiger auf die Stringmaske       */
    char    *te_pvalid;        /* Zeiger auf den Gltigkeitsstring */
    int     te_font;           /* Zeichensatz                      */
    int     te_junk1;
    int     te_just;           /* Justierung des Texts             */
    int     te_color;          /* Farbe                            */
    int     te_junk2;
    int     te_thickness;      /* Rahmenbreite                     */
    int     te_txtlen;         /* Maximale L„nge des Textes        */
    int     te_tmplen;         /* L„nge der Stringmaske            */
} TEDINFO;

Querverweis: \#OBJECT\#
\end

screen( capsensitive("bi_pdata"),
		capsensitive("bi_wb"),
		capsensitive("bi_x"),
		capsensitive("BITBLK"),
		capsensitive("bi_y"),
		capsensitive("bi_color"),
		capsensitive("bi_hl") )
Die Bitblkstruktur:
===================

Die BITBLK-Struktur ist wie die Objektstruktur eine C-Datenstruktur,
die benutzt wird, um ein Bildobjekt n„her zu beschreiben.

Hier die C-Deklaration in AES.H:

typedef struct
{
        int     *bi_pdata;         /* Zeiger auf die Grafikdaten    */
        int     bi_wb;             /* Breite des Bildes in Bytes    */
        int     bi_hl;             /* H”he in Linien                */
        int     bi_x;              /* x-Position                    */
        int     bi_y;              /* y-Position                    */
        int     bi_color;          /* Vordergrundfarbe              */
} BITBLK;

Querverweis: \#OBJECT\#
\end

screen( capsensitive("ib_pdata"),
		capsensitive("ib_wtext"),
		capsensitive("ib_wicon"),
		capsensitive("ib_ptext"),
		capsensitive("ib_pmask"),
		capsensitive("ib_xicon"),
		capsensitive("ib_xtext"),
		capsensitive("ib_char"),
		capsensitive("ib_ychar"),
		capsensitive("ICONBLK"),
		capsensitive("ib_hicon"),
		capsensitive("ib_xchar"),
		capsensitive("ib_yicon"),
		capsensitive("ib_ytext"),
		capsensitive("ib_htext") )
Die Iconblkstruktur:
====================

Die ICONBLK-Struktur ist wie die Objektstruktur eine C-Datenstruktur,
die benutzt wird, um ein Icon n„her zu beschreiben.

Hier die C-Deklaration in AES.H:

typedef struct
{
        int     *ib_pmask;         /* Zeiger auf die Maske          */
        int     *ib_pdata;         /* Zeiger auf das Icon-Bild      */
        char    *ib_ptext;         /* Zeiger auf einen String       */
        int     ib_char;           /* In den unteren 8 Bit das dar- */
                                   /* zustellende Zeichen, in den   */
                                   /* oberen 8 Bit die Farbe des    */
                                   /* gesetzten (obere 4 Bit) und   */
                                   /* des gel”schten (untere 8 Bit) */
                                   /* Bits des Bitmuster IB_PDATA   */
        int     ib_xchar;          /* x-Koordinate des Buchstabens  */
        int     ib_ychar;          /* y-Koordinate des Buchstabens  */
        int     ib_xicon;          /* x-Koordinate des Icons        */
        int     ib_yicon;          /* y-Koordinate des Icons        */
        int     ib_wicon;          /* Breite des Icons              */
        int     ib_hicon;          /* H”he des Icons                */
        int     ib_xtext;          /* x-Koordinate des Textes       */
        int     ib_ytext;          /* y-Koordinate des Textes       */
        int     ib_wtext;          /* Breite des Textes             */
        int     ib_htext;          /* H”he des Textes               */
} ICONBLK;

Querverweis: \#OBJECT\#
\end

screen( capsensitive("ub_code"),
		capsensitive("USERBLK"),
		capsensitive("ub_parm") )
Die Userblockstruktur:
======================

Die USERBLK-Struktur ist eine C-Datenstruktur, die benutzerdefinierte
Objekte n„her kennzeichnet.

C-Deklaration in AES.H:

typedef struct
{
        int \link("%%GLOBAL%%")cdecl\# (*ub_code)(\#PARMBLK\# *parmblock);
                                   /* Zeiger auf eine Funktion */
        long ub_parm;              /* optionaler Parameter     */
} USERBLK;

Dabei wird die Funktion ub_code bei jedem \#objc_draw\# und \#objc_change\#
Aufruf fr das entsprechende Objekt aufgerufen. Dabei wird ein Zeiger
auf eine \#PARMBLK\#-struktur bergeben.

Querverweis: \#OBJECT\#
\end

screen( capsensitive("pb_prevstate"),
		capsensitive("pb_wc"),
		capsensitive("pb_x"),
		capsensitive("PARMBLK"),
		capsensitive("pb_currstate"),
		capsensitive("pb_h"),
		capsensitive("pb_xc"),
		capsensitive("pb_y"),
		capsensitive("pb_yc"),
		capsensitive("pb_w"),
		capsensitive("pb_tree"),
		capsensitive("pb_obj"),
		capsensitive("pb_hc"),
		capsensitive("pb_parm") )
Die Paramblkstruktur:
=====================

Ein Zeiger auf eine PARMBLK-Struktur wird bei einem
benutzerdefinierten Objekten bei jedem \#objc_draw\# und
\#objc_change\# Aufruf als Parameter bergeben.

C-Deklaration in AES.H:

typedef struct
{
        \#OBJECT\#  *pb_tree;          /* Zeiger auf den Objektbaum     */
        int     pb_obj;            /* Nummer des Objekts            */
        int     pb_prevstate;      /* vorheriger Objektstatus       */
        int     pb_currstate;      /* neuer Objektstatus            */
        int     pb_x, pb_y, pb_w, pb_h;      /* Objektkoordinaten   */
        int     pb_xc, pb_yc, pb_wc, pb_hc;  /* Clipping-Koordinate */
        long    pb_parm;           /* der optionale Parameter aus der*/
} PARMBLK;                         /* \#USERBLK\#-struktur               */

Die Clipping-Koordinaten sind die, bei einem \#objc_draw\# und
\#objc_change\# Aufruf als Parameter bergebenen Koordinaten.
\end

screen( capsensitive("mf_yhot"),
		capsensitive("mf_data"),
		capsensitive("mf_bg"),
		capsensitive("MFORM"),
		capsensitive("mf_fg"),
		capsensitive("mf_mask"),
		capsensitive("mf_xhot"),
		capsensitive("mf_nplanes") )
Die Struktur MFORM legt das Aussehen des Mauszeigers fest.

typedef struct mfstr
{
    int  mf_xhot;
    int  mf_yhot;
    int  mf_nplanes;
    int  mf_fg;
    int  mf_bg;
    int  mf_mask[16];
    int  mf_data[16];
} MFORM;

Querverweis    \#graf_mouse\#
\end

screen( capsensitive("MFDB") )
Der Memory Form Definition Block ist eine Datenstruktur, die vom
VDI fr die Rasteroperationen benutzt wird, um die Ziel- und
Quellspeicherbereiche zu beschreiben.

C-Deklaration in VDI.H:

typedef struct mfdb
{
        void *fd_addr;               /* Zeiger auf den Beginn des*/
                                     /* Speicherbereichs, z. B.  */
                                     /* Bildspeicherbasisadresse */
        int  fd_w;                   /* Blockbreite in Pixeln    */
        int  fd_h;                   /* H”he des Blocks in Pixeln*/
        int  fd_wdwidth;             /* Blockbreite in Integern  */
        int  fd_stand;               /* 0 = ger„teabh„ngiges Format
                                        1 = Standardformat       */
        int  fd_nplanes;             /* Anzahl der Farbebenen    */
        int  fd_r1, fd_r2, fd_r3;    /* reserviert               */
} MFDB;

Querverweis: \#vro_cpyfm\#, \#vrt_cpyfm\#, \#vr_trnfm\#
\end

screen( capsensitive("global"),
		capsensitive("intout"),
		capsensitive("ptsout"),
		capsensitive("intin"),
		capsensitive("addrout"),
		capsensitive("contrl"),
		capsensitive("ptsin"),
		capsensitive("_GemParBlk"),
		capsensitive("addrin"),
		capsensitive("GEMPARBLK") )
Name            Gemparameterblockpointer

Deklaration:    extern  GEMPARBLK _GemParBlk;
Deklaration in  aes.h

Beschreibung:   Zeigt auf den Gemparameterblock der Applikation. šber
                diese Struktur werden dem GEM die Parameter bergeben.
                Sie mssen also nicht, die Arrays selbst definieren.
                Der Gemparameterblock hat folgende Struktur:

typedef struct
{
    int    contrl[15];
    int    global[80];
    int    intin[128];
    int    intout[45];
    int    ptsout[128];
    void   *addrin[128];
    void   *addrout[6];
    int    ptsin[128];
} GEMPARBLK;
\end

screen( capsensitive("MOBLK") )
MOBLK ist in aes.h wie folgt definiert:

typedef struct
{
        int             m_out;
        int             m_x;
        int             m_y;
        int             m_w;
        int             m_h;
} MOBLK;
\end

screen( capsensitive("ORECT") )
ORECT ist in aes.h wie folgt definiert:

typedef struct orect
{
        struct  orect   *o_link;
        int     o_x;
        int     o_y;
        int     o_w;
        int     o_h;
} ORECT;
\end

screen( capsensitive("GRECT"),
		capsensitive("g_h"),
		capsensitive("g_w"),
		capsensitive("g_y"),
		capsensitive("g_x") )
GRECT ist in aes.h wie folgt definiert:

typedef struct
{
        int     g_x;    /* x, obere linke Ecke des Rechtecks */
        int     g_y;    /* y, obere linke Ecke des Rechtecks */
        int     g_w;    /* Breite des Rechtecks              */
        int     g_h;    /* H”he des Rechtecks                */
} GRECT;
\end

screen( capsensitive("framecol"),
		capsensitive("fillpattern"),
		capsensitive("bfobspec"),
		capsensitive("character"),
		capsensitive("textcol"),
		capsensitive("textmode"),
		capsensitive("interiorcol"),
		capsensitive("framesize") )
bfobspec ist in aes.h wie folgt definiert:

typedef struct
{
    unsigned character   :    8;
    signed   framesize   :    8;
    unsigned framecol    :    4;
    unsigned textcol     :    4;
    unsigned textmode    :    1;
    unsigned fillpattern :    3;
    unsigned interiorcol :    4;
} bfobspec;

Querverweis: \#OBSPEC\#
\end

screen( capsensitive("userblk"),
		capsensitive("free_string"),
		capsensitive("index"),
		capsensitive("indirect"),
		capsensitive("OBSPEC"),
		capsensitive("iconblk"),
		capsensitive("bitblk"),
		capsensitive("tedinfo"),
		capsensitive("obspec") )
Da ob_spec je nach Typ des Objekts verschiede Bedeutungen und Datentypen
haben kann, erhielt es den TYP OBSPEC.

OBSPEC ist in aes.h wie folgt definiert:

typedef \link("%%GLOBAL%%")union\# obspecptr
{
    long     index;                 /* fr das RSC-C-output */
    union obspecptr *indirect;      /* Zeiger uaf ob_spec   */
    \#bfobspec\# obspec;                /* Bitfield             */
    \#TEDINFO\#  *tedinfo;              /* Zeiger auf TEDINFO   */
    \#ICONBLK\#  *iconblk;              /* Zeiger auf ICONBLK   */
    \#BITBLK\#   *bitblk;               /* Zeiger auf BITBLK    */
    \#USERBLK\#  *userblk;              /* Zeiger auf USERBLK   */
    char     *free_string;          /* zeiger auf String    */
} OBSPEC;

Wollen Sie zum Beispiel auf ob_spec als zeiger auf eine TEDINFO-struktur
zugreifen, so muten Sie bisher ob_spec zum gewnschten Typ casten:

(\#TEDINFO\# *) objectAdr[index].\#ob_spec\#->\#te_ptext\#;
    |        |        |
casting      |        |
             |        |
Baumaddresse mit      |
\#rsrc_gaddr\# ermittelt  |
                      |
index vom RCS---------+       

Dies ist nun nicht mehr notwendig. Schreiben Sie nun einfach:

objectAdr[index].ob_spec.tedinfo->te_ptext;

Querverweis: \#OBJECT\#
\end

screen( capsensitive("RSHDR") )
RSHDR ist in aes.h wie folgt definiert:

typedef struct rshdr
{
        unsigned     rsh_vrsn;
        unsigned     rsh_object;
        unsigned     rsh_tedinfo;
        unsigned     rsh_iconblk;    /* list of ICONBLKS */
        unsigned     rsh_bitblk;
        unsigned     rsh_frstr;
        unsigned     rsh_string;
        unsigned     rsh_imdata;     /* image data */
        unsigned     rsh_frimg;
        unsigned     rsh_trindex;
        unsigned     rsh_nobs;       /* counts of various structs */
        unsigned     rsh_ntree;
        unsigned     rsh_nted;
        unsigned     rsh_nib;
        unsigned     rsh_nbb;
        unsigned     rsh_nstring;
        unsigned     rsh_nimages;
        unsigned     rsh_rssize;     /* total bytes in resource */
} RSHDR;

Mit dieser Structur wird der Header eines Resourcefiles beschrieben.
\end

screen( capsensitive("ffblk"),
		capsensitive("ff_name"),
		capsensitive("ff_ftime"),
		capsensitive("ff_fsize"),
		capsensitive("ff_attrib"),
		capsensitive("ff_fdate") )
ffblk ist in ext.h wie folgt definiert:

struct ffblk
{
    char ff_reserved[21];               /* Reserved by TOS */
    char ff_attrib;                     /* Attribute found */
    int  ff_ftime;                      /* File time */
    int  ff_fdate;                      /* File date */
    long ff_fsize;                      /* File size */
    char ff_name[13];                   /* File name found */
};

Querverweis: \#findfirst\#, \#findnext\#
\end

screen( capsensitive("date"),
		capsensitive("da_day"),
		capsensitive("da_mon"),
		capsensitive("da_year") )
date ist in ext.h wie folgt definiert:

struct date
{
    int    da_year;                     /* Current year */
    char   da_day;                      /* Day of the month */
    char   da_mon;                      /* Month ( 1 = Jan ) */
};

Querverweis: \#getdate\#, \#setdate\#
\end

screen( "time, struct time",
		capsensitive("ti_sec"),
		capsensitive("ti_hour"),
		capsensitive("ti_hund"),
		capsensitive("ti_min") )
time ist in ext.h wie folgt definiert:

struct time
{
    unsigned char   ti_min;             /* Minutes */
    unsigned char   ti_hour;            /* Hours */
    unsigned char   ti_hund;            /* Hundredths of seconds */
    unsigned char   ti_sec;             /* Seconds */
};

Querverweis: \#gettime\#, \#settime\#
\end

screen( capsensitive("df_sclus"),
		capsensitive("df_avail"),
		capsensitive("df_bsec"),
		capsensitive("df_total"),
		capsensitive("dfree") )
dfree ist in ext.h wie folgt definiert:

struct dfree
{
        unsigned df_avail;
        unsigned df_total;
        unsigned df_bsec;
        unsigned df_sclus;
};

Querverweis: \#getdfree\#
\end

screen( capsensitive("ft_min"),
		capsensitive("ft_day"),
		capsensitive("ft_hour"),
		capsensitive("ftime"),
		capsensitive("ft_year"),
		capsensitive("ft_month"),
		capsensitive("ft_tsec") )
ftime ist in ext.h wie folgt definiert:

struct ftime
{
    unsigned ft_tsec:   5;
    unsigned ft_min:    6;
    unsigned ft_hour:   5;
    unsigned ft_year:   7;
    unsigned ft_month:  4;
    unsigned ft_day:    5;
};

Querverweis: \#getftime\#, \#setftime\#
\end

screen( capsensitive("st_dev"),
		capsensitive("st_mode"),
		capsensitive("st_ctime"),
		capsensitive("st_atime"),
		capsensitive("st_size"),
		capsensitive("st_ino"),
		capsensitive("st_rdev"),
		capsensitive("st_gid"),
		capsensitive("st_uid"),
		capsensitive("stat, struct stat"),
		capsensitive("st_mtime"),
		capsensitive("st_nlink") )
stat ist in ext.h wie folgt definiert:

struct stat
{
    int    st_dev;           /* Laufwerk, das die Datei enth„lt    */
    int    st_ino;
    int    st_mode;          /* Bit-Maske mit \link("findfirst")Dateiattributen\#      */
    int    st_nlink;         /* immer 1                            */
    int    st_uid;
    int    st_gid;
    int    st_rdev;          /* wie st_dev                         */
    size_t st_size;          /* Dateigr”e in Bytes                */
    long   st_atime;         /* Zeit der letzten Datei„nderung     */
    long   st_mtime;         /* wie st_atime                       */
    long   st_ctime;         /* wie st_atime                       */
};

Querverweis: \#stat\#, \#fstat\#
\end

screen( capsensitive("exception"),
		capsensitive("arg1"),
		capsensitive("name"),
		capsensitive("type"),
		capsensitive("arg2"),
		capsensitive("retval") )
exception ist in math.h wie folgt definiert:

struct exception
{
    mexcep      type;   /* Fehlerart ist in math.h definiert.       */
    char        *name;  /* name ist ein Zeiger auf einen nulltermi- */
                        /* nierten String der den Namen der fehler- */
                        /* ausl”senden Funktion enth„lt.            */
    double      arg1;   /* arg1 und arg2 enthalten die Werte der    */
                        /* Argumente, die der Funktion bergeben    */
    double      arg2;   /* wurden.                                  */
    double      retval; /* retval enh„lt das fehlerhafte Ergebnis.  */
};

Querverweis   \#setmatherr\#
\end

screen( capsensitive("size_t") )
size_t ist in mehreren Headerfiles wie folgt definiert:

typedef unsigned long   size_t;
\end

screen( capsensitive("clock_t") )
clock_t ist in time.h wie folgt definiert:

typedef long   clock_t;

Querverweis: \#clock\#
\end

screen( capsensitive("CLK_TCK") )
CLK_TCK ist in time.h wie folgt definiert:

\link("%%GLOBAL%%")#define\# CLK_TCK 200

Achtung auf anderen Systemen kann diese Konstante auch eine 
Fliekommazahl sein.

Querverweis: \#clock\#
\end

screen( capsensitive("fpos_t") )
fpos_t ist in stdio.h wie folgt definiert:

typedef unsigned long   fpos_t;

Querverweis: \#fgetpos\#, \#fsetpos\#
\end

screen( capsensitive("ptrdiff_t") )
ptrdiff_t ist in stddef.h wie folgt definiert:

typedef long   ptrdiff_t;

prtdiff ist der Typ einer Differenz zweier Pointer.
\end

screen( capsensitive("time_t") )
time_t ist in time.h wie folgt definiert:

typedef long  time_t;

Querverweis: \#ctime\#, \#gmtime\#, \#localtime\#, \#time\#, \#mktime\#, \#difftime\#
\end

screen( capsensitive("div_t"),
		capsensitive("quot"),
		capsensitive("rem") )
div_t ist in stdlib.h wie folgt definiert:

typedef struct
{
    int    quot; /* Quotient */
    int    rem;  /* Rest */
} div_t;

Querverweis: \#ldiv_t\#
\end

screen( capsensitive("LINE"),
		capsensitive("actuallen"),
		capsensitive("maxlen"),
		capsensitive("buffer") )
LINE ist in tos.h wie folgt definiert:

typedef struct
{
    unsigned char   maxlen;
    unsigned char   actuallen;
    char            buffer[255];
} LINE;

Querverweis: \#Cconrs\#
\end

screen( capsensitive("d_attrib"),
		capsensitive("d_time"),
		capsensitive("d_fname"),
		capsensitive("DTA"),
		capsensitive("d_date"),
		capsensitive("d_length") )
DTA ist in tos.h wie folgt definiert:

typedef struct
{
    char            d_reserved[21];
    unsigned char   d_attrib;
    unsigned int    d_time;
    unsigned int    d_date;
    unsigned long   d_length;
    char            d_fname[14];
} DTA;

Querverweis    \#Fsetdta\#   \#Fgetdta\#
\end

screen( capsensitive("b_secsiz"),
		capsensitive("b_clsiz"),
		capsensitive("b_total"),
		capsensitive("b_free"),
		capsensitive("DISKINFO") )
DISKINFO ist in tos.h wie folgt definiert:

typedef struct
{
    unsigned long   b_free;
    unsigned long   b_total;
    unsigned long   b_secsiz;
    unsigned long   b_clsiz;
} DISKINFO;

Querverweis    \#Dfree\#
\end

screen( capsensitive("ibuflow"),
		capsensitive("ibuftl"),
		capsensitive("IOREC"),
		capsensitive("ibufsiz"),
		capsensitive("ibufhd"),
		capsensitive("ibuf"),
		capsensitive("ibufhi") )
IOREC ist in tos.h wie folgt definiert:

typedef struct
{
        void    *ibuf;          /* Zeiger auf den Buffer   */
        int     ibufsiz;        /* Gr”e des Buffers       */
        int     ibufhd;         /* n„chste Schreibposition */
        int     ibuftl;         /* n„chste Leseposition    */
        int     ibuflow;        /* Marke fr Xon           */
        int     ibufhi;         /* Marke fr Xoff          */
} IOREC;

Querverweis    \#Iorec\#
\end

screen( capsensitive("kb_joyvec"),
		capsensitive("kb_statvec"),
		capsensitive("kb_clockvec"),
		capsensitive("kb_mousevec"),
		capsensitive("kb_midivec"),
		capsensitive("kb_midisys"),
		capsensitive("KBDVBASE"),
		capsensitive("kb_vkbderr"),
		capsensitive("kb_vmiderr"),
		capsensitive("kb_kbdsys") )
KBDVBASE ist in tos.h wie folgt definiert:

typedef struct
{
    void  (*kb_midivec)();   /* MIDI Interrupt-Vektor */
    void  (*kb_vkbderr)();   /* Tastatur Fehler-Vektor */
    void  (*kb_vmiderr)();   /* MIDI Fehler-Vektor */
    void  (*kb_statvec)();   /* Tastatur-Status */
    void  (*kb_mousevec)();  /* Tastatur-Maus-Status */
    void  (*kb_clockvec)();  /* Tastatur-Zeitgeber */
    void  (*kb_joyvec)();    /* Tastatur-Joystick-Status */
    void  (*kb_midisys)();   /* System-Midi-Vektor */
    void  (*kb_kbdsys)();    /* Tastatur-Vektor */
} KBDVBASE ;

Querverweis    \#Kbdvbase\#
\end

screen( capsensitive("p_stdfh"),
		capsensitive("p_resrvd0"),
		capsensitive("p_tlen"),
		capsensitive("p_curdrv"),
		capsensitive("BASPAG"),
		capsensitive("p_dlen"),
		capsensitive("p_bbase"),
		capsensitive("p_dbase"),
		capsensitive("p_blen"),
		capsensitive("p_cmdlin"),
		capsensitive("p_parent"),
		capsensitive("_BasPag"),
		capsensitive("p_dta"),
		capsensitive("p_env"),
		capsensitive("p_lowtpa"),
		capsensitive("p_tbase"),
		capsensitive("p_hitpa") )
Name            Basepagepointer

Deklaration:    extern BASPAG *_BasPag;
Deklaration in  tos.h

Beschreibung:   Zeigt auf die Basepage der Applikation. Die Basepage
                hat folgende Struktur:

typedef struct baspag
{
        void    *p_lowtpa;          /* Start der TPA              */
        void    *p_hitpa;           /* Ende der TPA               */
        void    *p_tbase;           /* Start des Textsegments     */
        long    p_tlen;             /* L„nge des Textsegments     */
        void    *p_dbase;           /* Start des Datasegments     */
        long    p_dlen;             /* L„nge des Datasegments     */
        void    *p_bbase;           /* Start des BSS              */
        long    p_blen;             /* L„nge des BSS              */
        DTA     *p_dta;             /* Start der \#DTA\#              */
        struct baspag *p_parent;    /* Start des aufrufenden Prg. */
        long    p_resrvd0;          /* reserviert                 */
        char    *p_env;             /* Start des Environments     */
        char    p_stdfh[6];         /* Standardhandles            */
        char    p_resrvd1;          /* reserviert                 */
        char    p_curdrv;           /* aktuelles Laufwerk         */
        long    p_resrvd2[18];      /* reserviert                 */
        char    p_cmdlin[128];      /* Kommandozeile              */
} BASPAG;

Querverweis: \#Pexec\#
\end

screen( capsensitive("recsiz"),
		capsensitive("fatrec"),
		capsensitive("clsiz"),
		capsensitive("datrec"),
		capsensitive("BPB"),
		capsensitive("rdlen"),
		capsensitive("bflags"),
		capsensitive("clsizb"),
		capsensitive("fsiz"),
		capsensitive("numcl") )
BPB ist in tos.h wie folgt definiert:

typedef struct
{
        int   recsiz;       /* Bytes pro Sektor      */
        int   clsiz;        /* Sektoren pro Cluster  */
        int   clsizb;       /* Bytes pro Cluster     */
        int   rdlen;        /* Verzeichnisl„nge      */
        int   fsiz;         /* L„nge der FAT         */
        int   fatrec;       /* Start der 2. FAT      */
        int   datrec;       /* 1. freier Sektor      */
        int   numcl;        /* Gesamtzahl an Cluster */
        int   bflags;       /* Flags                 */
} BPB ;

Querverweis: \#Getbpb\#
\end

screen( "date (DOSTIME)",
		"time (DOSTIME)",
		capsensitive("DOSTIME") )
DOSTIME ist in tos.h wie folgt definiert;

typedef struct
{
        unsigned int     time;
        unsigned int     date;
} DOSTIME;

               Die Struktur der beiden Integer-Werte gliedert sich wie
               folgt:

Bit            time
0-4            Sekunden in Zweierschritten (0-29)
5-10           Minuten (0-59)
11-15          Stunden (0-23)

Bit            date
0-4            Tag im Monat (1-31)
5-8            Monat (1-12)
9-15           Jahr (0-119, 0=1980)

Querverweis: \#Fdatime\#
\end

screen( capsensitive("command_tail"),
		capsensitive("length"),
		capsensitive("COMMAND") )
COMMAND ist in tos.h wie folgt definiert:

typedef struct
{
        unsigned char   length;
        char            command_tail[128];
} COMMAND;

Querverweis: \#Pexec\#
\end

screen( capsensitive("y_max"),
		capsensitive("x_start"),
		capsensitive("topmode"),
		capsensitive("buttons"),
		capsensitive("y_start"),
		capsensitive("y_scale"),
		capsensitive("x_max"),
		capsensitive("MOUSE"),
		capsensitive("x_scale") )
typedef struct
{
        char    topmode;
        char    buttons;
        char    x_scale;
        char    y_scale;
        int     x_max;
        int     y_max;
        int     x_start;
        int     y_start;
} MOUSE;

Querverweis: \#Initmouse\#
\end

screen( capsensitive("KEYTAB") )
KEYTAB ist in tos.h wie folgt definiert:

typedef struct
{
        char *unshift;
        char *shift;
        char *capslock;
} KEYTAB;

Querverweis: \#Keytbl\#
\end

screen( capsensitive("MD") )
MD ist in tos.h wie folgt definiert:

typedef struct __md
{
        struct __md *m_link;
        void        *m_start;
        long        m_length;
        BASPAG      *m_own;
} MD;

Querverweis: \#Getmpb\#, \#MPB\#
\end

screen( capsensitive("MPB") )
MPB ist int tos.h wie folgt definiert:

typedef struct          /* used by Getmpb */
{
        \#MD\# *mp_mfl;
        \#MD\# *mp_mal;
        \#MD\# *mp_rover;
} MPB;

Querverweis: \#Getmpb\#
\end

screen( capsensitive("MAPTAB"),
		capsensitive("bconout"),
		capsensitive("bconin"),
		capsensitive("bconstat"),
		capsensitive("iorec"),
		capsensitive("rsconf"),
		capsensitive("bcostat") )
MAPTAB ist in tos.h wie folgt definiert:

typedef struct
{
        int   (*bconstat) ();    /* Zeiger auf \#Bconstat\# */
        long  (*bconin) ();      /* Zeiger auf \#Bconin\#   */
        int   (*bcostat) ();     /* Zeiger auf \#Bcostat\#  */
        void  (*bconout) ();     /* Zeiger auf \#Bconout\#  */
        long  (*rsconf) ();      /* Zeiger auf \#Rsconf\#   */
        \#IOREC\# *iorec;
} MAPTAB;

Querverweis: \#Bconmap\#, \#BCONMAP\#
\end

screen( capsensitive("maptabsize"),
		capsensitive("maptab"),
		capsensitive("BCONMAP") )
BCONMAP ist in tos.h wie folgt definiert:
        
typedef struct
{
        \#MAPTAB\# *maptab;     /* Liste der seriellen Schnittstellen */
        int    maptabsize;  /* Anzahl der Schnittstellentreiber   */ 
} BCONMAP;

Querverweis: \#Bconmap\#
\end

screen( capsensitive("SYSHDR") )
SYSHDR ist in tos.h wie folgt definiert:

typedef struct _syshdr         
{
    unsigned   os_entry;   /* $00 BRA to reset handler             */     
    unsigned   os_version; /* $02 TOS version number               */
    void       *os_start;  /* $04 -> reset handler                 */ 
    struct _syshdr *os_base;   /* $08 -> baseof OS                     */     
    void       *os_membot; /* $0c -> end BIOS/GEMDOS/VDI ram usage */     
    void       *os_rsv1;   /* $10 << unused,reserved >>            */     
    long       *os_magic;  /* $14 -> GEM memoryusage parm. block   */     
    long       os_gendat;  /* $18 Date of system build($MMDDYYYY)  */     
    int        os_palmode; /* $1c OS configuration bits            */     
    int        os_gendatg; /* $1e DOS-format date of systembuild   */
/* 
    The next three fields are only available in TOS versions 1.2 and
    greater 
*/     
    void      *_root;     /* $20 -> base of OS pool               */     
    long      *kbshift;   /* $24 -> keyboard shift state variable */ 
    BASPAG    **_run;     /* $28 -> GEMDOS PID of current process */     
    void      *p_rsv2;    /* $2c << unused, reserved >>           */ 
} SYSHDR;

Ab Adresse 0x4F2L liegt ein Zeiger auf eine solche Struktur.
\end

screen( capsensitive("PBDEF") )
PBDEF ist in tos.h wie folgt definiert:

typedef struct
{
        void    *pb_scrptr;
        int     pb_offset;
        int     pb_width;
        int     pb_height;
        int     pb_left;
        int     pb_right;
        int     pb_screz;
        int     pb_prrez;
        void    *pb_colptr;
        int     pb_prtype;
        int     pb_prport;
        void    *pb_mask;
} PBDEF;

Querverweis    \#Prtblk\#
\end

screen( capsensitive("tm_isdst"),
		capsensitive("tm_wday"),
		capsensitive("tm_mday"),
		capsensitive("tm"),
		capsensitive("tm_year"),
		capsensitive("tm_min"),
		capsensitive("tm_yday"),
		capsensitive("tm_mon"),
		capsensitive("tm_sec"),
		capsensitive("tm_hour") )
tm ist in time.h wie folgt definiert:

struct    tm
{
      int    tm_sec;     /* Sekunden                            */
      int    tm_min;     /* Minuten                             */
      int    tm_hour;    /* Stunden (0..23)                     */
      int    tm_mday;    /* Tag im Monat (1..31)                */
      int    tm_mon;     /* Monat (0..11)                       */
      int    tm_year;    /* Jahr                                */
      int    tm_wday;    /* Wochentag (0..6) -> (So..Sa)        */
      int    tm_yday;    /* Tag im Jahr (0..365)                */
      int    tm_isdst;   /* ungleich Null entspricht Sommerzeit */
};

Querverweis: \#ctime\#
\end

screen( capsensitive("SIG_DFL"),
		capsensitive("SIG_SYS"),
		capsensitive("SIG_IGN"),
		capsensitive("SIG_ERR"),
		capsensitive("sigfunc_t") )
typedef void (*sigfunc_t)( int );

 SIG_SYS  =>   (sigfunc_t)0L
 SIG_DFL  =>   (sigfunc_t)-1L
 SIG_IGN  =>   (sigfunc_t)-2L
 SIG_ERR  =>   (sigfunc_t)-3L

Querverweis: \#raise\#, \#signal\#
\end

screen( capsensitive("FILE") )
Die FILE-Struktur in stdio.h beinhaltet die zur internen
Dateiverwaltung notwendigen Daten.
\end

screen( capsensitive("ldiv_t") )
Die Struktur ldiv_t ist in STDLIB.H definiert:

typedef struct
{
    long   quot; /* Quotient */
    long   rem;  /* Rest */
} ldiv_t;

Querverweis: \#div_t\#
\end

screen( capsensitive("fsm_component_t"),
		capsensitive("fsm_data_fpoint_t"),
		capsensitive("fsm_int"),
		capsensitive("fsm_fpoint_t") )
Die Strukturen fsm_int, fsm_fpoint_t, fsm_data_fpoint_t und
fsm_component_t sind in VDI.H definiert:

typedef struct
{
    int    value;
    int    remainder;

}   fsm_int;

typedef struct
{
    fsm_int    x;
    fsm_int    y;

}   fsm_fpoint_t;

typedef struct
{
    fsm_fpoint_t     pt;
    fsm_fpoint_t     cpt;
    fsm_int          sharp;

}   fsm_data_fpoint_t;

typedef struct fsm_component_t
{
    int                       resevered1;
    struct fsm_component_t    *nextComponent;
    unsigned char             numPoints;
    unsigned char             numCurves;
    unsigned char             numContours;
    unsigned char             reserved2[13];
    fsm_data_fpoint_f         *points;
    unsigned char             *startPts;

}   fsm_component_t;
\end

screen( capsensitive("Libraries") )
Die Bibliotheken im šberblick
----------------------------------------------------------------------

Der Programm-Code dieser Bibliotheksroutinen ist in den folgenden sieben
Bibliotheks-Dateien gespeichert:

ù PCFLTLIB.LIB \#Gleitkomma-Befehle\#
  \#PC881LIB.LIB\#
ù PCSTDLIB.LIB \#Standard-Funktionen\#
ù PCEXTLIB.LIB \#Pure-C-Spezialfunktionen\#
ù PCTOSLIB.LIB \#GEMDOS\#, \#BIOS\# und \#XBIOS\#
ù PCGEMLIB.LIB \#GEM\#-Funktionen bestehend aus \#VDI\# und \#AES\#
ù PCBGILIB.LIB \#BGI\#-Routinen

Querverweis:   \link("%%GLOBAL%%")Parameterbergabe\#  \#Startup\#
\end

screen( "PC881LIB.LIB" )
PC881LIB.LIB
----------------------------------------------------------------------

Die Bibliothek PC881LIB.LIB sollten Sie statt PCFLTLIB.LIB in Ihrer
Projektdatei angeben, wenn Sie zum šbersetzen Ihrer Programme in
den \link("%%GLOBAL%%")Compileroptionen\# den Schalter -8  bersetzen.
Dies macht jedoch nur Sinn, wenn Sie auf Ihrem Rechner eine FPU vom
Typ MC68881 oder MC68882 installiert haben und fr diese Code er-
zeugen wollen. Beachten Sie, daá dies nicht fr die Coprozessor-Karte
SFP004 von Atari gilt, da diese nicht ber den Line-F-Emulator
angesteuert wird.
\end

screen( "Betriebssystem" )
TOS - Das Betriebssystem
----------------------------------------------------------------------

Das Atari-Betriebssystem ist in verschiedene Bereiche aufgeteilt. Zum
einen gibt es die grafische Benutzeroberfl„che \#GEM\#, mit \#AES\# und \#VDI\#,
zum andern aber auch die ¯reinen® Betriebssystemfunktionen.
Diese Betriebssystemfunktionen sind wiederum in drei Bereiche aufge-
gliedert:

ù  \#GEMDOS\#
ù  \#XBIOS\#
ù  \#BIOS\#

\#GEMDOS\# ist der Kern des Betriebssystems. Es werden unter anderem
Funktionen zur Ein-/Ausgabe, Datei- und Speicherverwaltung bereitge-
stellt.
Im Grunde genommen gibt es fr einen Pure-C-Programmierer jedoch kaum
Grnde, auf diese Funktionen zurckzugreifen, da man nahezu alle
Funktionen auch unter Pure C zur Verfgung hat.
Im \#BIOS\# (¯basic input output system®) und \#XBIOS\# (¯extended basic input
output system®) sind die hardware-abh„ngigen Funktionen enthalten.
W„hrend die \#BIOS\#-Funktionen in erster Linie die zeichenweise Ausgabe
untersttzen, sind im \#XBIOS\# vor allem die Funktionen fr die speziellen
Ger„te am Atari ST vom Diskettenlaufwerk bis hin zur MIDI-Schnittstelle
zusammengefat.
\end

screen( "Startup",
		sensitive("PCXSTART"),
		sensitive("PCSTART") )
pcstart.o ist der Standard Startup Code. Es werden folgende Schritte
ausgefhrt:

1. Initialisierung der globalen Variablen \#_app\#, \#_BasPag\# und \#_PgmSize\#.
2. Freigeben des berflssigen Speichers.
3. Testen, ob eine Coprozessorerweiterung installiert ist.
4. Initialisierung des \link("%%GLOBAL%%")envp\#-arrays, des \link("%%GLOBAL%%")argv\#-arrays und von \link("%%GLOBAL%%")argc\#.
5. Aufruf von \link("%%GLOBAL%%")main\#.
6. Deinitialisierung.
7. Programmende.

pcxstart.o ist eine Erweiterung des Standard Startup Codes.
Zus„tzlich zu den oben genannten Schritten wird die Parameterliste
nach Eintr„gen, die mit den Zeichen < oder > beginnen durchsucht.
Bei einem Programm, das mit einem Parameter der Form <DATEINAME
aufgerufen wird, wird der Standardeingabekanal stdin zur Datei
DATEINAME umgeleitet. Wenn ein Parameter der Form >DATEINAME
erscheint, wird der Standardausgabekanal stdout zur Datei DATEINAME
umgeleitet.
\end

screen( capsensitive("_app") )
Name            Applikationflag

Deklaration:    extern int _app;
Deklaration in  aes.h

Beschreibung:   Diese Variable wird auf 0 gesetzt, wenn die
                Applikation als Deskaccessory gestartet wurde. Ein
                Wert ungleich 0 signalisiert, da die Applikation als
                Programm gestartet wurde.
\end

screen( capsensitive("_PgmSize") )
Name            Programsize

Deklaration:    extern long _PgmSize;
Deklaration in  tos.h

Beschreibung:   Diese Variable enth„lt die Gr”e der Applikation im
                Speicher. Sie ben”tigen diesen Wert, wenn Sie z.B Ihr
                Programm resident im Speicher halten wollen. Rufen
                Sie dazu \#Ptermres\# mit diesem Wert auf.
\end

screen( capsensitive("BGI") )
Borland Graphics Interface

Die rund 70 Funktionen des Grafikpakets lassen sich in sieben
Kategorien unterteilen:

       \#Kontrolle\# (Laden von Grafiktreibern und Zeichens„tzen,
                  Aktivierung)

       \#Zeichnen und Fl„chenfllung\#

       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildspeicher und Zeichenfenster\#

       \#grafische Textausgabe\#

       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#

       \#Fehlerbehandlung\#
\end

screen( capsensitive("Kontrolle") )
Kontrollfunktionen

Das Grafikpaket stellt die folgenden Funktionen zur
Initialisierung sowie der Aktivierung von Grafiktreibern und
Zeichens„tzen zur Verfgung:

\#registerbgidriver\#       ¯registriert® einen als .O-Datei
                        eingebundenen Grafiktreiber
\#registerbgifont\#         ¯registriert® einen als .O-Datei
                        eingebundenen Vektor-Zeichensatz
\#installuserdriver\#       erlaubt die ¯Installation® von Grafiktreibern,
                        die nicht direkt von Borland erstellt wurden
\#installuserfont\#         erlaubt die ¯Installation® von Vektor-
                        Zeichens„tzen, die nicht direkt von Borland
                        erstellt wurden
\#setgraphbufsize\#         setzt die Gr”áe des internen Grafikpuffers

\#_graphgetmem\#            wird von allen Routinen des Grafikpakets benutzt,
                        die Speicherplatz auf dem Heap belegen, und kann
                        durch eine eigene Routine ersetzt werden
\#_graphfreemem\#           wird von allen Routinen des Grafikpakets benutzt,
                        die Speicherplatz auf dem Heap freigeben,
                        und kann durch eine eigene Routine ersetzt werden

\#detectgraph\#             prft die Hardware des Computers und legt fest,
                        welcher Grafiktreiber geladen bzw. welcher
                        Grafikmodus gesetzt werden soll
\#getmoderange\#            ermittelt, welche Grafikmodi fr einen gegebenen
                        Treiber verwendet werden k”nnen
\#getmaxmode\#              ermittelt die Kennziffer des h”chsten Grafikmodus
                        fr Grafiktreiber, die nicht direkt von Borland
                        erstellt wurden
\#getmaxx\#                 liefert  die  maximal m”gliche X-Koordinate
                        des Bildschirms
\#getmaxy\#                 liefert  die  maximal m”gliche Y-Koordinate
                        des Bildschirms
\#getdrivername\#           liefert den Namen eines Grafiktreibers als
                        String zurck
\#getmodename\#             liefert den Namen eines Grafikmodus als String
                        zurck

\#initgraph\#               prft ber einen Aufruf von detectgraph,
                        welcher Grafiktreiber geladen werden soll
                        bzw. verifiziert eine Vorgabe ber getmoderange,
                        l„dt den Grafiktreiber, schaltet in den
                        Grafikmodus um und initialisiert das Grafikpaket
                        via graphdefaults
\#graphdefaults\#           setzt alle Parameter des Grafikpakets wieder auf
                        ihre Standardvorgaben zurck
\#graphresult\#             liefert  den  Fehlerstatus  der letzten
                        Grafikoperation zurck
\#setgraphmode\#            setzt einen Grafikmodus
\#getgraphmode\#            ermittelt den momentan gesetzten Grafikmodus
\#restorecrtmode\#          schaltet von ¯Grafik® auf ¯Text® um
\#closegraph\#              gibt die fr Treiber, Zeichens„tze und Puffer
                        belegten Bereiche auf dem Heap wieder frei und
                        schaltet danach via restorecrtmode wieder in den
                        Textmodus um
\end

screen( capsensitive("Zeichnen und Fl„chenfllung") )
Zeichnen und Fl„chenfllung

Das Grafikpaket definiert die folgenden Funktionen zum Zeichnen
grafischer Objekte und zur Ausfllung von Fl„chen:

\#arc\#                     zeichnet ein Kreisbogenstck
\#circle\#                  zeichnet einen Kreis
\#drawpoly\#                zeichnet den Umriá eines Polygons
\#ellipse\#                 zeichnet ein elliptisches Kreisbogenstck
\#getarccoords\#            liefert die Koordinaten des letzten Aufrufs
                        von arc oder ellipse zurck und erm”glicht so
                        die Fortsetzung eines Kreisbogens mit anderen
                        geometrischen Elementen
\#getaspectratio\#          liefert einen Korrekturfaktor fr das physikalische
                        H”hen-/Seitenverh„ltnis des Bildschirms, wird
                        fr Kreise automatisch benutzt
\#setaspectratio\#          erlaubt das direkte Setzen eines Korrekturfaktors
\#getlinesettings\#         liefert die momentane Linienart, das verwendete
                        Muster und die Dicke
\#line\#                    zeichnet eine Linie zwischen zwei angegebenen
                        Punkten
\#lineto\#                  zeichnet eine Linie von der momentanen Position
                        des Grafik-Cursors zu einem angegebenen Punkt
\#linerel\#                 zeichnet eine Linie relativ zur momentanen
                        Position des Grafik-Cursors
\#moveto\#                  setzt den Grafik-Cursor auf einen angegebenen Punkt
\#moverel\#                 bewegt den Grafik-Cursor relativ zu seiner
                        momentanen Position
\#rectangle\#               zeichnet ein Rechteck
\#setlinestyle\#           legt die Linienart, das Muster und die Dicke fest
\#setwritemode\#            legt fest, ob Linien den vorigen Inhalt des
                        Bildspeichers direkt berschreiben, oder ob eine
                        XOR-Funktion zum Linienzeichnen verwendet wird
\#bar\#                     zeichnet einen ausgefllten Balken
\#bar3d\#                   zeichnet einen ausgefllten, dreidimensionalen
                        Balken
\#fillellipse\#             zeichnet einen ausgefllten elliptischen Kreis
\#fillpoly\#                zeichnet ein ausgeflltes Polygon
\#floodfill\#              fllt eine umschlossene Fl„che
\#getfillpattern\#          liefert ein benutzerdefiniertes Muster zur
                        Fl„chenfllung zurck
\#getfillsettings\#         liefert die momentanen Parameter fr
                        Fl„chenfllungen zurck
\#pieslice\#                zeichnet ein ausgeflltes ¯Kuchenstck®
\#sector\#                  zeichnet ein ausgeflltes elliptisches ¯Kuchenstck®
\#setfillpattern\#          erlaubt beliebige Definitionen von Fll-Mustern
\#setfillstyle\#            legt die Parameter fr Fl„chenfllungen fest

Alle Funktionen des Grafikpakets, die Linien zeichnen, verwenden die
durch setlinestyle vorgegebenen Parameter; alle Funktionen, die Fl„chen
ausfllen, benutzen die durch setfillstyle und setfillpattern
vorgegebenen Werte.
\end

screen( capsensitive("Zugriffe auf Bs u. Zf") )
Zugriffe auf den Bildspeicher und Zeichenfenster

Die folgenden Funktionen des Grafikpakets erm”glichen die direkte
Manipulation des Grafik-Bildspeichers:

\#cleardevice\#             l”scht den gesamten Grafikbildschirm unabh„ngig
                        von einem eventuell gesetzten Zeichenfenster
\#setactivepage\#           legt bei Video-Adaptern mit mehreren Bildspeicher-
                        Seiten fest, welche Seite durch folgende Aufrufe
                        von Grafikfunktionen bearbeitet wird, und
                        erm”glicht so Grafik-Operationen ¯im Hintergrund®
\#setvisualpage\#           w„hlt bei Video-Adaptern mit mehreren Bildspeicher-
                        Seiten eine Speicherseite zur Anzeige auf dem
                        Bildschirm aus
\#clearviewport\#           l”scht den Inhalt des momentan gesetzten
                        Zeichenfensters und l„át den restlichen
                        Grafikbildschirm unver„ndert
\#getviewsettings\#         liefert die absoluten Koordinaten des momentan
                        gesetzten Zeichenfensters zurck
\#setviewport\#             definiert einen rechteckigen Bereich des
                        Grafikbildschirms als Zeichenfenster
\#getimage\#                kopiert den Inhalt eines rechteckigen
                        Bildausschnitts in eine C-Puffervariable
\#imagesize\#               berechnet den Platzbedarf fr die Speicherung
                        von Bildausschnitten mit getimage
\#putimage\#                schreibt einen zuvor mit getimage gespeicherten
                        Bildausschnitt in den Grafik-Bildspeicher zurck,
                        wobei Verknpfungen mit dem momentanen Inhalt
                        des entsprechenden Bereichs m”glich sind
\#getpixel\#                liefert die Farbe eines Bildpunktes an den
                        angegebenen Koordinaten
\#putpixel\#                zeichnet einen einzelnen Bildpunkt an den
                        angegebenen Koordinaten in der angegebenen Farbe
\#getx\#                    liefert die  X-Koordinate des Grafik-Cursors
\#gety\#                    liefert die  Y-Koordinate des Grafik-Cursors
\end

screen( capsensitive("grafische Textausgabe") )
Funktionen zur Ausgabe von Text

Das Grafikpaket definiert die folgenden Funktionen zur Textausgabe:

\#gettextsettings\#         liefert die momentan gesetzten Parameter zurck
                        (Textart, Schreibrichtung, Vergr”áerungsfaktor
                        und Justierung)
\#outtext\#                 gibt einen String ab der momentanen Position
                        des Grafik-Cursors aus und verwendet dabei die
                        durch settextstyle gesetzten Parameter
\#outtextxy\#               gibt einen String ab dem angegebenen Punkt aus
\#settextjustify\#          setzt linksbndige, rechtsbndige oder zentrierte
                        Formatierung fr folgende Ausgaben mit outtext
                        und outtextxy
\#settextstyle\#            l„dt einen Zeichensatz auf den Heap bzw.
                        aktiviert einen mit registerbgifont ¯registrierten®
                        Zeichensatz, legt die Schreibrichtung und den
                        Vergr”áerungsfaktor fest
\#setusercharsize\#         erlaubt die Skalierung von Textausgaben mit
                        voneinander unabh„ngigen Werten fr H”he und Breite
\#textheight\#              liefert den vertikalen Platzbedarf eines
                        Textstrings in Pixeln zurck
\#textwidth\#               liefert den horizontalen Platzbedarf eines
                        Textstrings zurck
Wenn die ¯Clip®-Funktion aktiviert ist (d.h. der fnfte Parameter von
setviewport einen Wert != 0 hat), dann schneiden outtext und outtextxy
Ausgaben an den Grenzen des Zeichenfensters ab. Bei nicht aktivierter
¯Clip®-Funktion werden Ausgaben mit dem Standard-Zeichensatz vollst„ndig
unterdrckt, wenn sie die Grenzen des Zeichenfensters berschreiten;
Ausgaben mit Vektor-Zeichens„tzen enden an den Grenzen des Bildschirms.
\end

screen( "Farbmanipulation und Farb-Pal" )
Bildschirmfarben

Das Grafikpaket definiert die folgenden Funktionen zur Festlegung von
Bildschirmfarben:

\#getbkcolor\#              liefert die momentan gesetzte Hintergrundfarbe
                        zurck
\#getcolor\#                liefert die momentan gesetzte Zeichenfarbe zurck
\#getmaxcolor\#             liefert die ¯h”chste Farbnummer® fr den
                        momentan geladenen Grafiktreiber und den gesetzten
                        Modus
\#getpalette\#              liefert die Eintr„ge der momentan gesetzten
                        Farb-Palette
\#getdefaultpalette\#       liefert einen Zeiger auf die Standard-
                        Farbpalette  fr   den  momentan  gesetzten
                        Grafikmodus zurck
\#getpalettesize\#          liefert die Gr”áe der momentan gesetzten
                        Farb-Palette  zurck (d.h.  die Anzahl der
                        Eintr„ge)
\#setallpalette\#           setzt s„mtliche Eintr„ge einer Farb-Palette neu
\#setbkcolor\#              setzt die Hintergrundfarbe
\#setcolor\#                setzt die Zeichenfarbe
\#setpalette\#              setzt einzelne Eintr„ge einer Farb-Palette
\#setrgbpalette\#           setzt einzelne Eintr„ge der Farb-Palette fr
                        den Grafik-Adapter 8514 von IBM
\end

screen( capsensitive("Fehlerbehandlung") )
Fehlerbehandlung

Das Grafikpaket definiert einen eigenen Statuscode, der durch
Fl„chenfllungen, Diskettenoperationen, die Prfung von Grafiktreibern,
Zeichens„tzen und erlaubten Grafikmodi gesetzt wird. Die Funktion
graphresult liefert den momentanen Status zurck (und setzt den intern
gespeicherten Wert dabei automatisch auf 0), die Funktion grapherrormsg
liefert den zu einem Statuscode geh”rigen Text in Form eines Strings
zurck. Prfungen und die Ausgabe (englischer) Fehlermeldungen gestalten
sich deshalb recht einfach:

#include <graphics.h>
#include <stdio.h>
main()
{
    int graphdriver = DETECT, graphmode;
    initgraph(&graphdriver, &graphmode, "");
    if (graphdriver < 0)    /* Fehler! */
    { 
      puts(grapherrormsg(graphresult()));  /* Ausgabe der Meldung */
      exit(1);
    }
  /*   ..... */
}
\end

screen( capsensitive("arc") )
Name         ¯arc® - zeichnet einen Kreisbogen.

Definition   void arc(int x, int y, int stangle, int endangle,
                      int radius);

Prototyp in  graphics.h

Beschreibung arc  zeichnet   einen  Kreisbogen  in  der  momentan
             gesetzten Zeichenfarbe  mit dem  Mittelpunkt  (x,y),
             wobei  stangle   den  Startpunkt  und  endangle  den
             Endpunkt des  mit radius gezogenen Bogens festlegen.
             Die Angabe  beider Winkel  erfolgt  in  Grad,  wobei
             entgegen dem  Uhrzeigersinn gez„hlt  wird (0  Grad =
             horizontal  rechts  des  Mittelpunktes,  90  Grad  =
             senkrecht ber dem Mittelpunkt usw).
Ergebnis     arc hat kein direktes Ergebnis.

Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {
               int graphdriver = DETECT,   /* automatische */
                    graphmode;              /* Erkennung */
                struct arccoordstype arcinfo;
                int xasp,yasp;
                int centerx,centery,rsize;
                long ylong;

                initgraph(&graphdriver,&graphmode,"");

                centerx = getmaxx() / 2;  /* Mittelpunkte */
                centery = getmaxy() / 2;
                rsize = centery - 10;     /* Kreisradien */

                /* Ein Kreisbogenstck mit
                   eingezeichneter Sehne */
                arc(centerx, centery, 0, 90, rsize);
                getarccoords(&arcinfo);
                line(arcinfo.xstart, arcinfo.ystart,
                     arcinfo.xend, arcinfo.yend);

                /* Ein Kreis und eine Ellipse */
                circle(centerx, centery, 100);
                ellipse(centerx, centery, 0, 360, 100, 50);

                /* Ein Kreis aus drei verschiedenfarbigen
                   Kuchenstcken */
                setcolor(WHITE);
                setfillstyle(SOLID_FILL, LIGHTRED);
                pieslice(100, 100, 0, 135, 49);
                setfillstyle(SOLID_FILL, LIGHTBLUE);
                pieslice(100, 100, 135, 225, 49);
                setfillstyle(SOLID_FILL, WHITE);
                pieslice(100, 100, 225, 360, 49);

                getaspectratio(&xasp, &yasp);
                /* Ein Quadrat mit der Breite centerx
                   (halbe Breite des Bildschirms) */
                ylong = (long)centerx * (long)xasp / (long)yasp;
                rectangle(centerx / 2, centery - (int)ylong/2,
                          centerx + centerx / 2, centery +
                          (int)ylong/2);
                getch();
                closegraph();
             }
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#circle\#, \#ellipse\#, \#fillellipse\#,  \#pieslice\#, \#sector\#,
             \#getarccoords\#, \#getaspectratio\#, \#setaspectratio\#
\end

screen( capsensitive("bar") )
Name         ¯bar® - zeichnet einen ausgefllten Balken.

Definition   void bar(int left, int top, int right, int bottom);

Prototyp in  graphics.h

Beschreibung bar zeichnet  ein geflltes  Rechteck, dessen  obere
             linke Ecke  durch die  Koordinaten (left,  top)  und
             dessen untere  rechte  Ecke  durch  die  Koordinaten
             (right, bottom)  festgelegt ist.  Verwendet wird die
             momentan  gesetzte  Zeichenfarbe,  sowie  das  durch
             \#setfillstyle\#    bzw.   \#setfillpattern\#    definierte
             Fllmuster. Einen  Umriá zeichnet  \#bar\# nicht  - dazu
             konnen Sie \#bar3d\# mit depth = 0 verwenden.
Ergebnis     bar  hat   kein  direktes   Funktionsergebnis.   Ein
             eventuell   aufgetretener    Fehler   kann   mittels
             \#graphresult\# erfragt werden.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {  
                int graphdriver = DETECT, /* automatische */
                               graphmode;  /* Erkennung */
                int i, width = 20;  /* Breite */

                initgraph(&graphdriver,&graphmode,"");

                 /* Eine absteigende Treppe */
                 for (i = 1; i < 10; i++)
                   bar(i*width,i*10,(i+1)*(width+1), 200);
                getch(); clearviewport();
                setfillstyle(LTSLASH_FILL,LIGHTRED);
                bar3d(10,10,60,60,12,1);  /* mit "Deckel" */
                bar3d(10,80,180,130,40,1);
                getch();
                closegraph();
             }
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#rectangle\#, \#setcolor\#, \#setfillstyle\#, \#bar3d\#
\end

screen( capsensitive("bar3d") )
Name         ¯bar     3-dimensional®     -     zeichnet     einen
             dreidimensionalen, ausgefllten Balken.

Definition   void bar3d(int left, int top, int right, int bottom,
                        int depth, int topflag);

Prototyp in  graphics.h

Beschreibung Balken,  die   mit  bar3d  gezeichnet  wurden,  sind
             ¯dreidimensional® und  bestehen aus  einem gefllten
             Rechteck, dessen  Ecken durch  die  Koordinatenpaare
             (left, top)  und (right,  bottom) festgelegt werden.
             bar3d zeichnet  zuerst die  Umriálinien in der durch
             \#setcolor\# gesetzten  Farbe und  der mit  \#setlinestyle\#
             festgelegten Linienart,  danach fllt  die  Funktion
             die umschlossene  Fl„che (wie  \#bar\#) mit dem momentan
             gltigen Fll-muster aus.
             šber den  Parameter depth  l„át sich die r„umliche
             Tiefe (in  Pixel) bestimmen,  die typischerweise bei
             rund 25% der Breite liegt:
             bar3d(left, top, right, bottom, (right-left) / 4,
             1);
             Der Parameter  topflag legt  fest,  ob  bar3d  einen
             oberen Abschluá  des  Balkens  zeichnet  (topflag=1)
             oder nicht  (topflag=0) -  im letzteren  Fall lassen
             sich mehrere Balken bereinanderstapeln.
Ergebnis     bar3d  hat   kein  direktes  Funktionsergebnis.  Ein
             eventuell   aufgetretener    Fehler   kann   mittels
             \#graphresult\# erfragt werden.
Beispiel     siehe bar
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#rectangle\#, \#setcolor\#, \#setfillstyle\#, \#bar\#
\end

screen( capsensitive("circle") )
Name         ¯circle® - zeichnet einen Kreis.
Definition   void circle(int x, int y, int radius);

Prototyp in  graphics.h

Beschreibung circle  zeichnet   einen  Kreis   in  der   momentan
             gesetzten  Zeichenfarbe   mit   dem   durch   radius
             gegebenen   Radius   um   den   Mittelpunkt   (x,y),
             entspricht also  \#arc\# mit  stangle = 0 und endangle =
             360.
Ergebnis     circle hat kein Ergebnis.
Beispiel     siehe \#arc\#
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#circle\#, \#ellipse\#,   \#fillellipse\#,  \#pieslice\#,  \#sector\#,
             \#getarccoords\#
\end

screen( capsensitive("cleardevice") )
Name         ¯clear device® - l”scht den Grafikbildschirm.
Definition   void cleardevice(void);

Prototyp in  graphics.h

Beschreibung cleardevice l”scht den gesamten Grafikbildschirm.
             Danach wird  der Grafik-Cursor auf den (relativen)
             Ursprung (0,0),  d.h. in  die linke  obere Ecke  des
             Bildschirms gesetzt.
Ergebnis     cleardevice liefert keinen Wert zurck.
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#setviewport\#, \#clearviewport\#
\end

screen( capsensitive("clearviewport") )
Name         ¯clear viewport®  - l”scht  den Inhalt  des momentan
             gesetzten Zeichenfensters.

Definition   void clearviewport(void);

Prototyp in  graphics.h

Beschreibung clearviewport  l”scht   den  Inhalt   des   momentan
             gesetzten Zeichenfensters.
             Hinweis:  Das   Zeichenfenster  selbst   (gesetzte
             Grenzen und Clip-Funktion) bleibt unver„ndert.
Ergebnis     clearviewport liefern keinen Wert zurck.
Portabilit„t Die Funktion  ist lauff„hig  auf allen Systemen, die
             BGI unterstzten.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#setviewport\#, \#cleardevice\#
\end

screen( capsensitive("closegraph") )
Name         ¯close graphics® - beendet die Grafikausgabe.

Definition   void closegraph(void);

Prototyp in  graphics.h

Beschreibung closegraph  beendet die Ausgabe von Graphik mittels
             des BGI.
Portabilit„t Auf allen  Systemen, die BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \#Kontrolle\#
Querverweis  \#initgraph\#
\end

screen( capsensitive("detectgraph") )
Name         ¯detect graphics  adapter® -  prft die Hardware des
             Computers  und   bestimmt,   welcher   Grafiktreiber
             geladen und welcher Grafikmodus gesetzt werden soll.

Definition   void detectgraph(int *graphdriver, int *graphmode);

Prototyp in  graphics.h

Beschreibung Nachdem es  unter TOS  nur einen Grafiktreiber gibt,
             bleibt  der   Wert  fr   den  Grafiktreiber   immer
             konstant.  Der   Grafikmodus,  der  von  detectgraph
             gesetzt    werden     soll,    h„ngt     von     der
             Hardwareausstattung   ab.   Bei   einem   Monochrom-
             Bildschirm   wird   die   hohe   Bildschirmaufl”sung
             untersttzt,  bei  einem  Farbmonitor  gibt  es  die
             Auswahl zwischen  der niedrigen  und  der  mittleren
             Bildschirmaufl”sung.
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \#Kontrolle\#
Querverweis  \#initgraph\#
\end

screen( capsensitive("drawpoly") )
Name         ¯draw polygon® - zeichnet einen Polygonzug.

Definition   void drawpoly(int numpoints, int *polypoints);

Prototyp in  graphics.h

Beschreibung drawpoly zeichnet  einen  Polygonzug  mit  numpoints
             Eckpunkten in der momentan gesetzten Linienart und -
             farbe. Der  als polypoints bergebene Zeiger muá auf
             eine Folge  von Koordinatenpaaren  zeigen (ein Array
             mit numpoints * 2 Elementen, siehe ¯Beispiel®).
             Hinweis:   drawpoly   beginnt   mit   dem   ersten
             angegebenen Punkt  und zieht von dort aus eine Linie
             zum zweiten,  von da  zum dritten  usw. Zum Zeichnen
             einer  geschlossenen  Figur  mit  n  Eckpunkten  muá
             polypoints n+1 Koordinatenpaare enthalten, wobei das
             letzte Paar dieselben Werte wie das erste Paar hat.
Ergebnis     drawpoly liefern keinen Wert zurck.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {
                int graphdriver = DETECT,    /* automatische */
                                 graphmode;  /* Erkennung */

                /* Dreieck (1. = letzter Eckpunkt) */
                int triangle[] = { 50, 100, 100, 100, 150, 150,
                                   50, 100 };

                initgraph(&graphdriver,&graphmode,"");

                drawpoly(4,triangle);   /* zeichnet ein Dreieck */
                getch(); clearviewport();

                setfillstyle(SOLID_FILL, LIGHTGREEN);
                fillpoly(3,triangle);  /* 4. Punkt unn”tig */

                getch();
                closegraph();
             }
Portabilit„t Die Funktion  ist lauff„hig  auf allen Systemen, die
             BGI unterstzten.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#getfillsettings\#,       \#fillpoly\#,       \#setfillstyle\#,
             \#setfillpattern\#
\end

screen( capsensitive("ellipse") )
Name         ¯ellipse®    -     zeichnet    einen    elliptischen
             Kreisausschnitt.

Definition   void  ellipse(int   x,  int   y,  int  stangle,
                           int endangle, int xradius, int yradius);

Prototyp in  graphics.h

Beschreibung ellipse zeichnet  einen elliptischen  Kreisbogen  in
             der momentan  gesetzten  Zeichenfarbe  um  den  Mit-
             telpunkt (x,y)  mit den  Radien xradius (horizontal)
             und yradius  (vertikal). stangle  und endangle legen
             in derselben  Weise wie  bei \#arc\#  den Anfangs-  bzw.
             Endpunkt des Kreisbogens fest.
Ergebnis     ellipse hat kein Ergebnis.
Beispiel     siehe \#arc\#
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#arc\#,   \#circle\#,    \#fillellipse\#,   \#pieslice\#,   \#sector\#,
             \#getarccoords\#
\end

screen( capsensitive("fillellipse") )
Name         ¯fill  ellipse®   -  zeichnet   einen   ausgefllten
             elliptischen Kreis.

Definition   void fillellipse(int  x, int  y,  int  xradius,
                              int yradius);

Prototyp in  graphics.h

Beschreibung fillellipse zeichnet einen elliptischen Vollkreis in
             der momentan gesetzten Zeichenfarbe (wie ellipse mit
             stangle =  0 und endangle = 360), danach fllt diese
             Funktion  den   entstandenen  Kreis  mit  dem  durch
             \#setfillpattern\# bzw. \#setfillstyle\# festgelegten Muster
             und der dort angegebenen Farbe aus.
Ergebnis     fillellipse hat kein direktes Ergebnis. Wenn w„hrend
             der Ausfhrung ein Fehler auftritt, liefert der
             n„chste Aufruf von \#graphresult\# den Wert grNoScanMem
Beispiel     siehe \#arc\#
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#arc\#, \#circle\#, \#ellipse\#, \#pieslice\#, \#sector\#, \#getarccoords\#
\end

screen( capsensitive("fillpoly") )
Name         ¯fill polygon® - zeichnet ein ausgeflltes Polygon.

Definition   void fillpoly(int numpoints, int *polypoints);

Prototyp in  graphics.h

Beschreibung fillpoly  erwartet  als  Pa4rameter  die  Anzhal  an
             Koordinatenpaaren in  numpoints und  die Koordinaten
             selbst im Feld polypoints, das 2* numpoints Elemente
             hat. Zun„chst  wird der  durch die  Koordinatenpaare
             festgelegt Polygonzug  gezeichnet, danach  wird  die
             Fl„chem   mit    dem   durch    \#setfillstyle\#    bzw.
             \#setfillpattern\# gesetzten Muster gefllt.
Ergebnis     fillpoly liefern  keinen Wert  zurck. Wenn  w„hrend
             des Ausfllens  ein  Fehler  auftritt,  liefert  der
             n„chste  Aufruf   von   \#graphresult\#   das   Ergebnis
             grNoScanMem.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {
                int graphdriver = DETECT,    /* automatische */
                                 graphmode;  /* Erkennung */

                /* Dreieck (1. = letzter Eckpunkt) */
                int triangle[] = { 50, 100, 100, 100, 150, 150,
                                   50, 100 };

                initgraph(&graphdriver,&graphmode,"");

                drawpoly(4,triangle);   /* zeichnet ein Dreieck */
                getch(); clearviewport();

                setfillstyle(SOLID_FILL, LIGHTGREEN);
                fillpoly(3,triangle);  /* 4. Punkt unn”tig */

                getch();
                closegraph();
             }
Portabilit„t Auf allen  Systemen, die BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#getfillsettings\#,      \#drawpoly\#,      \#setfillstyle\#,
             \#setfillpattern\#
\end

screen( capsensitive("floodfill") )
Name         ¯flood fill® - fllt einen umschlossenen Bereich mit
             dem momentan gesetzten Fll-Muster.

Definition   void floodfill(int x, int y, int border);

Prototyp in  graphics.h

Beschreibung floodfill arbeitet  im Gegensatz  zu  \#fillpoly\#  bit-
             orientiert:   ausgehend    von   dem   durch   (x,y)
             angegebenen  Punkt   wird  der  Bildschirm  in  alle
             Richtungen ¯geflutet®,  wobei  das  Erreichen  eines
             Pixels mit  der Farbe  border die  Operation in  der
             jeweiligen Richtung abbricht.
             Wenn sich  der Punkt  (x,y) innerhalb einer Fl„che
             befindet,  die   mit   Linien   der   Farbe   border
             umschlossen  ist,   fllt  floodfill  diese  Fl„che.
             Befindet sich  (x,y) auáerhalb  dieser Fl„che,  dann
             wird der  restliche Bildschirm  (bzw. das  restliche
             Zeichenfenster)  gefllt,  die  umschlossene  Fl„che
             bleibt frei.
Ergebnis     floodfill liefert  keinen Wert  zurck. Wenn w„hrend
             des Fl„chenfllens  ein Fehler auftritt, liefert ein
             nachfolgender Aufruf  von \#graphresult\#  das  Ergebnis
             grNoFloodMem.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {  int graphdriver = DETECT,     /* automatische */
                                  graphmode;  /* Erkennung */
                initgraph(&graphdriver,&graphmode,"");

                setcolor(RED);  /* ein rotes Dreieck */
                moveto(10,10); lineto(100,10);
                lineto(50,100); lineto(10,10);
                getch();

                floodfill(30,30,RED);  /* fllt das Dreieck */
                getch();

                floodfill(100,100,RED); /* fllt den restlichen */
                getch();                /* Bildschirm */

                closegraph();
             }
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#fillpoly\#, \#graphresult\#
\end

screen( capsensitive("getarccoords") )
Name         ¯get arc  coordinates® -  ermittelt die  Koordinaten
             des letzten Aufrufs von \#arc\#.

Definition   void getarccoords(struct arccoordstype *arccoords);

Prototyp in  graphics.h

Beschreibung getarccoords liefert  die Daten  des letzten Aufrufs
             von \#arc\#  in einer  Struktur des  Typs  arccoordstype
             zurck, die  in graphics.h  folgendermaáen definiert
             ist:

             struct arccoordstype
                    { int x,y;              /* Mittelpunkt */
                      int xstart, ystart,   /* Startpunkt */
                          xend, yend;       /* Endpunkt */
                    };
             Ntzlich ist  getarccoords beispielweise  dann, wenn
             ein Kreisbogen  mit einer  Linie oder  einem anderen
             geometrischen Element fortgesetzt werden soll.
Ergebnis     getarccords hat kein Ergebnis.
Beispiel     siehe \#arc\#
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#arc\#, \#circle\#, \#ellipse\#, \#fillellipse\#, \#pieslice\#, \#sector\#
\end

screen( capsensitive("getaspectratio") )
Name         ¯get aspect  ratio® -  ermittelt  das  physikalische
             H”hen-/ Seitenverh„ltnis des Bildschirms.

Definition   void getaspectratio(int *xasp, int *yasp);

Prototyp in  graphics.h

Beschreibung Der Faktor von aspectratio ist immer 1, da man unter
             TOS  nur   das  Seitenverh„ltnis,   nicht  aber  das
             H”henverh„ltnis explizit einstellen kann.
Ergebnis     getaspectratio hat kein Ergebnis.
Portabilit„t Auf allen  Systemen,  die  BGI  untersttzen,  ist
             diese Funktion lauff„hig.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#setaspectratio\#
\end

screen( capsensitive("getbkcolor") )
Name         ¯get  background   color®  -  liefert  die  momentan
             gesetzte Hintergrundfarbe im Grafikmodus zurck.

Definition   int getbkcolor(void);

Prototyp in  graphics.h

Beschreibung getbkcolor liefert  den Inhalt  des ersten  Eintrags
             der momentan gesetzten Farbpalette. Fr das Ergebnis
             von getbkcolor  sind  die  folgenden  Konstanten  in
             graphics.h als enum definiert:

             Wert  Name      Wert  Name
             --------------------------------------------------------
             0     BLACK      8    DARKGRAY
             1     BLUE       9    LIGHTBLUE
             2     GREEN     10    LIGHTGREEN
             3     CYAN      11    LIGHTCYAN
             4     RED       12    LIGHTRED
             5     MAGENTA   13    LIGHTMAGENTA
             6     BROWN     14    YELLOW
             7     LIGHTGRAY 15    WHITE
             --------------------------------------------------------
Ergebnis     getbkcolor liefert  einen Wert  zwischen  0  und  15
             zurck.
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int color;
                initgraph(&graphdriver,&graphmode,"");

                /* Linien mit gleichbleibender Farbe und
                   wechselndem Hintergrund */
                while (!kbhit())
                 { color = getbkcolor();
                   if (++color > getmaxcolor())  color = 0;
                   setbkcolor(color);
                   lineto(rand() % (getmaxx() + 1),
                      rand() % (getmaxy() + 1));
                   delay(100);
                  }

                getch();
                closegraph();
             }
Portabilit„t Diese Funktion ist zu allen Systemen kompatibel, die
             BGI untersttzen.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getpalette\#, \#initgraph\#, \#setbkcolor\#
\end

screen( capsensitive("getcolor") )
Name         ¯get color®  - liefert die momentan gesetzte Grafik-
             Zeichenfarbe zurck.

Definition   int getcolor(void);

Prototyp in  graphics.h

Beschreibung getcolor liefert  die Nummer  des  Eintrags  in  der
             Farbpalette, der  momentan als  Zeichenfarbe benutzt
             wird. Der  Wert  0  als  Funktionsergebnis  bedeutet
             also, daá  die  Grafikroutinen  den  ersten  Eintrag
             verwenden -  welche Farbe  dies letztlich ist, h„ngt
             vom Wert dieses Eintrags ab.
             Ein Beispiel: In der mittlere Aufl”sung (STMEDIUM)
             enth„lt die Farb-Palette die vier Eintr„ge BLACK(0),
             BLUE(1), GREEN(2)  und CYAN(3).  Wenn  getcolor  den
             Wert 1  zurckliefert, wird  BLUE  als  Zeichenfarbe
             benutzt.
             Solange nicht  mit setcolor  ein anderer Paletten-
             Eintrag als Zeichenfarbe gesetzt wird, verwenden die
             Grafikroutinen den  h”chsten Eintrag:  getcolor  hat
             direkt nach  dem  Start  der  Grafik  im  Modus  der
             mittleren Aufl”sung  das Ergebnis  3.  Abh„ngig  vom
             verwendeten Grafikmodus  sind Ergebnisse  im Bereich
             von 0..15 m”glich.
Ergebnis     getcolor liefert  die Nummer  des Paletten-Eintrags,
             der momentan als Zeichenfarbe gesetzt ist.
Beispiel     #include <graphics.h>
             #include <stdlib.h>
             #include <ext.h>
             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int color;

                initgraph(&graphdriver,&graphmode,"");

                /* Linien mit wechselnder Farbe und
                   gleichbleibendem Hintergrund */
                while (!kbhit())
                 { color = getcolor();
                   if (++color > getmaxcolor())   color = 0;
                   setcolor(color);
                   lineto(random(getmaxx()) + 1),
                          random(getmaxy() + 1));
                  }
                getch();
                closegraph();
             }
Portabilit„t Auf allen  Systemen, die BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getbkcolor\#, \#getpalette\#, \#getmaxcolor\#, \#setcolor\#
\end

screen( capsensitive("getdefaultpalette") )
Name         ¯get default palette® - liefert einen Zeiger auf die
             Standard-Farbpalette  fr   den  momentan  gesetzten
             Grafikmodus zurck.

Definition   void *getdefaultpalette(void);

Prototyp in  graphics.h

Beschreibung getdefaultpalette liefert einen Zeiger auf die Farb-
             Palette zurck,  die  bei  der  Initialisierung  des
             Treibers (via  \#initgraph\# bzw.  \#setgraphmode\#) gesetzt
             war.
             colornum hat einen zul„ssigen Bereich von 0..512 und
             legt die  Nummer des Farb-Eintrags fest, dessen Wert
             sich  aus   den  Komponenten  red,  green  und  blue
             zusammensetzt.
Ergebnis     getdefaultpalette liefert kein direktes Ergebnis.
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                struct palettetype palette;
                int x,y;

                initgraph(&graphdriver, &graphmode, "");

                getpalette(&palette);
                for (x = 0; x <10; x++)  /* 10 Balken
                                            nebeneinander */
                  { setfillstyle(x, (x % 4) + 1);
                    bar(x * 60, 20, (x+1) * 60, 200);
                  }

                while (!kbhit())
                 { setpalette(rand() % palette.size, rand() %
                 64);
                   delay(300);  /* bunter Farbwechsel */
                 }

                /* Farb-Palette zurck aufs Original */
                setallpalette(getdefaultpalette());

                getch();
                closegraph();
             }
Portabilit„t Diese Funktion ist zu allen Systemen kompatibel, die
             BGI untersttzen.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getbkcolor\#,   \#getcolor\#,    \#getpalette\#,   \#setpalette\#,
             \#setallpalette\#
\end

screen( capsensitive("getdrivername") )
Name         ¯get  driver   name®  -   liefert  den   Namen   des
             Grafiktreibers.

Definition   char *getdrivername(void);

Prototyp in  graphics.h

Beschreibung getdrivername kann  nur nach der Initialisierung des
             Grafikpakets mit  initgraph  verwendet  werden.  Die
             Funktion liefert  den Namen  des Grafiktreibers, der
             durch \#initgraph\# aktiviert wurde.
Ergebnis     getdrivername liefert  einen Zeiger auf einen String
             zurck.
Gruppe       \#Kontrolle\#
Portabilit„t Diese Funktion ist zu allen Systemen kompatibel, die
             BGI untersttzen.
\end

screen( capsensitive("getfillpattern") )
Name         ¯get fill  pattern®  -  ermittelt  das  zuletzt  mit
             \#setfillpattern\#      gesetzte      Bitmuster      fr
             Fl„chenfllungen.

Definition   void getfillpattern(char *pattern);

Prototyp in  graphics.h

Beschreibung getfillpattern ermittelt  das festgelegte Muster und
             die Zeichenfarbe  fr die  Aufrufe von  \#fillellipse\#,
             \#fillpoly\#,  \#floodfill\#,   \#bar\#,   \#bar3d\#,   \#sector\#   und
             \#pieslice\#.
             pattern ist ein Zeiger auf eine Folge von 8 Bytes,
             bei dem  jedes Bit  fr ein Pixel in der durch color
             festgelegten  Farbe  steht.  Jedes  Byte  legt  acht
             nebeneinanderliegende Punkte  einer  Bildschirmzeile
             fest,  die   Bytes   selbst   sind   ¯untereinander®
             angeordnet. Ein  Schachbrettmuster mit der Graustufe
             0.5 ist beispielsweise folgendermaáen definiert:
               char gray50[8] =
                 { 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55
                 };
Ergebnis     getfillpattern hat kein direktes Ergebnis.
Beispiel     siehe getfillsettings
Portabilit„t Auf allen  Systemen, die BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#getfillsettings\#, \#setfillpattern\#
\end

screen( capsensitive("getfillsettings") )
Name         ¯get  fill   settings®  -  liefert  Daten  ber  das
             momentan   gesetzte    Fllmuster   und    die   fr
             Fl„chenfllungen verwendete Farbe.

Definition   void getfillsettings(struct fillsettingstype *fillinfo);

Prototyp in  graphics.h

Beschreibung getfillsettings ermittelt die ber setfillstyle bzw.
             \#setfillpattern\# gesetzten  Parameter und  liefert sie
             in der als fillinfo bergebenen Struktur zurck. Der
             Datentypen  fillsetttingstype   ist  in   graphics.h
             folgendermaáen definiert:
             struct fillsettingstype
              { int pattern;     /* Nummer des momentan gesetzten
                                    Musters */
                int color;       /* Farbe (0..15) */
              };
             Fr  pattern   sind  in   graphics.h  die  folgenden
             Bitmuster definiert:

             Name               Wert  Beschreibung
             --------------------------------------------------------
             EMPTY_FILL         0     Fllen mit der Hintergrundfarbe
             SOLID_FILL         1     Fllen mit der Farbe color
             LINE_FILL          2     ----------
             LTSLASH_FILL       3     //////////
             SLASH_FILL         4     //////////  mit dicken Linien
             BKSLASH_FILL       5     \\\\\\\\\\  mit dicken Linien
             LTBKSLASH_FILL     6     \\\\\\\\\\
             HATCH_FILL         7     leicht schraffiert
             XHATCH_FILL        8     stark schraffiert, berkreuzend
             INTERLEAVE_FILL    9     abwechselnde Linien
             WIDEDOT_FILL      10     Punkte, weit auseinander
             CLOSEDOT_FILL     11     Punkte, dicht nebeneinander
             USER_FILL         12     benutzerdefiniert
             --------------------------------------------------------
Ergebnis     getfillsettings hat kein direktes Ergebnis.
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {  int graphdriver = DETECT; /* automatische */
                int graphmode;              /* Erkennung */
                struct fillsettingstype save;
                char savepattern[8];
                char checkboard[] = { 0x0F, 0xF0, 0x0F, 0xF0,
                                      0x0F, 0xF0, 0x0F, 0xF0 };

                initgraph(&graphdriver, &graphmode, "");

                /* momentan gesetztes Muster ermitteln */
                getfillsettings(&save);
                                      /* Muster speichern */
                if (save.pattern == USER_FILL)
                                      /* benutzerdefiniert? */
                  getfillpattern(savepattern);
                                      /* -ja, Bitmuster lesen */
                setfillstyle(SLASH_FILL, BLUE);
                                      /* /////, blau */
                bar (0,0,100,100);    /* Balken zeichnen */

                setfillpattern(checkboard, YELLOW);
                                      /* eigenes Muster */
                bar (100,100,200,200);
                                      /* noch ein Balken */

                /* und das alte Muster wieder setzen */
                if (save.pattern == USER_FILL)
                  setfillpattern(savepattern, save.color);
                 else
                  setfillstyle(save.pattern, save.color);

                getch();
                closegraph();
             }
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#arc\#,    \#fillpoly\#,     \#floodfill\#,     \#getfillpattern\#,
             \#setfillstyle\#
\end

screen( capsensitive("getgraphmode") )
Name         ¯get  graphics   mode®  -   Liefert  den  Modus  der
             Grafikaufl”sung.

Definition   int getgraphmode(void);

Prototyp in  graphics.h

Beschreibung Bei  Monochrommonitoren   wird   grunds„tzlich   ein
             konstantes Ergebnis  2 zurckgegeben,  da es hierfr
             nur  einen  Aufl”sungsmodus  gibt  (hohe  Aufl”sung,
             STHIGH 640x400).
             Bei Farbmonitoren  liefert getgraphmode ein Ergebnis
             im Teilbereich  zwischen  0..1  zurck,  0  fr  die
             niedrige  Aufl”sung   (STLOW  300x200),  1  fr  die
             Mittlere (STMEDIUM 640x200).
Ergebnis     getgraphmode liefert die Nummer des momentan
             gesetzten Grafikmodus zurck.
Beispiel       currentmode = getgraphmode();  /* momentaner Modus
                                                 (int) */
               restorecrtmode();  /* Textmodus setzen */
               ...
               setgraphmode(currentmode);  /* zurck zur Grafik */
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \#Kontrolle\#
Querverweis  \#initgraph\#, \#setgraphmode\#
\end

screen( capsensitive("getimage") )
Name         ¯get   image®    -   kopiert    einen   rechteckigen
             Bildausschnitt in einen Puffer.

Definition   void getimage(int  left, int  top,  int  right,
                           int bottom, void *bitmap);

Prototyp in  graphics.h

Beschreibung getimage kopiert  einen rechteckigen Bildausschnitt,
             dessen linke obere Ecke durch (left, top) und dessen
             rechte untere  Ecke durch (right, bottom) festgelegt
             ist, in  den durch bitmap spezifizierten Buffer. Die
             ersten beiden  16-Bit-Worte von  bitmap sind fr die
             Breite   und    H”he   des   kopierten   Ausschnitts
             reserviert:
             breite = right - left + 1;
             hoehe = bottom - top + 1;
             bitmap  muá   also  vier  Bytes  mehr  Speicherplatz
             bieten, als fr die eigentlichen Bilddaten gebraucht
             wird.

Ergebnis     getimage hat kein direktes Funktionsergebnis.

Beispiel     #include <stdlib.h>
             #include <graphics.h>
             #include <ext.h>

             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int maxx, x;
                unsigned long picsize;    /* Bildgr”áe */
                void * picptr;       /* Zeiger fr den
                                        Bildausschnitt */

                initgraph(&graphdriver, &graphmode, "");
                maxx = getmaxx() / 4;    /* 1/4 des Schirms */

                for (x= 0; x<100; x++)  /* ein paar bunte Linien */
                 { setcolor(rand() % (getmaxcolor() + 1));
                   lineto(rand() % maxx, rand() % getmaxy());
                 }
                getch();
                           /* Bild "einfangen" */
                picsize = imagesize(0,0,maxx,getmaxy());
                                           /* Gr”áe */
                picptr = malloc(picsize);  /* Speicherplatz */
                getimage(0,0,maxx,getmaxy(),picptr); /* Kopie */

                for (x = 1; x < 4; x++)  /* und drei Kopien davon */
                  putimage (x * maxx, 0, picptr, COPY_PUT);
                getch();
                closegraph();
             }

Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.

Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#

Querverweis  \#imagesize\#, \#putimage\#
\end

screen( capsensitive("getlinesettings") )
Name         ¯get  line  settings®  -  ermittelt  die  durch  den
             letzten Aufruf von \#setlinestyle\# gesetzten Parameter.

Definition   void getlinesettings(struct linesettingstype
                                         *lineinfo);

Prototyp in  graphics.h

Beschreibung getlinesettings  ermittelt   die  momentan  gesetzte
             Linienart,  das   verwendete   Muster,   sowie   die
             Liniendicke und  speichert die Ergebnisse in der als
             lineinfo    bergebenen     Variablen.    Der    Typ
             linesettingstype ist  in  graphics.h  folgendermaáen
             definiert:
             struct linesettingstype
              { int linestyle;       /* durchgezogen, gepunktet... */
                unsigned upattern;   /* "user pattern" */
                int thickness;       /* Dicke - 1 oder 3 Pixel */
              };
             Fr die  Linienart (linestyle)  definiert graphics.h
             mehrere Konstanten:

             Name    Wert  Beschreibung
             --------------------------------------------------------
             SOLID_LINE    0     durchgezogen
             DOTTED_LINE   1     gepunktet
             CENTER_LINE   2     Punkt Strich Punkt Strich...
             DASHED_LINE   3     gestrichelt
             USERBIT_LINE  4     benutzerdefiniert
             --------------------------------------------------------
             Fr die  Dicke einer Linie (thickness) sind nur zwei
             Werte m”glich, die ebenfalls in graphics.h definiert
             sind:

             Name    Wert  Beschreibung
             --------------------------------------------------------
             NORM_WIDTH    1normale Dicke (1 Pixel)
             THICK_WIDTH   3¯dicke® Dicke (3 Pixel)
             --------------------------------------------------------
Ergebnis     getlinesettings hat kein direktes Ergebnis.
Beispiel     struct linesettingstype save;
             int lkind, lpattern, lthickness;
             ...
             getlinesettings(&save);
             lkind      = save.linestyle;   /* Linienart (1..12) */
             lpattern   = save.pattern;     /* Bitmuster */
             lthickness = save.thickness;   /* Dicke (1 oder 3) */
             ...
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#setlinestyle\#, \#setwritemode\#
\end

screen( capsensitive("getmaxcolor") )
Name         ¯get   maximum   color®   -   liefert   die   Anzahl
             verwendbarer Farben zurck.

Definition   int getmaxcolor(void);

Prototyp in  graphics.h

Beschreibung getmaxcolor liefert  die Anzahl  der Farben,  die im
             momentan  gesetzten   Grafikmodus  verwendet  werden
             k”nnen.
Ergebnis     Der zurckgelieferte  Wert entspricht  der Gr”áe der
             Farb-Palette minus 1.
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getbkcolor\#, \#getcolor\#, \#getpalette\#
\end

screen( capsensitive("getmaxmode") )
Name         ¯get maximum  graphics mode®  - liefert  die  Anzahl
             verfgbarer Grafikmodi.

Definition   int getmaxmode(void);

Prototyp in  graphics.h

Beschreibung getmaxmode ermittelt  den maximal m”glichen Wert fr
             graphmode (der normalerweise fr den Grafikmodus mit
             der h”chsten Aufl”sung steht).
Ergebnis     Zurckgeliefert wird  ein Integer-Wert gr”áer gleich
             0.
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \#Kontrolle\#
\end

screen( capsensitive("getmaxx") )
Name         ¯get maximum  x coordinate®  - liefert  die  maximal
             m”gliche X-Koordinate des Bildschirms.

Definition   int getmaxx(void);

Prototyp in  graphics.h

Beschreibung getmaxx liefert  die maximal  m”gliche  X-Koordinate
             des Bildschirms  zurck, d.h.  die X-Koordinate  des
             rechten Bildschirmrandes.  Das  Ergebnis  h„ngt  vom
             verwendeten Grafikmodus ab.
             Ergebnis ist  vom momentan verwendeten Grafikmodus
             abh„ngig.
             getmaxx  und   \#getmaxy\#  erm”glichen,  ein  Grafik-
             Programm unabh„ngig  von der Aufl”sung zu schreiben.
             Diese  beiden   Funktionen   sollten   grunds„tzlich
             anstelle von Konstanten verwendet werden.
Ergebnis     getmaxx   liefert  fr  die  momentan  definierten
             Grafiktreiber Ergebnisse im Bereich von 319..1023.
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Kontrolle\#
Querverweis  \#getviewsettings\#, \#getmaxy\#
\end

screen( capsensitive("getmaxy") )
Name         ¯get maximum  y [coordinate]®  - liefert die maximal
             m”gliche Y-Koordinate des Bildschirms.

Definition   int getmaxy(void);

Prototyp in  graphics.h

Beschreibung getmaxy liefert  die maximal  m”gliche  Y-Koordinate
             des Bildschirms  zurck, d.h.  die Y-Koordinate  des
             unteren  Bildschirmrandes.   Das  Ergebnis  ist  vom
             momentan verwendeten Grafikmodus abh„ngig.
             \#getmaxx\# und  getmaxy erm”glichen  es, ein  Grafik-
             Programm unabh„ngig  von der Aufl”sung zu schreiben.
             Diese  beiden   Funktionen   sollten   grunds„tzlich
             anstelle von Konstanten verwendet werden.
Ergebnis     M”gliche Ergebnisse  von getmaxy  liegen im  Bereich
             von 199..767.
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Kontrolle\#
Querverweis  \#getviewsettings\#, \#getmaxx\#
\end

screen( capsensitive("getmodename") )
Name         ¯get mode name® - liefert den Namen eines Grafikmodi
             als String zurck.

Definition   char *getmodename(int mode_number);

Prototyp in  graphics.h

Beschreibung getmodename erwartet  die Nummer  eines  Grafikmodus
             als Parameter und liefert einen Zeiger auf den Namen
             dieses Modus zurck.
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \#Kontrolle\#
Querverweis  \#getgraphmode\#, \#getmaxmode\#, \#getmoderange\#, \#getdrivername\#,
             \#initgraph\#
\end

screen( capsensitive("getmoderange") )
Name         ¯get  mode   range®  -   ermittelt   die   m”glichen
             Grafikmodi fr einen Grafiktreiber.

Definition   void getmoderange(int graphdriver, int *lomode,
                                   int *himode);

Prototyp in  graphics.h

Beschreibung getmoderange    liefert    den    niedrigstm”glichen
             Grafikmodus  fr  graphdriver  in  *lomode  und  den
             h”chstm”glichen  Modus   in  *himode   zurck.  Wenn
             graphdriver  einen   Wert  auáerhalb  des  erlaubten
             Bereichs (siehe  \#initgraph\#) enth„lt,  werden *lomode
             und *himode auf -1 gesetzt.
             Hinweis: getmoderange  kann auch  dann  aufgerufen
             werden, wenn kein Grafikmodus gesetzt ist.
Ergebnis     getmoderange hat kein direktes Funktionsergebnis.
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \#Kontrolle\#
Querverweis  \#getgraphmode\#, \#getmaxmode\#, \#initgraph\#
\end

screen( capsensitive("getpalette") )
Name         ¯get  palette®  -  liefert  Informationen  ber  die
             momentan gesetzte Farb-Palette.

Definition   void getpalette(struct palettetype *palette);

Prototyp in  graphics.h

Beschreibung getpalette  liefert   die  Eintr„ge   der   momentan
             gesetzten Farb-Palette  und die  Gesamtgr”áe  dieser
             Palette in  der als  palette  bergebenen  Variablen
             zurck. Der  Datentyp palettetype  ist in graphics.h
             folgendermaáen definiert:
             #define MAXCOLORS 15
             struct palettetype
              { unsigned char size;     /* Anzahl der Eintr„ge */
                signed char colors[MAXCOLORS+1];  /* Paletten-
                                                     Eintr„ge */
              };
             Das Mitglied size enth„lt die Anzahl der tats„chlich
             benutzten Eintr„ge  des Arrays colors, sein Wert ist
             vom aktiven  Grafikmodus. Die  Elemente  von  colors
             (0..size-1) enthalten  die in  der  aktiven  Palette
             gespeicherten Bitmuster.
             Die folgenden  Konstanten sind  in graphics.h  fr
             Farb-Bitmuster definiert:

                   STLOW              STMEDIUM
             Name         Wert    Name        Wert
             --------------------------------------------------
             BLACK          0     BLACK         0
             BLUE           1     BLUE          1
             GREEN          2     GREEN         2
             CYAN           3     CYAN          3
             RED            4
             MAGENTA        5
             BROWN          6
             LIGHTGRAY      7
             DARKGRAY       8
             LIGHTBLUE      9
             LIGHTGREEN    10
             LIGHTCYAN     11
             LIGHTRED      12
             LIGHTMAGENTA  13
             YELLOW        14
             WHITE         15
             --------------------------------------------------------
Ergebnis     getpalette hat kein direktes Ergebnis.
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                struct palettetype palette;
                int x,y;

                initgraph(&graphdriver, &graphmode, "");

                getpalette(&palette);
                for (x = 0; x <10; x++)  /* 10 Balken
                                            nebeneinander */
                  { setfillstyle(x, (x % 4) + 1);
                    bar(x * 60, 20, (x+1) * 60, 200);
                  }

                while (!kbhit())
                 { setpalette(rand() % palette.size, rand() %
                   64);
                   delay(300);  /* bunter Farbwechsel */
                 }

                /* Farb-Palette zurck aufs Original */
                setallpalette(getdefaultpalette());

                getch();
                closegraph();
             }
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getbkcolor\#,       \#getcolor\#,       \#getdefaultpalette\#,
             \#setallpalette\#, \#setpalette\#, \#setrgbpalette\#
\end

screen( capsensitive("getpalettesize") )
Name         ¯get palette  size® - liefert die Gr”áe der momentan
             gesetzten Farb-Palette  zurck (d.h.  die Anzahl der
             Eintr„ge).

Definition   int getpalettesize(void);

Prototyp in  graphics.h

Beschreibung Mit getpalettesize  l„át  sich  ermitteln,  wieviele
             Eintr„ge  die  Farb-Palette  im  momentan  gesetzten
             Grafikmodus enth„lt.
Ergebnis     getpalettesize liefert  die Anzahl  der Eintr„ge als
             Integer zurck.
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#setpalette\#
\end

screen( capsensitive("getpixel") )
Name         ¯get pixel® - liefert die Farbe eines Pixels zurck.

Definition   unsigned getpixel(int x, int y);

Prototyp in  graphics.h

Beschreibung getpixel liefert  die Farbe des Pixels auf dem durch
             (x,y) angegebenen Punkt zurck.
             Das von getpixel gelieferte Ergebnis steht fr die
             Nummer des  Paletteneintrags -  welche Farbe  diesem
             Eintrag zugeordnet  ist, wird  durch  das  Bitmuster
             festgelegt, das  in diesem  Eintrag der Farb-Palette
             gespeichert ist.
Ergebnis     getpixel  liefert   einen  Wert  im  Bereich  von  0
             (¯Hintergrund®)..MAXCOLORS.
Beispiel     #include <graphics.h>
             #include <ext.h>
             #define NUMSTARS 1000
             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int x,px,py,pc;

                initgraph(&graphdriver, &graphmode, "");

                srand(1);   /* Viele bunte Sterne */
                for (x= 0; x < NUMSTARS; x++)
                  { px = rand() % getmaxx(); py = rand() %
                    getmaxy();
                    pc = 1 + rand() % getmaxcolor();
                    putpixel(px, py, pc);
                  }
                while (!kbhit())  /* Farbwechsel der Sterne */
                 { srand(1);  /* Wieder denselben Startwert */
                   for (x = 0; x < NUMSTARS; x++)
                    { px = rand() % getmaxx(); py = rand() %
                      getmaxy();
                      pc = rand() % getmaxcolor();  /* Dummy! */
                      pc = getpixel(px,py);  /* Farbe ermitteln */
                      putpixel(px,py, 1 + (++pc % getmaxcolor()));
                    }
                 }

                getch();
                closegraph();
             }
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#putpixel\#
\end

screen( capsensitive("gettextsettings") )
Name         ¯get text settings® - liefert Informationen ber die
             Parameter fr  folgende  Ausgaben  mit  \#outtext\#  und
             \#outtextxy\#.

Definition   void gettextsettings(struct textsettingstype
                                         *texttypeinfo);

Prototyp in  graphics.h

Beschreibung gettextsettings ermittelt  die mit  \#settextstyle\# und
             \#settextjustify\# gesetzten  Parameter und  liefert sie
             in der als *textinfo bergebenen Variablen zurck.
             Der Strukturtyp textsettingstype und die m”glichen
             Werte  seiner   Komponenten   sind   in   graphics.h
             folgendermaáen definiert:
             struct textsettingstype
              { int font;        /* Nummer des aktiven
                                    Zeichensatzes */
                int direction;   /* horizontal oder vertikal */
                int charsize;    /* Vergr”áerungsfaktor */
                int horiz;       /* Justierung horizontal */
                int vert;        /* Justierung vertikal */
              };
             Die Komponenten  horiz und vert geben an, in welcher
             Weise Textausgaben  relativ zur  momentanen Position
             des Grafik-Cursors  (bzw. des zusammen mit \#outtextxy\#
             angegebenen Punktes) justiert werden:

             Name        Wert  Beschreibung
             --------------------------------------------------------
             LEFT_TEXT     0   linksbndig (horiz)
             CENTER_TEXT   1   mittenzentriert (horiz und vert)
             RIGHT_TEXT    2   rechtsbndig (horiz)
             BOTTOM_TEXT   0   Cursorposition = Grundlinie (vert)
             TOP_TEXT      2   CP = oberer Abschluá (vert)
             --------------------------------------------------------
             Hinweis:  Die   Formatierungsm”glichkeiten  sind  im
             Abschnitt \#settextjustify\# ausfhrlich beschrieben.
             Es  stehen   fnf  verschiedene   Zeichens„tze   zur
             Verfgung,  fr   die   graphics.h   die   folgenden
             Konstanten definiert:

             Name          Wert  Beschreibung
             --------------------------------------------------------
             DEFAULT_FONT    0   8 * 16 Bit pixelweise (Standard)
             TRIPLEX_FONT    1   Vektor-Zeichensatz ¯Triplex®
             SMALL_FONT      2   kleiner Vektor-Zeichensatz
             SANSSERIF_FONT  3   Vektor-Zeichensatz ¯Sans serif®
             GOTHIC_FONT     4   Vektor-Zeichensatz ¯Gothic®
             --------------------------------------------------------
             Der pixelweise definierte Zeichensatz (DEFAULT_FONT)
             ist Teil  des Grafikpakets  und immer verfgbar. Die
             anderen  Zeichens„tze   sind  in  separaten  Dateien
             (*.CHR) gespeichert  und  k”nnen  entweder  als  .O-
             Dateien   eingebunden    und   via   \#registerbgifont\#
             ¯registriert® oder  durch  \#settextstyle\#  bei  Bedarf
             nachgeladen werden.
             Der Wert  von direction gibt an, ob Textausgaben von
             links nach  rechts (d.h.  horizontal) oder von unten
             nach oben  (d.h. in  vertikaler Richtung)  erfolgen.
             M”gliche Werte fr direction sind:

             Name        Wert  Beschreibung
             --------------------------------------------------------
             HORIZ_DIR     0   von links nach rechts (Standard)
             VERT_DIR      1   Ausgabe von unten nach oben
             --------------------------------------------------------
             charsize legt  den Vergr”áerungsfaktor  (0..10)  fr
             Textausgaben  fest.   Eine   ¯Kl”tzchenvergr”áerung®
             (d.h. Faktor 1: 1 Pixel pro Punkt, Faktor 2: 4 Pixel
             pro Punkt  usw.)  ergibt  sich  dabei  nur  fr  den
             Standard-Zeichensatz.
             Der ¯Vergr”áerungsfaktor® 0, fr den in graphics.h
             die Konstante USER_CHAR_SIZE definiert ist, wird auf
             spezielle Weise  behandelt:  \#outtext\#  und  \#outtextxy\#
             verwenden hier  entweder den  durch  \#setusercharsize\#
             vorgegebenen    Vergr”áerungsfaktor     oder     den
             Standardwert  1,   wenn  \#setusercharsize\#  zu  diesem
             Zeitpunkt noch nicht aufgerufen wurde.
Ergebnis     gettextsettings hat kein direktes Ergebnis.
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {
                int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int x,y;
                char msg[20];

                initgraph(&graphdriver, &graphmode, "");

                for (x = 1, y = 10; x < 10; x+= 2)
                 { sprintf(msg, "Faktor %d", x);
                   settextstyle(GOTHIC_FONT, HORIZ_DIR, x);
                   outtextxy(0,y, msg);
                   y += textheight(msg);
                 }
                getch();
                closegraph();
             }
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#registerbgifont\#, \#settextjustify\#, \#settextstyle\#,
             \#setusercharsize\#, \#textheight\#, \#outtext\#, \#outtextxy\#
\end

screen( capsensitive("getviewsettings") )
Name         ¯get viewport settings® - liefert Informationen ber
             das momentan gesetzte Zeichenfenster.

Definition   void getviewsettings(struct viewporttype *viewport);

Prototyp in  graphics.h

Beschreibung getviewsettings liefert  die  Grenzen  des  momentan
             gesetzten Zeichenfensters  und das  Flag der ¯Clip®-
             Funktion in  der als  viewport bergebenen Variablen
             zurck.  Der   Strukturtyp   viewporttype   ist   in
             graphics.h folgendermaáen definiert:
             struct viewporttype
              { int left, top,        /* obere linke und     */
                    right, bottom;    /* untere rechte Ecke  */
                int clipflag;         /* Clip-Funktion an/aus */
              };
Ergebnis     getviewsettings hat kein direktes Ergebnis.
Beispiel     siehe \#setviewport\#
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#clearviewport\#, \#setviewport\#
\end

screen( capsensitive("getx") )
Name         ¯get x  coordinate® -  liefert die  X-Koordinate des
             Grafik-Cursors.

Definition   int getx(void);

Prototyp in  graphics.h

Beschreibung getx  liefert   die  X-Koordinate   der   momentanen
             Position des Grafik-Cursors.
Ergebnis     Die von getx zurckgelieferte Koordinate ist relativ
             zum Ursprung  des momentanen  Zeichenfensters - nach
             einer Befehlsfolge wie
             setviewport(20, 10, 60, 20, 0);  /* linke Ecke:
                                                 (20,10) */
             clearviewport();        /* l”scht das Fenster, setzt
                                        den Cursor in die obere
                                        linke Ecke */
             liefert getx also das Ergebnis 0.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int xsave,ysave;

                initgraph(&graphdriver, &graphmode, "");
                moveto(40,40); outtext("Ein ");
                xsave = getx(); ysave = gety();  /* Position
                                                    speichern */

                moveto(100,100); lineto(200,100);
                outtext("Hier sind wir jetzt.");
                getch();
                moveto(xsave, ysave);  /* alte Position wieder
                                          setzen */
                outtext("Text.");

                getch();
                closegraph();
             }
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#getviewsettings\#, \#gety\#, \#initgraph\#, \#moveto\#
\end

screen( capsensitive("gety") )
Name         ¯get y  [coordinate]® - liefert die Y-Koordinate des
             Grafik-Cursors.

Definition   int gety(void);

Prototyp in  graphics.h

Beschreibung gety  liefert   die  Y-Koordinate   der   momentanen
             Position des Grafik-Cursors.
Ergebnis     Die von gety zurckgelieferte Koordinate ist relativ
             zum Ursprung  des momentanen  Zeichenfensters - nach
             einer Befehlsfolge wie
             setviewport(20, 10, 60, 20, 0);  /* linke Ecke:
                                                 (20,10) */
             clearviewport();        /* l”scht das Fenster, setzt
                                        den Cursor in die obere
                                        linke Ecke */
             liefert gety den Wert 0.
Beispiel     siehe getx
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#getviewsettings\#, \#getx\#, \#initgraph\#, \#moveto\#
\end

screen( capsensitive("graphdefaults") )
Name         ¯graphics defaults®  - setzt s„mtliche Parameter des
             Grafikpakets auf die Standardvorgaben zurck.

Definition   void graphdefaults(void);

Prototyp in  graphics.h

Beschreibung graphdefaults setzt die Standardvorgaben fr
             -  das Zeichenfenster (auf den gesamten Bildschirm);
             -  den Grafik-Cursor (Punkt (0,0));
             -  den  Hintergrund   (schwarz),  die   Zeichenfarbe
                (MAXCOLOR) und die Farb-Palette;
             -  Fl„chenfllungen (SOLID_FILL, MAXCOLOR);
             -  und Textausgaben  (DEFAULT_FONT,  HORIZ_DIR,  1),
                wobei der Wert 1 den Standard-Vergr”áerungsfaktor
                darstellt.
             Der Inhalt des Bildschirms bleibt unver„ndert.
Ergebnis     graphdefaults hat kein direktes Funktionsergebnis.
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \#Kontrolle\#
Querverweis  \#initgraph\#, \#getgraphmode\#
\end

screen( capsensitive("grapherrormsg") )
Name         ¯graphics error  message® -  liefert den  Text einer
             Fehlermeldung des Grafikpakets.

Definition   char *grapherrormsg(int errorcode);

Prototyp in  graphics.h

Beschreibung grapherrormsg  liefert   einen  Zeiger   auf   einen
             statischen String  zurck, der  den Text  zu dem als
             errorcode  bergebenen   Fehlerstatus  enth„lt,  und
             erspart so  dem Programmierer die Definition eigener
             Fehlermeldungen.
Ergebnis     grapherrormsg  liefert   einen  Zeiger   auf   einen
             statischen String  mit dem  Text  der  dazugeh”rigen
             Meldung.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {
                int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int errcode;
                initgraph(&graphdriver,
                          &graphmode, "###"); /* Suchweg ungltig */

                errcode = graphresult();
                if (errcode)
                  { restorecrtmode();
                    printf("Grafikfehler: %s\\n", grapherrormsg(errcode));
                    exit(1);
                  }

                /* Fr diese Demonstration nur der
                   Vollst„ndigkeit halber */
                getch();
                closegraph();
             }
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \#Fehlerbehandlung\#
Querverweis  \#initgraph\#, \#graphresult\#
\end

screen( capsensitive("_graphfreemem") )
Name         ¯graphics free  memory® - vom Grafikpaket verwendete
             Routine  zur   Freigabe   von   dynamisch   belegtem
             Speicherplatz.

Definition   void _graphfreemem(void *ptr, unsigned size);

Prototyp in  graphics.h

Beschreibung _graphfreemem gibt  ber den  Aufruf von  free einen
             dynamisch belegten  Bereich von  size  Bytes  wieder
             frei, auf den der als ptr bergebene Zeiger zeigt.
             Die   Routine    des   Grafikpakets   rufen   free
             ausschlieálich ber  diese Funktion  auf,  die  sich
             durch eine  eigene Version  ersetzen laát, damit hat
             der Programmierer  die Kontrolle ber die dynamische
             Speicherverwaltung der Grafik.
             Hinweis: Die  Deklaration von ¯Ersatzroutinen® fr
             _graphfreemem muá  exakt in  der unter  ¯Definition®
             gezeigten Form geschehen.
Ergebnis     _graphfreemem hat kein direktes Funktionsergebnis.
Beispiel     #include <graphics.h>
             #include <ext.h>
             #include <stdio.h>

             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                initgraph(&graphdriver, &graphmode, "");
                settextstyle(GOTHIC_FONT, HORIZ_DIR, 4);
                outtextxy(100, 100, "Textausgabe");
                getch();
                closegraph();
             }
             void *_graphgetmem(unsigned size)
             {
               printf("Aufruf _graphgetmem: %d Bytes\\n", size);
               getch();
               return(malloc(size));
             }

             void _graphfreemem(void *ptr, unsigned size)
             {
               printf("Aufruf _graphfreemem: %d Bytes\\n", size);
               getch();
               free(ptr);
             }
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Kontrolle\#
Querverweis  \#setgraphbufsize\#, \#_graphgetmem\#
\end

screen( capsensitive("_graphgetmem") )
Name         ¯graphics get  memory® -  vom Grafikpaket verwendete
             Routine zur dynamischen Belegung von Speicherplatz.

Definition   void *_graphgetmem(unsigned size);

Prototyp in  graphics.h

Beschreibung _graphgetmem belegt  ber den Aufruf von malloc size
             Bytes auf  dem Heap  und liefert  einen  Zeiger  auf
             diesen Bereich zurck.
             Die  Routine   des   Grafikpakets   rufen   malloc
             ausschlieálich ber  diese beide  Funktion auf,  die
             sich durch  eine eigene Version ersetzen l„át, damit
             hat  der   Programmierer  die   Kontrolle  ber  die
             dynamische Speicherverwaltung der Grafik.
             Hinweis: Die  Deklaration von ¯Ersatzroutinen® fr
             _graphgetmem muá  exakt in  der  unter  ¯Definition®
             gezeigten Form geschehen.
Ergebnis     _graphgetmem liefert  einen untypisierten Zeiger auf
             die  Startadresse   des   belegten   Speicherplatzes
             zurck.
Beispiel     siehe \#_graphfreemem\#
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \#Kontrolle\#
Querverweis  \#setgraphbufsize\#, \#_graphfreemem\#
\end

screen( capsensitive("graphresult") )
Name         ¯graphics result®  - liefert  den  Fehlerstatus  der
             letzten Grafikoperation zurck.

Definition   int graphresult(void);

Prototyp in  graphics.h

Beschreibung Das Grafikpaket  hat  einen  Status,  der  bei  I/O-
             Operationen (d.h.  Laden von Grafiktreibern und Zei-
             chens„tzen)  sowie  durch  Fl„chenfllungen  gesetzt
             wird. Dieser  Status kann  mit graphresult abgefragt
             werden:  der   Wert  0   steht   fr   ¯fehlerfreie®
             Ausfhrung, Werte kleiner 0 zeigen einen Fehler an.
             Der  Statuscode   wird  durch  Zeichenbefehle  wie
             \#lineto\# nicht beeinfluát:
              /* Status durch Aufruf von settextstyle gesetzt */
              settextstyle(GOTHIC_FONT, HORIZ_DIR, 1);
              setviewport(0,0,getmaxx(),getmaxy(),0);  /*
              unver„ndert */
              lineto(100,100);      /* unver„ndert */
              floodfill(10,10,RED);  /* Status wird neu gesetzt */
             Der Aufruf  von  graphresult  setzt  den  Statuscode
             automatisch auf  0  zurck.  Mehrere  Prfungen  des
             Statuscodes  mssen   deshalb  ber  eine  tempor„re
             Variable geschehen:
             int errcode;

             main()
             { int errcode;
               ...

               errcode = graphresult();  /* Lesen und
                                            Zwischenspeichern */
               if (errcode)
                 {
                   printf("Fehler %s\\n", grapherrormsg(errcode));
                   exit(1);
                 }
               ...

             Die  folgenden   Fehlercodes  und   Meldungen   sind
             definiert:

             Name       Wert Text/Beschreibung
             --------------------------------------------------------
             grOk               0 No error - fehlerfreie Ausfhrung
             grNoInitGraph     -1 (BGI) graphics not installed (use
                                  initgraph) - Grafiktreiber nicht
                                  initialisiert - initgraph muá zuerst
                                  aufgerufen werden
             grNotDetected     -2 Graphics hardware not detected -
                                  kein grafikf„higer Adapter vorhanden/
                                  gewnschter Modus wird nicht untersttzt
             grNoLoadMem       -5 Not enough memory to load driver - nicht
                                  genug Speicherplatz fr den
                                  Grafiktreiber
             grNoScanMem       -6 Out of memory in scan fill - nicht genug
                                  Speicherplatz (bar, fillpoly)
             grNoFloodMem      -7 Out of memory in flood fill - nicht
                                  genug Speicherplatz (floodfill)
             grFontNotFound    -8 Font file not found -
                                  Zeichensatzdatei nicht gefunden
             grNoFontMem       -9 Not enough memory to load font - nicht
                                  genug Speicherplatz fr den Zeichensatz
             grError          -11 Generic Error - nicht n„her
                                  klassifizierbarer Fehler
             grIOerror        -12 Graphics I/O error - Ein-/Ausgabefehler
                                  beim Laden von Dateien
             grInvalidFont    -13 Invalid font file - keine
                                  Zeichensatz-Datei (falsche Version,
                                  Datei zerst”rt...)
             grInvalidFontNum -14 Invalid font file number -
                                  Kennziffer fr Zeichensatz nicht
                                  definiert
             --------------------------------------------------------
Ergebnis     graphresult liefert  den momentanen  Statuscode  des
             Grafikpakets (m”gliche Werte von -0 bis -14).
Beispiel     siehe \#grapherrormsg\#
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Kontrolle\#
Querverweis  \#initgraph\#, \#grapherrormsg\#
\end

screen( capsensitive("imagesize") )
Name         ¯image   size®   -   berechnet   die   Gr”áe   einer
             Puffervariablen    zur     Speicherung    grafischer
             Bildausschnitte.

Definition   unsigned long imagesize(int left, int top, int right,
                                int bottom);

Prototyp in  graphics.h

Beschreibung imagesize berechnet  die Anzahl  von Bytes,  die zur
             Speicherung  eines   Bildausschnitts  mit   \#getimage\#
             ben”tigt  werden   (und  bercksichtigt   die   vier
             ¯Extrabytes® fr die H”he und Breite des Rechtecks):
              pixelzahl = breite * hoehe;
              bytezahl = (pixelzahl * bits_pixel) / 8;
             bits_pixel steht  hier fr  die Anzahl von Bits, die
             zur Speicherung eines einzelnen Punktes erforderlich
             sind.
Beispiel     siehe \#getimage\#
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#getpixel\#, \#getimage\#
\end

screen( capsensitive("initgraph") )
Name         ¯initialize   graphics®    -    initialisiert    das
             Grafikpaket und setzt einen Grafikmodus.

Definition   void  initgraph(int  *graphdriver,  int  *graphmode,
                             char *pathtodriver);

Prototyp in  graphics.h

Beschreibung initgraph   initialisiert    das   Grafikpaket   via
             \#graphdefaults\# und  schaltet in  den Grafikmodus  mit
             der h”chstm”glichen Aufl”sung. Graphdriver  gibt  an
             Welcher  Treiber verwendet wird.  Graphmode die Auf-
             l”sung.  Pathtodriver gibt den Pfad an unter dem die 
             Treiber und Fontdateien gesucht werden.
Ergebnis     initgraph hat kein direktes Funktionsergebnis
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Kontrolle\#
Querverweis  \#detectgraph\#
\end

screen( capsensitive("installuserdriver") )
Name         ¯install  unser   driver®  -  zur  Installation  von
             Grafiktreibern,  die   nicht  direkt   von   Borland
             angeboten werden.

Definition   int   installuserdriver(char *name, int (*detect)(void));

Prototype in graphics.h

Beschreibung Die Funktion installuserdriver installiert einen
             neuen BGI-Treiber. Der Dateiname des Treibers mu
             im Parameter name stehen (die Angabe der Endung
             .BGI ist nicht notwendig). detect ist ein Zeiger
             auf eine parameterlose Funktion, die einen Grafik-
             modus (vom Typ int) fr den Treiber zurckgibt oder
             einen Fehlercode (z.B. grError ).
             Falls es keine Funktion zur Feststellung von Grafik-
             hardware gibt, kann fr detect auch 0 bergeben
             werden.
             installuserdriver liefert als Ergebnis den Fehler-
             code grError, falls keine weiteren Treiber mehr
             installiert werden k”nnen, oder eine Kennummer fr
             den Treiber.

Beispiel     #include <stdio.h>
             #include <stdlib.h>
             #include <graphics.h>

             int  DetectWhatEver( void )
             {
                 /* recommended graphics mode: */
                 return( 2 );
             }
 
             int  main( void )
             {
                 int  driver, mode;

                 driver = installuserdriver( "WHATEVER", DetectWhatEver );
                 if ( driver == grError )
                      exit( 1 );
                 driver = DETECT;
                 initgraph( &driver, &mode, "" );
                 outtextxy( 50, 50, "This is the WHATEVER driver!" );
                 getchar( );
                 closegraph( );
                 return( 0 );
             }

Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.

Gruppe       \#Kontrolle\#

Querverweis  \#installuserfont\#
\end

screen( capsensitive("installuserfont") )
Name         ¯install user  font® -  zur Installation von Vektor-
             Zeichens„tzen,  die   nicht   direkt   von   Borland
             angeboten werden.

Definition   int installuserfont(char *name);

Prototyp in  graphics.h

Beschreibung Mit installuserfont  kann das Grafikpaket um Vektor-
             Zeichens„tze erweitert  werden, die  sich  nach  der
             ¯Installation® wie  die  Standard-Zeichens„tze  ber
             \#settextstyle\# aktivieren lassen.
             Die Funktion erwartet als Parameter name den Namen
             des Zeichensatzes,  der auch  unter diesem Namen als
             *.CHR-Datei charakterisiert ist.
             installuserfont  prft  die  als  name  angegebene
             Datei (wobei  die Endung  .CHR automatisch angeh„ngt
             wird) und  liefert einen  Integer als  Ergebnis, der
             von   \#settextstyle\#   als   Kennziffer   fr   diesen
             Zeichensatz verwendet werden kann.
             Mit   installuserfont    k”nnen   maximal    zwanzig
             zus„tzliche   Zeichens„tze    in   einem    Programm
             installiert werden.
Ergebnis     installuserfont liefert einen Integer zurck, der im
             weiteren  Programmverlauf  als  Kennziffer  fr  den
             entsprechenden Zeichensatz  interpretiert wird. Wenn
             die  Zeichensatz-Tabelle   des  Grafikpakets  keinen
             weiteren Eintrag  mehr aufnehmen  kann, liefert  die
             Funktion das Ergebnis grError (d.h. den Wert -11).
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Kontrolle\#
Querverweis  \#installuserdriver\#
\end

screen( capsensitive("line"),
		capsensitive("line (BGI)") )
Name         ¯line® - zeichnet eine Linie.

Definition   void line(int x0, int y0, int x1, int y1);

Prototyp in  graphics.h

Beschreibung line  verwendet   die  mit   \#setlinestyle\#   gesetzte
             Linienart,  -dicke   und  -farbe   sowie   den   mit
             \#setwritemode\# festgelegten  Schreibmodus (¯Copy® oder
             XOR).
             line zeichnet  eine Linie  vom Punkt  (x0,y0)  zum
             Punkt  (x1,y1),  ohne  den  Grafik-Cursor  dabei  zu
             bewegen.
Ergebnis     line hat kein direktes Ergebnis.
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#linerel\#, \#lineto\#, \#setlinestyle\#, \#setwritemode\#
\end

screen( capsensitive("linerel") )
Name         ¯line relative®  - zeichnet  eine Linie  relativ zur
             momentanen Position des Grafik-Cursors.

Definition   void linerel(int dx, int dy);

Prototyp in  graphics.h

Beschreibung linerel  verwendet  die  mit  \#setlinestyle\#  gesetzte
             Linienart,  -dicke   und  -farbe   sowie   den   mit
             \#setwritemode\# festgelegten  Schreibmodus (¯Copy® oder
             XOR).
             linerel interpretiert  die als  dx, dy bergebenen
             Werte  als   relative  Entfernung   zur   momentanen
             Position  des   Grafik-Cursors.  Die  durch  linerel
             ausgefhrte Operation ist mit den folgenden Befehlen
             identisch:
             xZiel = getx() + dx;  /* momentane X-Position plus
                                      dx */
             yZiel = gety() + dy;  /* momentane Y-Position plus
                                      dy */
             lineto(xZiel, yZiel);
             Wie bei  lineto bleibt  der Grafik-Cursor danach auf
             dem Endpunkt der Linie stehen.
Ergebnis     linerel hat kein direktes Ergebnis.
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#line\#, \#lineto\#, \#setlinestyle\#, \#setwritemode\#,
             \#linerel\#
\end

screen( capsensitive("lineto") )
Name         ¯line to®  - zeichnet  eine Linie von der momentanen
             Position des Grafik-Cursors zum angegebenen Punkt.

Definition   void lineto(int x, int y);

Prototyp in  graphics.h

Beschreibung lineto  verwendet   die  mit  \#setlinestyle\#  gesetzte
             Linienart,  -dicke   und  -farbe   sowie   den   mit
             \#setwritemode\# festgelegten  Schreibmodus (¯Copy® oder
             XOR).
             lineto zeichnet  eine  Linie  von  der  momentanen
             Position des  Grafik-Cursors zum  Punkt  (x,y).  Der
             Grafik-Cursor bleibt  danach  auf  dem  Punkt  (x,y)
             stehen.
Ergebnis     lineto hat kein direktes Ergebnis.
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#line\#, \#linerel\#, \#setlinestyle\#, \#setwritemode\#
\end

screen( capsensitive("moverel") )
Name         ¯move relative®  - bewegt  den Grafik-Cursor relativ
             zu seiner momentanen Position.

Definition   void moverel(int dx, int dy);

Prototyp in  graphics.h

Beschreibung moverel interpretiert  die als  dx,  dy  bergebenen
             Werte als  relativen Abstand zur momentanen Position
             und entspricht den folgenden Befehlen:
              xZiel = getx() + dx;   /* momentane X-Position plus
                                        dx */
              yZiel = gety() + dy;   /* momentane Y-Position plus
                                        dy */
              moveto(xZiel, yZiel);
             moverel  arbeitet   relativ   zu   einem   eventuell
             gesetzten Zeichenfenster.
Ergebnis     moverel liefert keinen Wert zurck.
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#line\#, \#moveto\#
\end

screen( capsensitive("moveto") )
Name         ¯move  to®  -  setzt  den  Grafik-Cursor  auf  einen
             bestimmten Punkt.

Definition   void moveto(int x, int y);

Prototyp in  graphics.h

Beschreibung moveto setzt den Grafik-Cursor auf den Punkt (x,y).
             moveto arbeitet relativ zu einem eventuell gesetzten
             Zeichenfenster.
Ergebnis     moveto hat kein direktes Ergebnis.
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#line\#, \#moverel\#
\end

screen( capsensitive("outtext") )
Name         ¯out text®  - gibt  Text ab  der momentanen Position
             des Grafik-Cursors aus.

Definition   void outtext(char *textstring);

Prototyp in  graphics.h

Beschreibung outtext gibt  den als  textstring bergebenen String
             ab der  momentanen Position  des Grafik-Cursors aus.
             Ein automatischer  Umbruch wie  im Textmodus  findet
             nicht  statt:   Ausgaben,  die  ber  den  Rand  des
             Bildschirms    bzw.     des    momentan    gesetzten
             Zeichenfensters   hinausgehen    wrden,   schneidet
             outtext einfach ab.
             outtext benutzt  die Schriftart  und Formatierung,
             die durch \#settextstyle\# (Schriftart, Rotation, Gr”áe)
             und    \#settextjustify\#    (linksbndig,    zentriert,
             rechtsbndig) vorgegeben ist. Damit das Programm bei
             einem  Wechsel   der  Schriftart  und  -gr”áe  nicht
             modifiziert  werden   muá,  sollte  der  Platzbedarf
             auszugebender  Strings   immer  ber  \#textwidth\#  und
             \#textheight\# berechnet werden.
             Solange  nicht   mit  Rotation   gearbeitet  wird,
             ver„ndert  outtext  die  X-  und  Y-Komponenten  des
             Grafik-Cursors  abh„ngig   von  der   Justierung  in
             folgender Weise:
             -  alle  Kombinationen   mit   LEFT_TEXT   fr   die
                horizontale Formatierung:
              GCX += textwidth(textstring);
              GCY += 0;    /* unver„ndert */
Ergebnis     outtext liefert einen Wert zurck.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */

                initgraph(&graphdriver, &graphmode, "");

                /* Markiert die Startposition des Cursors */
                settextjustify(CENTER_TEXT, TOP_TEXT);
                moveto(200,100); outtext("Start");
                moveto(200,100); lineto(200,50);

                /* Die "Experimentierzeile" */
                settextjustify(LEFT_TEXT, BOTTOM_TEXT);

                outtext("Eine Textzeile");

                /* Markiert die Endposition des Cursors */
                settextjustify(CENTER_TEXT, TOP_TEXT);
                lineto(400,100); outtext("Ende");

                getch();
                closegraph();
             }
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#gettextsettings\#,     \#settextjustify\#,     \#textheight\#,
             \#outtextxy\#
\end

screen( capsensitive("outtextxy") )
Name         ¯out text  at x/y®  - grafische Textausgabe ab einem
             bestimmten Punkt.

Definition   void outtextxy(int x, int y, char *textstring);

Prototyp in  graphics.h

Beschreibung outtextxy gibt den als textstring bergebenen String
             ab der  Position (x,y) aus. Die Position des Grafik-
             Cursors wird dabei nicht ver„ndert.
Ergebnis     outtextxy hat kein direktes Ergebnis.
Beispiel     siehe \#outtext\#
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#gettextsettings\#, \#settextjustify\#, \#textheight\#, \#outtext\#
\end

screen( capsensitive("pieslice") )
Name         ¯pie   slice®    -   zeichnet    ein    ausgeflltes
             ¯Kuchenstck®.

Definition   void pieslice(int x, int y, int stangle, int endangle,
                           int radius);

Prototyp in  graphics.h

Beschreibung pieslice  zeichnet   ein  Kreisbogenstck   in   der
             momentan gesetzten  Zeichenfarbe, dessen Mittelpunkt
             durch  (x,y)   angegeben  ist;   stangle  legt   den
             Startpunkt  des  mit  radius  gezogenen  Kreisbogens
             fest,  endangle   sein  Ende.   Die  Endpunkte   des
             Kreisbogens   werden    mit   dem   Kreismittelpunkt
             verbunden, danach  fllt  pieslice  das  entstandene
             ¯Kuchenstck®  mit  dem  durch  \#setfillpattern\#  bzw.
             \#setfillstyle\# festgelegten  Muster (und  in der  dort
             angegebenen Farbe).
Ergebnis     pieslice hat  kein direktes  Ergebnis. Wenn  w„hrend
             der Ausfhrung  ein  Fehler  auftritt,  liefert  der
             n„chste Aufruf von \#graphresult\# den Wert grNoScanMem.
Beispiel     siehe \#arc\#
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#arc\#, \#circle\#,  \#ellipse\#,  \#fillellipse\#,  \#getarccoords\#,
             \#sector\#
\end

screen( capsensitive("putimage") )
Name         ¯put image®  -  kopiert  den  Inhalt  eines  Puffers
             bitweise in einen rechteckigen Bildausschnitt, wobei
             logische  Verknpfungen   mit  dem   Inhalt   dieses
             Ausschnitts m”glich sind.

Definition   void putimage(int x, int y, void *bitmap, int op);

Prototyp in  graphics.h

Beschreibung putimage   kopiert    einen   zuvor   mit   \#getimage\#
             gespeicherten Bildausschnitt,  wobei (left,top)  die
             obere linke  Ecke des  ¯Zielbereichs® festlegt.  Fr
             den Parameter  op sind  die folgenden  Konstanten in
             graphics.h definiert:

             Name    Wert  Beschreibung
             --------------------------------------------------------
             COPY_PUT  0   Kopie (šberschreiben des ¯Zielbereichs®)
             XOR_PUT   1   XOR-Operation mit dem ¯Zielbereich®
             OR_PUT    2   OR-Operation
             AND_PUT   3   AND-Operation
             NOT_PUT   4   NOT-Operation und šberschreiben
             --------------------------------------------------------
Ergebnis     putimage hat kein direktes Funktionsergebnis.
Beispiel     siehe \#getimage\#
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#getimage\#, \#imagesize\#
\end

screen( capsensitive("putpixel") )
Name         ¯put  pixel®   -  zeichnet   einen  Punkt   auf  den
             angegebenen Koordinaten.

Definition   void putpixel(int x, int y, int pixelcolor);

Prototyp in  graphics.h

Beschreibung putpixel zeichnet  einen Punkt  mit der  Farbe color
             auf dem Punkt (x,y).
Ergebnis     putpixel hat kein Funktionsergebnis.
Beispiel     siehe \#getpixel\#
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#getpixel\#
\end

screen( capsensitive("rectangle") )
Name         ¯rectangle® - zeichnet ein Rechteck.

Definition   void rectangle(int  left, int  top, int  right,
                            int bottom);

Prototyp in  graphics.h

Beschreibung rectangle zeichnet  ein Rechteck, dessen obere linke
             Ecke durch (left, top) und dessen untere rechte Ecke
             durch (right,  bottom)  festgelegt  ist,  wobei  die
             durch \#setlinestyle\# gesetzten Parameter (Linienart, -
             dicke und -farbe) verwendet werden.
             Fr  die   Eckpunkte  des   Rechtecks  gelten  die
             folgenden Beziehungen:
              0 <= left <= right <= getmaxx();
              0 <= top <= bottom <= getmaxy();
             Etwas weniger  technisch: Alle  vier  Eckpunkte  des
             sich  ergebenden   Rechtecks  mssen  innerhalb  der
             Bildschirmgrenzen liegen, wobei sich die obere linke
             Ecke  tats„chlich   ¯links  oberhalb®   der  unteren
             rechten Ecke  befinden muá  -  einen  Austausch  von
             Wertepaaren   (d.h.    ein   ¯Umdrehen®   der   Zei-
             chenrichtung) fhrt rectangle nicht aus.
Ergebnis     rectangle liefert keinen Wert zurck.
Beispiel     #include <graphics.h>
             #include <ext.h>

             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int x, centerx, centery;

                initgraph(&graphdriver, &graphmode, "");
                centerx = getmaxx() / 2; centery = getmaxy() / 2;

                for (x = 10; x < centery; x += 20)
                  rectangle(centerx-x, centery-x, centerx+x,
                  centery+x);
                getch();
                closegraph();
             }
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#bar\#
\end

screen( capsensitive("registerbgidriver") )
Name         ¯register BGI  driver® - Registrierung eines als .O-
             Datei eingebundenen Grafiktreibers.

Definition   int  registerbgidriver( void (*driver)( void ));

Prototype in graphics.h

Beschreibung Die Funktion registerbgidriver meldet einen Treiber
             als resident im Speicher vorhanden an. Dazu wird die
             Startadresse des Treibers im Parameter driver ber-
             geben. Als Resultat erh„lt man die Kennummer des
             Treibers oder im Fehlerfall einen negativen Wert.

             Man kann einen Treiber einfach per \#fread\# in einen
             zuvor allozierten Speicherblock laden oder mittels
             des Programms \#BGIOBJ\# in eine Objektdatei kon-
             vertieren und diese dann in der Projektdatei ange-
             ben, um sie in sein eigenes Programm einzubinden.

Beispiel     #include <stdio.h>
             #include <stdlib.h>
             #include <graphics.h>

             extern void VdiDriver( void );

             int  main( void )
             {
                 int  mode, driver;

                 if ( registerbgidriver( VdiDriver ) < 0 )
                     exit( 1 );
                 driver = VDI;
                 mode = VDIMODE;
                 initgraph( &driver, &mode, "" );
                 outtextxy( 100, 100, "This driver is registered!" );
                 getchar( );
                 closegraph( );
                 return( 0 );
             }

Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.

Gruppe       \#Kontrolle\#
\end

screen( capsensitive("registerbgifont") )
Name         ¯register BGI  font® -  Registrierung eines  als .O-
             Datei eingebundenen Grafik-Zeichensatzes.

Definition   int registerbgifont(void (*font)(void));

Prototyp in  graphics.h

Beschreibung registerbgifont erwartet  die Adresse  eines als .O-
             Datei direkt  in das  Programm eingebundenen Grafik-
             Zeichensatzes und  tr„gt diesen  Zeichensatz in eine
             interne Tabelle  fr  \#settextstyle\#  ein.  Auf  diese
             Weise ¯registrierte®  Zeichens„tze werden nicht mehr
             als .CHR-Dateien  auf der  Diskette gesucht  und auf
             den Heap geladen, sondern direkt verwendet.
             Hinweis: Da  die  Zeichens„tze  nur  indirekt  von
             anderen Routinen  angesprochen werden,  erfllt  der
             Aufruf  der   ¯Registrierfunktion®  einen   weiteren
             Zweck: er  teilt  dem Linker von Pure C mit, daá die
             entsprechende   .O-Datei   mit   in   das   Programm
             aufgenommen werden muá.
Ergebnis     registerbgifont    liefert     die    Nummer     des
             ¯registrierten®    Grafik-Zeichensatzes.    Negative
             Funktionsergebnisse entsprechen  den Statuscodes des
             Grafikpakets und zeigen einen Fehler an.
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Kontrolle\#
Querverweis  \#initgraph\#,      \#getgraphmode\#,       \#gettextsettings\#,
             \#registerbgifont\#
\end

screen( capsensitive("restorecrtmode") )
Name         ¯restore CRT mode® - l”scht den Bildschirm.

Definition   void restorecrtmode(void);

Prototyp in  graphics.h

Beschreibung Auf   dem    Atari   wird    diese   Funktion    zum
             Bildschirml”schen benutzt.
             Unter  MS-DOS   hat  restorecrtmode  die  Aufgabe,
             zwischen Grafik- und Textmodus umzuschalten.
Ergebnis     restorecrtmode liefert keinen Wert zurck.
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \#Kontrolle\#
Querverweis  \#initgraph\#, \#setgraphmode\#
\end

screen( capsensitive("sector") )
Name         ¯sector® -  zeichnet ein  ausgeflltes  elliptisches
             ¯Kuchenstck®

Definition   void sector(int x, int y, int stangle, int endangle,
                             int xradius, int yradius);

Prototyp in  graphics.h

Beschreibung sector erfllt  dieselbe Funktion  wie pieslice  fr
             Ellipsen - der einzige Unterschied liegt hier darin,
             daá (wie bei \#ellipse\#) mit separaten Radien in X- und
             Y-Richtung gearbeitet wird.
Ergebnis     sector hat  kein direktes Ergebnis. Wenn w„hrend der
             Ausfhrung ein  Fehler auftritt, liefert der n„chste
             Aufruf von \#graphresult\# den Wert grNoScanMem.
Beispiel     siehe arc
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen..
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#arc\#,  \#circle\#,  \#ellipse\#,  \#fillellipse\#,  \#getarccoords\#,
             \#pieslice\#
\end

screen( capsensitive("setactivepage") )
Name         ¯set active  page® -  legt fest, auf welcher Grafik-
             speicherseite folgende Zeichenbefehle arbeiten.

Definition   void setactivepage(int pagenum);

Prototyp in  graphics.h

Beschreibung setactivepage ist fr das Atari BGI nicht notwendig,
             da es nur eine Grafikspeicherseite gibt.
Portabilt„t  Diese Funktion  ist nur  verfgbar, um kompatibel zu
             anderen BGI-Treibern zu bleiben.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#setvisualpage\#
\end

screen( capsensitive("setallpalette") )
Name         ¯set all  palette® -  setzt s„mtliche Eintr„ge einer
             Farb-Palette.

Definition   void setallpalette(struct palettetype *palette);

Prototyp in  graphics.h

Beschreibung setallpalette setzt  mit der als palette bergebenen
             Struktur  s„mtliche   Eintr„ge  einer  Farb-Palette,
             wobei size  hier festlegt, wieviele Eintr„ge (ab dem
             ersten, also  der ¯Farbe  0®) gesetzt werden sollen.
             Jedes  Element   des  Arrays  colors  ersetzt  einen
             Eintrag der  Farb-Palette und  kann einen Wert von -
             1..63 haben.  Der ¯Farbwert®  1  bedeutet,  daá  der
             korrespondierende    Eintrag     der     Farbpalette
             unver„ndert bleiben soll.
Ergebnis     setallpalette hat kein direktes Ergebnis.
Beispiel     siehe \#getpalette\#
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getbkcolor\#, \#getcolor\#, \#getdefaultpalette\#, \#getpalette\#,
             \#setpalette\#
\end

screen( capsensitive("setaspectratio") )
Name         ¯set aspect  ratio® -  ver„ndert den Korrekturfaktor
             fr das H”hen-/Seitenverh„ltnis des Bildschirms.

Definition   void setaspectratio(int xasp, int yasp);

Prototyp in  graphics.h

Beschreibung Die Funktion setaspectratio ist nicht notwendig. Der
             Faktor ist  immer  1,  da  man  unter  TOS  nur  das
             Seitenverh„ltnis,  nicht  aber  das  H”henverh„ltnis
             explizit einstellen kann.
Portabilt„t  Diese Funktion  ist nur  verfgbar, um kompatibel zu
             anderen BGI-Treibern zu bleiben.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#getaspectratio\#
\end

screen( capsensitive("setbkcolor") )
Name         ¯set background  color® - setzt die Hintergrundfarbe
             des Bildschirms.

Definition   void setbkcolor(int color);

Prototyp in  graphics.h

Beschreibung setbkcolor setzt den Inhalt des ersten Eintrages der
             Farbpalette auf  den Wert  color. Dieser Eintrag ist
             fr  die  Hintergrundfarbe  des  Bildschirmspeichers
             verantwortlich. Die  Konstanten sind  in  graphics.h
             folgendermaáen definiert:

             Wert  Name      Wert  Name
             --------------------------------------------------------
             0     BLACK      8    DARKGRAY
             1     BLUE       9    LIGHTBLUE
             2     GREEN     10    LIGHTGREEN
             3     CYAN      11    LIGHTCYAN
             4     RED       12    LIGHTRED
             5     MAGENTA   13    LIGHTMAGENTA
             6     BROWN     14    YELLOW
             7     LIGHTGRAY 15    WHITE
             --------------------------------------------------
             Hinweis: Im  Gegensatz zur  Funktion setcolor, die
             die Zeichenfarbe nachfolgender Operationen festlegt,
             hat setbkcolor eine unmittelbare Wirkung.
Ergebnis:    setbkcolor hat kein Funktionsergebnis.
Beispiel     siehe \#setcolor\#
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getpalette\#, \#initgraph\#, \#setcolor\#
\end

screen( capsensitive("setcolor") )
Name         ¯set  color®   -  setzt   die  Farbe  fr  folgenden
             Zeichenaktionen.

Definition   void setcolor(int color);

Prototyp in  graphics.h

Beschreibung setcolor   legt   fest,   welcher   Paletten-Eintrag
             zuknftig als Zeichenfarbe verwendet werden soll.
Ergebnis     setcolor liefert  die Nummer  des Paletten-Eintrags,
             der momentan  als Zeichenfarbe gesetzt ist. setcolor
             hat kein Funktionsergebnis.
Beispiel     #include <graphics.h>
             #include <stdlib.h>
             #include <ext.h>
             main()
             {
                int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int color;

                initgraph(&graphdriver,&graphmode,"");

                /* Linien mit wechselnder Farbe und
                   gleichbleibendem Hintergrund */
                while (!kbhit())
                 { color = getcolor();
                   if (++color > getmaxcolor())   color = 0;
                   setcolor(color);
                   lineto(random(getmaxx()) + 1),
                          random(getmaxy()) + 1));
                  }
                getch();
                closegraph();
             }

Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getbkcolor\#, \#getpalette\#, \#getmaxcolor\#, \#setbkcolor\#
\end

screen( capsensitive("setfillpattern") )
Name         ¯set fill pattern® - erm”glicht die freie Definition
             von Mustern fr Fl„chenfllungen.

Definition   void setfillpattern(char *pattern, int color);

Prototyp in  graphics.h

Beschreibung setfillpattern definiert  das ausgew„hlte Muster und
             die Zeichenfarbe  fr die  Aufrufe von  \#fillellipse\#,
             \#fillpoly\#,  \#floodfill\#,   \#bar\#,   \#bar3d\#,   \#sector\#   und
             \#pieslice\#.
             pattern ist ein Zeiger auf eine Folge von 8 Bytes,
             bei dem  jedes Bit  fr ein Pixel in der durch color
             festgelegten Farbe steht.
Ergebnis     setfillpattern hat kein Ergebnis.
Beispiel     siehe \#setfillstyle\#
Portabilit„t Auf allen  Systemen, die BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#getfillsettings\#, \#setfillstyle\#
\end

screen( capsensitive("setfillstyle") )
Name         ¯set fill  style® -  setzt ein vordefiniertes Muster
             zur Fl„chenfllung.

Definition   void setfillstyle(int pattern, int color);

Prototyp in  graphics.h

Beschreibung setfillstyle erwartet einen dieser Werte als pattern
             und setzt das entsprechende Bitmuster.
             Hinweis:  Um  ein  benutzerdefiniertes  Fllmuster
             (USER_FILL, Wert  12) zu  setzen, muá \#setfillpattern\#
             verwendet werden.
Ergebnis     setfillstyle hat  kein direktes Ergebnis. Ein Aufruf
             von  setfillstyle   mit  einem   Wert  fr   pattern
             auáerhalb  des   Bereichs  0..11   wird  als  Fehler
             gewertet: das  momentan gesetzte  Fll-Muster bleibt
             in  diesen  F„llen  unver„ndert,  ein  nachfolgender
             Aufruf von \#graphresult\# liefert den Wert -grError.
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {  int graphdriver = DETECT; /* automatische */
                int graphmode;              /* Erkennung */
                struct fillsettingstype save;
                char savepattern[8];
                char checkboard[] = { 0x0F, 0xF0, 0x0F, 0xF0,
                                      0x0F, 0xF0, 0x0F, 0xF0 };

                initgraph(&graphdriver, &graphmode, "");

                /* momentan gesetztes Muster ermitteln */
                getfillsettings(&save);       /* Muster
                                                 speichern */
                if (save.pattern == USER_FILL)
                                     /* benutzerdefiniert? */
                  getfillpattern(savepattern);  /* -> ja,
                                           Bitmuster lesen */

                setfillstyle(SLASH_FILL, BLUE);  /* /////, blau */
                bar (0,0,100,100);               /* Balken
                                                    zeichnen */

                setfillpattern(checkboard, YELLOW); /* eigenes
                                                       Muster */
                bar (100,100,200,200);    /* noch ein Balken */

                /* und das alte Muster wieder setzen */
                if (save.pattern == USER_FILL)
                  setfillpattern(savepattern, save.color);
                 else
                  setfillstyle(save.pattern, save.color);

                getch();
                closegraph();
             }
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#arc\#,    \#fillpoly\#,     \#floodfill\#,     \#getfillpattern\#,
             \#getfillsettings\#
\end

screen( capsensitive("setgraphbufsize") )
Name         ¯set graphics  buffer size®  - legt  die  Gr”áe  des
             Puffers fr Fl„chenfllungen und Polygone fest.

Definition   unsigned setgraphbufsize(unsigned bufsize);

Prototyp in  graphics.h

Beschreibung Fr   Fl„chenfllungen   und   Polygone   wird   von
             setgraphbufsize die  Gr”áe eines Puffers festgelegt.
             Diese Funktion ist unter TOS nicht notwendig, da der
             Speicherplatz intern verwaltet wir.
Portabilt„t  Diese Funktion  ist nur  verfgbar, um kompatibel zu
             MS-DOS zu sein.
Gruppe       \#Kontrolle\#
\end

screen( capsensitive("setgraphmode") )
Name         ¯set graphics  mode® - schaltet in einen Grafikmodus
             um und l”scht den Bildschirm.

Definition   void setgraphmode(int mode);

Prototyp in  graphics.h

Beschreibung setgraphmode  schaltet   immer   in   den   h”chsten
             Grafikmodus.     Bei     Monochrommonitoren     wird
             grunds„tzlich STHIGH  zurckgegeben, da  es  hierfr
             nur  einen  Aufl”sungsmodus  gibt  (hohe  Aufl”sung,
             STHIGH 640x400).
             Bei Farbmonitoren  schaltet  setgraphmode  in  den
             mittleren Grafikmodus  STMEDIUM (640x200),  da  dies
             bei Farbmonitoren die h”chste Aufl”sung ist.
             Ist  der   Grafikmodus  eingeschaltet   wird   der
             Bilschirm gel”scht.
Ergebnis     setgraphmode  liefert   die  Nummer   des   momentan
             gesetzten Grafikmodus zurck.
Portabilit„t Diese Funktion  ist kompatibel  zu allen Systemen,
             die BGI untersttzen.
Gruppe       \#Kontrolle\#  \#initgraph\#  \#getgraphmode\#
\end

screen( capsensitive("setlinestyle") )
Name         ¯set line  style® -  setzt die  Linienart und -dicke
             fr folgende Zeichenaktionen.

Definition   void setlinestyle(int linestyle, unsigned upattern,
                               int thickness);

Prototyp in  graphics.h

Beschreibung setlinestyle  setzt   die  Linienart   fr  folgende
             Zeichenoperationen  mit   \#line\#,  \#lineto\#,  \#rectangle\#,
             \#drawpoly\#, \#arc\#,  \#circle\#, \#ellipse\#,  \#pieslice\# usw.  Der
             Parameter upattern  hat hier  nur dann eine Wirkung,
             wenn linestyle den Wert USERBIT_LINE hat - in diesem
             Fall legen  die einzelnen  Bits das  Punktmuster der
             Linie fest,  wobei das  h”chstwertige Bit  (15)  dem
             jeweils  zuerst   gezeichneten  Punkt   einer  Linie
             entspricht:  0xFFFF   fr   upattern   ergibt   eine
             durchgezogene Linie,  0x3333 eine gestrichelte Linie
             usw.
             Hinweis:  Auch  wenn  setlinestyle  den  Wert  von
             pattern fr linestyle != USERBIT_LINE ignoriert, muá
             dieser Parameter immer angegeben werden.
Ergebnis     setlinestyle hat kein direktes Ergebnis. Aufrufe von
             setlinestyle mit  einem Wert fr linestyle auáerhalb
             des Bereichs  0..4 werden  als Fehler  gewertet:  in
             diesen F„llen bleibt die momentan gesetzte Linienart
             unver„ndert,   ein    nachfolgender    Aufruf    von
             \#graphresult\# liefert das Ergebnis -11.
Beispiel       struct linesettingstype save;
               int lkind, lpattern, lthickness;
               ...
               getlinesettings(&save);
               lkind      = save.linestyle;   /* Linienart
                                                 (1..12) */
               lpattern   = save.pattern;     /* Bitmuster */
               lthickness = save.thickness;   /* Dicke (1 oder 3) */
               ...
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#getlinesettings\#, \#setwritemode\#
\end

screen( capsensitive("setpalette") )
Name         ¯set palette®  - „ndert  einen Eintrag  der momentan
             gesetzten Farb-Palette.

Definition   void setpalette(int colornum, int actual_color);

Prototyp in  graphics.h

Beschreibung setpalette  setzt   einen  einzelnen   (durch  index
             bezeichneten) Eintrag  der Farb-Palette  auf das  in
             actual_color enthaltene Bitmuster.
Ergebnis     setpalette  hat   kein   direktes   Ergebnis.   Wenn
             setpalette  mit   ungltigen  Parametern  aufgerufen
             wird,  bleibt   die  momentan  gesetzte  Farbpalette
             unver„ndert; eine  folgender Aufruf  von \#graphresult\#
             liefert in diesem Fall den Wert grError.
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                struct palettetype palette;
                int x,y;

                initgraph(&graphdriver, &graphmode, "");

                getpalette(&palette);
                for (x = 0; x <10; x++)  /* 10 Balken
                                            nebeneinander */
                  { setfillstyle(x, (x % 4) + 1);
                    bar(x * 60, 20, (x+1) * 60, 200);
                  }

                while (!kbhit())
                 { setpalette(rand() % palette.size, rand() %
                   64);
                   delay(300);  /* bunter Farbwechsel */
                 }

                /* Farb-Palette zurck aufs Original */
                setallpalette(getdefaultpalette());

                getch();
                closegraph();
             }
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
Querverweis  \#getbkcolor\#, \#getcolor\#, \#getdefaultpalette\#, \#getpalette\#,
             \#setallpalette\#
\end

screen( capsensitive("setrgbpalette") )
Name         ¯set  RGB   palette®  -  „ndert  einen  Eintrag  der
             momentan gesetzten  Farbpalette fr  den IBM-Adapter
             8450.

Definition   void setpalette(int colornum, int red,
                             int green, int blue);

Prototyp in  graphics.h

Portabilt„t  Diese Funktion  ist nur  verfgbar, um kompatibel zu
             MS-DOS zu sein.
Ergebnis     setpalette hat kein Ergebnis
Gruppe       \link("Farbmanipulation und Farb-Pal")Farbmanipulation und Farb-Paletten\#
\end

screen( capsensitive("settextjustify") )
Name         ¯set text  justification® - legt die Ausrichtung von
             Textausgaben durch outtext und outtextxy fest.

Definition   void settextjustify(int horiz, int vert);

Prototyp in  graphics.h

Beschreibung Die   durch   settextjustify   gesetzten   Parameter
             bestimmen, in  welchem Verh„ltnis  Textausgaben  mit
             \#outtext\#  zur   Position  des   Grafik-Cursors   bzw.
             Textausgaben  mit   \#outtextxy\#  zu   den  angegebenen
             Koordinaten stehen. Eine Befehlsfolge wie
              settextjustify(CENTER_TEXT, CENTER_TEXT);
              outtextxy(100,100, "ABC");
             schreibt die  Zeichen ABC so auf den Bildschirm, daá
             der Punkt  (100,100) im  Zentrum des  Buchstabens  B
             liegt.
             Fr   die   Ausrichtung   von   Texten   definiert
             graphics.h die folgenden Konstanten:

             Name        Wert  Beschreibung
             --------------------------------------------------------
             LEFT_TEXT     0   linksbndig (horiz)
             CENTER_TEXT   1   mittelzentiert (horiz und vert)
             RIGHT_TEXT    2   rechtsbndig (horiz)
             BOTTOM_TEXT   0   Cursorposition = Grundlinie (vert)
             TOP_TEXT      2   Cursorposotion = oberer Abschluá
                               (vert)
             --------------------------------------------------------
Ergebnis     settextjustify liefert keinen Wert zurck.
Beispiel     siehe \#outtext\#
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#gettextsettings\#, \#outtext\#, \#outtextxy\#
\end

screen( capsensitive("settextstyle") )
Name         ¯set  text   style®  -  legt  den  Zeichensatz,  die
             Schreibrichtung und die Gr”áe folgender Textausgaben
             fest.

Definition   void  settextstyle(int   font,  int  direction,  int
             charsize);

Prototyp in  graphics.h

Beschreibung settextstyle setzt  einen  Zeichensatz  (font),  die
             Schreibrichtung      (direction)       und       den
             Vergr”áerungsfaktor         (charsize).          Die
             Strukturkomponente  font   gibt  Auskunft  ber  den
             Zeichensatz, der zur Textausgabe verwendet wird.
Ergebnis     Wenn eine Zeichensatz-Datei durch settextstyle nicht
             fehlerfrei  geladen   werden  konnte,   liefert  ein
             nachfolgender  Aufruf   von  graphresult  eines  der
             folgenden Ergebnisse:definiert:

             Name               Wert  Beschreibung
             --------------------------------------------------------
             grFontNotFound      -8   Zeichensatz-Datei nicht
                                      gefunden
             grfNoFontMem        -9   nicht genug Speicherplatz zum
                                      Laden der Datei
             grError             -11  unspezifischer Fehler
             grIOError           -12  I/O-Fehler
             grInvalidFont       -13  keine Zeichensatz-Datei
             grInvalidFontMem    -14  Wert von font auáerhalb des
                                      Bereichs 0..4
             --------------------------------------------------------
Beispiel     #include <graphics.h>
             #include <ext.h>
             main()
             {
                int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int x,y;
                char msg[20];

                initgraph(&graphdriver, &graphmode, "");

                for (x = 1, y = 10; x < 10; x+= 2)
                 { sprintf(msg, "Faktor %d", x);
                   settextstyle(GOTHIC_FONT, HORIZ_DIR, x);
                   outtextxy(0,y, msg);
                   y += textheight(msg);
                 }
                getch();
                closegraph();
             }
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#gettextsettings\#,  \#registerbgifont\#,   \#settextjustify\#,
             \#setusercharsize\#, \#textheight\#, \#outtext\#, \#outtextxy\#
\end

screen( capsensitive("setusercharsize") )
Name         ¯set  user   character  size®   -  legt  voneinander
             unabh„ngige Vergr”áerungsfaktoren  fr die X- und Y-
             Richtung der Grafik-zeichens„tze fest.

Definition   void setusercharsize(int multx, int divx,
                                  int multy, int divy);

Prototyp in  graphics.h

Beschreibung setusercharsize erlaubt im Gegensatz zu \#settextstyle\#
             voneinander unabh„ngige  Vergr”áerungsfaktoren in X-
             und  Y-Richtung:  die  Breite  eines  Zeichens  wird
             zuerst mit multx multipliziert und danach durch divx
             dividiert. Dasselbe gilt fr die Zeichenh”he und die
             Parameter multy bzw. divy.
             Im folgenden  Beispiel wird der Text ABC mit einer
             Breite von ¯8® und einer H”he von ¯6.5® ausgegeben:
              settextstyle(GOTHIC_FONT, HORIZ_DIR, 0);
              setusercharsize(8,1,13,2);
              outtextxy(100,100,"ABC");
             Hinweis:  Wie   im  Abschnitt  ber  \#gettextsettings\#
             erl„utert,  haben   mit   setusercharsize   gesetzte
             Vergr”áerungsfaktoren nur  dann eine  Wirkung,  wenn
             zuvor  \#settextstyle\#  mit  charsize  =  0  aufgerufen
             wurde. Die  Standardvorgabe fr  setusercharsize ist
             (4,1,4,1).
Ergebnis     setusercharsize liefert keinen Wert zurck.
Beispiel     #include <graphics.h>

             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */

                char title[] = "Text in einem Rechteck";

                initgraph(&graphdriver, &graphmode, "");
                settextstyle(GOTHIC_FONT, HORIZ_DIR,
                             USER_CHAR_SIZE);

                settextjustify(CENTER_TEXT, CENTER_TEXT);
                                               /*  zentriert */
                setusercharsize(1,1,1,1);  /* fr die Berechnung */

                rectangle(0,0,200,100); /* 200 Pixel breit, 100
                                           hoch */
                setusercharsize(200, textwidth(title),
                                100, textheight(title));
                outtextxy(100,50,title); /* Ausgabe in der Mitte */

                getch();
                closegraph();
             }
Portabilt„t  Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#gettextsettings\#, \#outtext\#, \#textheight\#
\end

screen( capsensitive("setviewport") )
Name         ¯set viewport® - setzt ein Grafik-Zeichenfenster.

Definition   void setviewport(int  left, int  top, int right,
                              int bottom, int clipflag);
Prototyp in  graphics.h

Beschreibung setviewport legt mit (left,top) die obere linke Ecke
             und mit (right, bottom) die untere rechte Ecke eines
             neuen  Zeichenfensters   fest   und   arbeitet   mit
             absoluten Koordinaten. Der Aufruf
              setviewport(0,0,100,100,1);
             setzt ein  Zeichenfenster von 100 Pixeln Breite, das
             sich in  der  oberen  linken  Ecke  des  Bildschirms
             befindet -  unabh„ngig davon,  ob zuvor  ein anderes
             Zeichenfenster gesetzt war oder nicht.
             setviewport setzt  den Grafik-Cursor auf den Punkt
             (0,0)   innerhalb    des   neuen    Fensters.    Der
             ¯Fensterinhalt®  wird  durch  diese  Funktion  nicht
             ver„ndert.
             Der   Parameter    clipflag    legt    fest,    ob
             Zeichenaktionen am  Rand des  Fensters abgeschnitten
             werden sollen  (clipflag = 1) oder nicht (clipflag =
             0). Eine Befehlsfolge wie
              setviewport(0,0,100,100,1); /* Clip-Funktion aktiv */
              lineto(200,200);
             zeichnet eine  Linie vom (absoluten) Punkt (0,0) zum
             Punkt   (100,100)   -   der   restliche   Teil   der
             Zeichenaktion  (d.h.   die  Fortsetzung   zum  Punkt
             (200,200)) wird unterdrckt.
             Hinweis: Der  Grafik-Cursor selbst  ist von  einem
             ¯Clipping® nie betroffen, nur Zeichenaktionen werden
             gegebenenfalls  unterdrckt.   Im  zuvor   gezeigten
             Beispiel befindet  sich der  Grafik-Cursor nach  dem
             Aufruf von \#lineto\# auf dem absoluten Punkt (200,200).
             \#initgraph\#    und     \#setgraphmode\#    setzen    das
             Zeichenfenster   auf    den   gesamten   Bildschirm,
             entsprechen also  einem Aufruf  von  setviewport mit
             den folgenden Parametern:
              setviewport(0, 0, getmaxx(), getmaxy(), 0);
Ergebnis     setviewport hat  kein direktes  Ergebnis. Der Aufruf
             von setviewport  mit Werten,  die  die  Grenzen  des
             Bildschirms   berschreiten,   l„át   das   momentan
             gesetzte     Zeichenfenster     unver„ndert.     Ein
             nachfolgender  Aufruf  von  \#graphresult\#  liefert  in
             diesem Fall das Ergebnis grError.
Beispiel     #include <graphics.h>
             #include <ext.h>

             #define CLIPON 1

             main()
             {  int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int x, x1,y1,x2,y2;

                initgraph(&graphdriver, &graphmode, "");

                while (!kbhit())  /* ein bunter Sternenhimmel */
                 putpixel(rand() % getmaxx(), rand() % getmaxy(),
                          1 + rand() % getmaxcolor());

                getch();
                x1 = getmaxx() - 90; y1 = getmaxy() - 90;
                setcolor(RED);
                do { x2 = x1 + 80; y2 = y1 + 80;
                     setviewport(x1,y1,x2,y2,CLIPON);
                     clearviewport();
                     rectangle(40,20,80,75);
                     x1 -= getmaxy() / 10;
                     y1 -= getmaxx() / 20;
                   } while ((x1 >= 0) && (y1 >= 0));

                getch();
                closegraph();
             }
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#clearviewport\#, \#getviewsettings\#
\end

screen( capsensitive("setvisualpage") )
Name         ¯set visual  page® - w„hlt eine von mehreren Grafik-
             Speicherseiten zur Anzeige aus.

Definition   void setvisualpage(int pagenum);

Prototyp in  graphics.h

Beschreibung Das Atari BGI untersttzt nur eine Grafikseite.
Ergebnis     setvisualpage hat kein Ergebnis
Portabilt„t  Diese Funktion  ist nur  verfgbar, um kompatibel zu
             MS-DOS zu bleiben.
Gruppe       \link("Zugriffe auf Bs u. Zf")Zugriffe auf den Bildschirmspeicher und Zeichenfenster\#
Querverweis  \#setactivepage\#
\end

screen( capsensitive("setwritemode") )
Name         ¯set  write   mode®  -  legt  den  Schreibmodus  fr
             Zeichenoptionen fest.

Definition   void setwritemode(int mode);

Prototyp in  graphics.h

Beschreibung setwritemode legt  fest,  ob  Zeichenaktionen  mit
             \#line\#, \#linerel\#,  \#lineto\#, \#rectangle\#  und \#drawpoly\#  den
             vorherigen  Bildschirminhalt   direkt  berschreiben
             (¯Copy®) oder  ob dazu  eine XOR-Operation verwendet
             wird. (Im  zweiten Fall  l„át sich  die  gezeichnete
             Linie durch  einen weiteren  Zeichenbefehl im selben
             Modus ohne  Zest”rung des  Hintergrundes wieder  vom
             Bildschirm   entfernen).    Die   beiden   m”glichen
             Parameter von  setwritemode sind  in graphics.h  als
             Konstanten definiert:

             Name    Wert  Beschreibung
             --------------------------------------------------------
             COPY_PUT  0   šberschreiben durch direkte Kopie
             XOR_PUT   1   XOR-Operation mit dem vorherigen Inhalt
             --------------------------------------------------------
Ergebnis     setwritemode hat kein direktes Ergebnis.
Beispiel     struct linesettingstype save;
             int lkind, lpattern, lthickness;
             ...
             getlinesettings(&save);
             lkind      = save.linestyle;   /* Linie (1..12) */
             lpattern   = save.pattern;     /* Bitmuster */
             lthickness = save.thickness;   /* Dicke (1 oder 3) */
             ...
Portabilit„t Diese Funktion ist lauff„hig auf allen Systemen, die
             BGI untersttzen.
Gruppe       \#Zeichnen und Fl„chenfllung\#
Querverweis  \#getlinesettings\#, \#setlinestyle\#
\end

screen( capsensitive("textheight") )
Name         ¯text height®  - liefert  den vertikalen Platzbedarf
             eines Strings in Pixeln zurck.

Definition   int textheight(char *textstring);

Prototyp in  graphics.h

Beschreibung textheight  berechnet   aus   dem   als   textstring
             bergebenen String,  sowie  dem  momentan  gesetzten
             Zeichensatz   und    dem   Vergr”áerungsfaktor   den
             vertikalen Platzbedarf einer Textzeile.
             Achtung: Anders  als  fr  die  Vektorzeichens„tze
             gibt  es   fr  den   Standardzeichensatz  nur  zwei
             verschiedene Texth”hen. Wird der Vergr”áerungsfaktor
             auf 0  oder 1 gesetzt, so wird der Text mit 10 Pixel
             H”he     ausgegeben,      fr      alle      anderen
             Vergr”áerungsfaktoren mit 32 Pixel.
             Hinweis:  Im   Gegensatz  zur  Funktion  \#textwidth\#
             spielt es bei textheight keine Rolle, welcher String
             zur Berechnung bergeben wird.
             Der Platzbedarf  von Strings  sollte grunds„tzlich
             ber  textheight  und  \#textwidth\#  ermittelt  werden.
             Nicht nur,  daá das Zentrieren von Titeln, Einpassen
             von Beschriftungen  usw. auf  diese Weise wesentlich
             einfacher geht  - Programme,  die  diese  Funktionen
             anstelle von  Konstanten  verwenden,  erfordern  bei
             einem Wechsel der Schriftart oder des Grafiktreibers
             erheblich weniger Modifikationen (wenn berhaupt).
Ergebnis     textheight liefert  das Ergebnis  der Berechnung  in
             Pixeln zurck.
Beispiel     #include <graphics.h>

             main()
             {
                int graphdriver = DETECT, /* automatische */
                graphmode;                /* Erkennung */
                int x, ypos;

                initgraph(&graphdriver, &graphmode, "");

                settextjustify(CENTER_TEXT, BOTTOM_TEXT);

                for (ypos = 0, x = DEFAULT_FONT; x <=
                     GOTHIC_FONT; x++)
                 {  settextstyle(x, HORIZ_DIR, 8);
                    ypos += textheight("T") + 5;
                    outtextxy(getmaxx() / 2,ypos, "Pure C");
                 }

                getch();
                closegraph();
             }
Portabilit„t Auf allen  Systemen die  BGI untersttzen, ist diese
             Funktion lauff„hig.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#gettextsettings\#, \#outtext\#, \#setusercharsize\#,
             \#textwidth\#
\end

screen( capsensitive("textwidth") )
Name         ¯text width®  - liefert  die Breite eines Strings in
             Pixeln zurck.

Definition   int textwidth(char *textstring);

Prototyp in  graphics.h

Beschreibung textwidth   berechnet   aus   dem   als   textstring
             bergebenen  String  sowie  dem  momentan  gesetzten
             Zeichensatz   und    dem   Vergr”áerungsfaktor   den
             horizontalen Platzbedarf einer Textzeile.
             Achtung: Im  Gegensatz zu  den Vektorzeichens„tzen
             kann auf  dem Atari der Standardzeichensatz nicht in
             der Breite  gestreckt werden.  Fr einen  5  Zeichen
             langen String  wird also  immer das  Ergebnis 5*8=40
             geliefert.
             Hinweis:  Im  Gegensatz  zur  Funktion  \#textheight\#
             spielt es  hier sehr  wohl eine Rolle, aus wievielen
             (und  bei   proportionalen  Zeichens„tzen:  welchen)
             Zeichen sich  der Text  zusammensetzt, der textwidth
             zur Berechnung bergeben wird.
             Der Platzbedarf  von Strings  sollte grunds„tzlich
             ber  \#textheight\#  und  textwidth  ermittelt  werden.
             Nicht nur,  daá das Zentrieren von Titeln, Einpassen
             von Beschriftungen  usw. auf  diese Weise wesentlich
             einfacher geht  - Programme,  die  diese  Funktionen
             anstelle von  Konstanten  verwenden,  erfordern  bei
             einem Wechsel der Schriftart oder des Grafiktreibers
             erheblich weniger Modifikationen (wenn berhaupt).
Ergebnis     textwidth liefert  das Ergebnis  ihrer Berechnung in
             Pixeln zurck.
Beispiel     siehe \#textheight\#
Portabilit„t Diese Funktion ist kompatibel zu allen Systemen, die
             BGI untersttzen.
Gruppe       \#grafische Textausgabe\#
Querverweis  \#gettextsettings\#,      \#outtext\#,      \#setusercharsize\#,
             \#textheight\#
\end

screen( capsensitive("BGIOBJ") )
BGIOBJ - Konvertierung von Zeichens„tzen

Die Standardzeichens„tze  existieren als separate Dateien (.CHR),
die bei  Bedarf auf  den Heap  des Programms  geladen werden. Der
Vorteil  dieses   Konzepts  liegt   darin,  daá   immer  nur  der
Zeichensatz  Platz  im  Speicher  belegt,  der  auch  tats„chlich
gebraucht wird. Die Nachteile: Sowohl die Aktivierung des Grafik-
pakets als  auch der  Wechsel des  Zeichensatzes  machen  Disket-
tenzugriffe (nebst der dazugeh”rigen Fehlerprfung) notwendig und
setzen die entsprechenden Dateien voraus.
Mit BGIOBJ  lassen sich Zeichens„tze in .O-Dateien  konvertieren,
die direkt in das Programm aufgenommen werden k”nnen. Ein eventu-
eller Nachteil  liegt hier  natrlich darin,  daá sich der Umfang
des Programms entsprechend erh”ht.
Die Aufnahme  eines Zeichensatzes  in ein  Programm besteht  aus
drei Schritten:
1.  Konvertierung mit  BGIOBJ in  eine .O-Datei. BGIOBJ gibt dem
    Zeichensatz dabei einen ¯Funktionsnamen®.
2.  ¯Registrierung®   des   Zeichensatzes   im   Programm   ber
    registerbgifont. An dieser Stelle wird der von BGIOBJ verge-
    bene ¯Funktionsname® verwendet:

    if (registerbgifont(gothic_font) != GOTHIC_FONT)
    {
       printf("Zeichensatz konnte nicht registriert werden!\\n");
       exit(1);
    }

TRIPLEX_FONT ist eine (in  graphics.h  definierte) Konstante  und
hat nichts mit dem ¯Funktionsnamen® triplex_font zu tun.

Hinweis:   Wie    im   Abschnitt    ber   registerbgifont    des
Bibliotheksverzeichnisses beschrieben,  erhalten das  Grafikpaket
und der  Linker erst durch diese ¯Registrierung® die Information,
daá der entsprechende Zeichensatz nicht geladen werden muá.


Der Aufruf von BGIOBJ

geschieht von der Kommandoebene aus durch die Eingabe von bgiobj
Wenn berhaupt  keine  Parameter  angegeben  sind,  erhalten  Sie
daraufhin den folgenden Text:

BGIOBJ 1.0          (c) 1990 by Borland International, Inc.

Usage: BGIOBJ <source> <destination> <public name>


Beispiel:
 BGIOBJ.TTP GOTH
 erzeugt GOTH.O mit dem globalen Nemen gothic_font
 BGIOBJ.TTP EURO
 erzeugt EURO.O mit dem globalen Nemen euro_font

Wenn nur  der Name  eines Zeichensatzes angegeben wird, verwendet
BGIOBJ die folgenden Standardvorgaben:

Quelldatei Zieldatei   globaler Name
-----------------------------------------------------------------
TRIP.CHR   TRIP.O      triplex_font
LITT.CHR   LITT.O      small_font
SANS.CHR   SANS.O      sansserif_font
GOTH.CHR   GOTH.O      gothic_font
-----------------------------------------------------------------

Mit BGIOBJ erzeugte .O-Dateien k”nnen
- entweder ber eine .PRJ-Datei in ein Programm aufgenommen


Weitergehende M”glichkeiten von BGIOBJ

Dieser  Abschnitt   erl„utert  die   restlichen   Kommandozeilen-
Parameter  von   BGIOBJ  im  Detail  und  ist  fr  erfahrene  C-
Programmierer gedacht  - fr ¯normale® Problemstellungen sind die
Standardvorgaben  des   Programms  in   praktisch  allen   F„llen
ausreichend.
Wie zu  Anfang dieses  Anhangs beschrieben,  hat der  Aufruf  von
BGIOBJ die folgende Syntax:

Syntax:   BGIOBJ  <Quelldatei>   <Zieldatei[.O]  <globaler Name>

Alle Parameter  auáer Quelldatei  sind optional.  Die Reihenfolge
der   Parameter   ist   zwingend   vorgeschrieben   -   um   also
beispielsweise   einen   globalen   Namen   festzulegen,   mssen
Quelldatei und Zieldatei angegeben werde.;

Parameter  Beschreibung
-----------------------------------------------------------------
Quelldatei Name der zu konvertierenden Datei. Solange mit den
           ausgelieferten Zeichens„tzen gearbeitet wird, fgt
           BGIOBJ das Suffix .CHR automatisch an, wenn der
           angegebene Name keinen Punkt enth„lt.
Zieldatei  Name der zu erzeugenden Datei. Die Standardvorgabe ist
           Quelldatei.O. Das Suffix .O wird automatisch
           angeh„ngt, wenn der angegebene Name keinen Punkt
           enth„lt.

globaler   Der hier angegebene ¯Funktionsname® wird bei Aufruf
Name       von registerbgifont verwendet.
-----------------------------------------------------------------

Wenn Sie  eigene globale Namen fr Zeichens„tze verwenden wollen,
mssen Sie Ihrem Programm entsprechende Prototypen hinzufgen:

              void globaler_Name(void);

Solange  mit   den   Standardvorgaben   von   BGIOBJ   und   den
Standardzeichens„tzen gearbeitet  wird,  sind  eigene  Prototypen
nicht notwendig  - die  entsprechenden Deklarationen sind bereits
in graphics.h enthalten.
\end

screen( "GEM" )
GEM (Graphics Environment Manager)
----------------------------------------------------------------------

Im Gegensatz zu einem konventionellen \#Betriebssystem\#, dessen Haupt-
augenmerk meist auf der Dateiorganisation, einem Multitaskingsystem
und der Ansteuerung von Peripherieger„ten liegt, ist GEM in erster
Linie zur konsistenten und portablen Programmierung von grafischen
Ausgabesystemen entwickelt worden. Darberhinaus soll GEM den Dialog
zwischen Programm und Anwender erleichtern.
Die \link("Betriebssystem")Betriebssystemumgebung\# von GEM besteht aus zwei Teilen, einem
mehr auf die Grafik spezialisiertem und einem berwiegend im Hinblick
auf eine leicht anzuwendende Benutzerschnittstelle orientierten Ab-
schnitt:

ù \#AES\#  (Application Environment Services)
ù \#VDI\#  (Virtual Device Interface)

\#AES\# bernimmt dabei die Organisation der Benutzerumgebung, wohingegen
\#VDI\# fr eine einheitliche grafische Gestaltung der Benutzeroberfl„che
sorgt. W„hrend \#AES\# auf \#VDI\#-Funktionen basiert, wird im \#VDI\# keine
\#AES\#-Funktion verwendet. Man kann \#AES\# als das bergeordnete System be-
trachten. Zusammen mit den Funktionen eines konventionellen Betriebs-
sytems erfllt GEM damit alle Anforderungen an ein anwendergerechetes
\#Betriebssystem\#.
\end

screen( "AES" )
Das AES-System (¯Application Environment Services®)
----------------------------------------------------------------------

besteht aus einem vereinfachten Multi-Tasking-Kernel (das ist jener
Teil eines Betriebssystems, der sich darum kmmert, da scheinbar
mehrere Aufgaben gleichzeitig erledigt werden), einem Bildschirm-
manager und elf Funktionsbibliotheken fr folgende Aufgabenbereiche:

ù \#Applikation\#sverwaltung (appl_...)
ù \#Ereignisverwaltung\#     (evnt_...)
ù \#Mens\#                  (menu_...)
ù \#Objekte\#                (objc_...)
ù \#Formulare\#              (form_...)
ù \#Grafikfunktionen\#       (graf_...)
ù \#Zwischenspeicher\#       (scrp_...)
ù \#Dateiauswahl\#           (fsel_...)
ù \#Fenster\#verwaltung      (wind_...)
ù \#Resource\#organisation   (rsrc_...)
ù \#Shell\#-Kommunikation    (shel_...)

Um AES-Funktionen in einem Programm verwenden zu k”nnen, mssen die
\link("%%GLOBAL%%")Prototypen\# in der Deklarationsdatei AES.H mittels #include-Anweisung
verfgbar sein.
\end

screen( "Ereignisverwaltung" )
Die Ereignisfunktionen auf einen Blick
----------------------------------------------------------------------

\#evnt_button\# Auf Maustastendruck warten.
\#evnt_dclick\# Doppelklickintervall ermitteln oder „ndern.
\#evnt_keybd\#  Auf Tastendruck warten.
\#evnt_mesag\#  Auf Mitteilung warten.
\#evnt_mouse\#  Auf Mausbewegungen in ein Rechteck hinein (oder auch
            heraus) warten.
\#evnt_multi\#  Auf mehrere Ereignisse wie Maustastendruck,
            Mausbewegungen usw. gleichzeitig warten.
\#evnt_timer\#  Eine bestimmte Zeitspanne lang warten.


Ereignisse im Multi-Tasking-Betrieb

Alle Benutzereingaben werden unter \#GEM\# als Ereignisse aufgefat.
Folgende Ereignisse k”nnen nun auftreten:

               ù Tastatureingaben
               ù Mausbewegungen
               ù Maustastendruck
               ù Zeitgeber Timeout
               ù Mitteilungen

Alle diese Ereignisse haben eine Gemeinsamkeit: Sie werden auerhalb
des betrachteten Programms erzeugt. Sie k”nnen deshalb nur durch
spezielle Vorkehrungen abgefangen werden.
Um Benutzeraktionen in einem Programm entgegenzunehmen, gibt es zwei
grunds„tzliche Strategien: Polling und Interruptsteuerung. Polling be-
deutet, da der Anwender von Zeit zu Zeit selbst nachfragen mu, ob
gerade ein bestimmtes Ereignis eingetreten ist. Mehrere Eingabeger„te
gleichzeitig per Polling abzufragen, ohne da Benutzerereignisse ver-
loren gehen, ist eine sehr aufwendige Angelegenheit, die die meisten
Anwenderprogramme um ein Vielfaches komplizierter machen wrde. \#GEM\#
bietet deshalb in Form von \#evnt_multi\# eine Funktion an, die im Stande
ist, mehrere Benutzerereignisse gleichzeitig abzufangen und zu verwal-
ten. Die interne Organisation dieser Funktion beruht natrlich auf
einem Interuptmechanismus, so da Ereignisse nicht verloren gehen
k”nnen.
Die Funktion \#evnt_multi\# kann ganz spezifisch je nach den Anforderungen
des Anwenderprogramms auf bestimmte Ereignisse angesetzt werden. W„h-
rend der Zeit, in der \#evnt_multi\# auf Ereignisse wartet, k”nnen andere
\#GEM\#-Programme im Hintergrund abgearbeitet werden. Die Ereignisverwal-
tung ist demnach sehr eng mit dem Multi-Tasking-Kernel verknpft.
Das Multi-Tasking-Schema ist jedoch sehr einfach ausgelegt. Es k”nnen
lediglich bis zu fnf Tasks (sprich Aufgaben) gleichzeitig ablaufen:
Drei Accessory-Programme, eine Applikation und der Bildschirmmanager.
Die einzelnen Tasks werden der Reihe nach mit Hilfe eines Dispatchers
abgearbeitet. Ein Dispatcher ist ein Programm im \#Betriebssystem\#, das
vergleichbar ist mit einem Dirigenten in einem Orchester. Seine Auf-
gabe ist es den Mitspielern im richtigen Moment den Einsatz zu geben.
Jeder AES-Proze l„uft nun dauernd durch die Schleife des Dispatchers.
Wenn die \#Applikation\# noch auf ein Ereignis wartet, wird sie in die
Reihe der noch nicht fertigen Prozesse gelegt. Tritt das Ereignis ein,
dann kommt der Proze in die Warteschlange der fertigen Prozesse und
mu dort solange auf die Weiterverarbeitung warten, bis die bereits
wartenden Prozesse vor ihm abgearbeitet wurden. Schlielich wird das
Programm abgearbeitet und nach einem Aufruf einer evnt-Funktion wieder
in die Reihe der noch nicht fertigen Prozesse eingereiht. Falls das
Programm jedoch auf kein Ereignis warten mu, kann es sich direkt an
der Schlange der fertigen Prozesse anstellen.
Die Umschaltung von einer Task auf die andere kann nur w„hrend des
Aufrufs von AES-Funktionen erfolgen. Ein Programm, das ber weite
Strecken lediglich \#VDI\#-Fumktionen oder \#Betriebssystem\#-Funktionen
verwendet, l„uft demnach Gefahr, andere Applikationen v”llig abzu-
h„ngen.
Dem Bildschirmmanager kommt als eigenst„ndige Task eine sehr wichtige
Aufgabe zu: Er verwaltet alle Mausbewegungen im Zusammenhang mit
selektierbaren Bildschirmbereichen, wie zum Beispiel den \#Mens\#. Wird
zum Beispiel ein Menpunkt ausgew„hlt, dann sendet der Bildschirmmana-
ger eine Mitteilung ber dieses Ereignis an das Anwenderprogramm.
Alle Ereignisse, die von \#evnt_multi\# auf einmal abgefangen werden
k”nnen, lassen sich auch einzeln ermitteln. \#evnt_keybd\# nimmt alle
Tastatur-Eingaben entgegen. \#evnt_button\# ist fr die Maustasten zu-
st„ndig. Die Geschwindigkeit bei Doppelklicks kann mit \#evnt_dclick\#
anwendungsspezifisch eingestellt werden. Mit \#evnt_mouse\# werden die
Bewegungen der Maus berwacht. Mitteilungen werden ber die Funktion
\#evnt_mesag\# analysiert. Die Funktion \#evnt_timer\# legt eine Time-
out-Periode fest. W„hrend die letztgenannten Einzelfunktionen nur in
Spezialsituationen zum Einsatz kommen, stellt \#evnt_multi\# das Kern-
stck eines jeden \#GEM\#-Programms dar. Nach den Initialisierungen
von Bildschirm, \#Mens\# und \#Resource\#-Set bewegt man sich normalerweise
in einer Endlosschleife, die nur bei schweren Fehlern oder der Option
Quit verlassen wird.
\end

screen( capsensitive("evnt_keybd") )
Name           Event Keyboard - wartet auf ein Tastaturereignis.

Definition     int evnt_keybd( void );

Prototyp in    aes.h

Beschreibung   evnt_keybd wartet auf ein Tastaturereignis.
Ergebnis       Die Funktion liefert als Funktionswert den Scancode
               der gedrckten Taste bzw. die Tastenkombination.

Gruppe         \#Ereignisverwaltung\#
Querverweis    \#evnt_multi\#
\end

screen( capsensitive("evnt_button") )
Name           Event Button - wartet auf einen Mausknopfereignis.

Definition     int evnt_button( int ev_bclicks, int ev_bmask,
                                int ev_bstate, int *ev_bmx,
                                int *ev_bmy, int *ev_bbutton,
                                int *ev_bkstate );

Prototyp in    aes.h

Beschreibung   Die Funktion wartet auf einen Button-Event, d.h. bis
               die in ev_bmask spezifizierten Mauskn”pfe ev_bclicks
               mal in den in ev_bstate angegeben Zustand versetzt
               werden.
ev_bclicks     die Anzahl der n”tigen Clicks
ev_bmask       einen Bitvektor, der die zu betrachtenden Kn”pfe mit
               einer 1 maskiert. Dabei ist der "linkeste" Knopf das
               niederwertigste Bit.
ev_bstate      einen Bitvektor wie ev_bmask, der fr jeden Knopf
               festlegt welchen Status er ereichen mu:
               1 = gedrckt, 0 = nicht gedrckt
ev_bmx,ev_bmy  die x bzw. y Koordinate der Maus zum Zeitpunkt des
               Auftretens des Ereignisses
ev_bbutton     der Zustand der Mauskn”pfe beim Auftreten des
               Ereignisses
ev_bkstate     den Zustand der Sondertasten der Tastatur beim
               Auftreten des Ereignisses
               0x001   rechte Shifttaste
               0x002   linke Shifttaste
               0x004   Controltaste
               0x008   Alternatetaste
               Bei gedrckter Taste wird das entsprechende Bit gesetzt
Ergebnis       Die Funktion liefert die Anzahl der tats„chlich
               vorgenommenen Mausklicks.
Gruppe         \#Ereignisverwaltung\#
Querverweis    \#evnt_multi\#
\end

screen( capsensitive("evnt_dclick") )
Name           Event Doubleclick - ermittelt oder legt den Zeitraum
               zwischen den beiden Klicks eines Doppelklicks fest.

Definition     int evnt_dclick( int ev_dnew, int ev_dgetset );

Prototyp in    aes.h

Beschreibung   Mit evnt_dclick kann man die Zeit ermitteln
               (ev_tgetset = 0) oder auf den Wert ev_dnew stellen
               (ev_dgetset <> 0), die zwischen zwei aufeinander-
               folgenden Klicks mit der Maustaste vergehen darf, soda
               das AES diese zwei Klicks als einen DoppelKlick
               interpretiert. Die Werte fr den Parameter ev_dnew
               liegen zwischen 0 und 4, wobei 4 fr die krzeste
               Zeitspanne steht.
Ergebnis       Die Funktion liefert die tats„chliche
               Doppelklickgeschwindigkeit.
Gruppe         \#Ereignisverwaltung\#
\end

screen( capsensitive("evnt_mesag") )
Name           Event Message - wartet auf eine Mitteilung des AES.

Definition     int evnt_mesag( int *ev_mgpbuff );

Prototyp in    aes.h

Beschreibung   Diese Funktion wartet auf das Eintreten eines
               Mesassage-Events, d. h. bis eine andere Applikation
               oder der Screenmanager der Applikation etwas mitteilen.
               \#ev_mgpbuff\# zeigt dabei auf einen 16 Byte groen
               Buffer.
Ergebnis       Als Ergwebnis wir immer 1 zurckgegeben.
Gruppe         \#Ereignisverwaltung\#
\end

screen( capsensitive("AC_CLOSE"),
		capsensitive("WM_SIZED"),
		capsensitive("AC_OPEN"),
		capsensitive("ev_mgpbuff"),
		capsensitive("WM_REDRAW"),
		capsensitive("WA_DNLINE"),
		capsensitive("WM_TOPPED"),
		capsensitive("WA_DNPAGE"),
		capsensitive("WM_VSLID"),
		capsensitive("WA_LFLINE"),
		capsensitive("WA_LFPAGE"),
		capsensitive("WA_RTLINE"),
		capsensitive("WA_RTPAGE"),
		capsensitive("WA_UPLINE"),
		capsensitive("MN_SELECTED"),
		capsensitive("WA_UPPAGE"),
		capsensitive("WM_ARROWED"),
		capsensitive("WM_CLOSED"),
		capsensitive("WM_FULLED"),
		capsensitive("WM_HSLID"),
		capsensitive("WM_NEWTOP"),
		capsensitive("WM_MOVED") )
Die Standardmessages des Screenmanagers sind wie folgt aufgebaut:

ev_mgpbuff[0]  Art der Message
ev_mgpbuff[1]  Identifikator der Applikation, die die Nachricht
               abgeschickt hat
ev_mgpbuff[2]  Anzahl der Bytes die ber die Standardl„nge von 16
               Bytes hinausgeht, die dann mit \#appl_read\# gelesen werden
               mssen

Arten der Standardmessages:

MN_SELECTED    ein Meneintrag wurde ausgew„hlt
                ev_mgpbuff[3]  Objektnummer des Titeleintrags
                ev_mgpbuff[4]  Objektnummer des Eintrags
WM_REDRAW      ein Fensterbereich mu neu gezeichnet werden
                ev_mgpbuff[3]  Handle des neuzuzeichnenden Fensters
                ev_mgpbuff[4]  x-Koordinate des Bereichs
                ev_mgpbuff[5]  y-Koordinate des Bereichs
                ev_mgpbuff[6]  Breite des Bereichs
                ev_mgpbuff[7]  H”he des Bereichs
WM_TOPPED      ein Fenster soll zum oben liegenden Fenster werden
                ev_mgpbuff[3]  Handle des nach oben zu holenden
                               Fensters
WM_CLOSED      das oberste Fenster soll geschlossen werden
                ev_mgpbuff[3]  Handle des zu schlieenden Fensters
WM_FULLED      der Fullsizeknopf des obersten Fensters wurde
               angeklickt
                ev_mgpbuff[3]  Handle des Fensters, das auf volle
                               Gr”e gebracht werden soll
WM_ARROWED     ein Pfeil oder Rollbalken wurde angeclickt
                ev_mgpbuff[3]  Handle des Fensters
                ev_mgpbuff[4]  einer der folgenden Werte:
                               WA_UPPAGE  Seite nach oben
                               WA_DNPAGE  Seite nach unten
                               WA_UPLINE  Zeile nach oben
                               WA_DNLINE  Zeile nach unten
                               WA_LFPAGE  Seite nach links
                               WA_RTPAGE  Seite nach rechts
                               WA_LFLINE  Spalte nach links
                               WA_RTLINE  Spalte nach rechts
WM_HSLID       der horizontale Rollbalken wurde verschoben
                ev_mgpbuff[3]  Handle des Fensters
                ev_mgpbuff[4]  die neue Sliderposition
                               (0 ganz links bis 1000 ganz rechts)
WM_VSLID       der vertikale Rollbalken wurde verschoben
                ev_mgpbuff[3]  Handle des Fensters
                ev_mgpbuff[4]  die neue Sliderposition
                               (0 ganz oben bis 1000 ganz unten)
WM_SIZED       die Fenstergr”e wurde ver„ndert
                ev_mgpbuff[3]  Handle des Fensters
                ev_mgpbuff[4]  neue x-Koordinate (unver„ndert)
                ev_mgpbuff[5]  neue y_Koordinate (unver„ndert)
                ev_mgpbuff[6]  neue Fensterbreite
                ev_mgpbuff[7]  neue Fensterh”he
WM_MOVED       das ganze Fenster wurde verschoben
                ev_mgpbuff[3]  Handle des Fensters
                ev_mgpbuff[4]  neue x-Koordinate
                ev_mgpbuff[5]  neue y_Koordinate
                ev_mgpbuff[6]  neue Fensterbreite (unver„ndert)
                ev_mgpbuff[7]  neue Fensterh”he (unver„ndert)
WM_NEWTOP      das Fenster wurde nach oben gebracht
                ev_mgpbuff[3]  Handle des Fensters
AC_OPEN        ein Accessory wurde aktiviert
                ev_mgpbuff[4]  Identifikator des Accessories
AC_CLOSE       wird an ein Accessory geschickt, wenn die aktuelle
               Applikation beendet wird und der Bildschirm gel”scht
               wird und der Windowmanager neu initialisiert wird
                ev_mgpbuff[4]  Identifikator des Accessories

Querverweis:    \#evnt_multi\# \#evnt_mesag\#
\end

screen( capsensitive("evnt_mouse") )
Name           Event Mouse - wartet darauf, da der Mauszeiger in
               einen Bereich hinein- oder hinausgeschoben wird.

Definition     int evnt_mouse( int ev_moflags, int ev_mox, int ev_moy,
                               int ev_mowidth, int ev_moheight,
                               int *ev_momx, int *ev_momy,
                               int *ev_mobutton, int *ev_mokstate );

Beschreibung   Die Funktion wartet darauf bis der Mauszeiger aus oder
               in ein angegebenes Rechteck bewegt wird.
ev_moflags     bei 1 wird ein Event erzeugt, wenn der Mauszeiger das
               Rechteck verl„t, bei 0 wird der Event erzeugt, wenn
               der Mauszeiger das Rechteck betritt.
ev_mox,ev_moy  x und y Koordinate des zu berwachenden Rechtecks
ev_mowidth     Breite des zu berwachenden Rechtecks
ev_moheight    H”he des zu berwachenden Rechtecks
ev_momx,ev_momy die x und y Koordinate des Mauszeigers beim Betreten
                bzw. Verlassen des Rechtecks
ev_mobutton    der Zustand der Mauskn”pfe beim Eintreten des Events
               (Format siehe \#evnt_button\#)
ev_mokstate    den Zustand der Sondertasten der Tastatur beim
               Auftreten des Events (Format siehe \#evnt_button\#)
Ergebnis       Als Ergebnis wird immer eine 1 zurckgeliefert.
Gruppe         \#Ereignisverwaltung\#
\end

screen( capsensitive("evnt_multi") )
Name           Event Multi - wartet auf ein beliebiges Ereignis.

Definition     int evnt_multi( int ev_mflags, int ev_mbclicks,
                               int ev_mbmask, int ev_mbstate,
                               int ev_mm1flags, int ev_mm1x,
                               int ev_mm1y, int ev_mm1width,
                               int ev_mm1height, int ev_mm2flags,
                               int ev_mm2x, int ev_mm2y,
                               int ev_mm2width, int ev_mm2height,
                               int *ev_mmgpbuff, int ev_mtlocount,
                               int ev_mthicount, int *ev_mmox,
                               int *ev_mmoy, int *ev_mmbutton,
                               int *ev_mmokstate, int *ev_mkreturn,
                               int *ev_mbreturn );

Prototyp in    aes.h

Beschreibung   Die evnt_multi Funktion wartet auf eine Reihe
               verschiedener Events.
ev_mflags      auf welche Events soll gewartet werden
                Keyboardevent   Bit 0 gesetzt   MU_KEYBD
                Buttonevent     Bit 1 gesetzt   MU_BUTTON
                Mouseevent 1    Bit 2 gesetzt   MU_M1
                Mouseevent 2    Bit 3 gesetzt   MU_M2
                Messageevent    Bit 4 gesetzt   MU_MESAG
                Timerevent      Bit 5 gesetzt   MU_TIMER
ev_mbclicks    Anzahl der Klicks, siehe ev_bclicks in \#evnt_button\#
ev_mbmask      welche Mauskn”pfe sollen betrachtet werden
               (Format siehe ev_bmask in \#evnt_button\#)
ev_mbstate     welchen Zustand mssen die Mauskn”pfe einnehmen
               (Format, siehe ev_bstate in \#evnt_button\#)
ev_mm1flags    soll der Event beim Betreten (0) oder Verlassen (1) des
               ersten Rechtecks ausgel”st werden, siehe ev_moflags in
               \#evnt_mouse\#
ev_mm1x,ev_mm1y x und y Koordinate des ersten Rechtecks, siehe ev_mox,
                ev_moy in \#evnt_mouse\#
ev_mm1width    die Breite des ersten Rechtecks, siehe ev_mowidth in
               \#evnt_mouse\#
ev_mm1height   die H”he des ersten Rechtecks, siehe ev_moheight in
               \#evnt_mouse\#
ev_mm2flags,
ev_mm2x,
ev_mm2y,
ev_mm2width,
ev_mm2height   sind die Parameter fr das zweite Mouseevent Rechteck
ev_mmgpbuff    ein 16 Byte Messagebuffer, siehe \#evnt_mesag\# und
               \#ev_mgpbuff\#
ev_mtlocount   low-Word fr den Timercounter, siehe \#evnt_timer\#
ev_mthicount   high-Word fr den Timercounter, siehe \#evnt_timer\#
ev_mmox,ev_mmoy die x und y Koordinate des Mauszeigers beim Auftreten
                des Events, siehe \#evnt_mouse\#
ev_mmobutton   Zustand der Mauskn”pfe beim Auftreten des Events
               (Format siehe \#evnt_button\#)
ev_mmokstate   den Zustand der Sondertasten der Tastatur beim
               Auftreten des Events (Format, siehe \#evnt_button\#)
ev_mkreturn    der Scancode der gedrckten Taste
ev_mbreturn    Anzahl der Klicks mit der Maustaste

Ergebnis       Als Ergebnis liefert die Funktion die Nummer des oder
               der aufgetretenen Events im oben angegeben Format.
Gruppe         \#Ereignisverwaltung\#
Querverweis    \#evnt_keybd\#   \#evnt_button\#   \#evnt_mouse\#   \#evnt_mesag\#
               \#evnt_timer\#   \#evnt_dclick\#
\end

screen( capsensitive("evnt_timer") )
Name           Event Timer - wartet einen Zeitabschnitt ab.

Definition     int evnt_timer( int ev_tlocount, int ev_thicount );

Prototyp in    aes.h

Beschreibung   Die Funktion wartet bis die Zeit, die durch ev_tlocount
               und ev_thicount in Millisekunden vorgegeben wird,
               verstrichen ist.
Ergebnis       Als Ergebnis wird immer eine 1 zurckgeliefert.
Gruppe         \#Ereignisverwaltung\#
\end

screen( "Fenster" )
Die Fensterfunktionen auf einen Blick:
----------------------------------------------------------------------

\#wind_calc\#   Fensterdimensionen berechnen.
\#wind_close\#  Fenster schlieen.
\#wind_create\# Fenster erzeugen.
\#wind_delete\# Fenster l”schen.
\#wind_find\#   Fensterhandle anhand einer Positionsangabe ermitteln.
\#wind_get\#    Eigenschaften eines Fensters ermitteln.
\#wind_new\#    Alle Fenster l”schen.
\#wind_open\#   Fenster ”ffnen.
\#wind_set\#    Eigenschaften eines Fensters ver„ndern.
\#wind_update\# Bildschirmoperationen sperren oder freigeben.


Fenster als Benutzerumgebung

Aus der Sicht des Anwenders ist die Integration von Fenstern die wohl
herausragendste Eigenschaft des \#GEM\#-Betriebssystems. Die Maus ist
dabei die ideale Erg„nzung fr den Umgang mit Fenstern. Ein Fenster
besteht aus einer Reihe von bestimmten Einheiten, die entsprechend den
Anforderungen der \#Applikation\# gesetzt werden k”nnen.

Im Mittelpunkt eines Fensters steht immer die Arbeitsfl„che, auf der
ein bestimmtes Objekt, wie zum Beispiel ein Text oder eine Grafik,
ganz oder in Ausschnitten dargestellt wird. Die Titelleiste gibt dem
Fenster einen Namen, dient aber gleichzeitig auch zum Verschieben des
Fensters auf dem Bildschirm. Mit der Schliebox (links oben) kann das
Fenster geschlossen werden. Klickt man die Full-Box (rechts oben) an,
wird das eventuell verkleinerte Fenster auf seine volle Gr”e ge-
bracht. Die Informationszeile ist fr kurze Mitteilungen an den Be-
nutzer gedacht. Mit den Pfeilen (auf und ab, links und rechts) erh„lt
ein Programm die Mitteilung, da der Inhalt des Fensters in die ent-
sprechende Richtung verschoben werden soll. Die horizontalen und ver-
tikalen Schieber erm”glichen die absolute Positionierung der Arbeits-
fl„che eines Fensters. Mit der Gr”eneinstellungsbox (rechts unten)
k”nnen Sie ein Fenster zumeist stufenlos vergr”ern bzw. verkleinern.
Um ein Fenster anzulegen, mu es zuerst mit der Funktion \#wind_create\#
erzeugt werden. Beim Anlegen wird das Fenster im Speicher initiali-
siert. Es wird gleichzeitig festgelegt, aus welchen Bestandteilen sich
das Fenster zusammensetzen soll und welche maximale Gr”e das Fenster
einnehmen darf. Man kann zwar die Gr”e eines Fenster beim ™ffnen mit
\#wind_open\# in beliebigen Schritten kleiner einstellen als beim Anlegen
mit \#wind_create\#, aber \#GEM\# mu fr seine Speicherbereichsverwaltung
genau wissen, wie gro das Fenster maximal werden kann. Ge”ffnete Fen-
ster k”nnen mit \#wind_close\# wieder geschlossen werden. Sie sind damit
jedoch noch nicht aus dem Speicher entfernt worden und k”nnen mit
\#wind_open\# erneut aktiviert werden. Soll ein geschlossenes Fenster auch
aus dem Speicher entfernt werden, so geschieht dies mit der Funktion
\#wind_delete\#. Mit Hilfe der Funktion \#wind_get\# lassen sich aktuelle
Einstellungen eines Fensters jederzeit abfragen. So erh„lt man Infor-
mationen ber die Position, die Gr”e, die verwendeten Fensterbestand-
teile, usw. Besonders wichtig ist meist die Stellung der horizontalen
und vertikalen Schieber. In umgekehrter Weise, kann man einzelne
Parameter eines Fensters mit Hilfe der Funktion \#wind_set\# auch direkt
vom Programm aus festlegen. Die meisten Ver„nderungen in den Fenstern
werden jedoch automatisch vom Bildschirmmanager berwacht. Wenn der
Anwender bestimmte Schlsselbereiche anklickt, sendet der Bildschirm-
manager sofort eine Mitteilung an das Programm, das mit Hilfe der
\#Ereignisverwaltung\# sofort die richtigen Aktionen in die Wege leiten
kann. Im Endeffekt liegt die gesamte Verantwortung fr die Verwaltung
der Fenster beim Anwenderprogramm.
Wenn man den Fensterinhalt ver„ndern will, sollte man zuvor mit der
Funktion \#wind_update\# alle anderen Bildschirmoperationen verbieten.
Ansonsten k”nnte es passieren, da eine andere \#Applikation\# zur selben
Zeit wie Sie den Bildschirm restaurieren will, und es entsteht Bild-
schirmsalat. Man darf aber nicht vergessen, den Bildschirm anschlie-
end erneut mit der Funktion \#wind_update\# fr weitere Bildschirm-
operationen wieder frei zugeben, da ansonsten auch alle \#Mens\# und
Accessories ausgeschaltet blieben.
\end

screen( capsensitive("wind_create") )
Name           Window create - meldet ein neues Fenster an.

Definition     int wind_create( int wi_crkind, int wi_crwx,
                                int wi_crwy, int wi_crww,
                                int wi_crwh );

Prototyp in    aes.h

Beschreibung   Die Funktion versucht beim AES ein neues Fenster
               anzumelden und legt dabei gleichzeitig sein Aussehen
               und die maximale Gr”e fest.
wi_crwx, wi_crwy, wi_crww, wi_crwh legen die maximale
               Ausdehnung des Fensters fest.
               wi_crkind beschreibt das Fensters als Bitvektor:
  NAME         0x0001   Titelzeile
  CLOSER       0x0002   Schliebox
  FULLER       0x0004   Volle-Gr”e-Box
  MOVER        0x0008   Fenster kann bewegt werden
  INFO         0x0010   Infozeile
  SIZER        0x0020   Gr”enverstellungsbox
  UPARROW      0x0040   Pfeil nach oben
  DNARROW      0x0080   Pfeil nach unten
  VSLIDE       0x0100   vertikaler Slider
  LFARROW      0x0200   Pfeil nach links
  RTARROW      0x0400   Pfeil nach rechts
  HSLIDE       0x0800   horizontaler Slider
Ergebnis       Die Funktion liefert ein nicht negatives Handle, falls
               das AES noch ein freies Windowhandle zur Verfgung hat.
               Ein Rckgabewert kleiner Null signalisiert einen Fehler
               oder keine weiteren Handles mehr.
Gruppe         \#Fenster\#
Querverweis    \#wind_delete\#
\end

screen( capsensitive("wind_open") )
Name           Open Window - ”ffnet ein Fenster.

Definition     int wind_open( int wi_ohandle, int wi_owx, int wi_owy,
                              int wi_oww, int wi_owh );

Prototyp in    aes.h

Beschreibung   Die Funktion stellt ein Fenster mit dem Handle
               wi_ohandle aus dem \#wind_create\#-Aufruf an den
               Koordinaten wi_owx und wi_owy mit den Maen wi_oww
               und wi_owh dar.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgeliefert wird.
Gruppe         \#Fenster\#
Querverweis    \#wind_create\#   \#wind_close\#
\end

screen( capsensitive("wind_new") )
Name           New Window - schliet alle Fenster.
               (erst ab TOS Version 1.4 verfgbar)

Definition     void wind_new(void);

Prototyp in    aes.h

Beschreibung   Die Funktion schliet und l”scht alle Fenster und
               bergibt die Mauskontrolle wieder an das System.
Ergebnis       Diese Funktion liefert kein Ergebnis
Gruppe         \#Fenster\#
Querverweis    \#wind_create\#   \#wind_close\#
\end

screen( capsensitive("wind_close") )
Name           Close Window - schliet ein Fenster.

Definition     int wind_close( int wi_clhandle );

Prototyp in    aes.h

Beschreibung   Die Funktion schliet das vorher mit \#wind_open\#
               ge”ffnete Fenster mit dem Handle wi_clhandle wieder,
               gibt aber das Windowhandle nicht frei. Das Fenster
               kann also jederzeit wieder er”ffnet werden.
Ergebnis       Ein Fehler ist nur dann aufgeteten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Fenster\#
Querverweis    \#wind_open\#
\end

screen( capsensitive("wind_delete") )
Name           Delete Window - l”scht ein Fenster.

Definition     int wind_delete( int wi_dhandle );

Prototyp in    aes.h

Beschreibung   Die Funktion l”scht das Fenster mit dem Handle
               wi_dhandle wieder vollst„ndig und gibt das Windowhandle
               wieder frei. Die Funktion ist also das Gegenstck zu
               \#wind_create\#.
Ergebnis       Ein Fehler ist nur dann aufgeteten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Fenster\#
Querverweis    \#wind_create\#  \#wind_close\#
\end

screen( capsensitive("wind_get") )
Name           Get Window - ermittelt die Parameter eines Fensters.

Definition     int wind_get( int wi_ghandle, int wi_gfield, ... );

Prototyp in    aes.h

Beschreibung   Die Funktion liefert je nach Wert des Parameters
               wi_gfield verschiedene Informationen ber das Fenster
               mit dem Handle wi_ghandle. Dabei sind die zus„tzlichen
               Parameter wi_gw1, wi_gw2, wi_gw3 und wi_gw4 alles
               Zeiger auf Integerwerte,also
               int *wi_gw1, *wi_gw2, *wi_gw3, *wi_gw4;
wi_gfield:
WF_WORKXYWH    berechnet die Koordinaten des Arbeitsbereichs des
               Fensters und schreibt sie in die weiteren Parameter
               wi_gw1, wi_gw2, wi_gw3 und wi_gw4.
WF_CURRXYWH    berechnet die Gesamtgr”e des Fenster und schreibt sie
               in die weiteren Parameter wi_gw1, wi_gw2, wi_gw3 und
               wi_gw4.
WF_PREVXYWH    berechnet die Gesamtgr”e des vorherigen Fensters und
               schreibt sie in die weiteren Paramter wi_gw1, wi_gw2,
               wi_gw3 und wi_gw4.
WF_FULLXYWH    berechnet die maximale Gesamtgr”e des Fensters und
               schreibt sie in die weiteren Parameter wi_gw1, wi_gw2,
               wi_gw3 und wi_gw4.
WF_HSLIDE      berechnet die Position des horizontalen Sliders und
               schreibt sie in den weiteren Parameter wi_gw1 (1 ganz
               links, bis 1000 ganz rechts).
WF_VSLIDE      berechnet die Position des vertikalen Sliders und
               schreibt sie in den weiteren Parameter wi_gw1 (1 ganz
               oben, bis 1000 ganz unten).
WF_TOP         liefert das Handle des obersten Fensters und schreibt
               es in den weiteren Parameter wi_gw1.
WF_FIRSTXYWH   berechnet die Koordinaten des ersten Rechtecks in der
               Rechtecksliste und schreibt sie in die weiteren
               Parameter wi_gw1, wi_gw2, wi_gw3 und wi_gw4.
WF_NEXTXYWH    berechnet die Koordinaten des n„chsten Rechtecks in der
               Rechtecksliste und schreibt sie in die weiteren
               Parameter wi_gw1, wi_gw2, wi_gw3 und wi_gw4.
WF_RESVD       reserviert.
WF_HSLSIZE     berechnet die Gr”e des horizontalen Sliders relativ
               zur Gesamtbreite und schreibt sie in den zus„tzlichen
               Parameter wi_gw1 (-1 kleinste Gr”e, 1 klein bis 1000
               Gesamtbreite).
WF_VSLSIZE     berechnet die H”he des vertikalen Sliders relativ zur
               Gesamth”he und schreibt sie in den zus„tzlichen
               Parameter wi_gw1 (-1 kleinste H”he, 1 klein bis 1000
               Gesamth”he).
WF_SCREEN      liefert die Adresse und L„nge des internen Buffers, in
               dem das AES den Hintergrund von Dropdownmens und
               Alertboxen zwischenspeichert und schreibt sie in die
               weiteren Parameter wi_gw1 Highword der Adresse,
               wi_gw2 Lowword der Adresse, wi_gw3 Highword der L„nge
               und wi_gw4 Lowword der L„nge.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Fenster\#
\end

screen( capsensitive("wind_set") )
Name           Set Window - ver„ndert einzelne Parameter eines
               Fensters.

Definition     int wind_set( int wi_shandle, int wi_sfield, ... );

Prototyp in    aes.h

Beschreibung   Die Funktion ver„ndert das Fenster mit dem Handle
               wi_shandle, je nach Wert des Parameters wi_sfield.
               Dabei sind die zus„tzlichen Parameter wi_sw1, wi_sw2,
               wi_sw3 und wi_sw4 alles Integerwerte, also:
               int wi_sw1, wi_sw2, wi_sw3, wi_sw4;
wi_sfield
WF_KIND        legt wi_sw1 als neue Fensterkomponenten fest, Format
               wie bei \#wind_create\#.
WF_NAME        schreibt den String, auf den wi_sw1 und wi_sw2 zeigt,
               in die Titelzeile.
WF_INFO        schreibt den String, auf den wi_sw1 und wi_sw2 zeigt,
               in die Infozeile.
WF_CURRXYWH    setzt die Fenstergr”e aus wi_sw1, wi_sw2, wi_sw3 und
               wi_sw4 fest.
WF_HSLIDE      setzt den horizontalen Slider auf die neue Position
               wi_sw1 (1 ganz links bis 1000 ganz rechts).
WF_VSLIDE      setzt den vertikalen Slider auf die neue Position
               wi_sw1 (1 ganz oben bis 1000 ganz unten).
WF_TOP         das Fenster mit dem Handle wi_shandle wird zum neuen
               oberen Fenster.
WF_NEWDESK     legt den Objektbaum, auf den wi_sw1 und wi_sw2 zeigt,
               mit dem Startobjekt wi_sw3 als neues Desktop fest.
WF_HSLSIZE     setzt die Gr”e des horizontalen Sliders relativ zur
               Gesamtbreite auf den Wert wi_sw1 (-1 kleinste Gr”e, 1
               klein bis 1000 Gesamtbreite).
WF_VSLSIZE     setzt die H”he des vertikalen Sliders relativ zur
               Gesamth”he auf den Wert  wi_sw1 (-1 kleinste H”he, 1
               klein bis 1000 Gesamth”he).
WF_COLOR       ver„ndert die Farbe eines Fensterelements. Dazu wird
               in wi_sw1 Nummer des Elements angegeben:
               
               Element     Objekttyp  Beschreibung
               ----------------------------------------------------
               W_BOX       IBOX        Wurzelobjekt des Fensters
               W_TITLE     BOX         Elternobjekt der Schlie-
                                       und Zoombox, sowie des Names
               W_CLOSER    BOXCHAR     Schliebox
               W_NAME      BOXTEXT     Move-Balken
               W_FULLER    BOXCHAR     Zoombox
               W_INFO      BOXTEXT     Infozeile
               W_DATA      IBOX        Elternobjekt der restlichen
                                       Elemente
               W_WORK      IBOX        Arbeitsfl„che
               W_SIZER     BOXCHAR     Size-Box
               W_VBAR      BOX         Elternobjekt der vertikalen
                                       Sliderelemente
               W_UPARROW   BOXCHAR     Pfeil nach oben
               W_DNARROW   BOXCHAR     Pfeil nach unten
               W_VSLIDE    BOX         Hintergrund des vert. Sliders
               W_VELEV     BOX         Vertikaler Slider
               W_HBAR      BOX         Elternobjekt der vertikalen
                                       Sliderelemente
               W_LFARROW   BOXCHAR     Pfeil nach links
               W_RTARROW   BOXCHAR     Pfeil nach rechts
               W_HSLIDE    BOX         Hintergrund des horiz. Sliders
               W_HELEV     BOX         Horizontaler Slider

               Im Parameter wi_sw2 wird die Farbe fr den Objekttyp
               des Fensterelements bergeben, falls das Fenster ge-
               toppt ist, in wi_sw3 falls es nicht aktiv ist. Ein
               Wert von -1 beh„lt die aktuelle Farbeinstellung
               bei (ab Atari TT verfgbar).
WF_DCOLOR      setzt die Standard-Farben fr die Fensterelemente.
               Der Parameter wi_shandle wird ignoriert (ab Atari TT
               verfgbar).

Hinweis zum Pure-C-Compiler:

Anstelle die Zeigerwerte, die bergeben werden mssen (z. B. bei
WF_NEWDESK), in zwei Integerwerte aufzuspalten, kann man gleich den
gesamten Zeiger als Parameter bergeben und dafr den zweiten
Integerparameter weglassen. Im obigen Beispiel lautet der Aufruf also:

        wind_set(wi_shandle,WF_NEWDESK,desk_tree,wi_sw3);

        OBJECT *desk_tree;
        int    wi_shandle, wi_sw3;

Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Fenster\#
Querverweis    \#wind_create\#   \#OBJECT\#
\end

screen( capsensitive("wind_find") )
Name           Find Window - sucht ein Fenster zu einem bestimmten
               Punkt.

Definition     int wind_find( int wi_fmx, int wi_fmy );

Prototyp in    aes.h

Beschreibung   Die Funktion berechnet das Windowhandle des Fensters
               das sich unter den Koordinaten wi_fmx, wi_fmy befindet.

Ergebnis       Die Funktion liefert das Windowhandle. Ein Rckgabewert
               von Null signalisiert, da sich kein Benutzerfenster an
               den angegebenen Koordinaten befindet, sondern nur das
               Desktopfenster, welches das Handle Null hat.
Gruppe         \#Fenster\#
Querverweis    \#wind_get\#
\end

screen( capsensitive("wind_update"),
		capsensitive("END_MCTRL"),
		capsensitive("BEG_UPDATE"),
		capsensitive("BEG_MCTRL"),
		capsensitive("END_UPDATE") )
Name           Update Window - bestimmt das Neuzeichnen eines Fensters.

Definition     int wind_update( int wi_ubegend );

Prototyp in    aes.h

Beschreibung   Die Funktion signalisiert dem AES, da die
               Benutzerapplikation gerade den Bildschirm neu aufbaut.
               Das AES schr„nkt daraufhin seine eigenen grafischen
               "T„tigkeiten", wie z. B. das Herunterklappen von
               Dropdownmens, ein.
wi_ubegend     BEG_UPDATE  ein Fenster wird nach dem dem Aufruf
                           aufgebaut.
               END_UPDATE  Fensteraufbau ist abgeschlossen.
               BEG_MCTRL   das Anwenderprogramm m”chte die alleinige
                           Kontrolle ber die Maus haben.
               END_MCTRL   das AES kann die Kontrolle wieder haben.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Fenster\#
\end

screen( capsensitive("WC_WORK"),
		capsensitive("WC_BORDER"),
		capsensitive("wind_calc") )
Name           Window Calculation - berechnet die Grenzen oder den
               gesamten Platzbedarf eines Fensters.

Definition     int wind_calc( int wi_ctype, int wi_ckind, int wi_cinx,
                              int wi_ciny, int wi_cinw, int wi_cinh,
                              int *coutx, int *couty, int *coutw,
                              int *couth );

Prototyp in    aes.h

Beschreibung   Die Funktion berechnet fr ein Fenster die Gr”e des
               Randbereichs aus den Koordinaten des Arbeitsbereichs
               oder aus den Koordinaten des Arbeitsbereichs die
               Koordinaten des Randbereichs.
wi_ctype       WC_BORDER  berechnet die Koordinaten des Randbereichs
               aus den Koordinaten des Arbeitsbereichs in den
               Parametern wi_cinx, wi_ciny, wi_cinw und wi_cinh.
               WC_WORK  berechnet die Koordinaten des Arbeitsbereichs
               aus den Koordinaten des Randbereichs in den Parametern
               wi_cinx, wi_ciny, wi_cinw und wi_cinh.
wi_crkind      ein Integerparameter der alle Komponenten des Fenster
               beeinhaltet, Format wie in \#wind_create\#
coutx, couty   die berechneten x und y Koordinaten
coutw, couth   die berechnete Ausdehnung
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Fenster\#
Querverweis    \#wind_create\#
\end

screen( "Objekte" )
Die Objektfunktionen auf einen Blick
----------------------------------------------------------------------

\#objc_add\#    Objekt im Objektbaum einfgen.
\#objc_change\# Status eine Objekts „ndern.
\#objc_delete\# Objekt aus dem Objektbaum entfernen.
\#objc_draw\#   Objekt (mit Unterobjekten) darstellen.
\#objc_edit\#   Texte eines Objekts ver„ndern.
\#objc_find\#   Objektindex ber Position ermitteln.
\#objc_offset\# Bildschirmkoordinaten eines Objekts ermitteln.
\#objc_order\#  Reihenfolge im Objektbaum umstellen.


Die Basis des AES-Systems: Objekte

Objekte sind die Basiselemente des \#AES\#-Systems. Sie sind nichts an-
deres als Datenstrukturen namens \#OBJECT\#, mit deren Hilfe Grafikele-
mente, wie Alarmboxen, \#Fenster\#, \#Mens\# und Symbole beschrieben werden.
Alle Objekte werden in einem einheitlichen Objektbaum zusammengefat.
Mit der Datenstruktur \#OBJECT\# hat man ein sehr flexibles Werkzeug zur
Verfgung, das gegenber einem Bin„rbaum den Vorteil hat, da man auf
die einzelnen Objekte sowohl ber eine vertikale Hierarchie als auch
ber eine horizontale Anordnung zugreifen kann. Mit \#OBJECT\# findet man
n„mlich die h„ufig ben”tigten Elemente auf gleicher Hierarchiestufe
sehr leicht.
Die Programmierung eines Objektbaums kann zwar im Grunde mit Hilfe der
Definition eines Objektbaums durchgefhrt werden, doch schon bei klei-
neren Aufgaben erweist sich dieses Unterfangen aufgrund der enormen
Datenflle als ziemlich aussichtslos. Aus diesem Grunde gibt es
\#Resource\# Construction Sets. Dies sind \#GEM\#-Programme, mit deren
Hilfe man die Objekte grafisch definieren kann. Die einzelnen Objekte
eines Programms werden dann in einer \#Resource\#datei gespeichert, aus
der sie bequem geladen werden k”nnen.
Die wichtigste Funktion in der Objektbibliothek ist sicherlich
\#objc_draw\#, die fr das Zeichnen eines Objekts bzw. eines Objektbaumes
verantwortlich ist. Sehr ntzlich ist auch \#objc_change\#, da mit ihr
gleichzeitig der Objektstatus ge„ndert und das betreffende Objekt
seinem neuen Status entsprechend neu gezeichnet werden kann. Wichtig
ist auch noch die Funktion \#objc_find\#, mit deren Hilfe man, ausgehend
von den Koordinaten einer Position, das darunter liegende Objekt er-
mitteln kann.
\end

screen( capsensitive("objc_add") )
Name           Object add - fgt ein Objekt im Objektbaum ein.

Definition     int objc_add( OBJECT *ob_atree, int ob_aparent,
                             int ob_achild );

Prototyp in    aes.h

Beschreibung   Die Funktion fgt im Objektbaum ob_atree das Objekt mit
               der Nummer ob_achild hierarchisch als Kind von
               ob_aparent ein.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#   \#objc_delete\#
\end

screen( capsensitive("objc_delete") )
Name           Object delete - l”scht ein Objekt aus dem Objektbaum.

Definition     int objc_delete( OBJECT *ob_dltree, int ob_dlobject );

Prototyp in    aes.h

Beschreibung   Die Funktion l”scht das Objekt mit der Nummer
               ob_dlobject aus dem Objektbaum ob_dltree.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#   \#objc_add\#
\end

screen( capsensitive("objc_draw") )
Name           Object draw - zeicnet ein Objekt.

Definition     int objc_draw( OBJECT *ob_drtree, int ob_drstart,
                              int ob_drdepth, int ob_drxclip,
                              int ob_dryclip, int ob_drwclip,
                              int ob_drhclip );

Prototyp in    aes.h

Beschreibung   Die Funktion stellt Objektb„ume oder Teile von
               Objektb„umen auf dem Bildschirm dar. Dabei ist
               ob_drtree der entsprechende Objektbaum und ob_drstart
               das Objekt, bei dem mit dem Zeichnen begonnen werden
               soll (also gleich Null, falls der ganze Baum gezeichnet
               werden soll).
ob_drdepth     gibt an, wieviele Stufen des Baumes ab dem Startobjekt
               gezeichnet werden sollen. Zus„tzlich kann man noch ein
               Rechteck (ob_drxclip, ob_dryclip, ob_drwclip,
               ob_drhclip) angeben, auerhalb dessen keine
               Zeichenoperationen stattfinden. Dies ist immer dann
               sinnvoll, wenn z. B. nach dem Schlieen eines Fensters
               nur ein Teil des Objektbaumes vom Fenster bedeckt war
               und nun neugezeichnet werden soll.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#
\end

screen( capsensitive("objc_find") )
Name           Objekt find - ermittelt, welches Objekt sich an der
               angegebenen Bildschirmposition befindet.

Definition     int objc_find( OBJECT *ob_ftree, int ob_fstartob,
                              int ob_fdepth, int ob_fmx, int ob_fmy );

Prototyp in    aes.h

Beschreibung   Die Funktion sucht in dem Objektbaum ob_ftree ab dem
               Objekt ob_fstartob bis in eine Verschachtelungstiefe
               von ob_fdepth nach der Objektnummer des Objekts, das
               unterhalb der Koordinaten ob_fmx, ob_fmy liegt.
Ergebnis       Als Ergebnis wird die Nummer des entsprechenden Objekts
               oder -1 fr "nicht gefunden" wird zurckgegeben.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#
\end

screen( capsensitive("objc_offset") )
Name           Object Offset - berechnet die Position eines Objekts
               auf dem Bildschirm.

Definition     int objc_offset( OBJECT *ob_oftree, int ob_ofobject,
                                int *ob_ofxoff, int *ob_ofyoff );

Prototyp in    aes.h

Beschreibung   Die Funktion berechnet zu dem Objekt mit der Nummer
               ob_ofobject im Objektbaum ob_oftree die absoluten
               Bildschirmkoordinaten und schreibt diese in die
               Rckgabeparameter ob_ofxoff und ob_ofyoff.
Ergebnis       Ein Rckgabewert von Null signalisiert einen Fehler.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#  \#form_center\#
\end

screen( capsensitive("objc_order") )
Name           Object Order - ordnet ein Kind innerhalb des
               Objektbaumes neu an.

Definition     int objc_order( OBJECT *ob_ortree, int ob_orobject,
                               int ob_ornewpos );

Prototyp in    aes.h

Beschreibung   Die Funktion verschiebt das Objekt mit der Nummer
               ob_orobjekt im Objektbaum ob_ortree.
ob_ornewpos    0  bringt das Objekt auf die unterste Hierarchiestufe
               1  bringt das Objekt eine Stufe ber die unterste
                  Hierarchiestufe
               2  bringt das Objekt zwei Stufen ber die unterste
                  Hierarchiestufe
                          :
                          :
               -1 bringt das Objekt ganz nach oben
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#
\end

screen( capsensitive("objc_edit") )
Name           Object edit - editiert einen Text in einem Objekt.

Definition     int objc_edit( OBJECT *ob_edtree, int ob_edobject,
                              int ob_edchar, int *ob_edidx,
                              int ob_edkind );

Prototyp in    aes.h

Beschreibung   Die Funktion erm”glicht es in Objekttypen G_FTEXT und
               G_FBOXTEXT Text einzufgen. Dabei ist ob_edtree der
               entsprechende Objektbaum, ob_edobjekt das zu
               editierende Objekt, ob_edchar das einzufgende
               Zeichen und ob_edidx die Position des Textcursors.
ob_edkind      ED_START  Reserviert.
               ED_INIT   Berechnet aus te_ptext und te_ptmptl einen
                         formatierten String und schaltet den
                         Grafikcursor ein.
               ED_CHAR   Eigentliches Einfgen, wie oben beschrieben.
               ED_END    Cursor wieder ausschalten.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#   \#TEDINFO\#
\end

screen( capsensitive("objc_change") )
Name           Object change - ver„ndert die Darstellung eines Objekts
               innerhalb der angegebenen Grenzen.

Definition     int objc_change( OBJECT *ob_ctree, int ob_cobject,
                                int ob_cresvd, int ob_cxclip,
                                int ob_cyclip, int ob_cwclip,
                                int ob_chclip, int ob_cnewstate,
                                int ob_credraw );

Prototyp in    aes.h

Beschreibung   Die Funktion setzt den Objektstatus des Objekts mit der
               Nummer ob_cobject im Objektbaum ob_ctree auf den Wert
               ob_cnewstate. Ist ob_credraw gleich Eins, so wird das
               Objekt innerhalb des Begrenzungsrechtecks mit den
               Koordinaten ob_cxclip, ob_cyclip, ob_cwclip, ob_chclip
               neu gezeichnet. Der Parameter ob_cresvd hat keine
               Bedeutung, mu aber Null sein.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Objekte\#
Querverweis    \#OBJECT\#   \#ob_state\#
\end

screen( "Objektbaum" )
Die Datenstruktur der Objekte: \#OBJECT\#
----------------------------------------------------------------------

Die Datenstruktur des Objektbaums ist zwar kein Baum im Sinne eines
Bin„rbaums, besitzt jedoch innerhalb eines Zeigers die logischen Ver-
kettungen eines Baums, mit Vorg„ngern und Nachfolgern. Die Spezifika-
tion von Vorg„ngern und Nachfolgern wird durch Indizes auf ein Array
vorgenommen. Die Baumstruktur der einzelnen Objekte kann man sich am
leichtesten an Hand eines einfachen Beispiels veranschaulichen:
Ein Men setzt sich zun„chst aus der Menleiste zusammen. Diese ent-
h„lt wiederum mehrere Titeltexte. Die Titeltexte sind also direkt in
der Menleiste enthalten, sie sind beide Nachfolger des Objekts 'Men-
leiste', bewegen sich also auf der selben hierarchischen Ebene.
Das Objekt Menleiste verweist mit ob_head auf den ersten Mentitel
und mit ob_tail auf den letzten Mentitel. Im ersten Mentitel dient
der Zeiger ob_next zur Adressierung des n„chsten Mentitels.
Die Verkettung weist also folgende Struktur auf:

      Menleiste:
   +---------+---------+--------+
   | \#ob_head\# | \#ob_tail\# | ...    |
   |    o    |    o    |        |
   +----|----+----|----+--------+
        |         +-------------------------+
        V                                   V
   +---------+---------+--------+       +---------+---------+--------+
   | ...     | \#ob_next\# | ...    |  ...  | ...     | ...     | ...    |
   |         |    o    |        |       |         |         |        |
   +---------+----|----+--------+       +---------+---------+--------+
      1.Mentitel |                         n-ter Mentitel
                  +-----> 2.Mentitel


Welche Aktionen mit einem Objekt durchgefhrt werden drfen, wird in
ob_flags festgelegt. Der Zustand eines Objekts wird im Eintrag
\#ob_state\# festgehalten. Der Eintrag ob_type legt den Objekttyp fest.
Manche Objekte ben”tigen zur exakten Festlegung eine zus„tzliche Da-
tenstruktur, wie TEDINFO oder BITBLK. In ob_spec wird dann ein Zeiger
auf diese zus„tzliche Struktur abgelegt. Zusammenfassend nochmals der
Gesamtaufbau der Datenstruktur fr Objekte \#OBJECT\#:

         +-------------+
         |  \#ob_next\#    |   Index fr das n„chste Objekt
         +-------------+
         |  \#ob_head\#    |   Index des ersten Kindes
         +-------------+
         |  \#ob_tail\#    |   Index des letzten Kindes
         +-------------+
         |  \#ob_type\#    |   \#Objektart\#
         +-------------+
         |  \#ob_flags\#   |   \#Manipulationsflags\#
         +-------------+
         |  \#ob_state\#   |   \#Objektstatus\#
         +-------------+
         |  \#ob_spec\#    |   \#OBSPEC\#
         +-------------+
         |  \#ob_x\#       |   relative x-Koordiante zum Eltern-Objekt
         +-------------+
         |  \#ob_y\#       |   relative y-Koordinate zum Eltern-Objekt
         +-------------+
         |  \#ob_width\#   |   Breite des Objekts
         +-------------+
         |  \#ob_height\#  |   H”he des Objekts
         +-------------+

Die Datenstruktur \#OBJECT\# ist in der Datei AES.H definiert. Die ent-
sprechenden Zusatzstrukturen, wie \#TEDINFO\#, \#ICONBLK\#, \#BITBLK\#, \#PARMBLK\#,
\#USERBLK\# und \#ICONBLK\#, befinden sich ebenfalls in AES.H.
\end

screen( "Objektart" )
Objektarten
----------------------------------------------------------------------

Folgende Objektarten stehen zur Auswahl:

20  G_BOX        Rechteckiger Kasten.
21  G_TEXT       Grafiktext, ob_spec zeigt auf TEDINFO-Struktur.
22  G_BOXTEXT    rechteckiger Kasten mit Grafiktext, ob_spec zeigt
                 auf TEDINFO-Struktur.
23  G_IMAGE      Bild, ob_spec zeigt auf BITBLK-Struktur.
24  G_USERDEF    Benutzerdefinierte Funktion zum Zeichnen eines
                 eigenen Objekts. ob_spec verweist auf eine USERBLK
                 Struktur.
25  G_IBOX       Transparentes Rechteck.
26  G_BUTTON     Text mit Rahmen fr Optionsauswahl.
27  G_BOXCHAR    Rechteck, mit einem Zeichen.
28  G_STRING     Zeichenkette, ob_spec zeigt auf den String.
29  G_FTEXT      Formatierter Grafiktext, ob_spec zeigt auf
                 TEDINFO-Struktur
30  G_FBOXTEXT   Rechteck mit formatiertem Grafiktext, ob_spec zeigt
                 auf TEDINFO-Struktur.
31  G_ICON       Icon-Symbol, ob_spec zeigt auf die ICONBLK-Struktur.
32  G_TITLE      Titel eines Drop-Down-Mens, ob_spec zeigt auf
                 den String.

Diese Objekte sind in der Datei AES.H als Konstanten definiert. Die
Datenstrukturen, wie \#OBJECT\#, \#TEDINFO\#, \#ICONBLK\#, \#BITBLK\#, \#PARMBLK\#,
\#USERBLK\# und \#ICONBLK\#, befinden sich ebenfalls in AES.H.
\end

screen( "Objektstatus" )
Objektstati
----------------------------------------------------------------------

Vom Objektstatus h„ngt es ab, wie ein Objekt sp„ter auf dem Bildschirm
dargestellt wird.
Ein Objektstatus kann von folgendem Typ sein:

0  NORMAL      Normale Darstellung.
1  SELECTED    Inverse Darstellung, dh. das Objekt ist selektiert.
2  CROSSED     Falls die \#Objektart\# BOX ist, wird das Objekt mit
               durchgestrichen gezeichnet.
4  CHECKED     Am linken Objektrand befindet sich ein H„kchen.
8  DISABLED    Das Objekt wird grau dargestellt und ist nicht mehr
               selektierbar.
16 OUTLINED    Das Objekt bekommt einen Rahmen.
32 SHADOWED    Ein Schatten wird unter das Objekt gezeichnet.

Sie finden diese Konstanten in der Datei AES.H definiert.
\end

screen( "Manipulationsflags",
		"Objektflags" )
Objektflags
----------------------------------------------------------------------

Die Manipulationsflags eines Objektes bestimmen seine Eigenschaften.
Folgende M”glichkeiten stehen zu Auswahl:

0   NONE          Keine Eigenschaften.
1   SELECTABLE    Das Objekt ist selektierbar.
2   DEFAULT       Wenn der Benutzer die 'Return'- oder 'Enter'-Taste
                  drckt, wird dieses Objekt automatisch selektiert.
                  Diese Flag ist pro Baum nur einmal zugelassen.
4   EXIT          Beim Anklicken eines solchen Objektes wird der
                  Dialog beendet (siehe auch \#form_do\#).
8   EDITABLE      Dieses Objekt kann vom Benutzer mittels der Tastatur
                  editiert werden.
16  RBUTTON       Haben im selben Objektbaum mehrere Objekte die
                  eigenschaft RBUTTON, so kann immer nur eines dieser
                  Objekte selektiert sein. Diese Objekte sollten alle
                  Kinder eines Elternobjekts mit der \#Objektart\# G_IBOX
                  sein. Wird ein anderes Objekt dieser Gruppe ausge-
                  w„hlt, wird das zuvor selektierte automatisch de-
                  selektiert.
32  LASTOB        Hierbei handelt es sich um das letzte Objekt inner-
                  halb eines Objektbaumes.
64  TOUCHEXIT     Der Dialog (siehe auch \#form_do\#) wird beendet, sobald
                  sich der Mauszeiger ber diesem Objekt befindet, und
                  der linke Mausknopf gedrckt wird.
128 HIDETREE      Alle Kinder dieses Objektes werden von \#objc_draw\# und
                  \#objc_find\# nicht mehr bemerkt, sobald dieses Flag ge-
                  setzt ist.
256 INDIRECT      ob_spec zeigt nun auf einen weiteren Zeiger, der
                  dann auf den eigentlichen Wert von ob_spec zeigt
                  (siehe auch \#OBJECT\#). Auf diese Weise lassen sich
                  die Standarddatenstrukturen wie TEDINFO etc. auf
                  einfache Art erweitern.

Sie finden diese Konstanten in der Datei AES.H definiert.
\end

screen( "Resource" )
Die Resourcefunktionen auf einen Blick
----------------------------------------------------------------------

\#rsrc_free\#   Resourcespeicher freigeben.
\#rsrc_gaddr\#  Adresse einer Datenstruktur ermitteln.
\#rsrc_load\#   Resourcedatei laden.
\#rsrc_obfix\#  Zeichenkoordinaten eines Objekts in Pixelkoordinaten
            umwandeln.
\#rsrc_saddr\#  Adresse fr eine Datenstruktur zuordnen.


Resourcen - Grundlage der flexiblen Programmierung

šber Resourcedateien kann man nahezu alle Daten fr die Programmierung
einer Benutzeroberfl„che, wie zum Beispiel Mentexte und Formularber-
schriften, auerhalb eines C-Programms bequem mit einem \#Resource\#-
Editor verwalten. Die Daten werden lediglich beim Programmstart mit
\#rsrc_load\# geladen. Anschlieend kann man mit \#rsrc_gaddr\# auf die
einzelnen \#Objekte\#, \#Mens\# oder \#Formulare\# direkt zugreifen. Mit Hilfe
von \#rsrc_obfix\# kann man die Koordinaten eines Objekts auf die ger„te-
spezifische Umgebung umrechnen.
\end

screen( capsensitive("rsrc_load") )
Name           Recource load - l„dt eine Recourcedatei in den Speicher.

Definition     int rsrc_load( const char *re_lpfname );

Prototyp in    aes.h

Beschreibung   Die Funktion l„dt ein Resourcefile mit dem Filenamen
               re_lpfname in den Speicher und initialisiert einige
               interne Zeiger.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Resource\#
Querverweis    \#rsrc_free\#
\end

screen( capsensitive("rsrc_free") )
Name           Resource free - gibt den Speicher eines Recourcesets
               wieder frei.

Definition     int rsrc_free( void );

Prototyp in    aes.h

Beschreibung   Die Funktion gibt den durch ein Resourcefile belegten
               Speicherplatz wieder frei.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Resource\#
Querverweis    \#rsrc_load\#
\end

screen( capsensitive("rsrc_gaddr") )
Name           Resource get Address - ermittelt die Adresse eines
               Objekts in einem Resourceset.

Definition     int rsrc_gaddr( int re_gtype, int re_gindex,
                               void *gaddr );

Prototyp in    aes.h

Beschreibung   Die Funktion ermittelt die Anfangsadressen
               verschiedener Objektstrukturen von im Speicher
               geladenen Resourcefiles.
re_gindex      fr re_gtype ungleich Null die Objektnummer
gaddr          fr Werte von re_gtype zwischen 0 und 6 erh„lt man die
               Adresse des Zeigers, fr alle anderen Werte erh„lt man
               den Zeiger direkt
re_gtype       die Anfangsadresse welcher Struktur soll berechnet
               werden
                0       Objektbaum
                1       OBJECT
                2       TEDINFO
                3       ICONBLK
                4       BITBLK
                5       String
                6       imagedate
                7       ob_spec
                8       te_ptext
                9       te_ptmplt
                10      te_pvalid
                11      ib_pmask
                12      ib_pdata
                13      ib_ptext
                14      ib_pdate
                15      ad_frstr
                16      ad_frimg
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Resource\#
Querverweis    \#rsrc_load\#   \#OBJECT\#   \#TEDINFO\#-struktur   \#BITBLK\#-struktur
               \#ICONBLK\#-struktur
\end

screen( capsensitive("rsrc_saddr") )
Name           Resource store Address - speichert die Adresse eines
               Objwekts.

Definition     int rsrc_saddr( int re_stype, int re_sindex,
                               void *saddr );

Prototyp in    aes.h

Beschreibung   Die Funktion speichert die Anfangsadresse saddr einer
               Datenstruktur im Speicher.
re_stype       die Anfangsadresse welcher Struktur soll gespeichert
               werden, fr die Typencodierung: siehe \#rsrc_gaddr\#
re_sindex      fr re_stype ungleich Null die Objektnummer

Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Resource\#
Querverweis    \#rsrc_gaddr\#   \#OBJECT\#
\end

screen( capsensitive("rsrc_obfix") )
Name           Resource Object fix - wandelt Zeichensatz- in Pixel-
               Koordinaten um.

Definition     int rsrc_obfix( OBJECT *re_otree, int re_oobject );

Prototyp in    aes.h

Beschreibung   Die Funktion konvertiert die Gr”e und die Position des
               Objekts mit der Nummer re_oobject im Objektbaum
               re_otree von Zeichendarstellung in Pixeldarstellung.
Ergebnis       Als Ergebnis wird immer der Wert 1 zurckgegeben.
Gruppe         \#Resource\#
\end

screen( "Formulare" )
Die Formularfunktionen auf einen Blick
----------------------------------------------------------------------

\#form_alert\#  Alarmbox darstellen.
\#form_button\# Auswerten eines Mausklicks ber einem Formular.
\#form_center\# Koordinaten fr eine zentrierte Objektausgabe berechnen.
\#form_dial\#   Bildschirmspeicher reservieren und freigeben.
\#form_do\#     Eingaben in einem Formular aufnehmen.
\#form_error\#  \#Betriebssystem\#fehlermeldung ausgeben.
\#form_keybd\#  Auswerten einer Tastatureingabe.

Mit den Formularfunktionen kann man bestimmte, h„ufig ben”tigte Ele-
mente fr die Benutzerfhrung sehr schnell aktivieren. Insbesondere
fr Fehlermeldungen und Ja/Nein-Entscheidungen eignen sich die beiden
Funktionen \#form_error\# und \#form_alert\# hervorragend. Daneben sind in
dieser Funktionsreihe einige Funktionen zur Manipulation und Darstel-
lung von Objekten integriert: \#form_center\#, \#form_dial\# und  \#form_do\#.
Die beiden Funktionen \#form_button\# und \#form_keybd\# sind nicht offiziell
dokumentiert, funktionieren aber in der angegebenen Weise.
\end

screen( capsensitive("form_do") )
Name           Form do Dialog - fhrt den dialog mit dem Anwender
               durch.

Definition     int form_do( OBJECT *fo_dotree, int fo_dostartob );

Prototyp in    aes.h

Beschreibung   Die Funktion bernimmt die Behandlung von
               Benutzeraktionen in einem Formular.
fo_dotree      Zeiger auf den Objektbaum der Dialogbox
fo_dostartob   Nummer des Editobjekts, wo sich zu Dialogbeginn der
               Textcursor befinden soll (0 falls der Objektbaum kein
               Editobjekt enth„lt)
Ergebnis       Als Ergebnis wird der Index des Objekts zurckgegeben,
               mit dessen Hilfe der Dialog beendet wurde. Bei einem
               Doppelklick wird zus„tzlich das 15. Bit gesetzt.
Gruppe         \#Formulare\#
Querverweis    \#OBJECT\#   \#ob_type\#   \#ob_flags\#
\end

screen( capsensitive("form_alert") )
Name           Form alert box - zeichnet eine Auswahlbox.

Definition     int form_alert( int fo_adefbttn,
                               const char *fo_astring );

Prototyp in    aes.h

Beschreibung   Die Funktion stellt eine Alarmbox auf dem Bildschirm
               dar und gibt die Nummer des Buttons zurck, mit dem die
               Alarmbox verlassen wurde. Der Bildschirmhintergrund
               wird dabei vom AES gesichert.
fo_adefbttn    Nummer des Defaultbuttons der darzustellenden Alarmbox
                0  kein Defaultbutton
                1  erster Button
                2  zweiter Button
                3  dritter Button
fo_astring     Zeiger auf den String, der das Aussehen der Alarmbox
               bestimmt. Format: "[n][lines][buttons]" wobei
n              die Nummer des einzublendenden Icons ist
                0  kein Icon
                1  Ausrufezeichen
                2  Fragezeichen
                3  Stopschild
lines          h”chstens fnf Textzeilen mit maximal 40 Zeichen, die
               durch das Zeichen '|' getrennt werden
buttons        Texte fr h”chstens drei Buttons, die durch das Zeichen
               '|' getrennt werden.
Ergebnis       Als Ergebnis wird die Nummer der ausgew„hlten Option
               zurckgeliefert.
Gruppe         \#Formulare\#
\end

screen( capsensitive("form_dial") )
Name           Form Dialog Space- reserviert oder gibt Speicherplatz
               frei fr ein Dialogobjekt.

Definition     int form_dial( int fo_diflag, int fo_dilittlx,
                              int fo_dilittly, int fo_dilittlw,
                              int fo_dilittlh, int fo_dibigx,
                              int fo_dibigy, int fo_dibigw,
                              int fo_dibigh );

Prototyp in    aes.h

Beschreibung   Die Funktion form_dial bernimmt mehrere verschiedene
               Aufgaben, um eine Dialogbox darzustellen, in
               Abh„ngigkeit vom Parameter fo_diflag.
fo_diflag      FMD_START   reserviert Bildschirmspeicher fr die
                           Dialogbox
               FMD_GROW    zeichnet eine sich ”ffnende Box von den
                           Anfangskoordinaten zu den Endkoordinaten
                           (\#graf_growbox\#)
               FMD_SHRINK  zeichnet eine sich schlieende Box von den
                           Anfangskoordinaten zu den Endkoordinaten
                           (\#graf_shrinkbox\#)
               FMD_FINISH  gibt den Bildschirmspeicher wieder frei und
                           verursacht eine WM_REDRAW Message
                           (siehe auch unter: \#evnt_mesag\#)
fo_dilittlx,   x und y Koordinate, Breite und H”he des kleinsten,
fo_dilittly,   sich ausdehnenden bzw. schlieenden Rechtecks.
fo_dilittlw,
fo_dilittlh
fo_dibigx,     x und y Koordinate, Breite und H”he des gr”ten, sich
fo_dibigy,     ausdehnenden bzw. schlieenden Rechtecks.
fo_dibigw,
fo_dibigh
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Formulare\#
Querverweis    \#evnt_mesag\#   \#graf_growbox\#   \#graf_shrinkbox\#
\end

screen( capsensitive("form_error") )
Name           Form Error - stellt eine Fehlerbox fr TOS-Fehler dar.

Definition     int  form_error( int fo_enum );

Prototyp in    aes.h

Beschreibung   Gibt eine Fehlerbox auf dem Bildschirm aus, die die
               bergebene MS-DOS Fehlernummer fo_enum im Klartext
               beinhaltet. Man mu also erst die GEMDOS Fehlernummer
               in die entsprechende MS-DOS Fehlernummer umrechnen.
Ergebnis       Als Ergebnis wird die Nummer (1-3) der ausgew„hlten
               Option zurckgegeben. Bei der jetzigen GEM-Version
               steht jedoch nur eine Option zur Verfgung.
Gruppe         \#Formulare\#
\end

screen( capsensitive("form_center") )
Name           Form centered Object - zentriert ein Objekt auf dem
               Bildschirm.

Definition     int  form_center( OBJECT *fo_ctree, int *fo_cx,
                                  int *fo_cy, int *fo_cw, int *fo_ch );

Prototyp in    aes.h

Beschreibung   Die Funktion plaziert ein beliebiges Objekt, auf das
               fo_ctree zeigt, in der Bildschirmmitte und schreibt die
               errechneten Koordinaten in fo_cx, fo_cy, fo_cw, fo_ch.
Ergebnis       Als Ergebnis wird immer eine 1 zurckgegeben.
Gruppe         \#Formulare\#
Querverweis    \#OBJECT\#  \#objc_offset\#
\end

screen( capsensitive("form_keybd") )
Name           Form Keyboard - Nimmt Tastatureingaben in ein Formular
               vor.

Definition     int form_keybd( OBJECT *fo_ktree, int fo_kobject,
                               int fo_kobnext, int fo_kchar,
                               int *fo_knxtobject, int *fo_knxtchar );

Prototyp in    aes.h

Beschreibung   Die Funktion bernimmt Eingaben von der Tastatur in ein
               Formular auf das fo_ktree zeigt. Dabei ist fo_kchar das
               einzutragende Zeichen, fo_kobject das aktuelle
               Editobjekt und fo_obnext, das n„chste Editobjekt. In
               fo_knxtobject steht das neue Editobjekt und in
               fo_knxtchar entweder Null, d. h. die Funktion konnte
               mit fo_kchar etwas anfangen oder den Orginalwert, d. h.
               es handlet sich um einen Buchstaben, den man mit
               \#objc_edit\# einfgen mu.
Ergebnis       Der Rckgabewert der Funktion ist Null, falls ein
               Exitobjekt gew„hlt wurde, sonst ist er positiv.
Gruppe         \#Formulare\#
Querverweis    \#OBJECT\#   \#objc_edit\#   \#form_button\#
\end

screen( capsensitive("form_button") )
Name           Form Button - Nimmt Maustasteneingaben in ein Formular
               vor.

Definition     int form_button( OBJECT *fo_btree, int fo_bobject,
                                int fo_bclicks, int *fo_bnxtobj );

Prototyp in    aes.h

Beschreibung   Die Funktion behandelt Mausknopfevents, die in einem
               Formular, auf das fo_btree zeigt, auftreten und
               bernimmt alle T„tigkeiten die aus diesem Event
               resultieren (z. B. Invertierung von Buttons, die
               selektiert wurden). Dabei ist fo_bobject das aktuelle
               Editobjekt und fo_bclicks die Anzahl der Mausklicks. In
               fo_bnxtobj erh„lt man das neue Editobjekt.
Ergebnis       Der Rckgabewert der Funktion ist Null, falls ein
               Exitobjekt selektiert wurde, sonst ist er positiv.
Gruppe         \#Formulare\#
Querverweis    \#OBJECT\#   \#evnt_multi\#   \#form_keybd\#
\end

screen( "Mens" )
Die Menfunktionen im šberblick
----------------------------------------------------------------------

\#menu_bar\#        Menleiste darstellen oder entfernen.
\#menu_icheck\#     H„kchen bei Menoptionen setzen oder l”schen.
\#menu_ienable\#    Menoptionen setzen oder l”schen.
\#menu_register\#   Menoptionen einfgen.
\#menu_text\#       Text von Meneintr„gen „ndern.
\#menu_tnormal\#    Mentitel invertieren.

Die wichtigste Funktion unter den Menfunktionen ist zweifellos die
Funktion \#menu_bar\#. Damit wird ein kompletter Menbaum dargestellt,
dessen Adresse man sich vorzugsweise aus einer \#Resource\#datei holt.
Um einzelne Menfunktionen w„hrend des Programmablaufs flexibel ein-
und auszuschalten, verwendet man die Funktion \#menu_ienable\#. Schalter
lassen sich sehr gut mit \#menu_icheck\# verwalten. Mit \#menu_register\#
kann man zus„tzliche Menoptionen w„hrend des Programmlaufs bequem
einfgen. Wenn das Men nicht mehr gebraucht wird kann es mit
\#menu_bar\# wieder vollst„ndig entfernt werden.
\end

screen( capsensitive("menu_bar") )
Name           Menu Bar - zeigt oder l”scht eine Menleiste.

Definition     int menu_bar( OBJECT *me_btree, int me_bshow );

Prototyp in    aes.h

Beschreibung   Die Funktion l”scht (me_bshow = 0) oder stellt
               (me_bshow = 1) die Menleiste des Objektbaumes dar,
               auf den me_btree zeigt.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Mens\#
Querverweis    \#OBJECT\#
\end

screen( capsensitive("menu_tnormal") )
Name           Menu Text normal - stellt einen Mentitel invers
               oder normal dar.

Definition     int menu_tnormal( OBJECT *me_ntree, int me_ntitle,
                                 int me_nnormal );

Prototyp in    aes.h

Beschreibung   Die Funktion stellt den Titel mit der Objektnummer
               me_ntitle im Menbaum me_ntree entweder normal
               (me_nnormal = 1) oder invers (me_nnormal = 0) dar.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Mens\#
\end

screen( capsensitive("menu_icheck") )
Name           Menu indicate Check - schreibt oder l”scht ein
               H„ckchen in der Menleiste.

Definition     int menu_icheck( OBJECT *me_ctree, int me_citem,
                                int me_ccheck );

Prototyp in    aes.h

Beschreibung   Falls me_ccheck gleich Null ist, so wird das H„ckchen
               vor dem Meneintrag me_citem im Objektbaum me_ctree
               entfernt, falls me_ccheck gleich Eins ist, so wird das
               H„ckchen vor den Eintrag gesetzt.
Ergebnis       Bei einem Rckgabewert von Null ist ein Fehler
               aufgetreten.
Gruppe         \#Mens\#
Querverweis    \#OBJECT\#   \#ob_state\#
\end

screen( capsensitive("menu_ienable") )
Name           Menu indicate enable - aktiviert oder desaktiviert
               einen Menpunkt.

Definition     int menu_ienable( OBJECT *me_etree, int me_eitem,
                                 int me_eenable );

Prototyp in    aes.h

Beschreibung   Die Funktion setzt den Objektstatus des Meneintrags
               me_eitem im Objektbaum me_etree auf DISABLED bzw.
               NORMAL, falls me_eenable gleich Null bzw. Eins ist.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Mens\#
Querverweis    \#OBJECT\#   \#ob_state\#
\end

screen( capsensitive("menu_register") )
Name           Menu Register - fgt ein Accessory im
               Accessorymen ein.

Definition     int menu_register( int me_rapid,
                                  const char *me_rpstring );

Prototyp in    aes.h

Beschreibung   Die Funktion hat zwei Aufgaben. Zum einen placiert sie
               den String me_rpstring in der Desk-Accessory-Liste.
               Zum anderen gibt sie die Nummer des Meneintrags
               (0 - 5) zurck.
Ergebnis       Ein Rckgabewert von -1 signalisiert einen Fehler.
               me_rapid ist der Accessoryidentifikator.
Gruppe         \#Mens\#
\end

screen( capsensitive("menu_text") )
Name           Menu Text - ersetzt den Text eines Meneintrags.

Definition     int menu_text( OBJECT *me_ttree, int me_titem,
                              const char *me_ttext );

Prototyp in    aes.h

Beschreibung   Die Funktion „ndert den Text des Meneintrages me_titem
               im Objektbaum me_ttree in den Text, auf den me_ttext
               zeigt.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Mens\#
Querverweis    \#OBJECT\#
\end

screen( "Grafikfunktionen" )
Die Grafik-Funktionen auf einen Blick
----------------------------------------------------------------------

\#graf_dragbox\#   Verschieben eines Rechtecks
\#graf_growbox\#   Animation eines sich vergr”ernden Rechtecks.
\#graf_handle\#    Kennung der Bildschirm-Arbeitsstation ermitteln.
\#graf_mkstate\#   Status der Maustasten ermitteln.
\#graf_mouse\#     Mausdarstellung ver„ndern.
\#graf_mbox\#      Rechteckverschiebung darstellen.
\#graf_rubbox\#    Rechteckhlle (¯Gummiband®) darstellen.
\#graf_shrinkbox\# Animation eines sich verkleinernden Rechtecks.
\#graf_slidebox\#  Vertikale oder horizontale Verschiebung eines Rechtecks.
\#graf_watchbox\#  Objektstatus an Position des Mauszeigers koppeln.

In dieser Funktionsgruppe befinden sich einige Funktionen zur allge-
meinen Programmierung unter \#AES\#, wie \#graf_handle\# und \#graf_mouse\#, in
erster Linie aber Funktionen, die vor allem zur grafischen Animation
verwendet werden, wie \#graf_shrinkbox\# und \#graf_growbox\#, die jedoch
beide aus urheberrechtlichen Grnden in neueren \#GEM\#-Implementationen
nicht mehr vorhanden sein werden. Bisher sind jedoch noch alle Atari-
STs mit diesen Funktionen ausgeliefert worden.
\end

screen( capsensitive("graf_rubbox"),
		capsensitive("graf_rubberbox") )
Name           Graphics Rubberbox - zeichnet eine 'Rubberbox'
               (Gummirechteck) auf den Bildschirm.

Definition     int graf_rubbox( int gr_rx, int gr_ry,
                                int gr_minwidth, int gr_minheight,
                                int *gr_rlastwidth,
                                int *gr_rlastheight );
               oder

               int graf_rubberbox(...

Prototyp in    aes.h

Beschreibung   Die Funktion stellt ein Gummiband in Form eines
               Rechtecks auf dem Bildschirm dar, dessen obere linke
               Ecke festbleibt und dessen untere rechte Ecke solange
               bewegt werden kann, wie die linke Maustaste gedrckt
               wird.
gr_rx, gr_ry   Koordinaten der linken, oberen Ecke
gr_minwidth    kleinste Breite des Gummibandes
gr_minheight   kleinste H”he des Gummibandes
gr_rlastwidth  Breite des Gummibandes bei Loslassen des  Mausknopfs
gr_rlastheight H”he des Gummibandes bei Loslassen des Mausknopfs
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Grafikfunktionen\#
\end

screen( capsensitive("graf_dragbox") )
Name           Graphics drag Box - verschiebt ein Rechteck mit
               der Maus.

Definition     int graf_dragbox( int gr_dwidth, int gr_dheight,
                                 int gr_dstartx, int gr_dstarty,
                                 int gr_dboundx, int gr_dboundy,
                                 int gr_dboundw, int gr_dboundh,
                                 int *gr_dfinishx, int *gr_dfinishy );

Prototyp in    aes.h

Beschreibung   Die Funktion erm”glicht das Verschieben eines kleineren
               Rechtecks innerhalb eines gr”eren Begrenzungsrechtecks.
gr_dwidth      Breite des zu verschiebenden Rechtecks
gr_dheight     H”he des zu verschiebenden Rechtecks
gr_dstartx     x-Anfangskoordinate des zu verschiebenden Rechtecks
gr_dstarty     y-Anfangskoordinate des zu verschiebenden Rechtecks
gr_dboundx     x-Koordinate des Begrenzungsrechtecks
gr_dboundy     y-Koordinate des Begrenzungsrechtecks
gr_dboundw     Breite des Begrenzungsrechtecks
gr_dboundh     Breite des Begrenzungsrechtecks
gr_dfinishx    x-Koordinate des zu verschiebenden Rechtecks
               beim Loslassen des Mausknopfs
gr_dfinishy    y-Koordinate des zu verschiebenden Rechtecks
               beim Loslassen des Mausknopfs
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Grafikfunktionen\#
\end

screen( capsensitive("graf_movebox"),
		capsensitive("graf_mbox") )
Name           Graphics move Box - verschiebt ein Rechteck mit
               der Maus.

Definition     int graf_mbox( int gr_mwidth, int gr_mheight,
                              int gr_msourcex, int gr_msourcey,
                              int gr_mdestx, int gr_mdesty );

               oder

               int graf_movebox(...

Prototyp in    aes.h

Beschreibung   Die Funktion zeichnet ein Rechteck mit den Maen
               gr_mwidth und gr_mheight, das sich von den
               Ausgangskoordinaten gr_msourcex und gr_msourcey zu den
               Koordinaten gr_mdestx und gr_mdesty bewegt.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Grafikfunktionen\#
\end

screen( capsensitive("graf_growbox") )
Name           Graphics grow Box - zeichnet ein sich vergr”erndes
               Rechteck.

Definition     int graf_growbox( int gr_gstx, int gr_gsty,
                                 int gr_gstwidth, int gr_gstheight,
                                 int gr_gfinx, int gr_gfiny,
                                 int gr_gfinwidth, int gr_gfinheight);

Prototyp in    aes.h

Beschreibung   Die Funktion zeichnet ein sich ausdehnendes Rechteck
               der Anfangsgr”e gr_gstwidth und gr_gstheight mit den
               Anfangskoordinaten gr_gstx und gr_gsty bis zur Endgr”e
               gr_gfinwidth und gr_gfinheight mit den Endkoordinaten
               gr_gfinx und gr_gfiny.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Grafikfunktionen\#
Querverweis    \#form_dial\#   \#graf_shrinkbox\#
\end

screen( capsensitive("graf_shrinkbox") )
Name           Graphics shrink Box - zeichnet ein sich verkleinerndes
               Rechteck.

Definition     int graf_shrinkbox(int gr_sfinx, int gr_sfiny,
                                  int gr_sfinwidth, int gr_sfinheight,
                                  int gr_sstx, int gr_ssty,
                                  int gr_sstwidth, int gr_sstheight);

Prototyp in    aes.h

Beschreibung   Die Funktion zeichnet ein sich zusammenziehendes
               Rechteck der Anfangsgr”e gr_sstwidth und gr_sstheight
               mit den Anfangskoordinaten gr_sstx und gr_ssty bis zur
               Endgr”e gr_sfinwidth und gr_sfinheight mit den
               Endkoordinaten gr_sfinx und gr_sfiny.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Grafikfunktionen\#
Querverweis    \#form_dial\#   \#graf_growbox\#
\end

screen( capsensitive("graf_watchbox") )
Name           Graphics watch Box - selektiert ein Objekt und
               berwacht die Mausbewegungen bezglich dieses Objekts.

Definition     int graf_watchbox( OBJECT *gr_wptree, int gr_wobject,
                                  int gr_winstate, int gr_woutstate );

Prototyp in    aes.h

Beschreibung   Die Funktion setzt den Objektstatus des Objekts
               gr_wobject im Objektbaum gr_wptree in Abh„ngigkeit der
               Position des Mauszeigers innerhalb oder auerhalb eines
               Rechtecks. Die Funktion wird beim Loslassen des
               Mausknopfs verlassen. Dabei ist gr_winstate der
               Objektstatus, falls sich der Mauszeiger innerhalb des
               Rechtecks befindet, und gr_woutstate der Objektstatus,
               falls sich der Mauszeiger auerhalb des Rechtecks
               befindet.
Ergebnis       Der Rckgabewert der Funktion ist entweder gleich Eins
               fr "Mauszeiger innerhalb des Objekts" oder gleich Null
               fr "Mauszeiger auerhalb des Objekts".
Gruppe         \#Grafikfunktionen\#
Querverweis    \#OBJECT\#
\end

screen( capsensitive("graf_slidebox") )
Name           Graphics slide Box - ermittelt die Position der
               Schieberegler.

Definition     int graf_slidebox( OBJECT *gr_slptree, int gr_slparent,
                                  int gr_slobject, int gr_slvh );

Prototyp in    aes.h

Beschreibung   Die Funktion erm”glicht es einen "Slider" recht einfach
               zu realisieren. Solange die linke Maustaste gedrckt
               wird, kann das Objekt mit der Nummer gr_slobjekt
               innerhalb des Mutterobjekts gr_slparent im Objektbaum
               gr_slptree horizontal (gr_slvh = 0) oder vertikal
               (gr_slvh = 1) verschoben werden.
Ergebnis       Die Funktion liefert die relative Position zwischen 0
               (ganz links bzw. ganz oben) und 1000 (ganz rechts bzw.
               ganz unten) des "Sliders" als Funktionswert.
Gruppe         \#Grafikfunktionen\#
Querverweis    \#OBJECT\#
\end

screen( capsensitive("graf_handle") )
Name           Graphics handle - ermittelt den VDI-Handle der
               Arbeitsstation.

Definition     int graf_handle( int *gr_hwchar, int *gr_hhchar,
                                int *gr_hwbox, int *gr_hhbox );

Prototyp in    aes.h

Beschreibung   Die Funktion ermittelt die Kennung (\#handle\#) der
               VDI-Workstation, auf die die Ausgaben des AES gehen.
               Zus„tzlich bekommt man noch Information ber die Gr”e
               des Zeichensatzes. Dabei sind gr_hwchar und gr_hhchar
               die Breite und H”he des Zeichensatzes in
               Bildschirmpunkten und gr_hwbox und gr_hhbox die Breite
               und H”he eines Rechtecks, das jedes einzelne Zeichen
               vollst„ndig umgibt.
Ergebnis       Als Ergebnis erh„lt man den VDI-Handle.
Gruppe         \#Grafikfunktionen\#
Querverweis    \#v_opnvwk\#
\end

screen( capsensitive("graf_mouse") )
Name           Graphics Mouse - ver„ndert die Darstellung des
               Mauszeigers.

Definition     int graf_mouse( int gr_monumber, \#MFORM\# *gr_mofaddr );

Prototyp in    aes.h

Beschreibung   Die Funktion w„hlt die neue Form gr_monumber fr den
               Mauszeiger aus.
gr_monumber    ARROW                   0
               TEXT_CRSR               1
               HOURGLASS,BUSYBEE       2
               POINT_HAND              3
               FLAT_HAND               4
               THIN_CROSS              5
               THICK_CROSS             6
               OUTLN_CROSS             7
               USER_DEF                255  eigene Mausform
               M_OFF                   256  Mauszeiger abschalten
               M_ON                    257  Mauszeiger anschalten
               Falls gr_monumber gleich USER_DEF, dann ist der
               Parameter ein Zeiger auf die Struktur \#MFORM\#, die das
               Aussehen des Mauszeigers festlegt.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Grafikfunktionen\#
\end

screen( capsensitive("graf_mkstate") )
Name           Graphics Mouse and Keyboard Status - ermittelt
               den Status von Maus und Tastatur.

Definition     int graf_mkstate( int *gr_mkmx, int *gr_mkmy,
                                 int *gr_mkmstate, int *gr_mkkstate );

Prototyp in    aes.h

Beschreibung   Die Funktion ermittelt die aktuelle Mausposition und
               den Zustand der  Maustasten und der Sondertasten der
               Tastatur.
               gr_mkmx,
               gr_mkmy        Position des Mauszeigers
               gr_mkkstate    Sondertasten der Tastatur (\#evnt_button\#)
               gr_mkmstate    Zustand der Mauskn”pfe (\#evnt_button\#)
Ergebnis       Als Ergebis wird immer eine 1 zurckgegeben.
Gruppe         \#Grafikfunktionen\#
\end

screen( "Applikation" )
Die Applikationsfunktionen auf einen Blick
----------------------------------------------------------------------

\#appl_exit\#    AES-Anwenderprogramm abmelden und Kennung freigeben.
\#appl_find\#    AES-Kennung einer anderen AES-Applikation ermitteln.
\#appl_init\#    AES-Anwendung anmelden.
\#appl_read\#    AES-Mitteilungen lesen.
\#appl_tplay\#   Ereignisse abspielen.
\#appl_trecord\# Ereignisse aufzeichnen.
\#appl_write\#   AES-Mitteilungen schreiben.

Jede Applikation unter \#GEM\# hat ein Anfang und ein Ende: Mit \#appl_init\#
meldet man sie ordnungsgem„ unter \#GEM\# an. Am Ende eines Programms
verl„t man das \#AES\#-System mit \#appl_exit\#. Um mit anderen Applika-
tionen kommunizieren zu k”nnen, mu man zuerst mit \#appl_find\# deren
Kennung ermitteln. Anschlieend kann man mit \#appl_write\# Mitteilungen
an andere Programme weitergeben. Mit \#appl_read\# kann man dann l„ngere
Mitteilungen empfangen, fr krzere (bis zu 16 Bytes) empfiehlt sich
jedoch der Gebrauch der Funktion \#evnt_mesag\#. Insbesondere fr De-
monstrationen und die Implementation von Makro-Recordern eignen sich
die Funktionen \#appl_trecord\# und \#appl_tplay\#. Damit lassen sich \#GEM\#-
Ereignisse aufzeichnen und wieder abspielen.
\end

screen( capsensitive("appl_init") )
Name           Application Initialization - meldet die Applikation
               unter AES an.

Definition     int appl_init( void );

Prototyp in    aes.h

Beschreibung   Der Aufruf von appl_init meldet das Programm beim AES
               an, initialisiert die internen Parameterbergabefelder
               und gibt eine nichtnegative Zahl als
               Applikationsidentifikation zurck.
Ergebnis       Eine Zahl kleiner Null signalisiert einen Fehler.
Gruppe         \#Applikation\#
Querverweis    \#appl_find\#   \#appl_exit\#
\end

screen( capsensitive("appl_find") )
Name           Application find - ermittelt die Applikationsnummer
               einer AES-Anwendung.

Definition     int appl_find( const char *ap_fpname );

Prototyp in    aes.h

Beschreibung   Diese Funktion ermittelt die Applikationsidentifikation
               einer anderen, parallel laufenden Applikation. Dabei
               zeigt ap_fpname auf den Namen der Applikation deren
               Identifikator gefunden werden soll.
               Wichtig: Der Name mu unbedingt acht Zeichen lang sein,
               ist er krzer, so mu er mit Leerzeichen aufgefllt
               werden.
Ergebnis       Ein Rckgabewert kleiner Null kennzeichnet einen
               aufgetretenen Fehler.
Gruppe         \#Applikation\#
\end

screen( capsensitive("appl_read") )
Name           Application read - empf„ngt eine Mitteilung einer
               anderen Applikation.

Definition     int appl_read( int ap_rid, int ap_rlength,
                              void *ap_rpbuff );

Prototyp in    aes.h

Beschreibung   Mit dieser Funktion ist es m”glich nach einem
               Message-Event  ap_rlength Bytes aus dem Buffer
               ap_rpbuff zu lesen. ap_rid ist dabei die
               Applikationsidentifikation der Applikation, die die
               Nachricht gesendet hat.
Ergebnis       Wird eine Null zurckgegeben, so ist ein Fehler
               aufgetreten, sonst wird eine positive Zahl als
               Ergebnis zurckgegeben.
Gruppe         \#Applikation\#
Querverweis    \#appl_init\#   \#appl_write\#   \#evnt_mesag\#
\end

screen( capsensitive("appl_write") )
Name           Application write - sendet eine Mitteilung an eine
               ander Applikation.

Definition     int appl_write( int ap_wid, int ap_wlength,
                               void *ap_wpbuff );

Prototyp in    aes.h

Beschreibung   Mit appl_write ist es m”glich einer parallel laufenden
               Applikation, deren Applikationsidentifikator ap_wid
               ist, ap_wlength Bytes aus dem Buffer ap_wpbuff als
               Nachricht zu schicken.
Ergebnis       Wird eine Null zurckgegeben, so ist ein Fehler
               aufgetreten, sonst wird eine positive Zahl als
               Ergebnis zurckgegeben.
Gruppe         \#Applikation\#
Querverweis    \#appl_init\#   \#appl_read\#   \#appl_find\#
\end

screen( capsensitive("appl_exit") )
Name           Application exit - meldet eine Applikation vom AES ab.

Definition     int appl_exit( void );

Prototyp in    aes.h

Beschreibung   Meldet eine Applikation beim AES wieder ab und gibt
               deren Applikationsidentifikator wieder frei.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Applikation\#
Querverweis    \#appl_init\#
\end

screen( capsensitive("appl_tplay") )
Name           Application play - spielt aufgezeichnete AES-
               Ereignise ab.

Definition     int appl_tplay( void *ap_tpmem, int ap_tpnum,
                               int ap_tpscale );

Prototyp in    aes.h

Beschreibung   Die Funktion appl_tplay erlaubt es eine Reihe von
               aufgezeichneten Benutzeraktionen (Events) wieder
               abzuspielen. ap_tpmem zeigt dabei auf den
               Aufzeichnungsbuffer, ap_tpnum ist die Anzahl der
               abzuspielenden Events und ap_tpscale gibt die
               Wiederholungsgeschwindigkeit an ( 50 entspricht z. B.
               halber Geschwindigkeit)
Ergebnis       Als Ergebnis wird immer der Wert 1 zurckgegeben.
Gruppe         \#Applikation\#
Querverweis    \#appl_trecord\#
\end

screen( capsensitive("appl_trecord") )
Name           Application record - nimmt AES-Ereignisse auf.

Definition     int appl_trecord( void *ap_trmem, int ap_trcount );

Prototyp in    aes.h

Beschreibung   Die Funktion erm”glicht es, eine Anzahl von ap_trcount
               an Benutzeraktionen (Events) in dem Buffer, auf den
               ap_trmem zeigt, aufzuzeichnen.
Ergebnis       Als Ergebnis wird die Anzahl der tats„chlich
               aufgezeichneten Ereignisse zurckgeliefert.
Gruppe         \#Applikation\#
Querverweis    \#appl_tplay\#
\end

screen( "Zwischenspeicher",
		"Clipboardfunktionen" )
Clipboardfunktionen

Unter \#GEM\# gibt es die M”glichkeit, Informationen in einem Zwischen-
speicher, dem Clipboard, abzulegen. Das Clipboard ist als Datei reali-
siert. Man kann Daten hineinschreiben und wieder auslesen.

Die Clipboardfunktionen auf einen Blick:

\#scrp_read\#   Aus dem Clipboard lesen.
\#scrp_write\#  Ins Clipboard schreiben.
\end

screen( capsensitive("scrp_read") )
Name           Scrap read - liest das Clipboard ein.

Definition     int scrp_read( char *sc_rpscrap );

Prototyp in    aes.h

Beschreibung   Die Funktion ermittelt den aktuellen Pfadnamen fr die
               Zwischenablage und schreibt ihn in sc_rpscrap.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Zwischenspeicher\#
Querverweis    \#scrp_write\#
\end

screen( capsensitive("scrp_write") )
Name           Scrap write - schreibt in ein Clipboard.

Definition     int scrp_write( char *sc_wpscrap );

Prototyp in    aes.h

Beschreibung   Die Funktion setzt den Pfadnamen fr die Zwischenablage
               auf den neuen Namen sc_wpscrap.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Zwischenspeicher\#
Querverweis    \#scrp_read\#
\end

screen( "Shell" )
Shellfunktionen

Fr den Aufruf anderer Applikationen und der Kommunikation mit diesen
Programmen sind die Shellfunktionen zust„ndig. Sie stellen auch
weitere \#Betriebssystem\#informationen zur Verfgung.

Die Shellfunktionen auf einen Blick:

\#shel_envrn\#  Environment-Variable abfragen.
\#shel_find\#   Datei suchen.
\#shel_get\#    Environment-Puffer lesen.
\#shel_put\#    Environment-Puffer schreiben.
\#shel_read\#   Kommandozeilenparameter lesen.
\#shel_write\#  Applikation starten.
\end

screen( capsensitive("shel_read") )
Name           Shell read - liest die Kommandozeilen-Parameter
               der Applikation.

Definition     int shel_read( char *sh_rpcmd, char *sh_rptail );

Prototyp in    aes.h

Beschreibung   Die Funktion kann fr eine Applikation den Pfadnamen
               und Kommandozeile bestimmen, wenn diese Applikation mit
               \#shel_write\# gestartet wurde. Nach Beendigung der
               Funktion beinhaltet sh_rptail den Pfadnamen und
               sh_rpcmd die Kommandozeile.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Shell\#
Querverweis    \#shel_write\#
\end

screen( capsensitive("shel_write") )
Name           Shell write - startet eine Andere Applikation.

Definition     int shel_write( int sh_wdoex, int sh_wisgr,
                               int sh_wiscr, char *sh_wpcmd,
                               char *sh_wptail );

Prototyp in    aes.h

Beschreibung   Mit der Funktion shel_write kann man aus einer
               Applikation eine nachfolgende Applikation starten.
sh_wdoex       0  kein weiteres Programm laden und starten
               1  ein neues Programm laden und starten
sh_wisgr       0  es handelt sich um kein Grafikprogramm
               1  es handelt sich um ein Grafikprogramm
sh_wiscr       wird ignoriert
sh_wpcmd       Pfadname des zu startenden Programms
sh_wptail      Kommandozeile fr das zu startende Programm
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Shell\#
\end

screen( capsensitive("shel_find") )
Name           Shell find - sucht Dateien.

Definition     int shel_find( char *sh_fpbuff );

Prototyp in    aes.h

Beschreibung   Mit der Funktion shel_find kann man eine Datei mit dem
               Namen sh_fpbuff im Inhaltsverzeichnis suchen. Die Datei
               wird dabei im Wurzelverzeichnis, im aktuellen Directory
               und unter Bercksichtigung aller Suchpfade, die in der
               Environmentvariable 'PATH=' angegeben sind, gesucht.
               Nach der Bearbeitung der Funktion findet man den ganzen
               Zugriffspfad in sh_fpbuff.
Ergebnis       Ein Rckgabewert von Null signalisiert 'Datei nicht
               gefunden'.
Gruppe         \#Shell\#
Querverweis    \#shel_envrn\#
\end

screen( capsensitive("shel_envrn") )
Name           Shell environment - ermittelt den Wert von
               Environmentvariablen.

Definition     int shel_envrn( char **sh_epvalue, char *sh_eparm );

Prototyp in    aes.h

Beschreibung   Die Funktion erm”glicht es den Wert von verschiedenen
               Environmentvariablen zu ermitteln. Dazu bergibt man
               den Namen der Variable in sh_eparm und erh„lt einen
               Zeiger auf den Wert der Variablen in sh_epvalue.
Ergebnis       Die Funktion liefert als Ergebnis immer 1.
Gruppe         \#Shell\#
\end

screen( capsensitive("shel_put") )
Name           Shell put - schreibt in den GEM-Environment-Puffer.

Definition     int shel_put( char *sh_paddr, int sh_plen );

Prototyp in    aes.h

Beschreibung   Die Funktion schreibt in den Environment-Puffer des
               AES. Dabei werden sh_plen Zeichen aus dem
               Speicherbereich, auf den sh_paddr zeigt, in den
               Environment-Puffer kopiert.
Ergebnis       Ein Rckgabewert von Null signalisiert einen Fehler.
Gruppe         \#Shell\#
Querverweis    \#shel_get\#   \#shel_envrn\#   \#shel_find\#
\end

screen( capsensitive("shel_get") )
Name           Shell get - liest den GEM-Environment-Puffer.

Definition     int shel_get( char *sh_gaddr, int sh_glen );

Prototyp in    aes.h

Beschreibung   Die Funktion liest aus dem Environment-Puffer des AES
               sh_glen Zeichen und kopiert sie in den Speicherbereich
               auf den sh_gaddr zeigt.
Ergebnis       Ein Rckgabewert von Null signalisiert einen Fehler.
Gruppe         \#Shell\#
Querverweis    \#shel_put\#
\end

screen( "Dateiauswahl" )
Dateiauswahl

Zur Auswahl eines Dateinamens mit Hilfe einer Dialogbox dienen die
Funkitonen:

\#fsel_input\#    Dateinamen ausw„hlen.
\#fsel_exinput\#  Dateinamen ausw„hlen. 
              (erst ab TOS Version 1.4 verfgbar)
\end

screen( capsensitive("fsel_input") )
Name           File Selection Input - selektiert Dateinamen.

Definition     int fsel_input( char *fs_iinpath, char *fs_iinsel,
                               int *fs_iexbutton );

Prototyp in    aes.h

Beschreibung   Die Funktion stellt eine Dateiauswahlbox mit dem
               Pfadnamen, auf den fs_iinpath zeigt, auf dem Bildschirm
               dar und erlaubt es dem Benutzer, ein File auszuw„hlen.
               Der eventuell ver„nderte Pfadname steht dann in dem
               Buffer, auf den fs_iinpath zeigt. Der ausgew„hlte
               Filename steht in fs_iinsel, und fs_iexbutton enth„lt
               die Nummer des Knopfes, mit dem die Fileselektorbox
               verlassen wurde (0 = CANCEL, 1 = OK).
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Dateiauswahl\#
Querverweis    \#fsel_exinput\#
\end

screen( capsensitive("fsel_exinput") )
Name           File Selection Input - selektiert Dateinamen.
               (erst ab TOS Version 1.4 verfgbar)

Definition     int fsel_exinput( char *fs_einpath, char *fs_einsel,
                               int *fs_eexbutton, char *elabel );

Prototyp in    aes.h

Beschreibung   Die Funktion stellt eine Dateiauswahlbox mit dem
               Pfadnamen, auf den fs_einpath zeigt, auf dem Bildschirm
               dar und erlaubt es dem Benutzer, ein File auszuw„hlen.
               Der eventuell ver„nderte Pfadname steht dann in dem
               Buffer, auf den fs_einpath zeigt. Der ausgew„hlte
               Filename steht in fs_einsel, und fs_eexbutton enth„lt
               die Nummer des Knopfes, mit dem die Fileselektorbox
               verlassen wurde (0 = CANCEL, 1 = OK).
               Mit elabel kann zus„tzlich ein Titel bergeben werden,
               der als šberschrift in der Dateiauswahlbox angezeigt
               wird.
Ergebnis       Ein Fehler ist nur dann aufgetreten, wenn als Ergebnis
               0 zurckgegeben wird.
Gruppe         \#Dateiauswahl\#
Querverweis    \#fsel_input\#
\end

screen( "VDI" )
Das VDI
----------------------------------------------------------------------

Die VDI-Funktionen lassen sich in folgende Gruppen gliedern:

               \#Kontrollfunktionen\#
               \#Ausgabefunktionen\#
               \#Attributfunktionen\#
               \#Rasterfunktionen\#
               \#Eingabefunktionen\#
               \#Auskunftsfunktionen\#
               \#Escapefunktionen\#

W„hrend das \#AES\#-System in erster Linie die Basis fr eine bedie-
nungsfreundliche Benutzeroberfl„che sein soll, sind die VDI-Funktionen
als standardisiertes Grafiksystem zu verstehen.
Leider ist das VDI-System auerhalb der \#GEM\#-Welt nur wenig verbrei-
tet und hat aus diesem Grund nur wenig Chancen einmal ein echter Stan-
dard zu werden. Dem Programmierer stellt sich VDI als eine sehr um-
fangreiche Grafikbibliothek dar, deren Ausgabeformat ber mehrere Com-
putersysteme hinweg portabel ist.
Fr ein systemunabh„ngiges Grafiksystem ist ein von der jeweiligen
Hardware unabh„ngiges Koordinatensystem n”tig. In VDI sind dies die
Normalkoordinaten. Der Ursprung dieses Koordinatensystems liegt in der
linken unteren Ecke, der Wertebereich reicht von 0 bis 32767, sch”pft
demnach die 16 Bit eines Maschinenwortes voll aus. Daneben gibt es
jedoch noch ein zweites Koordinatensystem, die Rasterkoordinaten, mit
deren Hilfe grofl„chige Kopieroperationen und Verschiebungen ohne Ge-
schwindigkeitsverlust durchgefhrt werden k”nnen. Unter \#GEM\# kann man
also wahlweise zwei verschiedene Koordinatensysteme verwenden.

Die zum Arbeiten mit den VDI-Funktionen n”tigen Konstanten, Daten-
strukturen und Funktionsprototypen finden Sie in der Datei VDI.H.

Einige der VDI-Funktionen ben”tigen jedoch die VDI-erweiterung \#GDOS\#.
\end

screen( "GDOS" )
Das GDOS
----------------------------------------------------------------------

Einige Funktionen des VDI k”nnen erst nach der Installation des GDOS
aus dem AUTO-Ordner heraus richtig benutzt werden. Grunds„tzlich
erm”glicht das GDOS beliebige Ger„tetreiber und Zeichens„tze, die
im ASSIGN.SYS File aufgefhrt werden mssen, zu laden und zu benutzen.
Es ist dabei v”llig unabh„ngig vom verwendeten Ger„t. Ger„tespezifisch
sind nur die nachzuladenden Treiber, die die VDI Funktionen auf dem
entsprechenden Ger„t realisieren. Bei genauer Kenntnis des
Treiberformats ist es so m”glich beliebige, und auch exotische
Ausgabeger„te als VDI Ausgabeger„t zu betreiben.
Mit residentem GDOS erh”ht sich die Zahl der Verfgung stehenden
VDI-Funktionen, w„hrend alle anderen Funktionen voll funktionsf„hig
bleiben bzw. einen erweiterten Ausgabeumfang erhalten. Umgekehrt ist
das aber nicht so, Funktionen, die GDOS ben”tigen, fhren ohne
residentes GDOS zum Absturz des Rechners.

Die neueste Version des GDOS ist das \#FSMGDOS\#, das zus„tzlich
frei scalierbare Zeichens„tze zur Verfgung stellt.

Die Funktionen \#vq_gdos\# und \#vq_vgdos\# prfen, ob GDOS installiert
ist. Einige Funktionen sollten nicht ohne GDOS benutzt werden:

\#v_opnwk\#, \#v_clswk\#, \#vst_load_fonts\#, \#vst_unload_fonts\#,
\#vst_font\#, \#v_clear_disp_list\#, \#v_bit_image\#, \#vqp_films\#,
\#vqp_state\#, \#vsp_state\#, \#vsp_save\#, \#vsp_message\#, \#vqp_error\#,
\#v_meta_extents\#, \#v_write_meta\#, \#vm_filename\#,  \#vm_coords\#,
\#vm_pagesize\#
\end

screen( "FSM",
		"FSMGDOS" )
Das FSMGDOS
----------------------------------------------------------------------

Die neueste Version des \#GDOS\# ist das FSMGDOS, das zus„tzlich
frei scalierbare Zeichens„tze zur Verfgung stellt. FSM steht
fr Font Scale Manager.

Die Funktion \#vq_vgdos\# prft, ob FSMGDOS installiert ist.
Einige Funktionen k”nnen ohne FSMGDOS nicht benutzt werden
(zus„tzlich zu den unter \#GDOS\# aufgefhrten Funktionen):


\#vqt_f_extent\#, \#v_ftext\#, \#v_killoutline\#, \#v_getoutline\#,
\#vst_scratch\#, \#vst_error\#, \#vqt_advance\#, \#vst_arbpt\#,
\#vqt_devinfo\#, \#v_flushcache\#, \#vqt_cachesize\#,
\#vqt_get_tables\#, \#v_loadcache\#, \#v_savecache\#,
\#vst_setsize\#, \#vst_skew\#
\end

screen( capsensitive("handle") )
Das VDI-Handle
----------------------------------------------------------------------

dient zur Spezifikation des Zieles der VDI-Funktionen. Hat man mehrere
Ger„te, wie Drucker und Bildschirm, als Arbeitsstation (\#v_opnwk\#,
\#v_opnvwk\#) ge”ffnet, wird jeder Arbeitsstation ein handle zugeteilt,
durch das das VDI erkennt, welches Ger„t angesprochen werden soll.
Jede VDI-Funktion braucht also grunds„tzlich einen Parameter handle
zur Zielangabe und die \#Attributfunktionen\# setzen die Attribute
grunds„tzlich nur fr das durch das handle spezifizierte Ger„t, d. h.
Attribute k”nnen fr alle Ger„te verschieden eingestellt werden.
\end

screen( capsensitive("pxyarray") )
Das pxyarray
----------------------------------------------------------------------

wird im VDI benutzt um verschiedene grafische Objekte
anhand von mehreren Koordinatenpaaren (x,y) darzustellen. Beispiele
fr die Anwendung des pxyarrays sind die Darstellung von Rechtecken.

       pxyarray[0]         x-Koordinate des oberen linken Eckpunktes
       pxyarray[1]         y-Koordinate des oberen linken Eckpunktes
       pxyarray[2]         x-Koordinate des unteren rechten Eckpunktes
       pxyarray[3]         y-Koordinate des unteren rechten Eckpunktes
oder allgemein von n Punktepaaren
       pxyarray[0]         x-Koordinate des ersten Punktepaares
       pxyarray[1]         y-Koordinate des ersten Punktepaares
       pxyarray[2]         x-Koordinate des zweiten Punktepaares
       pxyarray[3]         y-Koordinate des zweiten Punktepaares
           :
       pxyarray[2*n - 2]   x-Koordinate des n-ten Punktepaares
       pxyarray[2*n - 1]   y-Koordinate des n-ten Punktepaares
\end

screen( "Kontrollfunktionen" )
Kontrollfunktionen im šberblick
----------------------------------------------------------------------

Alle VDI-Applikationen mssen sich beim System ordentlich anmelden,
damit die vorhandenen Resourcen einwandfrei bereitgestellt werden
k”nnen.

\#v_bez_on\#          Bezier-Spline-Erzeugung an.
\#v_bez_off\#         Bezier-Spline-Erzeugung aus.
\#v_clrwk\#           Reinitialisierung einer Arbeitsstation.
\#v_clswk\#           Physikalische Arbeitstation (Drucker etc.) abmelden.
\#v_clsvwk\#          Virtuelle Arbeitstation (Bildschirm) abmelden.
\#v_flushcache\#      \#FSM\#-Cache l”schen.
\#v_getoutline\#      Outline eines Zeichens berechnen.
\#v_killoutline\#     Speicher zur Outline-Generierung freigeben.
\#v_loadcache\#       FSM-Cache laden.
\#v_opnwk\#           Physikalische Arbeitstation (Drucker etc.) anmelden.
\#v_opnvwk\#          Virtuelle Arbeitstation (Bildschirm) anmelden.
\#v_set_app_buff\#    Speicher fr Bezier-Spline-Erzeugung reservieren.
\#v_savecache\#       FSM-Cache speichern.
\#v_updwk\#           Befehle im Puffer eines Ein-/Ausgabeger„ts sofort
                  ausfhren.
\#vs_clip\#           Arbeitsbereich auf einen Teil des Bildschirms be-
                  schr„nken.
\#vst_load_fonts\#    Zus„tzliche Zeichens„tze laden.
\#vst_unload_fonts\#  Speicherplatz, den zus„tzliche Zeichens„tze belegt
                  haben, freigeben.
\end

screen( "Ausgabefunktionen" )
Ausgabefunktionen im šberblick
----------------------------------------------------------------------

\#v_alpha_text\#   Ausgabe von Text im Textmodus
\#v_bez\#          Bezier-Spline zeichnen.
\#v_bez_fill\#     Bezier-Spline zeichnen und fllen.
\#v_pline\#        Linienzug zeichnen.
\#v_pmarker\#      Markierung zeichnen.
\#v_gtext\#        Text grafisch ausgeben.
\#v_ftext\#        Text mittels \#FSM\#-Font ausgeben.
\#v_fillarea\#     Angegebene Fl„che ausfllen.
\#v_cellarray\#    Farbauswahltabelle darstellen.
\#v_contourfill\#  Fl„che bis zu bestimmten Begrenzungen ausfllen.
\#vr_recfl\#       Rechteck ausfllen.
\#v_arc\#          Kreisbogen zeichnen.
\#v_bar\#          Ausgeflltes Rechteck zeichnen.
\#v_circle\#       Ausgefllten Kreis zeichnen.
\#v_ellipse\#      Ausgefllte Ellipse zeichnen.
\#v_ellarc\#       Ellipsenbogen zeichnen.
\#v_ellpie\#       Ausgeflltes Ellipsensegment zeichnen.
\#v_justified\#    Ausgerichteten Text ausgeben.
\#v_pieslice\#     Ausgeflltes Kreissegment zeichnen.
\#v_rbox\#         Abgerundetes Rechteck zeichnen.
\#v_rfbox\#        Ausgeflltes, abgerundetes Rechteck zeichnen.

Mit den Ausgabefunktionen k”nnen grafische Elemente wie Kreise und
Linien, aber auch Texte auf den angemeldeten Arbeitsstationen ausge-
geben werden.
\end

screen( "Attributfunktionen" )
Attributfunktionen im šberblick
----------------------------------------------------------------------

Diese Gruppe von Funktionen dient dem Einstellen von Farbe, Typ, Stil
und H”he der \#Ausgabefunktionen\#.

ù šbergeordnete Attribute:

\#vs_color\#       Farbintensit„t einer Farbe festlegen.
\#vswr_mode\#      Schreibmodus(Replace, Transparent, ...) ausw„hlen.

ù Linienattribute:

\#vsl_color\#      Linienfarbe ausw„hlen.
\#vsl_ends\#       Linienenden definieren (Abrundung, Pfeile, ...).
\#vsl_type\#       Liniendarstellung einstellen.
\#vsl_udsty\#      Eigene Liniendarstellung definieren.
\#vsl_width\#      Linienbreite definieren.
\#v_bez_qual\#     Qualit„t der Bezier-Spline-Erzeugung setzen.

ù Markierungsattribute:

\#vsm_color\#      Markierungsfarbe festlegen.
\#vsm_height\#     Markierungsgr”e festlegen.
\#vsm_type\#       Markierungstyp ausw„hlen.

ù Textattribute:

\#vst_alignment\#  Horizontale und vertikale Ausrichtung eines Texts
               bestimmen.
\#vst_arbpt\#      Setzen der Zeichenzellenh”he in Punkten.
\#vst_color\#      Farbe fr Textausgaben festlegen.
\#vst_effects\#    Texteffekte ausw„hlen (kursiv, ...).
\#vst_error\#      Setzen der \#FSMGDOS\# Fehlerbehandlung.
\#vst_font\#       Zeichensatz ausw„hlen.
\#vst_height\#     Textgr”e festlegen.
\#vst_point\#      Gr”e der Zeichenzelle festlegen.
\#vst_rotation\#   Drehung der Textausgabe.
\#vst_scratch\#    Bestimmen der Gr”e des Scratch-Buffers.
\#vst_setsize\#    Setzen der Zeichenzellenbreiten in Punkten.
\#vst_skew\#       Setzen des Neigungsgrades fr Kursivschrift.

ù Flltypattribute:

\#vsf_color\#      Fllfarbe ausw„hlen.
\#vsf_interior\#   Auswahl des Flltyps (Muster, schraffiert, ...).
\#vsf_perimeter\#  Rahmen zeichnen oder nicht.
\#vsf_style\#      Fllmuster ausw„hlen.
\#vsf_udpat\#      Eigenes Fllmuster definieren.
\end

screen( "Rasterfunktionen" )
Rasterfunktionen
----------------------------------------------------------------------

Die Rasterfunktionen erlauben es logische Operationen auf rechtwink-
ligen Bl”cken auszufhren. Dazu geh”rt auch das Kopieren von Speicher-
bereichen in den Bildschirm hinein oder ebenso heraus.

\#v_get_pixel\# Pixelstatus ermitteln (gesetzt oder gel”scht).
\#vr_trnfm\#    Raster in ger„tespezifische Formate transformieren.
\#vro_cpyfm\#   Bildschirmbereich pixelweise kopieren (opaque).
\#vrt_cpyfm\#   Bildschirmbereich pixelweise kopieren (transparent).
\end

screen( "Eingabefunktionen" )
Eingabefunktionen im šberblick
----------------------------------------------------------------------

\#v_hide_c\#          Grafikcursor abschalten.
\#v_show_c\#          Grafikcursor darstellen.
\#vex_butv\#          Serviceroutine fr Maustasteninterrupt verlegen.
\#vex_curv\#          Mauszeiger selbst zeichnen.
\#vex_motv\#          Serviceroutine fr Mausbewegungsinterrupt verlegen.
\#vex_timv\#          Serviceroutine des Timerinterrupts verlegen.
\#vq_key_s\#          Tastaturstatus abfragen.
\#vq_mouse\#          Position des Grafikcursors ermitteln.
\#vrq_choice\#        Tastendruck abwarten (REQUEST).
\#vrq_locator\#       Position des Grafikcursor ermitteln (REQUEST).
\#vrq_string\#        String von Tastatur einlesen (REQUEST).
\#vrq_valuator\#      šberwachung von Eingabeger„ten (REQUEST).
\#vsc_form\#          Grafikcursor definieren.
\#vsin_mode\#         Umschalten zwischen REQUEST- und SAMPLE-Modus.
\#vsm_choice\#        Ermittelt die zuletzt gedrckte Taste (SAMPLE).
\#vsm_locator\#       Position des Grafikcursor ermitteln (SAMPLE).
\#vsm_string\#        String von Tastatur einlesen (SAMPLE).
\#vsm_valuator\#      Ermittlung des Status von Eingabeger„ten (SAMPLE).

Die Eingabefunktionen dienen der Interaktion zwischen \#Betriebssystem\#
und Anwenderprogramm. Sie lassen sich in zwei verschiedenen Modi be-
treiben:

ù REQUEST-Modus:     Es wird nach Aufruf einer der Funktionen solange
                     gewartet, bis das entsprechende Ereignis ein-
                     tritt.
ù SAMPLE-Modus:      Es wird lediglich der Status des Ger„tes ber-
                     prft, danach kehrt die Funktion sofort wieder
                     zurck.
\end

screen( "Auskunftsfunktionen" )
Auskunftsfunktionen im šberblick
----------------------------------------------------------------------

\#vq_cellarray\#      Abfrage der Belegung einer Farbauswahltabelle.
\#vq_color\#          Farbintensit„ten ermitteln.
\#vq_extnd\#          Zus„tzliche Informationen ber die Konfiguration
                  einer Arbeitsstation ermitteln.
\#vq_gdos\#           Ermitteln, ob \#GDOS\# geladen ist.
\#vq_vgdos\#          Ermitteln, welche GDOS-Version geladen ist,
                  bespielsweise \#FSMGDOS\#.
\#vq_scan\#           Druckerparameter ermitteln.
\#vqf_attributes\#    Fllattribute ermitteln.
\#vqin_mode\#         Eingabemodus eines Eingabeger„ts abfragen.
\#vql_attributes\#    Linienattribute ermitteln.
\#vqm_attributes\#    Markierungsattribute ermitteln.
\#vqt_advance\#       Position fr n„chstes \#FSM\#-Zeichen ermitteln.
\#vqt_attributes\#    Textattribute ermitteln.
\#vqt_cachesize\#     Ermitteln der Gr”e des \#FSM\#-Caches.
\#vqt_devinfo\#       Status des Ausgabeger„ts erfragen.
\#vqt_extent\#        Dimensionen eines Textrechtecks berechnen.
\#vqt_f_extent\#      Dimensionen eines Textrechtecks fr \#FSM\#-Fonts
                  berechnen.
\#vqt_fontinfo\#      Informationen ber einen Zeichensatz ermitteln.
\#vqt_get_tables\#    Adresse der Zeichentransformationstabellen
                  erfragen.
\#vqt_name\#          Namen und Index eines Zeichensatzes ermitteln.
\#vqt_width\#         Dimensionen einer Zeichenzelle berechnen.

Mittels der Auskunftsfunktionen ist es m”gliche weitere Informationen
ber Einstellungen einzelner Ger„te zu holen.
\end

screen( "Escapefunktionen" )
Escapefunktionen im šberblick
----------------------------------------------------------------------

Mit den Escapefunktionen wird es einem Anwenderprogramm erm”glicht auf
spezielle Eigenschaften einer Arbeitsstation zuzugreifen.

ù Textfunktionen:

\#vs_curaddress\#     Textcursor in Reihe und Spalte positionieren.
\#v_curdown\#         Textcursor eine Zeile nach unten bewegen.
\#v_curright\#        Textcursor eine Spalte nach rechts bewegen.
\#v_curleft\#         Textcursor eine Spalte nach links bewegen.
\#v_curhome\#         Textcursor in die linke obere Ecke bewegen.
\#v_curtext\#         Text ab Textcursorposition ausgeben.
\#v_curup\#           Textcursor eine Zeile nach oben bewegen.
\#v_eeol\#            Bildschirm ab Textcursor bis Zeilenende l”schen.
\#v_eeos\#            Bildschirm ab Textcursor bis Bildschirmende l”schen.
\#v_enter_cur\#       Textmodus einschalten.
\#v_exit_cur\#        Textmodus verlassen.
\#v_rvon\#            Inverse Darstellung einschalten.
\#v_rvoff\#           Inverse Darstellung abschalten.
\#vq_chcells\#        Zeilen und Spalten des Textbildschirms ermitteln.
\#vq_curaddress\#     Zeile und Spalte des Textcursors ermitteln.

ù Grafikspezialfunktionen:

\#v_bit_image\#       Bildinformationen auf Drucker ausgeben.
\#v_clear_disp_list\# Druckpuffer l”schen.
\#v_dspcur\#          Grafikcursor versetzen.
\#v_form_adv\#        Seitenvorschub auf Drucker durchfhren.
\#v_hardcopy\#        Hardcopy auf Drucker ausgeben.
\#v_output_window\#   Bildschirmbereich auf Drucker ausgeben.
\#v_rmcur\#           Letzten Grafikcursor l”schen.
\#vq_tabstatus\#      Verfgbarkeit eines Grafiktabletts,
                  Maus, usw. abfragen.
\#vs_palette\#        Auswahl der Farbpalette.

ù Polaroid-Camera:

\#vqp_error\#         Fehlercodes des Polaroid-Treibers abfragen.
\#vqp_films\#         Verfgbare Filmtypen ermitteln.
\#vqp_state\#         Status des Polaroid-Treibers ermitteln.
\#vsp_message\#       Fehlermeldungen des Polaroid-Treibers unterdrcken
                  oder zulassen.
\#vsc_expose\#        Preview-M”glichkeit fr Kamera ein-/ausschalten.
\#vsp_film\#          Filmtyp und Belichtungszeit festlegen.
\#vsp_save\#          Einstellung des Polaroid-Treibers sichern.
\#vsp_state\#         Polaroid-Treiber neu einstellen. 

ù Grafiktablett:

\#vt_alignment\#      Koordinatensystem des Grafiktabletts ausrichten.
\#vq_tdimensions\#    Ausmae des Grafiktabletts in 1/10-Zoll.
\#vt_resolution\#     Aufl”sung des Grafiktabletts einstellen.
\#vt_axis\#           Aufl”sung des Grafiktabletts einstellen.
\#vt_origin\#         Koordinatenursprung fr Grafiktablett setzen.

ù Metafiles:

\#v_meta_extents\#    Dimensionen eines Metafiles berechnen.
\#v_write_meta\#      Grafik-Pimitive in Metafile ablegen.
\#vm_filename\#       Metafile umbenennen.
\#vm_coords\#         Neues Koordinatensystem fr Metafile
\#vm_pagesize\#       Physikalische Seitengr”e fr Metafile

ù Spezialfunktionen:

\#vs_mute\#           Ein-/Ausschalten der Tonerzeugung.
\#v_escape2000\#      Spezialfunktion fr ATARI-Page-Printer.
\#v_fontinit\#        Eigenen Systemzeichensatz ausw„hlen.
\#v_offset\#          Abstand zum linken Bildschirmrand festlegen.
\#v_sound\#           Ton generieren.
\end

screen( capsensitive("v_opnwk") )
Name           Open Workstation

Definition     void  v_opnwk( int *work_in, int *\#handle\#,
                              int *work_out);

Beschreibung   Die Funktion l„dt einen Ger„tetreiber. Dazu mu sich
               jedoch das \#GDOS\# im Speicher befinden und der
               Ger„tetreiber mu im ASSIGN.SYS File aufgez„hlt sein.
               Falls alles geklappt hat, erh„lt man in \#handle\# eine
               positive Ger„tekennung und Null im Fehlerfall.

        work_in         Zeiger auf ein Integerfeld mit den genaueren
                        Spezifikationen des zu ladenden Ger„tetreibers
        work_in[0]      Nummer des Ger„tetreibers wie im ASSIGN.SYS
                        angegeben
        work_in[1]      Linientyp
        work_in[2]      Polylinefarbe
        work_in[3]      Markertyp
        work_in[4]      Markerfarbe
        work_in[5]      Textstil
        work_in[6]      Textfarbe
        work_in[7]      Fllmustertyp
        work_in[8]      Fllmusternummer
        work_in[9]      Fllmusterfarbe
        work_in[10]     welche Koordinaten sollen benutzt werden:
                                0  NDC Koordinaten
                                2  RC Koordinaten
        work_out        Zeiger auf ein Integerfeld, das genauere
                        Informationen ber den geladenen Ger„tetreiber
                        enth„lt
        work_out[0]     Anzahl der maximal ansprechbaren
                        Rastereinheiten in der Horizontalen
        work_out[1]     Anzahl der maximal ansprechbaren
                        Rastereinheiten in der Vertikalen
        work_out[2]     Skalierungsflag:
                                0  Ger„t kann exakt skalieren
                                1  Ger„t kann nicht exakt skalieren
        work_out[3]     Breite einer Rastereinheit in Mikrometern
        work_out[4]     H”he einer Rastereinheit in Mikrometern
        work_out[5]     Anzahl der Zeichensatzh”hen oder Null, falls
                        die H”he kontinuierlich ver„ndert werden kann
        work_out[6]     Anzahl der Linientypen
        work_out[7]     Anzahl der Linienst„rken oder Null, falls die
                        Strichst„rke kontinuierlich ver„ndert werden
                        kann
        work_out[8]     Anzahl der Markertypen
        work_out[9]     Anzahl der Markergr”en oder Null, falls die
                        Gr”e kontinuierlich ver„ndert werden kann
        work_out[10]    Anzahl der Zeichens„tze
        work_out[11]    Anzahl der Fllmuster
        work_out[12]    Anzahl der Schraffurarten
        work_out[13]    Anzahl der gleichzeitig darstellbaren Farben
        work_out[14]    Anzahl der verfgbaren Grafikgrundfunktionen
                        (GENERAL DRAWING PRIMITIV, GDP)
        work_out[15]    Liste der auf dem Ger„t verfgbaren GDP's.
            :           Sind es weniger als zehn wird die Liste
            :           durch -1 beendet. Das \#VDI\# untersttzt
            :           folgende GDP's:
            :
            :                   1   BAR
            :                   2   ARC
            :                   3   PIESLICE
            :                   4   CIRCLE
            :                   5   ELLIPSE
            :                   6   ELLIPTICAL ARC
            :                   7   ELLIPTICAL PIE
            :                   8   ROUNDED RECTANGLE
            :                   9   FILLED ROUNDED RECTANGLE
            :                   10  JUSTIFIED GRAPHICS TEXT
        work_out[24]
        work_out[25]    Liste aller Attribute der GDP's:
            :
            :                   0  Linie
            :                   1  Marker
            :                   2  Text
            :                   3  Fllbereich
            :                   4  kein Attribut
        work_out[34]
        work_out[35]    das Ger„t ist farbtchtig (1) oder nicht (0)
        work_out[36]    das Ger„t kann Text rotieren (1) oder
                        nicht (0)
        work_out[37]    das Ger„t kann eine Flloperation
                        ausfhren (1) oder nicht (0)
        work_out[38]    das Ger„t untersttzt CELL ARRAY (1) oder
                        nicht (0)
        work_out[39]    Anzahl der verfgbaren Farben
        work_out[40]    LOCATOR Ger„t:  1  nur die Tastatur
                                        2  Tastatur und andere Ger„te
        work_out[41]    VALUATOR Ger„t: 1  nur die Tastatur
                                        2  anderes Ger„t
        work_out[42]    Auswahtasten:   1  Funktionstasten auf der
                                           Tastatur
                                        2  zus„tzliches Tastenfeld
        work_out[43]    Zeicheneingabe: 1  Tastatur
        work_out[44]    Ger„tetyp:      0  reines Ausgabeger„t
                                        1  reines Eingabeger„t
                                        2  Ein/Ausgabeger„t
                                        3  reserviert
                                        4  Metafile Ausgabe
        work_out[45]    kleinste Buchstabenbreite
        work_out[46]    kleinste Buchstabenh”he
        work_out[47]    gr”te Buchstabenbreite
        work_out[48]    gr”te Buchstabenh”he
        work_out[49]    kleinste darstellbare Linienst„rke
        work_out[50]    immer Null
        work_out[51]    gr”te Linienst„rke
        work_out[52]    immer Null
        work_out[53]    kleinste darstellbare Markerbreite
        work_out[54]    kleinste darstellbare Markerh”he
        work_out[55]    gr”te Markerbreite
        work_out[56]    gr”te Markerh”he

Querverweis    \#GDOS\#, \#v_clswk\#
\end

screen( capsensitive("v_clswk") )
Name           Close Workstation - Die Kontrollfunktion v_clswk
               schliet ein mit \#v_opnwk\# ge”ffnetes Ger„t

Definition     void    v_clswk( int \#handle\# );

Beschreibung   Die Funktion schliet ein vorher mit \#v_opnwk\#
               ge”ffnetes Ger„t mit dem Handle \#handle\#. Vor
               Aufruf dieser Funktion sollten alle mit \#v_opnvwk\#
               ge”ffneten virtuellen Arbeitsger„te mittels \#v_clsvwk\#
               geschlossen werden.

Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis
Gruppe         \#Kontrollfunktionen\#
Querverweis    \#GDOS\#, \#v_opnwk\#, \#v_opnvwk\#, \#v_clsvwk\#
\end

screen( capsensitive("v_opnvwk") )
Name           Open virtual Screen Workstation - ”ffnet eine
               Bildschirmarbeitsstation

Definition     void v_opnvwk ( int *work_in, int *\#handle\#,
                               int *work_out );

Beschreibung   Die Funktion ”ffnet eine Bildschirmarbeitsstation.
               Die Belegung der Parameter ist identisch mit der
               Parameterbelegung in \#v_opnwk\#.

Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis
Gruppe         \#Kontrollfunktionen\#
Querverweis    \#v_opnwk\#, \#v_clsvwk\#, \#graf_handle\#
\end

screen( capsensitive("v_clsvwk") )
Name           Close virtual Screen Workstation - schliet eine
               Bildschirmarbeitsstation

Definition     void    v_clsvwk( int \#handle\# );

Beschreibung   Die Funktion schliet eine vorher mit \#v_opnvwk\#
               ge”ffnete Bildschirmarbeitstation mit dem VDI-Handle
               \#handle\#.

Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis
Gruppe         \#Kontrollfunktionen\#
Querverweis    \#v_opnvwk\#, \#v_clswk\#
\end

screen( capsensitive("v_clrwk") )
Name           Clear Workstation - l”scht das Arbeitsger„t

Definition     void    v_clrwk( int \#handle\# );

Beschreibung   Die Funktion setzt das Arbeitsger„t \#handle\# in den
               Leerzustand, d. h. der Bildschirm wird gel”scht, auf
               dem Drucker oder Plotter wird ein Seitenvorschub erzeugt
               und der Datenpuffer wird gel”scht.
Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis
Gruppe         \#Kontrollfunktionen\#
Querverweis    \#v_form_adv\#
\end

screen( capsensitive("v_updwk") )
Name           Update Workstation - gepufferte Ausgabekommandos
               ausfhren

Definition     void    v_updwk( int \#handle\# );

Beschreibung   Die Funktion veranlat das Ausgabeger„t \#handle\#, alle
               gepufferten Ausgabekommandos auszufhren. Diese
               Funktion ist jedoch nur fr alle Ger„te auer dem
               Bildschirm sinnvoll, da auf dem Bildschirm alle
               Ausgaben sofort ausgefhrt werden.
Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis
Gruppe         \#Kontrollfunktionen\#
Querverweis    \#v_opnwk\#
\end

screen( capsensitive("vst_load_fonts") )
Name           Load Fonts - Zeichens„tze laden

Definition     int     vst_load_fonts( int \#handle\#, int select );

Beschreibung   Die Funktion l„dt eine Reihe weiterer Zeichens„tze fr
               das Ausgabeger„t \#handle\#, die im ASSIGN.SYS File
               angegeben sind.
               Sie ist allerdings nur dann sinnvoll, wenn vorher das
               \#GDOS\# installiert worden ist.
               select ist immer Null.
Ergebnis       Als Ergebnis erh„lt man die Anzahl der geladenen
               Zeichens„tze.
Gruppe         \#Kontrollfunktionen\#
Querverweis    \#GDOS\#, \#vst_unload_fonts\#, \#vst_font\#, \#vqt_name\#
\end

screen( capsensitive("vst_unload_fonts") )
Name           Unload Fonts - l”scht geladene Zeichens„tze

Definition     void    vst_unload_fonts( int \#handle\#, int select );

Beschreibung   Die Funktion gibt den Speicherbereich, der durch
               zus„tzlich geladene Zeichens„tze fr das Ger„t \#handle\#
               belegt wird, wieder frei. Da man zus„tzliche
               Zeichens„tze nur mit \#GDOS\# im Speicher geladen werden
               k”nnen, ist auch diese Funktion nur mit \#GDOS\# sinnvoll.
               select  ist immer Null.
Ergebnis       Die Funktion hat kein direktes Funktionsergebnis.
Gruppe         \#Kontrollfunktionen\#
Querverweis    \#GDOS\#, \#vst_load_fonts\#
\end

screen( capsensitive("vs_clip") )
Name           Set clipping Rectangle - setzt Begrenzungsrechteck.

Definition     void vs_clip ( int \#handle\#, int clip_flag,
                              int *\#pxyarray\# );

Beschreibung   Die Funktion begrenzt alle grafischen Ausgaben auf dem
               Ger„t \#handle\# auf das in \#pxyarray\# angegebene
               Rechteck, falls clip_flag gleich Eins ist.
               Ist clip_flag gleich Null, so wird das Clipping wieder
               ausgeschaltet.
Ergebnis       Die Funktion hat kein direktes Funktionsergebnis.
Gruppe         \#Kontrollfunktionen\#
\end

screen( capsensitive("v_pline") )
Name           Polyline - Linienzug zeichnen

Definition     void v_pline( int \#handle\#, int count, int *\#pxyarray\# );

Beschreibung   Die Funktion zeichnet einen Linienzug zwischen count
               Punkten in \#pxyarray\# auf dem Ausgabeger„t \#handle\# unter
               Bercksichtigung aller Linienattribute.
Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vs_color\#   \#vswr_mode\#   \#vsl_type\#   \#vsl_width\#
               \#vsl_color\#  \#vsl_ends\#    \#vsl_udsty\#  \#pxyarray\#
\end

screen( capsensitive("v_pmarker") )
Name           Polymarker - makiert Punkte.

Definition     void v_pmarker ( int \#handle\#, int count,
                                int *\#pxyarray\# );

Beschreibung   Die Funktion markiert count Punkte, die in \#pxyarray\#
               angegeben sind, auf dem Ausgabeger„t \#handle\# unter
               Bercksichtigung der aktuellen Polymarkerattribute.
Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vs_color\#   \#vswr_mode\#   \#vsm_type\#   \#vsm_height\#
               \#vsm_color\#  \#pxyarray\#
\end

screen( capsensitive("v_gtext") )
Name           Text - gibt eine Text aus.

Definition     void  v_gtext( int \#handle\#, int x, int y, char *string );

Beschreibung   Die Funktion gibt den string an den Koordinaten x und y
               auf dem durch \#handle\# spezifizierten Arbeitsger„t
               aus. Die \#Textattribute\# werden dabei bercksichtigt.

Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis.

Gruppe         \#Ausgabefunktionen\#

Querverweis    \#vswr_mode\#    \#vs_color\#    \#vst_alignment\#
               \#vst_height\#   \#vst_point\#   \#vst_rotation\#
               \#vst_font\#     \#vst_color\#   \#vst_effects\#
               \#v_ftext\#
\end

screen( capsensitive("v_ftext") )
Name           Text - gibt eine Text mittels FSM-Font aus.

Definition     void  v_ftext( int \#handle\#, int x, int y, char *string );

Beschreibung   Die Funktion gibt den string an den Koordinaten x und y
               auf dem durch \#handle\# spezifizierten Arbeitsger„t
               aus.

Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis.

Gruppe         \#Ausgabefunktionen\#
Querverweis    \#v_gtext\#      \#FSMGDOS\#
\end

screen( capsensitive("v_fillarea") )
Name           Filled Area - fllt eine Fl„che.

Definition     void v_fillarea ( int \#handle\#, int count,
                                 int *\#pxyarray\# );

Beschreibung   Die Funktion fllt die Fl„che, die durch den
               Polygonzug, der durch count und \#pxyarray\# festgelegt
               wird, eingerahmt wird, auf dem Ger„t \#handle\# unter
               Beachtung aller Fllattribute.
Ergebnis       Die Funktion hat kein direktes Funktionsergebnis.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#   \#vsf_udpat\#  \#vsf_perimeter\#  \#pxyarray\#
\end

screen( capsensitive("v_cellarray") )
Name           Cell Array - Farbaufbau des Bildschirms in Koordinaten.

Definition     void v_cellarray( int \#handle\#, int *\#pxyarray\#,
                                 int row_length,int el_used,
                                 int num_rows,  int wrt_mode,
                                 int *colarray );

Beschreibung   Die Funktion erm”glicht es, den Farbaufbau des
               Bildschirms nicht von den gezeichneten Objekten
               abh„ngig zu machen, sondern von den Koordinaten des
               Bildschirms. Dazu wird das Ausgabeger„t \#handle\# in
               eine Anzahl von Zellen unterteilt, wobei jeder Zelle
               eine Farbe zugeordnet wird. Erfolgt nun eine Ausgabe
               in der entsprechenden Zelle, so erfolgt diese in der,
               der Zelle zugeordneten Farbe. Die Funktion ist nicht
               auf allen Ausgabeger„ten verfgbar.
\#pxyarray\#       Koordinaten des Begrenzungsrechtecks
colarray       Farbindexarray, enth„lt zeilenweise die
               Farbinformation fr das ganze Rechteck
row_length     Anzahl der Spalten
num_row        Anzahl der Zeilen
el_used        Anzahl der benutzten Eintr„ge im
               Farbindexarray colarray
wrt_mode       Schreibmodus, wie in \#vswr_mode\#, jedoch
               nur fr das angegebene Rechteck
Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#pxyarray\#
\end

screen( capsensitive("v_contourfill") )
Name           Countour fill - fllt eine Fl„che.

Definition     void v_contourfill ( int \#handle\#, int x, int y,
                                    int index );

Beschreibung   Die Funktion fllt die Fl„che, innerhalb derer der
               Punkt x,y liegt, und die von Punkten der Farbe index
               umgeben ist, auf dem Ger„t \#handle\# unter Beachtung
               der aktuellen Fllattribute.
Ergebnis       Die Funktion liefert kein direktes Funktionsergebnis.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#   \#vsf_udpat\#  \#vsf_perimeter\#
\end

screen( capsensitive("vr_recfl") )
Name           Fill Rectangle - fllt eine Rechtecksfl„che.

Definition     void vr_recfl( int \#handle\#, int *\#pxyarray\# );

Beschreibung   Die Funktion fllt eine Rechtecksfl„che, die durch
               \#pxyarray\# festgelegt wird, auf dem Ger„t \#handle\# unter
               Beachtung der aktuellen Fllattribute aus.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#v_fillarea\#   \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#
               \#vsf_style\#    \#vsf_color\#   \#vsf_udpat\#  \#vsf_perimeter\#
               \#pxyarray\#
\end

screen( capsensitive("v_bar") )
Name           Bar - zeichnet ein ausgeflltes Rechteck.

Definition     void v_bar( int \#handle\#, int *\#pxyarray\# );

Beschreibung   Die Funktion zeichnet auf dem Ausgabeger„t \#handle\# ein
               ausgeflltes Rechteck, dessen Ausmae durch \#pxyarray\#
               festgelegt werden, unter Bercksichtigung der
               Fllattribute.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#   \#vsf_udpat\#  \#vsf_perimeter\#  \#pxyarray\#
\end

screen( capsensitive("v_arc") )
Name           Arc - zeichnet einen Kreisbogen.

Definition     void v_arc( int \#handle\#, int x, int y, int radius,
                           int begang, int endang );

Beschreibung   Die Funktion zeichnet auf dem Ausgabeger„t \#handle\# einen
               Kreisbogen mit den Mittelpunktskoordinaten x, y, dem
               Radius radius von dem Start”ffnungswinkel begang bis zu
               dem Winkel endang unter Beachtung der Linienattribute.
               Die Winkel werden dabei in 1/10 Grad Schritten
               angegeben.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vs_color\#   \#vswr_mode\#   \#vsl_type\#   \#vsl_width\#
               \#vsl_color\#  \#vsl_ends\#    \#vsl_udsty\#
\end

screen( capsensitive("v_pieslice") )
Name           Pie - zeichnet ein "Tortenstck".

Definition     void v_pieslice ( int \#handle\#, int x, int y,
                                 int radius, int begang, int endang );

Beschreibung   Die Funktion zeichnet auf dem Ausgabeger„t \#handle\# ein
               "Tortenstck" mit den Mittelpunktskoordinaten x, y, dem
               Radius radius von dem Start”ffnungswinkel begang bis zu
               dem Winkel endang unter Beachtung der Fllattribute.
               Die Winkel werden dabei in 1/10 Grad Schritten
               angegeben.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#   \#vsf_udpat\#  \#vsf_perimeter\#
\end

screen( capsensitive("v_circle") )
Name           Circle - zeichnet eine Kreisfl„che.

Definition     void v_circle( int \#handle\#, int x, int y, int radius );

Beschreibung   Die Funktion zeichnet auf dem Ger„t mit der
               Ger„tekennung \#handle\# mit den Mittelpunktskoordinaten
               x, y und dem Radius radius eine Kreisfl„che unter
               Beachtung der aktuellen Fllattribute.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#  \#vsf_udpat\#   \#vsf_perimeter\#
\end

screen( capsensitive("v_ellipse") )
Name           Ellipse - zeichnet eine Ellipsenfl„che.

Definition     void v_ellipse( int \#handle\#, int x, int y, int xradius,
                               int yradius  );

Beschreibung   Auf dem Ausgabeger„t mit der Kennung \#handle\# wird unter
               Beachtung der aktuellen Fllattribute mit den
               Mittelpunktskoordinaten x, y und den Radien xradius in
               x-Richtung und yradius in y-Richtung eine
               Ellipsenfl„che gezeichnet.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#   \#vsf_udpat\#  \#vsf_perimeter\#
\end

screen( capsensitive("v_ellarc") )
Name           Elliptical Arc - zeichnet einen Ellipsenbogen.

Definition     void v_ellarc( int \#handle\#, int x, int y, int xradius,
                              int yradius, int begang, int endang );

Beschreibung   Die Funktion zeichnet auf dem Ausgabeger„t mit der
               Kennung \#handle\# einen Ellipsenbogen mit den
               Mittelpunktskoordinaten x, y und den Radien xradius in
               x-Richtung und yradius in y-Richtung. Der Bogen wird
               dabei bei dem Winkel begang begonnen und endet mit dem
               Winkel endang.
               Beide Winkel werden in 1/10 Grad Schritten angegeben.
               Die aktuellen Linienattribute werden dabei beachtet.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vs_color\#   \#vswr_mode\#   \#vsl_type\#   \#vsl_width\#
               \#vsl_color\#  \#vsl_ends\#    \#vsl_udsty\#
\end

screen( capsensitive("v_ellpie") )
Name           Elliptical Pie - zeichnet eine Ellipsenbogenfl„che.

Definition     void v_ellpie( int \#handle\#, int x, int y, int xradius,
                              int yradius, int begang, int endang );

Beschreibung   Die Funktion zeichnet auf dem Ausgabeger„t mit der
               Kennung \#handle\# eine Ellipsenbogenfl„che mit den
               Mittelpunktskoordinaten x, y und den Radien xradius in
               x-Richtung und yradius in y-Richtung. Das Fl„chenstck
               beginnt dabei bei dem Winkel begang und endet mit dem
               Winkel endang. Beide Winkel werden in 1/10 Grad
               Schritten angegeben.
               Die aktuellen Fllattribute werden bercksichtigt.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
                \#vsf_color\#  \#vsf_udpat\#  \#vsf_perimeter\#
\end

screen( capsensitive("v_rbox") )
Name           Rounded Rectangle - zeichnet ein Rechteck mit
               abgerundeten Ecken

Definition     void v_rbox ( int \#handle\#, int *\#pxyarray\# );

Beschreibung   Die Funktion zeichnet auf dem Ger„t mit der Kennung
               \#handle\# ein Rechteck mit abgerundeten Ecken, dessen
               Lage durch die Koordinaten im \#pxyarray\# festgelegt
               wird. Es werden dabei die aktuellen Linienattribute
               beachtet.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vs_color\#   \#vswr_mode\#   \#vsl_type\#   \#vsl_width\#
               \#vsl_color\#  \#vsl_ends\#    \#vsl_udsty\#  \#pxyarray\#
\end

screen( capsensitive("v_rfbox") )
Name           Filled rounded Rectangle - zeichnet eine
               Rechtecksfl„che mit gerundeten Ecken.

Definition     void v_rfbox ( int \#handle\#, int *\#pxyarray\# );

Beschreibung   Wie \#v_rbox\#, nur mit dem Unterschied, da eine
               ausgefllte Rechtecksfl„che mit abgerundeten Ecken
               unter Beachtung der Fllattribute gezeichnet wird.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#   \#vsf_udpat\#  \#vsf_perimeter\#  \#v_rbox\#
               \#pxyarray\#
\end

screen( capsensitive("v_justified") )
Name           Justified Graphics Text - Positionierter Graphiktext.

Definition     void v_justified( int \#handle\#,int x, int y,
                                 char *string, int length,
                                 int word_space, int char_space );

Beschreibung   Die Funktion gibt den Text auf den string zeigt auf dem
               Ger„t mit der Kennung \#handle\# an der Position x, y aus.+
               Dabei besteht die M”glichkeit den Text auf die L„nge+
               length (in Pixeln) durch Dehnung der Wortzwischenr„ume
               (word_space ungleich Null) oder derZeichenzwischenr„ume
               (char_space ungleich Null) zu formatieren.
Gruppe         \#Ausgabefunktionen\#
Querverweis    \#vswr_mode\#     \#vs_color\#    \#vst_alignment\#
               \#vst_height\#    \#vst_point\#   \#vst_rotation\#
               \#vst_font\#      \#vst_color\#   \#vst_effects\#
\end

screen( capsensitive("vswr_mode") )
Name           Set writing Mode - bestimmt den Schreibmodus fast aller
               Grafikfunktionen.

Definition     int vswr_mode( int \#handle\#, int mode );

Beschreibung   Diese Funktion bestimmt, wie der Bildschirmhintergrund
               mit dem neuen zu zeichnenden Objekten verknpft wird.
               Der Gltigkeitsbereich des gew„hlten Schreibmodus
               beschr„nkt sich dabei auf das Ger„t mit der Kennung
               \#handle\# und den Bereich auerhalb eines eventuell mit
               der Funktion \#v_cellarray\# gew„hlten Rechtecks.
mode           MD_REPLACE      1  Replace
               MD_TRANS        2  Transparent
               MD_XOR          3  Xor
               MD_ERASE        4  Reverse Transparent
Ergebnis       Die Funktion liefert den tats„chlich eingestellten
               Schreibmodus.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pline\#        \#v_pmarker\#   \#v_gtext\#   \#v_fillarea\#
               \#v_contourfill\#  \#vr_recfl\#    \#v_bar\#     \#v_arc\#,
               \#v_pieslice\#     \#v_circle\#    \#v_ellarc\#  \#v_ellpie\#
               \#v_ellipse\#      \#v_rbox\#      \#v_rfbox\#   \#v_justified\#
\end

screen( capsensitive("vs_color") )
Name           Set Color Representation - legt die Farbintensit„t fest.

Definition     void vs_color( int \#handle\#, int index, int *rgb_in );

Beschreibung   Die Funktion setzt fr das Ausgabeger„t mit der Kennung
               \#handle\# die Farbanteile der einzelnen Grundfarben fr
               die Farbe mit der Nummer index auf die Werte, die in
               dem Feld rgb_in stehen.
rgb_in[0]      Rotanteil in Promille
rgb_in[1]      Grnanteil in Promille
rgb_in[2]      Blaunanteil in Promille
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pline\#      \#v_pmarker\#      \#v_gtext\#   \#v_fillarea\#
               \#v_cellarray\#  \#v_contourfill\#  \#vr_recfl\#  \#v_bar\#
               \#v_arc\#        \#v_pieslice\#     \#v_circle\#  \#v_ellarc\#
               \#v_ellpie\#     \#v_ellipse\#      \#v_rbox\#    \#v_rfbox\#
               \#v_justified\#  \#vq_color\#

\end

screen( capsensitive("vsl_type") )
Name           Set Polyline Type - setzt den Linientyp.

Definition     int vsl_type( int \#handle\#, int style );

Beschreibung   Die Funktion w„hlt fr das Ausgabeger„t mit der Kennung
               \#handle\# das Aussehen aller Linienausgaben.
style          1     (durchgezogen)
               2     (langer Strich)
               3     (punktiert)
               4     (Strich, Punkt)
               5     (Strich)
               6     (Strich, Punkt, Punkt)
               7     (frei definierbar, \#vsl_udsty\#)
               ab 8  eventuell weitere Linientypen auf verschiedenen
                     Ausgabeger„ten.

Ergebnis       Die Funktion liefert den tats„chlich eingestellten
               Linientyp.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pline\#   \#v_arc\#   \#v_ellarc\#   \#v_rbox\#   \#vsl_udsty\#
\end

screen( capsensitive("vsl_udsty") )
Name           Set User defined Line Style Pattern - setzt den frei
               definierten Linientyp.

Definition     void vsl_udsty( int \#handle\#, int pattern );

Beschreibung   Die Funktion setzt den Linientyp mit der Indexnummer 7
               fr das Ger„t \#handle\# auf den Wert pattern. Das
               h”chstwertige Bit ist dabei der erste Punkt des
               Linienmusters.
Gruppe         \#Attributfunktionen\#
Querverweis    \#vsl_type\#
\end

screen( capsensitive("vsl_width") )
Name           Set Polyline Width - setzt die Linienbreite.

Definition     int vsl_width( int \#handle\#, int width );

Beschreibung   Die Funktion setzt fr das Ausgabeger„t mit der Kennung
               \#handle\# die Strichst„rke auf den Wert width.
Ergebnis       Die Funktion liefert die tats„chlich eingestellte
               Strichst„rke.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pline\#   \#v_arc\#   \#v_ellarc\#   \#v_rbox\#
\end

screen( capsensitive("vsl_color") )
Name           Set Polyline Color Index - setzt die Linienfarbe.

Definition     int vsl_color( int \#handle\#, int color_index );

Beschreibung   Die Funktion w„hlt fr das Ausgabeger„t mit der Kennung
               \#handle\# die Farbe mit der Nummer color_index als
               Linienfarbe aus.
Ergebnis       Die Funktion liefert die tats„chlich gesetzte
               Linienfarbe
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pline\#   \#v_arc\#   \#v_ellarc\#   \#v_rbox\#
\end

screen( capsensitive("vsl_ends") )
Name           Set Polyline End Styles - setzt die Linienendeform.

Definition     void vsl_ends ( int \#handle\#, int beg_style,
                               int end_style );

Beschreibung   Die Funktion legt fr das Ger„t mit der Kennung \#handle\#
               das Aussehen sowohl des Linienanfangs als auch des
               Linienendes fest.

beg_style      Aussehen am Anfangspunkts
                0  eckig
                1  Pfeil
                2  abgerundet
end_style      wie beg_style, nur fr das Linienende
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pline\#   \#v_arc\#   \#v_ellarc\#   \#v_rbox\#
\end

screen( capsensitive("vsm_type") )
Name           Set Polymarker Type - bestimmt die Art der
               Markierungspunkte

Definition     int vsm_type ( int \#handle\#, int symbol );

Beschreibung   Die Funktion w„hlt den Markertyp symbol fr das
               Ausgabeger„t \#handle\# aus und gibt den ausgew„hlten
               Typ zurck.

symbol         1  Punkt (nur eine feste Gr”e)
               2  Plus
               3  Stern
               4  Quadrat
               5  Andreaskreuz
               6  Raute
               eventuell weitere Marker auf anderen Ger„ten
Ergebnis       Die Funktion liefert den Code der tats„chlich
               ausgew„hlten Markiwerung.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pmarker\#   \#vsm_height\#
\end

screen( capsensitive("vsm_height") )
Name           Set Polymarker Height - bestimmt die H”he von
               Markierungspunkten.

Definition     int vsm_height( int \#handle\#, int height );

Beschreibung   Die Funktion setzt fr das Ausgabeger„t mit der Kennung
               \#handle\# die Gr”e des Markers auf den Wert height.
Ergebnis       Die Funktion liefert die tats„chlich gew„hlte Gr”e.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pmarker\#
\end

screen( capsensitive("vsm_color") )
Name           Set Polymarker Color Index - bestimmt die Farbe von
               Markierungspunkten.

Definition     int vsm_color ( int \#handle\#, int color_index );

Beschreibung   Die Funktion setzt die Polymarkerfarbe fr das
               Ausgabeger„t \#handle\# auf den Farbwert color_index.
Ergebnis       Die Funktion liefert den tats„chlich gew„hlten
               Farbindex.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_pmarker\#
\end

screen( capsensitive("vst_height") )
Name           Set Character Height, absolute Mode - bestimmt die
               Zeichengr”e von Textausgaben.

Definition     void vst_height ( int \#handle\#, int height,
                                 int *char_width, int *char_height,
                                 int *cell_width, int *cell_height );

Beschreibung   Mit der Funktion wird die absolute Zeichengr”e von
               Textausgaben auf dem Ger„t mit der Kennung \#handle\#
               festgelegt.
height         gewnschte Zeichenh”he
char_width     gew„hlte Zeichenbreite
char_height    gew„hlte Zeichenh”he
cell_width     Zeichenzellenbreite
cell_height    Zeichenzellenh”he
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_gtext\#   \#v_justified\#  \#vst_point\#
\end

screen( capsensitive("vst_point") )
Name           Set Character Height, Points Mode - bestimmt die
               Zeichenh”he von Textausgaben.

Definition     int vst_point ( int \#handle\#, int point, int *char_width,
                               int *char_height, int *cell_width,
                               int *cell_height );

Beschreibung   Die Funktion setzt die Zeichenzellengr”e, d. h. den
               Abstand zweier Basislinien, fr das Ger„t mit der
               Kennung \#handle\# auf den Wert point, der in 1/72"
               Schritten angegeben wird.
point          gewnschte Zellenh”he
char_width     gew„hlte Zeichenbreite
char_height    gew„hlte Zeichenh”he
cell_width     Zeichenzellenbreite
cell_height    Zeichenzellenh”he
Ergebnis       Die Funktion liefert die gew„hlte Zeichenzellenh”he
               in 1/72" Schritten.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_gtext\#   \#v_justified\#   \#vst_height\#
\end

screen( capsensitive("vst_rotation") )
Name           Set Character Baseline Vector - Bestimmt den Winkel der
               Textausgaben.

Definition     int vst_rotation( int \#handle\#, int angle );

Beschreibung   Die Funktion legt fr das Ausgabeger„t \#handle\# den
               Winkel fest, unter dem alle Textausgaben erscheinen.
               Die vorhandenen Treiber untersttzen allerdings nur
               Winkel in 90 Grad Schritten, obwohl man den Winkel in
               1/10 Grad Schritten angeben mu.
Ergebnis       Die Funktion liefert den tats„chlich gew„hlten Winkel.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_gtext\#   \#v_justified\#
\end

screen( capsensitive("vst_font") )
Name           Set Text Face - bestimmt einen Zeichensatz.

Definition     int vst_font( int \#handle\#, int font );

Beschreibung   Die Funktion w„hlt fr das Ausgabeger„t \#handle\# einen
               Zeichensatz aus. Dabei ist font die Nummer des Zeichensatzes,
               die mit \#vqt_name\# errmittelt werden kann. Die Funktion ist
               also nur zusammen mit dem \#GDOS\# in vollen  Umfang einsatz-
               f„hig. Falls font gleich Eins ist, wird der Systemzeichensatz
               ausgew„hlt.
Ergebnis       Die Funktion liefert die Nummer des tats„chlich
               gew„hlten Zeichensatzes.

Beispiel       numSets =  \#vst_load_fonts\#( handle, 0 ); /* fonts laden     */
               id = \#vqt_name\#(handle, 2, name );        /* 2. Zeichensatz  */
               vst_font( handle, id );                 /* ausw„hlen       */
               \#v_gtext\#( handle, 100, 100, name );      /* benutzen        */
               
Gruppe         \#Attributfunktionen\#
Querverweis    \#GDOS\# \#vst_load_fonts\# \#v_gtext\# \#v_justified\#
\end

screen( capsensitive("vst_color") )
Name           Set Graphic Text Color Index - bestimmt die Farbe der
               Textausgaben.

Definition     int vst_color ( int \#handle\#, int color_index );

Beschreibung   Die Funktion setzt die Farbe unter der Textausgaben
               erfolgen fr das Ger„t mit der Kennung \#handle\# auf den
               Wert color_index.
Ergebnis       Die Funktion liefert die tats„chlich eingestellte Farbe.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_gtext\#   \#v_justified\#
\end

screen( "Textattribute",
		capsensitive("vst_effects") )
Name           Set Graphic Text Special Effects - legt Spezialeffekte
               fr Textausgaben fest.

Definition     int vst_effects ( int \#handle\#, int effect );

Beschreibung   Die Funktion legt die Textgestalt fr das Ausgabeger„t
               mit der Kennung \#handle\# fest.
effect         Bitvektor, der die Textgestalt festlegt. Um einen
               Effekt zu selektieren, mu das entsprechende Bit
               gesetzt werden. Dadurch sind beliebige Kombinationen
               m”glich.
Bit            0      1      2        3               4     5
Effekt         fett   hell   kursiv   unterstrichen   hohl  schattiert
Ergebnis       Die Funkltion liefert das Bitmuster der tats„chlich
               eingestellten Effekte.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_gtext\#   \#v_justified\#
\end

screen( capsensitive("vst_alignment") )
Name           Set Graphic Text Alignment - bestimmt die Ausrichtung
               fr Textausgaben.

Definition     void vst_alignment ( int \#handle\#, int hor_in,
                                    int vert_in, int *hor_out,
                                    int *vert_out );

Beschreibung   Mit dieser Funktion wird die Ausrichtung von Grafiktext
               in den Textausgabefunktionen fr das Ger„t mit der
               Kennung \#handle\# festgelegt.
hor_in      0  Linksbndig (das ist auch der Default-Wert)
            1  Zentriert
            2  Rechtsbndig
vert_in     0  Basislinie (das ist auch der Default-Wert)
            1  Kleinbuchstabenh”he
            2  Zeichenoberkante
            3  Zellenunterkante
            4  Zeichenunterkante
            5  Zeichenzellenoberkante
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_gtext\#   \#v_justified\#
\end

screen( capsensitive("vsf_interior") )
Name           Set Fill Interior Style - bestimmt den Fllmustertyp.

Definition     int vsf_interior( int \#handle\#, int style );

Beschreibung   Die Funktion w„hlt fr das Ger„t \#handle\# den
               Fllmustertyp aus.
type       0   FIS_HOLLOW     leer
           1   FIS_SOLID      deckend
           2   FIS_PATTERN    gemustert
           3   FIS_HATCH      schraffiert
           4   FIS_USER       frei definierbar
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_fillarea\#   \#v_contourfill\#   \#vr_recfl\#   \#v_bar\#
               \#v_pieslice\#   \#v_circle\#        \#v_ellipse\#  \#v_ellpie\#
               \#v_rfbox\#      \#vsf_style\#       \#vsf_udpat\#
\end

screen( capsensitive("vsf_style") )
Name           Set Fill Style Index - bestimmt das Fllmuster.

Definition     int vsf_style ( int \#handle\#, int style_index );

Beschreibung   Die Funktion w„hlt fr ein Ausgabeger„t \#handle\# den
               Musterindex style_index aus. Eine šbersicht ber die
               Fllmuster findet sich im Handbuch.
Ergebnis       Die Funktion liefert das tats„chlich eingestellte
               Fllmuster.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_fillarea\#   \#v_contourfill\#   \#vr_recfl\#   \#v_bar\#
               \#v_pieslice\#   \#v_circle\#        \#v_ellipse\#  \#v_ellpie\#
               \#v_rfbox\#      \#vsf_interior\#
\end

screen( capsensitive("vsf_color") )
Name           Set Fill Color Index - bestimmt die Farbe mit der ein
               Polygon ausgefllt wird.

Definition     int vsf_color ( int \#handle\#, int color_index );

Beschreibung   Die Funktion setzt fr das Ger„t mit der Kennung \#handle\#
               die Fllfarbe auf den Wert color_index.
Ergebnis       Die Funktion liefert die tats„chlich eingestellte
               Farbe.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_fillarea\#   \#v_contourfill\#   \#vr_recfl\#   \#v_bar\#
               \#v_pieslice\#   \#v_circle\#        \#v_ellipse\#  \#v_ellpie\#
               \#v_rfbox\#
\end

screen( capsensitive("vsf_perimeter") )
Name           Set Fill Perimeter Visibility - bestimmt, ob eine
               Umrandung um Fllbereiche gezeichnet wird.

Definition     int vsf_perimeter( int \#handle\#, int per_vis );

Beschreibung   Die Funktion bestimmt, ob bei einer Flloperation auf
               dem Ger„t mit der Kennung \#handle\# eine Umrahmung
               gezeichnet wird oder nicht. Falls per_vis gleich Null
               ist, wird keine Umrahmung gezeichnet, sonst schon.
Ergebnis       Die Funktion liefert den tats„chlich eingestellten
               Modus.
Gruppe         \#Attributfunktionen\#
Querverweis    \#v_fillarea\#   \#v_contourfill\#   \#vr_recfl\#   \#v_bar\#
               \#v_pieslice\#   \#v_circle\#        \#v_ellipse\#  \#v_ellpie\#
               \#v_rfbox\#
\end

screen( capsensitive("vsf_udpat") )
Name           Set User Defined Fill Pattern - definiert ein neues
               Fllmuster.

Definition     void vsf_udpat ( int \#handle\#, int *pfill_pat,
                                int planes );

Beschreibung   Die Funktion definiert das frei definierbare
               Fllmuster mit der Nummer vier aus \#vsf_interior\# fr
               das Ger„t mit der Kennung \#handle\#.
planes         Anzahl der Farbebenen
pfill_pat      Zeiger auf ein Feld mit planes Zeilen zu je
               16 Eintr„gen. Dabei gibt jede Zeile das
               Fllmuster fr eine Farbebene wieder. Der
               erste Eintrag in einer Zeile entspricht dabei
               der ersten Zeile des Musters usw.
Gruppe         \#Attributfunktionen\#
Querverweis    \#vsf_interior\#
\end

screen( capsensitive("vro_cpyfm") )
Name           Copy Raster, Opaque - kopiert einen Speicherbereich.

Definition     void vro_cpyfm( int \#handle\#, int vr_mode,
                               int *\#pxyarray\#, \#MFDB\# *psrcMFDB,
                               \#MFDB\# *pdesMFDB);

Beschreibung   Die Funktion kopiert einen Quellspeicherbereich an ein
               Ziel und verknpft dabei die Quelle und das Ziel durch
               die in vr_mode decodierte logische Verknpfung.

psrcMFDB       Zeiger auf den MFDB der Quelle
pdesMFDB       Zeiger auf den MFDB des Ziels
vr_mode        eine von 16 logischen Verknpfungen zwischen
               den Pixeln des Quell- und Zielraster
ALL_WHITE      0     D := 0
S_AND_D        1     D := S AND D
S_AND_NOTD     2     D := S AND (NOT D)
S_ONLY         3     D := S
NOTS_AND_D     4     D := (NOT S) AND D
D_ONLY         5     D := D
S_XOR_D        6     D := S XOR D
S_OR_D         7     D := S OR D
NOT_SORD       8     D := NOT (S OR D)
NOT_SXORD      9     D := NOT (S XOR D)
D_INVERT       10    D := NOT D
NOT_D          11    D := S OR (NOT D)
S_OR_NOTD      12    D := NOT S
NOTS_OR_D      13    D := (NOT S) OR D
NOT_SANDD      14    D := NOT (S AND D)
ALL_BLACK      15    D := 1

pxyarray[0]    x-Koordinate eines Eckpunktes des Quellrasters
pxyarray[1]    y-Koordinate eines Eckpunktes des Quellrasters
pxyarray[2]    x-Koordinate des diagonal gegenberliegenden
               Eckpunktes des Quellrasters
pxyarray[3]    y-Koordinate des diagonal gegenberliegenden
               Eckpunktes des Quellrasters
pxyarray[4]    x-Koordinate eines Eckpunktes des Zielrasters
pxyarray[5]    y-Koordinate eines Eckpunktes des Zielrasters
pxyarray[6]    x-Koordinate des diagonal gegenberliegenden
               Eckpunktes des Zielrasters
pxyarray[7]    y-Koordinate des diagonal gegenberliegenden
               Eckpunktes des Zielrasters
Gruppe         \#Rasterfunktionen\#
Querverweis    \#pxyarray\#   \#MFDB\#
\end

screen( capsensitive("vrt_cpyfm") )
Name           Copy Raster, Transparent - kopiert ein Monochromraster
               auf ein Farbraster.

Definition     void vrt_cpyfm( int \#handle\#, int vr_mode, int *\#pxyarray\#,
                               \#MFDB\# *psrcMFDB, \#MFDB\# *pdesMFDB,
                               int *color_index );

Beschreibung   Die Funktion ist „hnlich der Funktion \#vro_cpyfm\#, nur
               da hier ausgehend von einem Monochromraster auf ein
               Farbraster kopiert wird.
               Auch stehen fr vr_mode weniger Verknpfungen zur
               Verfgung, n„mlich nur diejenigen, die man mit
               \#vswr_mode\# setzen kann.

psrcMFDB       Zeiger auf den MFDB der Quelle
pdesMFDB       Zeiger auf den MFDB des Ziels
color_index[0] Farbnummer der Farbe, die als gesetzt
               interpretiert werden soll
color_index[1] Farbnummer der Farbe, die als nicht
               gesetzt interpretiert werden soll
pxyarray       siehe \#vro_cpyfm\#
vr_mode        siehe \#vswr_mode\#
Gruppe         \#Rasterfunktionen\#
Querverweis    \#pxyarray\#   \#MFDB\#   \#vswr_mode\#   \#vro_cpyfm\#
\end

screen( capsensitive("vr_trnfm") )
Name           Transform Form - wandelt ein Rasterbild um.

Definition     void vr_trnfm( int \#handle\#, \#MFDB\# *psrcMFDB,
                              \#MFDB\# *pdesMFDB );

Beschreibung   Die Funktion konvertiert ein Standardraster, auf dessen
               \#MFDB\# psrcMFDB zeigt, in ein ger„tespezifisches Raster,
               auf dessen \#MFDB\# pdesMFDB zeigt, oder umgekehrt.
Gruppe         \#Rasterfunktionen\#
Querverweis    \#MFDB\#
\end

screen( capsensitive("v_get_pixel") )
Name           Get Pixel - liefert den Farbwert eines Pixels.

Definition     void v_get_pixel( int \#handle\#, int x, int y, int *pel,
                                 int *index );

Beschreibung   Die Funktion ermittelt, ob ein Pixel x, y auf dem
               Ausgabeger„t \#handle\# gesetzt ist oder nicht und den
               zugeh”rigen Farbwert des Pixels.
pel         0  Pixel nicht gesetzt
            1  Pixell gesetzt
index          Farbnummer
Gruppe         \#Rasterfunktionen\#
\end

screen( capsensitive("vsin_mode") )
Name           Set Input Mode - setzt den Eingabemodus

Definition     void vsin_mode( int handle, int dev_type, int mode );

Beschreibung   Die Funktion setzt den Eingabemodus aller Eingaben auf
               dem Eingabeger„t \#handle\# auf Sample (šberprfung des
               Zustands und gegebenenfalls der Position) oder Request
               (das Ger„t wartet auf eine Eingabe).
dev_type       Art des Eingabeger„ts
            1  Eingabeger„t zur Positionseingabe (Maus)
            2  wert„ndernde Eingabeeinheiten (Cursor)
            3  ausw„hlende Einheiten (Funktionstasten)
            4  alphanumerische Eingabeger„te (Tastatur)
mode           gewnschter Modus
            1  Request
            2  Sample
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vrq_locator") )
Name           Input Locator, Request Mode - ermittel die Mausposition,
               wenn eine Taste gedrckt wurde.

Definition     void vrq_locator( int \#handle\#, int x, int y, int *xout,
                                 int *yout, int *term );

Beschreibung   Die Funktion stellt den Grafikcursor an der Position x,
               y dar und wartet auf einen Tastendruck. Nach der
               Rckkehr der Funktion hat man die neue Position des
               Cursors in xout, yout und im Lowbyte von term den ASCII
               Code der gedrckten Taste.
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vsm_locator") )
Name           Input Locator, Sample Mode - bestimmt die Position des
               Grafikcursors.

Definition     int vsm_locator( int \#handle\#, int x, int y, int *xout,
                                int *yout, int *term );

Beschreibung   Die Funktion bestimmt die neue Position des
               Grafikcursors ohne ihn auf dem Ger„t \#handle\#
               darzustellen. Aus den alten Koordinaten x, y werden
               die neuen Koordinaten xout, yout berechnet. In term
               erh„lt man die gedrckte Taste.
Ergebnis       Die Funktion liefert kodiert Informationen darber, ob
               sich die Position ver„ndert hat (Bit 0 gesetzt) und
               ob eine Taste gedrckt wurde (Bit 1 gesetzt).
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vrq_valuator") )
Name           Input Valuator, Request Mode - stellt Wertver„nderungen
               im REQUEST-Modus fest.

Definition     void vrq_valuator( int \#handle\#, int valuator_in,
                                 int *valuator_out, int *terminator );

Beschreibung   Die Funktion ermittelt fr das Eingabeger„t eine
               Wertver„nderung, die sich aus entsprechenden
               Tastenbet„tigungen ergibt. Typische Werte sind +10 fr
               die Cursoraufw„rtstaste, -10 fr die Cursorabw„rtstaste,
               die zum Parameter valuator_in addiert werden und nach
               dem Aufruf in valuator_out stehen.
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vsm_valuator") )
Name           Input Valuator, Sample Mode - stellt Wertver„nderungen
               im SAMPLE-Modus fest.

Definition     void vsm_valuator( int \#handle\#, int val_in,
                                  int *val_out, int *term,
                                  int *status );

Beschreibung   hnlich der Funktion \#vrq_valuator\# ermittelt die
               Funktion Wertver„nderungen hervorgerufen durch
               Tastenbet„tigung spezieller "Werttasten".

val_in         zu ver„ndernder Wert
val_out        entsprechend der bet„tigten Taste ver„nderter
               Wert von val_in
term           ASCII-Code der gedrckten Taste
status      0  keine Ver„nderung
            1  Wert ver„ndert
            2  Taste bet„tigt
Gruppe         \#Eingabefunktionen\#
Querverweis    \#vrq_valuator\#
\end

screen( capsensitive("vrq_choice") )
Name           Input Choise, Request Mode - liefert den Status der
               Funktionstasten, wenn eine gedrckt wurde.

Definition     void vrq_choice( int \#handle\#, int ch_in, int *ch_out );

Beschreibung   Die Funktion wartet darauf, da eine Auswahltaste
               (Funktionstaste) auf dem Eingabeger„t \#handle\# bet„tigt
               wird. Wird eine andere Taste bet„tigt, so wird der Wert
               ch_in zurckgeliefert.
Gruppe         \#Eingabefunktionen\#
Querverweis    \#vsm_choice\#
\end

screen( capsensitive("vsm_choice") )
Name           Input Choise, Sample Mode - ermittelt welche
               Funktionstaste zuletzt gedrckt wurde.

Definition     int vsm_choice( int \#handle\#, int *choice );

Beschreibung   Die Funktion berprft den Zustand der Auswahltasten
               (Funktionstasten) und schreibt den Code in choice.
Ergebnis       Die Funktion liefert eine Eins, falls eine Auswahltaste
               bet„tigt wurde, sonst eine Null.
Gruppe         \#Eingabefunktionen\#
Querverweis    \#vrq_choice\#
\end

screen( capsensitive("vrq_string") )
Name           Input String, Request Mode - liest einen String im
               REQUEST-Modus ein.

Definition     void vrq_string( int \#handle\#, int max_length,
                                int echo_mode, int *echo_xy,
                                char *string );

Beschreibung   Die Funktion gestattet die Eingabe von Grafiktext der
               maximalen L„nge max_length auf dem Eingabeger„t \#handle\#.
               Falls echo_mode gleich Eins ist, wird der eingegebene
               Text auf dem Eingabeger„t unter Beachtung der
               \#Textattribute\# an den Koordinaten echo_xy[0], echo_xy[1]
               dargestellt. Die Funktion wird entweder durch das
               Bet„tigen von RETURN oder bei šberschreittung von
               max_len Eingabezeichen beendet. Der eingegebene Text
               steht in string.
Gruppe         \#Eingabefunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#       \#vst_alignment\#  \#vst_height\#
               \#vst_point\#   \#vst_rotation\#   \#vst_font\#       \#vst_color\#
               \#vst_effects\# \#vsm_string\#
\end

screen( capsensitive("vsm_string") )
Name           Input String, Sample Mode - liest einen String im
               SAMPLE-Modus ein.

Definition     int vsm_string( int \#handle\#, int max_length,
                               int echo_mode, int *echo_xy,
                               char *string );

Beschreibung   Die Funktion gestattet die Eingabe von Grafiktext auf
               dem Eingabeger„t \#handle\#. Die Funktion wird beendet,
               falls die Anzahl der maximalen Eingabezeichen
               max_length berschritten wird, die RETURN-Taste
               bet„tigt wurde oder eine nicht zul„ssige Taste gedrckt
               wurde. Falls echo_mode Eins ist, wird die Eingabe unter
               Beachtung der \#Textattribute\# auf dem Eingabeger„t an den
               Koordinaten echo_xy[0], echo_xy[1] dargestellt.
Ergebnis       Die Funktion liefert entweder die Anzahl der gelesen
               Zeichen oder Null, falls die Eingabe durch eine
               ungltige Taste  abgebrochen wurde. Der eingegebene
               Text steht in string.
Gruppe         \#Eingabefunktionen\#
Querverweis    \#vswr_mode\#    \#vs_color\#      \#vst_alignment\#   \#vst_height\#
               \#vst_point\#    \#vst_rotation\#  \#vst_font\#        \#vst_color\#
               \#vst_effects\#  \#vrq_string\#
\end

screen( capsensitive("vsc_form") )
Name           Set Mouse Form - setzt die Mauszeigerform.

Definition     void vsc_form( int \#handle\#, int *pcur_form );

Beschreibung   Die Funktion setzt auf dem Ger„t \#handle\# eine neue
               Mauszeigerform. Die Information ber das Aussehen des
               Mauszeigers steht dabei in der Datenstruktur, auf die
               pcur_form zeigt. Der Aufbau der Datenstruktur:

               pcur_form[0]      relative x-Koordinate des Hot-Spot
               pcur_form[1]      relative y-Koordinate des Hot-Spot
               pcur_form[2]      reserviert: 1
               pcur_form[3]      Farbindex der Hintergrundmaske
               pcur_form[4]      Farbindex der Vordergrundmaske
               pcur_form[5..20]  Hintergrundmaske
               pcur_form[21..36] Vordergrundmaske

Gruppe         \#Eingabefunktionen\#
Querverweis    \#graf_mouse\#
\end

screen( capsensitive("vex_timv") )
Name           Exchange Timer Interrupt Vector - stellt den
               Interruptvector fr den Zeitgeber um.

Definition     void vex_timv( int \#handle\#, int (*tim_addr)(),
                              int (**otim_addr)(), int *tim_conv );

Beschreibung   Die Funktion erm”glicht es, eine eigene Routine in den
               Timerinterrupt einzuh„ngen. Dabei ist tim_addr ein
               Zeiger auf die eigene Funktion, in otim_addr erh„lt man
               die alte Adresse der Interruptroutine und in tim_conv
               die Anzahl der Millisekunden. Am Ende des Programms mu
               der alte Vektor wieder hergestellt werden.
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("v_show_c") )
Name           Show Cursor - schaltet den Grafikcursor ein.

Definition     void v_show_c( int \#handle\#, int reset );

Beschreibung   Die Funktion zeigt auf dem Ger„t \#handle\# den
               Grafikcursor an, falls reset gleich Null ist bzw. hebt
               einen Aufruf der Funktion \#v_hide_c\# auf. Es ist also
               eine Verschachtelung der Aufrufe beider Funktionen
               m”glich.
Gruppe         \#Eingabefunktionen\#
Querverweis    \#v_hide_c\#
\end

screen( capsensitive("v_hide_c") )
Name           Hide Cursor - schaltet den Grafikcursor aus.

Definition     void v_hide_c( int \#handle\# );

Beschreibung   Die Funktion schaltet den Grafikcursor auf dem Ger„t
               mit der Kennung \#handle\# aus.

Gruppe         \#Eingabefunktionen\#
Querverweis    \#v_show_c\#
\end

screen( capsensitive("vq_mouse") )
Name           Sample Mouse Button State - ermittelt Position und
               Status der Maustasten.

Definition     void vq_mouse( int \#handle\#, int *pstatus, int *x,
                              int *y );

Beschreibung   Die Funktion berprft den Status der linken Maustaste
               und schreibt ihn in pstatus (0  Taste nicht gedrckt,
               1  Taste gedrckt).
               Zus„tzlich erh„lt man die Position des Mauszeigers in x
               und y.
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vq_scan") )
Name           Inquire Printer Scan - Abfrage der Druckerparameter

Definition     void vq_scan( int \#handle\#, int *g_slice,
                             int *g_page, int *a_slice, int *a_page,
                             int *div_fac );

Beschreibung   Die Funktion fr„gt verschiedene druckerspezifische
               Paramater ab. Der Druckertreiber unterteilt eine
               Druckseite in mehrere "Scheiben" (slices), die
               nacheinander formatiert und gedruckt werden, um den
               Speicherplatzbedarf zu senken. Dabei ist g_slice die
               Anzahl dieser Scheiben und g_page die Pixelh”he einer
               Scheibe. a_slice gibt die H”he einer Textzeile in Pixel
               und a_page die Anzahl Textzeilen pro Seite an.
               Durch div_fac mssen die anderen Werte ggf. noch
               geteilt werden.
Gruppe         \#Auskunftsfunktionen\#
\end

screen( capsensitive("v_alpha_text") )
Name           Output Alpha Text - Ausgabe von Text im Textmodus

Definition     void v_alpha_text( int \#handle\#, char *string);

Beschreibung   Die Funktion gibt Text im Textmodus aus. Grundlegende
               Steuerzeichen sind fr alle Druckertypen genormt:

               DC2 0:    Fett an
               DC2 1:    Fett aus
               DC2 2:    Kursiv an
               DC2 3:    Kursiv aus
               DC2 4:    Unterstrichen an
               DC2 5:    Unterstrichen aus

Gruppe         \#Ausgabefunktionen\#
\end

screen( capsensitive("vex_butv") )
Name           Exchange Button Change Vector - stellt den
               Interruptvektor fr einen Maustastendruck um.

Definition     void vex_butv( int \#handle\#, int (*pusrcode)(),
                              int (**psavcode)() );

Beschreibung   Die Funktion gestattet es, eine eigene Routine in den
               Maustastenvektor einzuh„ngen. Dazu bergibt man den
               Zeiger auf die eigene Routine in pusrcode und erh„lt
               den alten Vektor in psavcode. Am Programmende mu der
               alte Vektor wiederhergestellt werden.

Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vex_motv") )
Name           Exchange Mouse Movement Vector - stellt den
               Interruptvektor fr Mausbewegungen um.

Definition     void vex_motv( int \#handle\#, int (*pusrcode)(),
                              int (**psavcode)() );

Beschreibung   Die Funktion erm”glicht es, eine eigene Routine in den
               Mousemovementvektor einzuh„ngen, d. h. bei jeder
               Mausbewgung wird dann die neue Routine aufgerufen.
               Dabei ist pusrcode der Zeiger auf die einzuh„ngende
               Routine und in psavecode erh„lt man den alten Vektor,
               der am Programmende wiederhergestellt werden mu.
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vex_curv") )
Name           Exchange Cursor Change Vector - stellt den
               Interruptvector fr Cursorbewegungen um.

Definition     void vex_curv( int \#handle\#, int (*pusrcode)(),
                              int (**psavcode)() );

Beschreibung   Die Funktion erm”glicht es, eine eigene Routine in den
               Cursorchangevektor einzuh„ngen. Dabei ist pusrcode ein
               Zeiger auf die einzuh„ngende Routine und in psavcode
               erh„lt man den alten Vektor, den man am Programmende
               wiederherstellen mu.
Gruppe         \#Eingabefunktionen\#
\end

screen( capsensitive("vq_key_s") )
Name           Sample Keyboard State Information - ermittelt den
               Status der Kontrolltasten.

Definition     void vq_key_s( int \#handle\#, int *pstatus );

Beschreibung   Die Funktion berprft die Tastatur und schreibt den
               Zustand der Sondertasten in pstatus. Das Format ist
               dabei das gleiche wie in ev_bkstate bei \#evnt_button\#.
Gruppe         \#Eingabefunktionen\#
Querverweis    \#evnt_button\#
\end

screen( capsensitive("vq_extnd") )
Name           Extended Inquire Funktion - ermittelt Informationen
               ber eine Arbeitsstation.

Definition     void vq_extnd( int \#handle\#, int owflag, int *work_out );

Beschreibung   Die Funktion erlaubt es, ber ein Ger„t mit der Kennung
               \#handle\# einige Ausknfte, d. h. Angaben ber die
               F„higkeiten des Ger„ts, einzuholen. Ist owflag gleich
               Null, so erh„lt man in \#work_out\# die gleichen Angaben,
               wie in \#v_opnwk\#, ist dagegen owflag gleich Eins, so
               erh„lt man in \#work_out\# erweiterte Ausknfte.
Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#v_contourfill\#   \#vswr_mode\#   \#v_pline\#   \#v_pmarker\#
               \#v_fillarea\#      \#v_opnwk\#
\end

screen( capsensitive("work_out") )
work_out[0]    genaue Spezifikation des Bildschirms
               0  kein Bildschirm
               1  getrennte Grafik/Textbildschirme mit getrennten
                  Kontrollern
               2  gemeinsame Grafik/Textbildschirme mit getrennten
                  Kontrollern
               3  getrennte Grafik/Textbildschirme mit gemeinsamen
                  Kontroller
               4  gemeinsamer Grafik/Textbildschirm mit gemeinsamen
                  Kontroller
work_out[1]    Anzahl der vom Ger„t untersttzten Farben
work_out[2]    Anzahl der vom Ger„t untersttzten Texteffekte
work_out[3]    Vergr”erungsflag
               0  Ger„t untersttzt vergr”ern nicht
               1  Ger„t untersttzt vergr”ern
work_out[4]    Anzahl der Farbebenen
work_out[5]    falls Null, so untersttzt das Ger„t einen
               "lookup-table", sonst nicht
work_out[6]    Anzahl der m”glichen 16x16 Rasteroperationen / Sekunde
work_out[7]    falls Eins, so untersttzt das Ger„t die
               \#v_contourfill\# Funktion.
work_out[8]    Textrotationsflag
               0  nicht m”glich
               1  in 90 Grad Schritten m”glich
               2  kontinuierliche Drehung m”glich
work_out[9]    Anzahl der untersttzten Schreibmodi ( \#vswr_mode\# )
work_out[10]   welche Eingabemodi stehen zur Verfgung
               0  keine
               1  Request Modus
               2  Sample Modus
work_out[11]   Textausrichtung wird
               0  nicht untersttzt
               1  untersttzt
work_out[12]   Farbstiftwechsel wird
               0  nicht untersttzt
               1  untersttzt
work_out[13]   Wechsel des Farbbandes wird am Ausgabeger„t
               0  nicht untersttzt
               1  zeilenweise untersttzt
               2  zeilen- und spaltenweise untersttzt
work_out[14]   H”chstzahl von Koordinatenpaare fr \#v_pline\#,
               \#v_pmarker\#, \#v_fillarea\#
work_out[15]   maximale Gr”e des int_in Feldes (-1 unbegenzt)
work_out[16]   Zahl der verfgbaren Maustasten
work_out[17]   verschiedene Linientypen werden fr breite Linien
               0  nicht untersttzt
               1  untersttzt
work_out[18]   Anzahl der verfgbaren Schreibmodi fr breite Linien
work_out[19]   0 (reserviert)
    :
work_out[56]
\end

screen( capsensitive("vq_color") )
Name           Inquire Color Representation - ermittelt die
               Intensit„t einer Farbe.

Definition     void vq_color( int \#handle\#, int color_index,
                             int set_flag, int *rgb );

Beschreibung   Falls set_flag Null ist, so ermittelt die Funktion die
               vom Anwender gewnschte Farbe und und schreibt die
               Farbanteile der Grundfarben fr die Farbe color_index
               in das Feld rgb.
               Falls dagegen set_flag Eins ist, so ermittelt die
               Funktion die Farbe, die von der Workstation auch
               tats„chlich realisiert werden konnte.

rgb_in[0]      Rotanteil in Promille
rgb_in[1]      Grnanteil in Promille
rgb_in[2]      Blaunanteil in Promille

Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vs_color\#
\end

screen( capsensitive("vql_attributes") )
Name           Inquire Current Polyline Attributes - ermittelt die
               Attribute fr das Zeichnen von Linien.

Definition     void vql_attributes( int \#handle\#, int *attrib );

Beschreibung   Die Funktion ermittelt die derzeit gesetzten Attribute,
               die fr alle POLYLINE Operationen auf dem Ger„t \#handle\#
               gltig sind.

attrib[0]      aktueller Linientyp
attrib[1]      Linienfarbnummer
attrib[2]      Schreibmodus
attrib[3]      Darstellung des Linienanfangs
attrib[4]      Darstellung des Linienendes
attrib[5]      Linienstrichst„rke

Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#   \#vsl_type\#   \#vsl_width\#
               \#vsl_color\#   \#vsl_ends\#
\end

screen( capsensitive("vqm_attributes") )
Name           Inquire Current Polymarker Attributes - ermittelt die
               Attribute fr das Zeichnen von Markierungen.

Definition     void vqm_attributes( int \#handle\#, int *attrib );

Beschreibung   Die Funktion ermittelt die derzeit gesetzten
               Linienattribute, die fr alle POLYMARKER Operationen
               auf dem Ger„t \#handle\# gltig sind.

attrib[0]      aktueller Markertyp
attrib[1]      Markerfarbnummer
attrib[2]      Schreibmodus
attrib[3]      Breite des Markers
attrib[4]      H”he des Markers

Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vswr_mode\#  \#vs_color\#  \#vsm_type\#  \#vsm_height\#  \#vsm_color\#
\end

screen( capsensitive("vqf_attributes") )
Name           Inquire Current Fill Area Attributes - ermittelt die
               Attribute zum Ausfllen von Fl„chen.

Definition     void vqf_attributes( int \#handle\#, int *attrib );

Beschreibung   Die Funktion ermittelt die derzeit gesetzten
               Fllattribute, die fr alle FILL Operationen auf
               dem Ger„t \#handle\# gltig sind.

attrib[0]      Fllmuster
attrib[1]      Fllfarbnummer
attrib[2]      Fllmusterindex
attrib[3]      Schreibmodus
attrib[4]      Umrahmung zeichnen

Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vswr_mode\#   \#vs_color\#      \#vsf_interior\#   \#vsf_style\#
               \#vsf_color\#   \#vsf_perimeter\#
\end

screen( capsensitive("vqt_attributes") )
Name           Inquire Current Graphic Text Attributes - ermittelt die
               Attribute fr das Schreiben von Texten.

Definition     void vqt_attributes( int \#handle\#, int *attrib );

Beschreibung   Die Funktion ermittelt die derzeit gesetzten
               \#Textattribute\#, die fr alle GRAPHICS TEXT
               Operationen auf dem Ger„t \#handle\# gltig sind.
attrib[0]      Zeichensatznummer
attrib[1]      Textfarbnummer
attrib[2]      Drehwinkel des Texts (in 1/10 Grad)
attrib[3]      horizontale Ausrichtung
attrib[4]      vertikale Ausrichtung
attrib[5]      Schreibmodus
attrib[6]      Breite eines Zeichens
attrib[7]      H”he eines Zeichens
attrib[8]      Zeichenzellenbreite
attrib[9]      Zeichenzellenh”he
Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vswr_mode\#     \#vs_color\#   \#vst_height\#   \#vst_point\#
               \#vst_rotation\#  \#vst_font\#   \#vst_color\#    \#vst_effects\#
               \#vst_alignment\#
\end

screen( capsensitive("vqt_extent") )
Name           Inquire Text Extent - ermittelt die L„nge eines Strings.

Definition     void vqt_extent( int \#handle\#, char *string,
                                int *extent );

Beschreibung   Die Funktion ermittelt fr die, in string stehende
               Zeichenkette, ein Rechteck, das den Text unter
               Beachtung aller gesetzten \#Textattribute\# auf dem Ger„t
               \#handle\# voll umgibt und schreibt die Koordinaten der
               Ecken dieses Rechtecks in extent.

                 extent[0]      x-Koordinate der unteren linken Ecke
                 extent[1]      y-Koordinate der unteren linken Ecke
                 extent[2]      x-Koordinate der unteren rechten Ecke
                 extent[3]      y-Koordinate der unteren rechten Ecke
                 extent[4]      x-Koordinate der oberen rechten Ecke
                 extent[5]      y-Koordinate der oberen rechten Ecke
                 extent[6]      x-Koordinate der oberen linken Ecke
                 extent[7]      y-Koordinate der oberen linken Ecke

Gruppe         \#Auskunftsfunktionen\#

Querverweis    \#vst_height\#   \#vst_point\#     \#vst_rotation\#
               \#vst_font\#     \#vst_effects\#
\end

screen( capsensitive("vqt_f_extent") )
Name           Inquire FSM Text Extent - ermittelt die L„nge eines
               Strings im FSM-Zeichensatz.

Definition     void  vqt_f_extent( int \#handle\#, char *string,
                                     int *extent );

Beschreibung   Die Funktion ermittelt fr die, in string stehende
               Zeichenkette, ein Rechteck, das den Text unter
               Beachtung aller gesetzten \#Textattribute\# auf dem Ger„t
               \#handle\# und des aktuellen FSM-Zeichensatzes voll
               umgibt und schreibt die Koordinaten der Ecken dieses
               Rechtecks in extent.

                 extent[0]      x-Koordinate der unteren linken Ecke
                 extent[1]      y-Koordinate der unteren linken Ecke
                 extent[2]      x-Koordinate der unteren rechten Ecke
                 extent[3]      y-Koordinate der unteren rechten Ecke
                 extent[4]      x-Koordinate der oberen rechten Ecke
                 extent[5]      y-Koordinate der oberen rechten Ecke
                 extent[6]      x-Koordinate der oberen linken Ecke
                 extent[7]      y-Koordinate der oberen linken Ecke

Gruppe         \#Auskunftsfunktionen\#

Querverweis    \#FSMGDOS\#     \#vqt_extent\#
\end

screen( capsensitive("vqt_width") )
Name           Inquire Character Cell Width - ermittelt die Breite
               einer Zeichenzelle.

Definition     int vqt_width( int \#handle\#, char character,
                              int *cell_width, int *left_delta,
                              int *right_delta );

Beschreibung   Die Funktion ermittelt fr einen Buchstaben character
               auf dem Ger„t \#handle\# die Zeichenzellenbreite
               cell_width und die Zeichenzwischenr„ume left_delta und
               right_delta. Dabei werden die mit \#vst_effects\# gesetzten
               Textspezialeffekte nicht mit bercksichtigt.
Ergebnis       Die Funktion liefert  -1, falls die Ausmae aus irgend
               einem Grund nicht berechnet werden konnten.
Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vst_effects\#
\end

screen( capsensitive("vqt_name") )
Name           Inquire Face Name and Index - ermittelt den Namen und
               Kurzbeschreibung eines Zeichensatzes.

Definition     int vqt_name( int \#handle\#, int element_num, char *name);

Beschreibung   Die Funktion ermittelt fr den Zeichensatz mit der
               Nummer element_num auf dem Ger„t \#handle\# den Namen des
               Zeichensatzes und schreibt ihn in name.

Ergebnis       Die Funktion liefert die Indexnummer des Zeichensatzes.
name[0]        Name des Zeichensatzes
  :
name[15]
name[16]       Kurzbeschreibung des Zeichesatzes
  :
name[31]
name[32]       Flag fr \link("FSM")FSM-Font\#

Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vst_load_fonts\# \#vst_font\#
\end

screen( capsensitive("vq_cellarray") )
Name           Inquire Cell Array - ermittelt Informationen ber eine
               dargestellte Farbtabelle.

Definition     void vq_cellarray( int \#handle\#, int *\#pxyarray\#,
                                  int row_length, int num_rows,
                                  int *el_used, int *rows_used,
                                  int *status, int *colarray );

Beschreibung   Die Funktion ermittelt auf dem Ger„t \#handle\# die
               derzeitigen Attribute eines eventuell vorhanden
               CELL ARRAY.
\#pxyarray\#       Begrenzungsrechteck
row_length     Anzahl der Spalten
num_rows       Anzahl der Zeilen
el_used        Anzahl benutzter Zellen in einer Reihe
rows_used      Anzahl benutzter Zeilen
status         0   alles hat ohne Fehler geklappt
               >0  eine Farbe konnte nicht gefunden werden
colarray       Farbindexarray
Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#v_cellarray\#
\end

screen( capsensitive("vqin_mode") )
Name           Inquire Input Mode - ermittelt den Eingabemodus.

Definition     void vqin_mode( int \#handle\#, int dew_type,
                               int *input_mode );

Beschreibung   Die Funktion ermittelt den fr das Ger„t \#handle\#
               gltigen Eingabemodus.
dew_type       Art des Eingabeger„ts
            1  Eingabeger„t zur Positionseingabe (Maus)
            2  wert„ndernde Eingabeeinheiten (Cursor)
            3  ausw„hlende Einheiten (Funktionstasten)
            4  alphanumerische Eingabeger„te (Tastatur)
input_mode     eingestellter Modus
            1  Request
            2  Sample
Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vsin_mode\#      \#vrq_locator\#  \#vsm_locator\#   \#vrq_valuator\#
               \#vsm_valuator\#   \#vrq_choice\#   \#vsm_choice\#    \#vrq_string\#
               \#vsm_string\#
\end

screen( capsensitive("vqt_fontinfo") )
Name           Inquire Current Face Information - ermittelt
               Informationen ber Zeichens„tze.

Definition     void vqt_fontinfo( int \#handle\#, int *minADE,
                                  int *maxADE, int *distances,
                                  int *maxwidth, int *effects );

Beschreibung   Die Funktion gibt ausfhrliche Auskunft ber den
               derzeit aktuellen Zeichensatz auf dem Ger„t \#handle\#.
minADE         Zeichennummer des ersten Zeichens im Zeichensatz
maxADE         Zeichennummer des letzten Zeichens im Zeichensatz
distances[0]   Abstand untere Kante der Zeichenzelle zur Basislinie
distances[1]   Unterl„nge in Pixeln (Abstand Untergrenze Zeichen zur
               Basislinie)
distances[2]   Obergrenze der Kleinbuchstaben (Halblinie)
distances[3]   Abstand Obergrenze des Zeichens zur Basislinie
distances[4]   Abstand der oberen Kante der Zeichenzelle zur Basislinie
max_width      Zeichenzellenbreite des breitesten Zeichens ohne
               Beachtung von Spezialeffekten
effects[0]     Verbreiterung der Zeichen bei Spezialeffekten
effects[1]     linke Verbreiterung bei Kursivdarstellung
effects[2]     rechte Verbreiterung bei Kursivdarstellung
Gruppe         \#Auskunftsfunktionen\#
Querverweis    \#vst_effects\#
\end

screen( capsensitive("vq_chcells") )
Name           Inquire Addressable Alpha Character Cells - ermittelt
               die Anzahl der Reihen und Spalten einer Arbeitsstation.

Definition     void vq_chcells( int \#handle\#, int *rows, int *columns );

Beschreibung   Die Funktion ermittelt die auf dem Ger„t \#handle\# mit dem
               Alphacursor ansprechbaren Zeilen rows und Spalten
               columns. Falls keine Adressierung m”glich ist, erh„lt
               man -1 im entsprechenden Parameter.

Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_exit_cur") )
Name           Exit Alpha Mode - schaltet den Textmodus ab.

Definition     void v_exit_cur( int \#handle\# );

Beschreibung   Die Funktion veranlat das Ger„t mit der Kennung \#handle\#
               den alphanumerischen Darstellungsmodus zu Verlassen und
               wieder auf den Grafikbildschirm zu schalten.

Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_enter_cur") )
Name           Enter Alpha Mode - schaltet den Textmodus ein.

Definition     void v_enter_cur( int \#handle\# );

Beschreibung   Die Funktion veranlat das Ger„t mit der Kennung \#handle\#
               in den alphanumerischen Darstellungsmodus zu schalten
               und setzt den Textcursor in die linke obere Ecke.

Gruppe         \#Escapefunktionen\#
Querverweis    \#v_exit_cur\#
\end

screen( capsensitive("v_curup") )
Name           Alpha Cursor up - bewegt den Alphacursor um eine Zeile
               nach oben.

Definition     void v_curup( int \#handle\# );

Beschreibung   Die Funktion bewegt den Alphacursor auf dem Ger„t
               \#handle\# eine Zeile nach oben. Falls sich der Cursor
               bereits in der obersten Zeile befindet, so ver„ndert
               sich nichts.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_curdown") )
Name           Alpha Cursor down - bewegt den Alphacursor um eine
               Zeile nach unten.

Definition     void v_curdown( int \#handle\# );

Beschreibung   Die Funktion bewegt den Alphacursor auf dem Ger„t
               \#handle\# eine Zeile nach unten. Falls sich der Cursor
               bereits in der untersten Zeile befindet, so ver„ndert
               sich nichts.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_curright") )
Name           Alpha Cursor right - bewegt den Alphacursor um ein
               Zeichen nach rechts.

Definition     void v_curright( int \#handle\# );

Beschreibung   Die Funktion bewegt den Alphacursor auf dem Ger„t
               \#handle\# eine Spalte nach rechts. Falls sich der
               Cursor bereits in der rechtesten Spalte befindet, so
               ver„ndert sich nichts.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_curleft") )
Name           Alpha Cursor left - bewegt den Alphacursor um ein
               Zeichen nach links.

Definition     void v_curleft( int \#handle\# );

Beschreibung   Die Funktion bewegt den Alphacursor auf dem Ger„t
               \#handle\# eine Spalte nach links. Falls sich der Cursor
               bereits in der linksten Spalte befindet, so ver„ndert
               sich nichts.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_curhome") )
Name           Home Alpha Cursor - bewegt den Alphcursor in die linke
               obere Ecke.

Definition     void v_curhome( int \#handle\# );

Beschreibung   Die Funktion bewegt den Alphacursor auf dem Ger„t
               \#handle\# in die "Home"-Stellung (meist oben links).
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_eeos") )
Name           Erase to End of Alpha Screen - l”scht den Bildschirm ab
               dem Alphacursor.

Definition     void v_eeos( int \#handle\# );

Beschreibung   Die Funktion l”scht auf dem Ger„t mit der Kennung
               \#handle\# den alphanumerischen Bildschirm ab der
               aktuellen Alphacursorposition. Die Position des Cursors
               wird dabei nicht ver„ndert.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_eeol") )
Name           Erase to End of Alpha Text Line - l”scht die Zeile ab
               dem Alphacursor.

Definition     void v_eeol( int \#handle\# );

Beschreibung   Die Funktion l”scht auf dem Ger„t mit der Kennung
               \#handle\# die Zeile des alphanumerischen Bildschirm ab
               der aktuellen Alphacursorposition. Die Position des
               Cursors bleibt dabei unver„ndert.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("vs_curaddress"),
		capsensitive("v_curaddress") )
Name           Direct Alpha Cursor Address - setzt den Alphacursor an
               die angegebene Position.

Definition     void v_curaddress( int \#handle\#, int row, int column );
               bzw.
               void vs_curaddress( int \#handle\#, int row, int column );

Beschreibung   Die Funktion setzt den Alphacursor auf dem Ger„t mit
               der Kennung \#handle\# in die Zeile row und die Spalte
               column.
Beschreibung   \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("v_curtext") )
Name           Output Cursor Addressable Alpha Text - gibt einen Text
               ab dem Alphacursor aus.

Definition     void v_curtex( int \#handle\#, char *string );

Beschreibung   Die Funktion gibt den Text, auf den string zeigt, auf
               dem Ger„t mit der Kennung \#handle\# an der aktuellen
               Cursorposition aus.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#   \#v_enter_cur\#   \#v_curup\#     \#v_curdown\#
               \#v_curright\#    \#v_curleft\#     \#v_curhome\#   \#vs_curaddress\#
\end

screen( capsensitive("v_rvon") )
Name           Reverse Video on - schaltet den Invertiermodus ein.

Definition     void v_rvon( int \#handle\# );

Beschreibung   Die Funktion schaltet fr das Ger„t mit der Kennung
               \#handle\# in den Reversemodus, d. h. alle
               alphanumerischen Ausgaben werden invertiert.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#   \#v_rvoff\#
\end

screen( capsensitive("v_rvoff") )
Name           Reverse Video off - schaltet den Invertiermodus ab.

Definition     void v_rvoff( int \#handle\# );

Beschreibung   Die Funktion schaltet fr das Ger„t mit der Kennung
               \#handle\# den Reversemodus wieder ab, d. h. alle
               alphanumerischen Ausgaben werden wieder normal
               dargestellt.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#   \#v_rvon\#
\end

screen( capsensitive("vq_curaddress") )
Name           Inquire Current Alpha Cursor Address - ermittelt die
               aktuelle Alphacursorposition.

Definition     void vq_curaddress( int \#handle\#, int *row, int *column);

Beschreibung   Die Funktion ermittelt die aktuelle Position des
               Alphacursors auf dem Ger„t \#handle\# und schreibt sie
               in row (Zeile) und column (Spalte).

Gruppe         \#Escapefunktionen\#
Querverweis    \#v_enter_cur\#
\end

screen( capsensitive("vq_tabstatus") )
Name           Inquire Tablet Status - ermittelt die Verfgbarkeit
               einer Eingabeeinheit.

Definition     int vq_tabstatus( int \#handle\# );

Beschreibung   Die Funktion ermittelt fr das Ger„t mit der Kennung
               \#handle\#, ob ein Grafiktablet, eine Maus, ein Joystick
               oder ein „hnliches Eingabeeinheit verfgbar ist. Ist
               ein solche Eingabeeinheit verfgbar, so liefert die
               Funktion einen Rckgabewert von Eins, sonst liefert
               sie Null.
Gruppe         \#Escapefunktionen\#
\end

screen( capsensitive("v_hardcopy") )
Name           Hardcopy - fhrt eine Hardcopy des Bildschirms durch.

Definition     void v_hardcopy( int \#handle\# );

Beschreibung   Die Funktion erstellt auf dem Ger„t mit der Kennung
               \#handle\# eine Hardcopy des Bildschirminhalts.
Gruppe         \#Escapefunktionen\#
\end

screen( capsensitive("v_dspcur") )
Name           Place Graphic Cursor at Location - positioniert den
               Grafikcursor an die angegebene Position.

Definition     void v_dspcur( int \#handle\#, int x, int y );

Beschreibung   Die Funktion plaziert den Grafikcursor an den
               Koordinaten x, y auf dem Ger„t \#handle\#.
Gruppe         \#Escapefunktionen\#
\end

screen( capsensitive("v_rmcur") )
Name           Remove last Graphic Cursor - entfernt den Grafikcursor.

Definition     void v_rmcur( int \#handle\# );

Beschreibung   Die Funktion entfernt den Grafikcursor vom
               Ger„t \#handle\#.
Gruppe         \#Escapefunktionen\#
\end

screen( capsensitive("v_form_adv") )
Name           Form Advance - erzeugt einen Seitenvorschub.

Definition     void v_form_adv( int \#handle\# );

Beschreibung   Die Funktion erzeugt auf dem Ger„t mit der Kennung
               \#handle\# einen Seitenvorschub und der Inhalt des
               Datenpuffers bleibt abei erhalten.
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_clrwk\#
\end

screen( capsensitive("v_output_window") )
Name           Output Window - gibt den Fensterinhalt auf dem
               Drucker aus.

Definition     void v_output_window( int \#handle\#, int *xyarray );

Beschreibung   Die Funktion gibt den Inhalt des durch xyarray
               festgelegten Fensters der Arbeitsstation mit der
               Kennung \#handle\# auf dem Drucker aus.

               falls Normalkoordinaten (NDC) verwendet werden:
xyarray[0]     x-Koordinate der linken unteren Ecke
xyarray[1]     y-Koordinate der linken unteren Ecke
xyarray[2]     x-Koordinate der rechten oberen Ecke
xyarray[3]     y-Koordinate der rechten oberen Ecke

               falls Rasterkoordinaten (RC) verwendet werden:
xyarray[0]     x-Koordinate der linken oberen Ecke
xyarray[1]     y-Koordinate der linken oberen Ecke
xyarray[2]     x-Koordinate der rechten unteren Ecke
xyarray[3]     y-Koordinate der rechten unteren Ecke
Gruppe         \#Escapefunktionen\#
Querverweis    \#v_updwk\#
\end

screen( capsensitive("v_clear_disp_list") )
Name           Clear Display List - l”scht die Druckerpufferliste.

Definition     void v_clear_disp_list( int \#handle\# );

Beschreibung   Die Funktion l”scht die Druckerpufferliste eines
               angeschlossenen Druckers „hnlich der Funktion \#v_clrwk\#.
               Es wird jedoch im Unterschied dazu kein Seitenvorschub
               erzeugt. Die Funktion sollte nur mit \#GDOS\# verwendet
               werden.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#   \#v_clrwk\#
\end

screen( capsensitive("v_bit_image") )
Name           Output Bit Image File - gibt ein Bitimagefile auf
               dem Drucker aus.

Definition     void v_bit_image( int handle, const char *filename,
                                 int aspect, int x_scale, int y_scale,
                                 int h_align, int v_align,
                                 int *xyarray );

Beschreibung   Die Funktion liest ein Bit-Image-File mit dem Pfadnamen
               filename und gibt den Bildinhalt auf dem Drucker \#handle\#
               aus. Wichtig ist, da die Funktion nur bei residenten
               \#GDOS\# richtig arbeitet.

aspect         gibt an, wie der Abbildungsmastab interpretiert
               werden soll:
            0  ignorieren
            1  Pixel bercksichtigen (das Verh„ltnis Breite/H”he
               bleibt konstant)
            2  Seite bercksichtigen (rechnet eventuell verschiedene
               Seitengr”en ineinander um)
x_scale        Skalierung der X-Achse
y_scale        Skalierung der Y-Achse
               bei šbergabe von Koordinaten wird n”tigenfalls der
               Mastab ver„ndert.
            0  gebrochen, beachtet den Abbildungsmastab aspect
            1  ganzzahlig, nutzt das angegebene Rechteck in xyarray
               voll aus unter Ver„nderung des angegeben Mastabs
h_align        Horizontale Ausrichtung
            0  linksbndig
            1  zentriert
            2  rechtsbndig
v_align        Vertikale Ausrichtung
            0  obenbndig
            1  zentriert
            2  untenbndig
xyarray[0]     x-Koordinate der linken oberen Ecke des Ausgabefensters
xyarray[1]     y-Koordinate der linken oberen Ecke des Ausgabefensters
xyarray[2]     x-Koordinate der rechten unteren Ecke des
               Ausgabefensters
xyarray[3]     y-Koordinate der rechten unteren Ecke des
               Ausgabefensters
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#
\end

screen( capsensitive("vs_palette") )
Name           Select Palette - w„hlt eine Farbpalette aus.

Definition     void vs_palette( int \#handle\#, int palette );

Beschreibung   Die Funktion w„hlt eine Farbpalette fr das Ger„t
               \#handle\# aus.

palette     0  Rot, Grn, Braun
            1  Cyan, Magenta, Wei
Gruppe         \#Escapefunktionen\#
\end

screen( capsensitive("vqp_films") )
Name           Inquire Palette Film Types - ermittelt Informationen
               ber einen Film.

Definition     void vqp_films( int \#handle\#, char *film_names );

Beschreibung   Die Funktion ben”tigt zum einen \#GDOS\# und zum anderen
               einen Polaroidbildrecorder. Fr dieses Ausgabeger„t
               ermittelt die Funktion dann die Namen, den Hersteller
               und die Empfindlichkeit in ASA der zur Verfgung
               stehenden Filme.

film_names     Zeiger auf einen 126 Byte groen Zeichenbuffer in den 5
               Eintr„ge zu je 25 Zeichen gemacht werden.

Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#
\end

screen( capsensitive("vqp_state") )
Name           Inquire Palette Driver State - ermittelt den
               Ger„tezustand des Polaroidbildrecorders.

Definition     void vqp_state( int \#handle\#, int *port, char *film_name,
                               int *lightness, int *interlace,
                               int *planes, int *indexes );

Beschreibung   Die Funktion ben”tigt zum einen \#GDOS\# und zum
               anderen einen Polaroidbildrecorder und ermittelt dann
               fr dieses Ausgabeger„t den Ger„tezustand.

port           Nummer des Ports (0  erster Port)
film_name      Nummer des Filmnamen (0 bis 4)
lightness      Helligkeit (-3 bis 3, wobei eine Stufe einer Drittel
               Blende entspricht)
interlace      Bild wird mit (1) oder ohne (0) Zeilensprung abgetastet
planes         Farbanzahl =  2^planes, wobei planes zwischen
               1 und 4 liegt
indexes        Festlegung der Farben der Farbpalette. Es wird ein
               Speicherplatz von 16 Bytes ben”tigt. Jede Farbe wird
               durch eine Zahl (fr die Zeilen der Farbmatrix) und
               einen Buchstaben von A bis H (fr die Spalten der
               Farbmatrix) gekennzeichnet.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#  \#vsp_state\#  \#vsp_save\#  \#vsp_message\#  \#vqp_films\#
\end

screen( capsensitive("vsp_state") )
Name           Set Palette Driver State - setzt den Ausgabezustand
               des Polaroidrecorders.

Definition     void vsp_state( int \#handle\#, int port, int film_num,
                               int lightness, int interlace,
                               int planes, int *indexes );

Beschreibung   Die Funktion ben”tigt zum einen \#GDOS\# und zum anderen
               einen Polaroidbildrecorder und w„hlt dann fr dieses
               Ger„t einen Ausgabezustand.

port           Nummer des Ports (0  erster Port)
film_name      Nummer des Filmnamen (0 bis 4)
lightness      Helligkeit (-3 bis 3, wobei eine Stufe einer Drittel
               Blende entspricht)
interlace      Bild wird mit (1) oder ohne (0) Zeilensprung abgetastet
planes         Farbanzahl =  2^planes, wobei planes zwischen
               1 und 4 liegt
indexes        Festlegung der Farben der Farbpalette. Es wird ein
               Speicherplatz von 16 Bytes ben”tigt. Jede Farbe wird
               durch eine Zahl (fr die Zeilen der Farbmatrix) und
               einen Buchstaben von A bis H (fr die Spalten der
               Farbmatrix) gekennzeichnet.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#         \#vsc_expose\#   \#vqp_state\#  \#vsp_save\#
               \#vsp_message\#  \#vqp_films\#
\end

screen( capsensitive("vsp_save") )
Name           Save Palette Driver State - speichert den Ger„testatus
               des Polaroidbildrecorders.

Definition     void vsp_save( int \#handle\# );

Beschreibung   Die Funktion ben”tigt zum einen \#GDOS\# und zum anderen
               einen Polaroidbildrecorder und speichert fr dieses
               Ger„t den Ger„testatus auf Diskette.

Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#       \#vqp_state\#   \#vsp_state\#   \#vsp_message\#
               \#vqp_films\#  \#vsc_expose\#
\end

screen( capsensitive("vsc_expose") )
Name           Disable or Enable Film Exposure for Frame Preview -
               Ein-/Ausschalten des Previews einer Kamera.

Definition     void vsc_expose( int \#handle\#, int state );

Beschreibung   Die Funktion ben”tigt zum einen \#GDOS\# und zum anderen
               einen Polaroidbildrecorder und schaltet den Preview-
               Modus, d.h. die Belichtung, einer Kamera ein bzw. aus,
               sofern diese das gestattet.

Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#         \#vsp_save\#   \#vqp_state\#   \#vsp_state\#
               \#vsp_message\#  \#vqp_films\#
\end

screen( capsensitive("vsp_message") )
Name           Suppress Palette Message - unterdrckt Fehlermeldungen
               des Polaroidbildrecorders.

Definition     void vsp_message( int \#handle\# );

Beschreibung   Die Funktion ben”tigt zum einen \#GDOS\# und zum anderen
               einen Polaroidbildrecorder und verhindert dann, da
               der Recorder Fehlermelungen abschickt.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#   \#vqp_error\#
\end

screen( capsensitive("vqp_error") )
Name           Palette Error Inquire - liefert die Nummer eines
               augetretenen Fehlers.

Definition     int vqp_error( int \#handle\# );

Beschreibung   Die Funktion ben”tigt zum einen \#GDOS\# und zum anderen
               einen Polaroidbildrecorder und liefert als
               Funktionsergebnis die Nummer des aufgetretenen Fehlers.
Ergebnis       Die Funktion liefert:
           0   kein Fehler
           1   Verschlu offen
           2   kein Port ausgew„hlt
           3   Palette am gew„hlten Port nicht verfgbar
           4   Verbindung unterbrochen
           5   Operationssystem erlaubt keine Speicherzuteilung
           6   Pufferspeicher reicht nicht aus
           7   Speicher nicht frei
           8   Ger„tetreiber-File fehlt
           9   Ger„tetreiber-File hat falsches Format
           10  Film zu Ende
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#
\end

screen( capsensitive("v_meta_extents") )
Name           Update Metafile Extents - aktualisiert das Metafile.

Definition     void v_meta_extents( int \#handle\#, int min_x, int min_y,
                                    int max_x, int max_y );

Beschreibung   Die Funktion setzt die minimalen bzw. maximalen Werte
               fr eine, Zeichnung, die im Metafile gespeichert wird,
               auf die Werte min_x, min_y und max_x, max_y. Wichtig
               ist, da die Funktion nur zusammen mit \#GDOS\# richtig
               arbeitet.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#   \#vm_filename\#   \#v_write_meta\#
\end

screen( capsensitive("v_write_meta") )
Name           Write Metafile Item - schreibt ein Objekt ein ein
               Metafile.

Definition     void v_write_meta( int \#handle\#, int num_intin,
                                  int num_ptsin, int *intin,
                                  int *ptsin );

Beschreibung   Die Funktion schreibt ein benutzterdefiniertes Objekt
               in ein Metafile. Dabei erh„lt jedes zu speichernde
               Objekt einen vom Benutzter festgelegten Opcode, der
               gr”er oder gleich 101 sein mu. Wichtig ist, da die
               Funktion nur mit residentem \#GDOS\# korrekt arbeitet.
num_intin      Anzahl der Eintr„ge im intin Feld
num_ptsin      Anzahl der Eintr„ge im ptsin Feld
intin[0]       benutzterdefinierter Opcode
intin[1]       benutzterdefinierte Information
  :
intin[num_intin - 1]
ptsin[0]       benutzterdefinierte Information
  :
ptsin[num_ptsin - 1]
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#   \#v_meta_extents\#
\end

screen( capsensitive("vm_coords") )
Name           VDI meta file coordinates - Eigenes Koordinatensystem
               fr Metafiles.

Definition     void vm_coords( int \#handle\#, int llx, int lly,
                               int urx, int ury );

Prototyp in    vdi.h

Beschreibung   Die VDI-Routine vm_coords legt ein neues Koordinaten-
               sytem fr die Seite im Metafile fest, wobei llx
               und lly die linke untere Ecke und die Parameter
               urx und ury die rechte obere Ecke beschreiben.
Ergebnis       Die Funktion liefert kein Ergebnis
Querverweis    \#v_write_meta\#
\end

screen( capsensitive("vm_filename") )
Name           Change GEM VDI File Name - „ndert den Namen eines
               Metafiles.

Definition     void vm_filename( int \#handle\#, const char *filename );

Prototyp in    vdi.h

Beschreibung   Die Funktion benennt ein mit \#v_opnwk\# ge”ffnetes
               Metafile, das standardm„ig den Namen GEMFILE.GEM
               erh„lt, in den durch filename spezifizierten Namen um.
               Wichtig ist, da fr das korrekte Arbeiten der Funktion
               das \#GDOS\# resident sein mu.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#   \#v_opnwk\#   \#v_meta_extents\#   \#v_write_meta\#
\end

screen( capsensitive("vm_pagesize") )
Name           VDI page size - legt die physikalische Seitengr”áe
               fr Metafiles fest.

Definition     void vm_pagesize( int \#handle\#, int pgwidth,
                                 int pgheight );

Prototyp in    vdi.h

Beschreibung   Die VDI-Routine vm_pagesize legt die physikalische
               Seitengr”e fr ein Metafile fest, wobei pgwidth
               die Breite und pgheight die H”he der Seite fest-
               legen. Beide Parameter werden in Zehntelmillimeter
               angegeben.
Ergebnis       Die Funktion liefert kein Ergebnis
Querverweis    \#v_write_meta\#, \#Escapefunktionen\#
\end

screen( capsensitive("v_offset") )
Name           Set Line Offset - setzt den linken Rand.

Definition     void v_offset( int \#handle\#, int offset);

Beschreibung   Die Funktion setzt fr das Ger„t mit der Kennung
               \#handle\# den oberen Rand auf den Wert offset
               (in Rasterzeilen).
Gruppe         \#Escapefunktionen\#
\end

screen( capsensitive("v_fontinit") )
Name           Init System Font - initialisiert einen Zeichensatz.

Definition     void v_fontinit( int \#handle\#, int fh_high, int fh_low);

Beschreibung   Die Funktion installiert den Zeichensatz, dessen
               Adresse durch fh_high und fh_low decodiert wird, als
               neuen Systemzeichensatz. Dabei ist zu beachten, da der
               Zeichensatz eine feste Zeichenbreite von 8 Pixeln
               aufweist.
Gruppe         \#Escapefunktionen\#
\end

screen( capsensitive("vq_gdos") )
Name           Inquire GDOS - ermittelt ob GDOS installiert ist.

Definition     int vq_gdos( void );

Beschreibung   Die Funktion ermittelt, ob GDOS installiert ist.
Ergebnis       Die Funktion liefert den Funktionswert Null, falls
               das \#GDOS\# nicht resident ist, sonst liefert die
               Funktionen einen von Null verschiedenen Rckgabewert.

Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#    \#vq_vgdos\#
\end

screen( capsensitive("vq_vgdos") )
Name           Inquire GDOS version - ermittelt welche GDOS Version
               installiert ist.

Definition     long  vq_vgdos( void );

Beschreibung   Die Funktion ermittelt, welche GDOS Version installiert
               ist.
Ergebnis       Die liefert die Versionsnummer der installierten GDOS
               Version oder -2 zurck. Fr \#FSMGDOS\# ist dies die Nummer
               0x5F46534D und fr FONTGDOS 0x5F464E54. Fr andere GDOS
               Treiber ergibt sich eine anderer Wert ungleich -2.

Gruppe         \#Escapefunktionen\#
Querverweis    \#FSMGDOS\#   \#GDOS\#    \#vq_gdos\#
\end

screen( capsensitive("v_escape2000") )
Name           Escape 2000 - Spezialfunktion fr ATARI-Page-Printer.

Definition     void v_escape2000( int handle, int times );

Beschreibung   Diese Spezialfunktion ist fr den ATARI-Page-Printer.
               Dieser druckt times Kopien der laufenden Seite
               aus.
Ergebnis       Die Funktion hat kein Ergebnis.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#
\end

screen( capsensitive("vt_resolution") )
Name           set tablet axis resolution in lines/inch - Aufl”sung
               des Grafiktabletts einstellen in Zeilen pro Inch.

Definition     void vt_resolution( int handle, int xres, int yres, 
                                   int *xset, int *yset );

Beschreibung   Die Funktion setzt die horizontale und vertikale
               Aufl”sung xres und yres des Grafiktablets.
               xset und yset enthalten nach dem Aufruf die alten
               Werte.
Ergebnis       Die Funktion hat kein Ergebnis.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#     \#vq_tabstatus\#  \#vt_alignment\#
               \#vt_axis\#  \#vt_origin\#     \#vq_tdimensions\#
\end

screen( capsensitive("vt_axis") )
Name           set tablet axis resolution in lines - Aufl”sung
               des Grafiktabletts einstellen in Zeilen.

Definition     void    vt_axis( int handle, int xres, int yres, 
                                int *xset, int *yset );

Beschreibung   Die Funktion setzt die horizontale und vertikale
               Aufl”sung xres und yres des Grafiktablets.
               xset und yset enthalten nach dem Aufruf die alten
               Werte.
Ergebnis       Die Funktion hat kein Ergebnis.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#           \#vq_tabstatus\#  \#vt_alignment\#
               \#vt_resolution\#  \#vt_origin\#     \#vq_tdimensions\#
\end

screen( capsensitive("vt_origin") )
Name           set tablet x and y origin - Koordinatenursprung
               fr Grafiktablett setzen.

Definition     void vt_origin( int handle, int xorigin,
                               int yorigin );

Beschreibung   Die Funktion setzt den Koordinatenursprung
               xorigin und yorigin des Grafiktabletts.
Ergebnis       Die Funktion hat kein Ergebnis.
Querverweis    \#GDOS\#           \#vq_tabstatus\#  \#vt_alignment\#
               \#vt_resolution\#  \#vt_axis\#       \#vq_tdimensions\#
\end

screen( capsensitive("vq_tdimensions") )
Name           return tablet x and y dimensions - Ausmae des
               Grafiktabletts in 1/10-Zoll.

Definition     void vq_tdimensions( int handle, int *xdimension,
                                    int *ydimension );

Beschreibung   Die Funktion liefert die Ausmae des Grafik-
               tabletts in xdimension und ydimension in 1/10-Zoll.
Ergebnis       Die Funktion hat kein Ergebnis.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#           \#vq_tabstatus\#  \#vt_alignment\#
               \#vt_resolution\#  \#vt_axis\#       \#vt_origin\#
\end

screen( capsensitive("vt_alignment") )
Name           set tablet alignment - Koordinatensystem des Grafik-
               tabletts ausrichten.

Definition     void vt_alignment( int handle, int dx, int dy );

Beschreibung   Die Funktion dient der Ausrichtung des Koordinaten-
               systems innerhalb eines Ausschnitts des Grafik-
               tabletts.
Ergebnis       Die Funktion hat kein Ergebnis.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#           \#vq_tabstatus\#  \#vq_tdimensions\#
               \#vt_resolution\#  \#vt_axis\#       \#vt_origin\#
\end

screen( capsensitive("vsp_film") )
Name           set camera film type and exposure time - Filmtyp
               und Belichtungszeit festlegen.

Definition     void vsp_film( int handle, int index,
                              int lightness );

Beschreibung   Die Funktion legt Filmtyp und Belichtungszeit fest.
Ergebnis       Die Funktion hat kein Ergebnis.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#
\end

screen( capsensitive("v_sound") )
Name           generate specified tone - Ton generieren.

Definition     void v_sound( int handle, int frequency,
                              int duration );

Beschreibung   v_sound erzeugt einen Ton der H”he frequency Hertz
               und der Dauer duration in Timer-Ticks.
Ergebnis       Die Funktion hat kein Ergebnis.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#    \#vs_mute\#
\end

screen( capsensitive("vs_mute") )
Name           set/clear tone muting flag - Ein-/Ausschalten der
               Tonerzeugung.

Definition     int  vs_mute( int handle, int action );

Beschreibung   vs_mute schaltet die Tonerzeugung ein (action == 1)
               bzw. aus (action == 0) und liefert deren Status
               zurck. Fr action == -1 wird nur der Status abgefragt.
Ergebnis       Die Funktion liefert den Status der Tonerzeugung.
Gruppe         \#Escapefunktionen\#
Querverweis    \#GDOS\#    \#v_sound\#
\end

screen( capsensitive("vqt_advance") )
Name           Inquire FSM text advance placement vector - Position
               fr n„chstes FSM-Zeichen ermitteln.

Definition     void  vqt_advance( int handle, int ch, int *advx,
                                   int *advy, int *remx, int *remy );

Beschreibung   vqt_advance liefert den x- und y-Offset in advx und
               advy, der ben”tigt wird, um das n„chste Zeichen ch
               eines Strings an die richtige Position zu schreiben.
               Zus„tzlich liefern remx und remy die Restwerte fr
               modulo 16384 der x- und y-Offsets, so da die Ausmae
               der Zeichenbox mit \#v_ftext\# und \#vqt_f_extent\# besser
               berechnet werden k”nnen.
               Diese Funktion wird gebraucht, wenn der Winkel fr
               Textrotation ein anderer als 0, 90, 180 oder 270 Grad
               ist. 
Ergebnis       Diese Funktion hat kein Ergebnis.

Gruppe         \#Auskunftsfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#    \#vst_rotation\#
\end

screen( capsensitive("vst_arbpt") )
Name           Set character cell height by arbitrary points - Setzen
               der Zeichenzellenh”he in Punkten.

Definition     int vst_arbpt( int handle, int point, int *chwd,
                               int *chht, int *cellwd, int *cellht );

Beschreibung   vst_arbpt setzt die aktuelle Zeichenh”he in Printer-
               Punkten. Im Gegensatz zu vst_point erlaubt vst_arbpt
               die Skalierung in jeder Punktgr”e, unabh„ngig davon,
               welche Angaben in EXTEND.SYS stehen. Diese Funktion
               arbeitet ausschlielich mit FSM-Outline-Fonts.

Ergebnis       Als Resultat erh„lt man die gesetzte Zeichenh”he
               in Punkten.

Gruppe         \#Attributfunktionen\#

Querverweis    \#GDOS\#        \#FSMGDOS\#
               \#vst_point\#   \#vst_setsize\#
\end

screen( capsensitive("vqt_devinfo") )
Name           Inquire device status info - Status des Ausgabeger„ts
               erfragen.

Definition     void  vqt_devinfo( int handle, int devnum,
                                   int *devexits, char *devstr );

Beschreibung   vqt_devinfo prft, ob der ein Treiber fr das durch
               devnum spezifizierte Ger„t durch \#GDOS\# installiert
               wurde. In diesem Fall erh„lt devexits den Wert 1,
               sonst Null. In den ausreichend groen String devstr
               wird im Erfolgsfall der Name des Treibers kopiert.

Ergebnis       Diese Funktion hat kein direktes Ergebnis.

Gruppe         \#Auskunftsfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#
\end

screen( capsensitive("v_flushcache") )
Name           Flush FSM cache - FSM Cache l”schen.

Definition     int  v_flushcache( int handle );

Beschreibung   v_flushcache l”scht den Inhalt des FSM-Cache, der
               Bitmaps von FSM-Zeichen enth„lt.

Ergebnis       Falls ein Fehler auftrat, erh„lt man -1 als Resultat,
               sonst 0.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#GDOS\#         \#FSMGDOS\#
               \#v_loadcache\#  \#v_savecache\#   \#vqt_cachesize\#
\end

screen( capsensitive("vqt_cachesize") )
Name           Get FSM chache size - Ermitteln der Gr”e des FSM
               Caches.

Definition    void  vqt_cachesize( int handle, int which_cache,
                                    long *size );

Beschreibung   Als Resultat liefert vqt_cachesize im Parameter size
               die L„nge des gr”ten verfgbaren Blocks in den
               FSM-Caches. Man kann somit die maximale Gr”e der
               Zeichen absch„tzen, die FSMGDOS ausgeben kann.
               Hat which_cache den Wert 0, so erh„lt man die Gr”e
               des Bitmap-Cache, fr 1 die des Datenstruktur-Cache.

Ergebnis       Diese Funktion hat kein direktes Ergebnis.

Gruppe         \#Auskunftsfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#
               \#v_loadcache\#  \#v_savecache\#   \#v_flushcache\#
\end

screen( capsensitive("vqt_get_tables") )
Name           Get FSM gascii tables - Adresse der Zeichentrans-
               formationstabellen erfragen.

Definition     void  vqt_get_tables( int handle, int **gascii,
                                      int **style );

Beschreibung   Wenn Zeichen mittels \#v_gtext\# ausgegeben werden,
               werden sie in ein Wortformat bersetzt, das durch
               den Fontgenerator weiterverarbeitet werden kann.
               Die šbersetzungen sind in der gascii-Tabelle
               vorhanden. Sie enth„lt 223 Eintr„ge, beginnend mit
               dem ASCII-Zeichen 32. Die zweite Tabelle, style,
               gibt Auskunft darber aus welcher Font-Datei das
               Zeichen erzeugt wurde. Es gibt drei M”glichkeiten:

                        0      Standardzeichensatz
                        1      Symbolzeichensatz
                        2      Hebr„ischer Zeichensatz

               Diese Informationen sind ntzlich, da FSM-Fonts
               auch Zeichen enthalten, die im normalen Atari-
               Zeichensatz nicht enthalten sind.

Ergebnis       Diese Funktion hat kein direktes Ergebnis.

Gruppe         \#Auskunftsfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#   \#v_gtext\#
\end

screen( capsensitive("v_loadcache") )
Name           Load FSM cache - FSM-Cache laden.

Definition     int  v_loadcache( int handle, char *filename,
                                  int mode );

Beschreibung   v_loadcache l„dt den Inhalt des FSM-Cache aus
               einer Datei mit dem Namen filename. mode gibt an,
               ob der alte Inhalt berschrieben werden soll (1)
               oder die geladenen Information an den alten Inhalt
               angeh„ngt werden soll (0).

Ergebnis       Falls ein Fehler auftrat, erh„lt man -1 als Resultat,
               sonst 0.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#
               \#v_flushcache\#  \#v_savecache\#   \#vqt_cachesize\#
\end

screen( capsensitive("v_savecache") )
Name           Save FSM cache to disk - FSM-Cache speichern.

Definition     int  v_savecache( int handle, char *filename );

Beschreibung   v_savecache speichert den Inhalt des Cache unter dem
               Namen filename im aktuellen Verzeichnis.

Ergebnis       Falls ein Fehler auftrat, erh„lt man -1 als Resultat,
               sonst 0.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#
               \#v_flushcache\#  \#v_loadcache\#   \#vqt_cachesize\#
\end

screen( capsensitive("vst_setsize") )
Name           Set character cell width by arbitrary points - Setzen
               der Zeichenzellenbreiten in Punkten.

Definition     int  vst_setsize( int handle, int point,
                                  int *chwd, int *chht,
                                  int *cellwd, int *cellht );

Beschreibung   vst_setsize setzt die Zeichenbreite in Printer-
               Punkten. Zu beachten ist, da der n„chste Aufruf
               von vst_point, vst_arbpt oder vst_height die
               durch vst_setsize gesetzte Breite aufhebt und
               die vom jeweiligen Zeichen verlangte Breite
               einstellt. Diese Funktion arbeitet ausschlielich
               mit FSM-Outline-Fonts.

Ergebnis       Als Resultat erh„lt man die gesetzte Zeichenzellen-
               breite in Punkten.

Gruppe         \#Attributfunktionen\#

Querverweis    \#GDOS\#        \#FSMGDOS\#
               \#vst_point\#   \#vst_height\#   \#vst_arbpt\#
\end

screen( capsensitive("vst_skew") )
Name           Set FSM skew - Setzen des Neigungsgrades fr Kursivschrift.

Definition     int  vst_skew( int handle, int skew );

Beschreibung   vst_skew setzt den Neigungsgrad fr Kursivschrift.
               Der neue Neigungsgrad skew wird in zehntel Grad
               angegeben und darf zwischen -900 und +900 variieren.
               Negative Werte fhren zu einer Linksneigung, w„hrend
               positive Werte eine Rechtsneigung verursachen. Diese
               Funktion arbeitet ausschlielich mit FSM-Outline-
               Fonts.

Ergebnis       Als Resultat erh„lt man den gesetzten Neigungsgrad.

Gruppe         \#Attributfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#   \#vst_effects\#
\end

screen( capsensitive("v_killoutline") )
Name           Kill FSM outline - Speicher zur Outline-Generierung
               freigeben.

Definition     void  v_killoutline( int handle,
                                     \#fsm_component_t\# *component );

Beschreibung   component ist die Adresse einer von \#v_getoutline\#
               generierten Outline. Der Speicher, den diese belegt,
               wird mittels v_killoutline wieder freigegeben.
               Diese Funktion sollte stets aufgerufen werden, sobald
               eine Outline nicht mehr ben”tigt wird. Andernfalls
               l„uft man Gefahr, keinen freien Speicher mehr zu
               haben.

Ergebnis       Diese Funktion hat kein Ergebnis.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#   \#v_getoutline\#
\end

screen( capsensitive("v_getoutline") )
Name           Get FSM outline - Outline eines Zeichens berechnen.

Definition     void  v_getoutline( int handle, int ch,
                                    \#fsm_component_t\# **component );

Beschreibung   v_getoutline generiert zum Zeichen ch geh”rige Outline.
               Die Adresse des Buffers, in dem die Outline zu finden
               ist, wird unter der Adresse component abgelegt.

Ergebnis       Diese Funktion hat kein Ergebnis.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#   \#v_killoutline\#
\end

screen( capsensitive("vst_scratch") )
Name           Set scratch buffer allocation mode - Bestimmen der
               Gr”e des Scratch-Buffers.

Definition     void  vst_scratch( int handle, int mode );

Beschreibung   vst_scratch setzt den Modus zur Berechnung der
               Gr”e des Scratch-Buffers. Der Scratch-Buffer
               dient der Generierung von Texteffekten. Da \#FSM\#-
               Zeichens„tze frei skallierbar sind, kann dem
               Scratch-Buffer keine eindeutige Gr”e zugeordnet
               werden. Deshalb kann man einen Modus mode zur
               Gr”enbestimmung setzen:

                      0      Bercksichtigung auch von FSM-
                             Zeichens„tzen (Standardeinstellung).
                      1      Gr”e richtet sich nach den
                             Bitmap-Zeichens„tzen. Texteffekte
                             fr FSM-Zeichens„tze sollten nicht
                             genutzt werden.
                      2      Es wird kein Scratch-Buffer angelegt
                             und es k”nnen somit auch keine
                             Texteffekte ausgefhrt werden.

Ergebnis       Diese Funktion hat kein Ergebnis.

Gruppe         \#Attributfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#   \#vst_effects\#
\end

screen( capsensitive("vst_error") )
Name           Set FSM error mode - Setzen der FSMGDOS
               Fehlerbehandlung.

Definition     void  vst_error( int handle, int mode, int *errorvar );

Beschreibung   Wenn mode den Wert 1 enth„lt, werden FSMGDOS Fehler
               direkt auf dem Bildschirm ausgegeben. Dies ist auch
               die Standardeinstellung. Falls Mode gleich Null ist,
               wird im Fehlerfall ein Fehlercode in die Variable 
               mit der Adresse errorvar geschrieben. Diese sollte
               mit Null initiallisiert werden. Vor der Benutzung
               der folgenden Funktionen unter FSMGDOS sollte
               die Variable abgefragt werden:

                   \#v_gtext\#            \#v_ftext\#
                   \#v_justified\#        \#vst_point\#
                   \#vst_height\#         \#vst_font\#
                   \#vst_arbpt\#          \#vqt_advance\#
                   \#vst_setsize\#        \#vqt_fontinfo\#
                   \#vqt_name\#           \#vqt_width\#
                   \#vqt_extent\#         \#vqt_f_extent\#
                   \#v_opnwk\#            \#v_opnvwk\#
                   \#vst_load_fonts\#     \#vst_unload_fonts\#

               Folgende Fehlercodes sind definiert:

                   0      Kein Fehler.
                   1      Zeichen nicht im Zeichensatz vorhanden.
                   8      Fehler beim Lesen der Zeichensatzdatei.
                   9      Fehler beim ™ffnen der Zeichensatzdatei.
                   10     Falsches Dateiformat.
                   11     Kein freier Speicher mehr oder Cache voll.
                   -1     Unbestimmter Fehler.

Ergebnis       Diese Funktion hat kein Ergebnis.

Gruppe         \#Attributfunktionen\#

Querverweis    \#GDOS\#    \#FSMGDOS\#
\end

screen( capsensitive("v_bez_on") )
Name           Enable Bezier capabilities - Bezier-Spline-Erzeugung
               an.

Definition     int  v_bez_on( int handle );

Beschreibung   Dieser Funktion aktiviert die Bezier-Spline-
               Erzeugung des GDOS. Obwohl mittels handle eine
               spezielle Arbeitsstation spezifiziert wird,
               gilt die Aktivierung fr alle Arbeitsstationen.

Ergebnis       Als Ergebnis erh„lt man die maximale Bezier-Tiefe,
               ein Ma fr die Geschmeidigkeit des erzeugten
               Splines. Der Wert aus dem Intervall von 0 bis 7
               ist ein Exponent von 2 und gibt die Anzahl der
               Segmente an, aus denen ein Spline zusammengesetzt
               ist.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#v_bez_off\#     \#v_bez\#      \#v_bez_fill\#
               \#v_bez_qual\#   \#v_set_app_buff\#
               \#GDOS\#
\end

screen( capsensitive("v_bez_off") )
Name           Disable Bezier capabilities - Bezier-Spline-Erzeugung
               aus.

Definition     void  v_bez_off( int handle );

Beschreibung   Diese Funktion deaktiviert die Bezier-Spline-
               Erzeugung fr alle Arbeitsstationen. Speicher, der
               von GDOS zur Erzeugung der Splines angefordert
               wurde, wird freigegeben.

Ergebnis       Diese Funktion hat kein Ergebnis.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#v_bez_on\#     \#v_bez\#      \#v_bez_fill\#
               \#v_bez_qual\#   \#v_set_app_buff\#
               \#GDOS\#
\end

screen( capsensitive("v_set_app_buff") )
Name           Reserve Bezier workspace - Speicher fr Bezier-
               Spline-Erzeugung reservieren.

Definition     void  v_set_app_buff( int handle, int **address,
                                      int nparagraphs );

Beschreibung   Mit dieser Funktion kann man einen Speicher fr
               die Bezier-Spline-Erzeugung setzen. Die Adresse
               des Buffers wird ber address angegeben und die
               Gr”e in Paragraphen ( 16-Byte-Bl”cke ) ber
               nparagraphs. Werden Bezier-Funktionen aufgerufen,
               werden in diesem Buffer die Spline-Daten abgelegt.
               Andernfalls kann er auch vom Programm benutzt
               werden. Vor Programmende sollte man mit
               v_set_app_buff einen Null-Zeiger als Buffer
               mit Gr”e 0 setzen.
               Wird kein Buffer mittels v_set_app_buff gesetzt,
               legt GDOS einen eigenen Buffer (ca.8 KByte) an.

Ergebnis       Diese Funktion hat kein Ergebnis.

Gruppe         \#Kontrollfunktionen\#

Querverweis    \#v_bez_on\#     \#v_bez_off\#      \#v_bez\#
               \#v_bez_fill\#   \#v_bez_qual\#
               \#GDOS\#
\end

screen( capsensitive("v_bez") )
Name           Output Bezier - Bezier-Spline zeichnen.

Definition     void  v_bez( int handle, int count, int *xyarr,
                             char *bezarr, int *extent,
                             int *totpts, int *totmoves );

Beschreibung   v_bez zeichnet einen Bezier-Spline. count gibt
               die Anzahl der Knoten an.

Ergebnis       Diese Funktion hat kein direktes Ergebnis.
               In totpts wird die Anzahl der Punkte im
               resultierenden Polygon abgelegt, in totmoves
               die Anzahl der Zge.

Gruppe         \#Ausgabefunktionen\#

Querverweis    \#v_bez_on\#     \#v_bez_off\#      \#v_bez_fill\#
               \#v_bez_qual\#   \#v_set_app_buff\#
               \#GDOS\#
\end

screen( capsensitive("v_bez_fill") )
Name           Output filled Bezier - Bezier-Spline zeichnen
               und fllen.

Definition     void  v_bez_fill( int handle, int count,
                                  int *xyarr, char *bezarr,
                                  int *extent, int *totpts,
                                  int *totmoves );

Beschreibung   v_bez_fill zeichnet einen Bezier-Spline und
               fllt diesen anschlieend aus. count gibt die
               Anzahl der Knoten an.

Ergebnis       Diese Funktion hat kein direktes Ergebnis.
               In totpts wird die Anzahl der Punkte im
               resultierenden Polygon abgelegt, in totmoves
               die Anzahl der Zge.

Gruppe         \#Ausgabefunktionen\#

Querverweis    \#v_bez_on\#     \#v_bez_off\#      \#v_bez\#
               \#v_bez_qual\#   \#v_set_app_buff\#
               \#GDOS\#
\end

screen( capsensitive("v_bez_qual") )
Name           Set Bezier quality - Qualit„t der Bezier-Spline-
               Erzeugung setzen.

Definition     int  v_bez_qual( int handle, int prcnt,
                                   int *actual );

Beschreibung   Diese Funktion setzt einen neuen Geschwindigkeit/
               Qualit„ts-Faktor prcnt, angegeben in Prozent.

Ergebnis       Man erh„lt den bisherigen Geschwindigkeit/
               Qualit„ts-Faktor. Dieser Wert wird auch unter
               der Adresse actual abgelegt.

Gruppe         \#Attributfunktionen\#

Querverweis    \#v_bez_on\#     \#v_bez_off\#      \#v_bez\#
               \#v_bez_fill\#   \#v_set_app_buff\#
               \#GDOS\#
\end

screen( "Gleitkomma-Befehle" )
Gleitkomma-Befehle...
----------------------------------------------------------------------

... sind in der PCFLTLIB.LIB- bzw. \#PC881LIB.LIB\#-Bibliothek zusammen-
gefat. Will man diese Bibliotheken dazulinken, mssen sie in der
\link("%%GLOBAL%%")Projektdatei\# vor PCSTDLIB.LIB stehen, da z.B. \#printf\# in beiden
Bibliotheken enthalten ist, aber nur PCFLTLIB.LIB bzw. PC881LIB.LIB
auch Gleitkommazahlen ausgegeben kann.

\#printf\#   <stdio.h> -+ Formatierte Ausgabe auf Standardausgabeger„t
                    | bei Fliekommazahlen
\#fprintf\#  <stdio.h>  |
\#sprintf\#  <stdio.h>  |
\#vfprintf\# <stdio.h>  |
\#vprintf\#  <stdio.h>  |
\#vsprintf\# <stdio.h> -+
\#scanf\#    <stdio.h> -+ Formatierte Eingabe ber Standardeingabeger„t
                    | bei Fliekommazahlen
\#sscanf\#   <stdio.h>  |
\#fscanf\#   <stdio.h>  |
\#vfscanf\#  <stdio.h>  |
\#vscanf\#   <stdio.h>  |
\#vsscanf\#  <stdio.h> -+
\#ecvt\#     <math.h>  Konvertiert eine Fliekommazahl in einen String
\#fcvt\#     <math.h>  Konvertiert eine Fliekommazahl in einen String
\#gcvt\#     <math.h>  Konvertiert eine Fliekommazahl in einen String
\#atof\#     <math.h>  Umwandlung von ASCII-String in Fliekommazahl
\#xdcnv\#    <math.h>  Fliekommaformat konvertieren
\#dxcnv\#    <math.h>  Fliekommaformat konvertieren
\#fpumode\#  <math.h>  Fliekomma-Koprozessorstatus ermitteln/setzen

Querverweis   \#Libraries\#   \#Mathematische Routinen\#
\end

screen( "Pure-C-Spezialfunktionen" )
Pure-C-Spezialfunktionen
----------------------------------------------------------------------

\#chdir\#      <ext.h> Wechselt das momentan gesetzte Directory.
\#coreleft\#   <ext.h> ermittelt den gr”ten freien Speicherblock.
\#delay\#      <ext.h> wartet die angegebene Anzahl von Millisekunden.
\#filelength\# <ext.h> L„nge einer Datei ermitteln.
\#findfirst\#  <ext.h> Ersten Eintrag im Verzeichnis ermitteln.
\#findnext\#   <ext.h> N„chsten Eintrag im Verzeichnis ermitteln.
\#fstat\#      <ext.h> Informationen zu einer Datei ermitteln.
\#ftimtotm\#   <ext.h> Konvertiert eine ftime-Struktur in eine
                   tm-Struktur.
\#getch\#      <ext.h> Tastendruck einlesen.
\#getche\#     <ext.h> Tastendruck einlesen und ausgeben.
\#getcurdir\#  <ext.h> momentanes Dir. eines Laufwerks ermitteln.
\#getcwd\#     <ext.h> momentanes Directory als vollst. Suchweg.
\#getdate\#    <ext.h> Datum ermitteln.
\#getdfree\#   <ext.h> freien Platz einer Diskette/Festplatte
                   ermitteln.
\#getdisk\#    <ext.h> liefert das momentan gesetzte Laufwerk.
\#getftime\#   <ext.h> nderungsdatum einer Datei ermitteln.
\#gettime\#    <ext.h> Uhrzeit ermitteln.
\#isatty\#     <ext.h> Ger„t abfragen.
\#kbhit\#      <ext.h> Tastatur abfragen.
\#putch\#      <ext.h> Zeichen direkt auf Bildschirm schreiben.
\#random\#     <ext.h> Zufallszahl ermitteln.
\#setdate\#    <ext.h> Datum setzen.
\#setdisk\#    <ext.h> Laufwerk setzen.
\#setftime\#   <ext.h> nderungsdatum einer Datei festlegen.
\#settime\#    <ext.h> Uhrzeit setzen.
\#sleep\#      <ext.h> Ausfhrung des Programms einen bestimmten
                   Zeitraum anhalten.
\#stat\#       <ext.h> Informationen zu einer Datei oder einem
                   Directory ermitteln.

Querverweis   \#Libraries\#
\end

screen( "Standard-Funktionen" )
Die Gruppen der Standard-Funktionen
----------------------------------------------------------------------

     \#Datum und Uhrzeit\#
     \#Directory-Routinen\#
     \link("Dynamische Verwaltung des Spe")Dynamische Verwaltung des Speichers\#
     \#I/O-Routinen\#
     \link("Behandlung variabler Argument")Behandlung variabler Argumente\#
     \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#
     \#Umwandlungsroutinen\#
     \#Mathematische Routinen\#
     \#Prozess-Routinen\#
     \#Sprnge\#
     \link("String- und Speichermanipulat")String- und Speichermanipulation\#
     \#Verschiedene Routinen\#

Querverweis    \#Libraries\#
\end

screen( "Datum und Uhrzeit" )
Datum und Uhrzeit
----------------------------------------------------------------------

Setzen, Lesen, Konvertieren von Datum/Uhrzeit des Systems.

\#asctime\#   <time.h> Datum/Uhrzeit in ASCII-String umwandeln.
\#clock\#     <time.h> Ermittelt die Systemzeit.
\#ctime\#     <time.h> Datum und Uhrzeit in String umwandeln.
\#difftime\#  <time.h> Zeitunterschied berechnen.
\#getdate\#   <ext.h>  Datum ermitteln.
\#gettime\#   <ext.h>  Uhrzeit ermitteln.
\#gmtime\#    <time.h> Greenwich Meantime berechnen.
\#localtime\# <time.h> Datum/Uhrzeit in Zeitstruktur tm umwandeln.
\#mktime\#    <time.h> Datum konvertieren in Sekundenformat.
\#setdate\#   <ext.h>  Datum setzen.
\#settime\#   <ext.h>  Uhrzeit setzen.
\#strftime\#  <time.h> Datum in frei w„hlbaren String umwandeln.
\#time\#      <time.h> Datum/Uhrzeit ermitteln.

Querverweis  \#Standard-Funktionen\#
\end

screen( "Directory-Routinen" )
Directory-Routinen
----------------------------------------------------------------------

Suche von Dateien in Verzeichnissen.

\#findfirst\# <ext.h> Ersten Eintrag im Verzeichnis ermitteln.
\#findnext\#  <ext.h> N„chsten Eintrag im Verzeichnis ermitteln.

Querverweis   \#Standard-Funktionen\#
\end

screen( "Dynamische Verwaltung des Spe" )
Dynamische Verwaltung des Speichers
----------------------------------------------------------------------

Routinen zur dynamischen Verwaltung des Speichers

\#calloc\#  <stdlib.h> Speicherbereich blockweise reservieren
\#free\#    <stdlib.h> Speicherbereich freigeben
\#malloc\#  <stdlib.h> Speicherbereich reservieren
\#realloc\# <stdlib.h> Speicherbereich anpassen

Querverweis   \#Standard-Funktionen\#
\end

screen( "I/O-Routinen" )
I/O-Routinen
----------------------------------------------------------------------

Ein-/Ausgaben sowohl auf Maschinenebene als auch durch Aufrufe des
Betriebssystems.

\#clearerr\# <stdio.h> Fehler- und EOF-Flags zurcksetzen.
\#close\#    <stdio.h> Datei schlieen.
\#creat\#    <stdio.h> Datei anlegen.
\#fclose\#   <stdio.h> Datei schlieen.
\#feof\#     <stdio.h> Dateiende (EOF) abfragen.
\#ferror\#   <stdio.h> Fehler ermitteln.
\#fflush\#   <stdio.h> Dateipuffer leeren.
\#fgetc\#    <stdio.h> Zeichen aus Datei lesen (Funktion).
\#fgetpos\#  <stdio.h> Datei-Position speichern
\#fgets\#    <stdio.h> Einlesen eines Strings aus Datei.
\#fileno\#   <stdio.h> Handle einer Datei erfragen.
\#fopen\#    <stdio.h> ™ffnen einer Datei.
\#fprintf\#  <stdio.h> Formatierte Ausgabe ber Datei.
\#fputc\#    <stdio.h> Ausgabe eines Zeichens auf Datei (Funktion).
\#fputs\#    <stdio.h> Ausgabe eines Strings auf Datei.
\#fread\#    <stdio.h> Einlesen eines Puffers von Datei.
\#freopen\#  <stdio.h> Datei-Handle mit neuem Dateinamen verknpfen.
\#fscanf\#   <stdio.h> Formatierte Eingabe ber Datei.
\#fseek\#    <stdio.h> Datei-Position „ndern.
\#fsetpos\#  <stdio.h> Gespeicherte Datei-Position anspringen.
\#ftell\#    <stdio.h> Datei-Position ermitteln.
\#fwrite\#   <stdio.h> Ausgabe eines Puffers auf Datei.
\#getc\#     <stdio.h> Zeichen von Datei einlesen (Makro).
\#getch\#    <ext.h>   Tastendruck einlesen.
\#getchar\#  <stdio.h> Eingabe eines Zeichens ber Standardeingabeger„t.
\#getftime\# <ext.h>   nderungsdatum einer Datei ermitteln.
\#gets\#     <stdio.h> String ber Standardeingabeger„t einlesen.
\#kbhit\#    <ext.h>   Tastatur abfragen.
\#lseek\#    <stdio.h> Datei-Position versetzen.
\#open\#     <stdio.h> Datei ”ffnen.
\#perror\#   <stdio.h> Fehlermeldung ausgeben.
\#printf\#   <stdio.h> Formatierte Ausgabe auf Standardausgabeger„t.
\#putc\#     <stdio.h> Ausgabe eines Zeichens in Datei (Makro).
\#putch\#    <ext.h>   Zeichen direkt auf Bildschirm schreiben.
\#putchar\#  <stdio.h> Zeichen auf Standardausgaberger„t schreiben.
\#puts\#     <stdio.h> String auf Standardausgabeger„t ausgeben.
\#read\#     <stdio.h> Direktes Einlesen eines Dateiabschnitts.
\#remove\#   <stdio.h> Datei l”schen.
\#rename\#   <stdio.h> Datei umbenennen.
\#rewind\#   <stdio.h> Datei-Position an den Anfang setzen.
\#scanf\#    <stdio.h> Formatierte Eingabe ber Standardeingabeger„t.
\#setbuf\#   <stdio.h> Puffergr”e einer Datei „ndern.
\#setftime\# <ext.h>   nderungsdatum einer Datei festlegen.
\#setvbuf\#  <stdio.h> Puffergr”e fein einstellen.
\#sprintf\#  <stdio.h> Formatierte Ausgabe in String.
\#sscanf\#   <stdio.h> Formatierte Eingabe von String.
\#strerror\# <string.h>liefert Strings mit Systemfehlermeldungen.
\#tmpnam\#   <stdio.h> Dateinamen fr tempor„re Datei erzeugen.
\#tmpfile\#  <stdio.h> Tempor„re Datei anlegen.
\#ungetc\#   <stdio.h> Zeichen an die Eingabedatei zurckgeben.
\#vfprintf\# <stdio.h> Formatierte Ausgabe mit variabler Argumentliste
                   auf Datei.
\#vfscanf\#  <stdio.h> Formatierte Eingabe aus einer Datei.
\#vprintf\#  <stdio.h> Formatierte Ausgabe mit variabler Argumentliste
                   auf das Standardausgabeger„t.
\#vscanf\#   <stdio.h> Formatierte Eingabe vom Standardeingabeger„t.
\#vsprintf\# <stdio.h> Formatierte Ausgabe mit variabler Argumentliste
                   in einen String.
\#vsscanf\#  <stdio.h> Formatierte Eingabe aus einer Datei.
\#write\#    <stdio.h> Direktes Schreiben eines Dateiabschnitts.
\#unlink\#   <stdio.h> Datei l”schen.

Querverweis   \#Standard-Funktionen\#
\end

screen( "Behandlung variabler Argument" )
Behandlung variabler Argumente
----------------------------------------------------------------------

Diese Routinen erm”glichen den Zugriff auf Parameter in Funktionen
mit variabler Parameter-Liste.

\#va_arg\#   <stdarg.h> Zugriff auf einen Parameter in einer varibalen
                    Argumentliste.
\#va_end\#   <stdarg.h> Ende der Behandlung variabler Argumente.
\#va_start\# <stdarg.h> Startpunkt der variablen Argumentliste festlegen.

Querverweis   \#Standard-Funktionen\#
\end

screen( "Zeichen-Klassifizierungs-Rout" )
Zeichen-Klassifizierungs-Routinen
----------------------------------------------------------------------

Prfung einzelner Zeichen auf ¯Buchstabe®, ¯Ziffer®, ¯Hex-Digit® usw.

\#isalnum\#  <ctype.h> Prfung auf alphanumerisches Zeichen.
\#isalpha\#  <ctype.h> Prfung auf Buchstaben.
\#isascii\#  <ctype.h> Prfung auf ASCII-Zeichen.
\#iscntrl\#  <ctype.h> Prfung auf Control-Zeichen.
\#isdigit\#  <ctype.h> Prfung auf dezimale Ziffer.
\#isgraph\#  <ctype.h> Prfung auf Grafik-Zeichen.
\#islower\#  <ctype.h> Prfung auf Kleinbuchstaben.
\#isodigit\# <ctype.h> Prfung auf oktale Ziffer.
\#isprint\#  <ctype.h> Prfung auf druckbares Zeichen.
\#ispunct\#  <ctype.h> Prfung auf Interpunktionszeichen
\#isspace\#  <ctype.h> Prfung auf Leerzeichen.
\#isupper\#  <ctype.h> Prfung auf Grobuchstabe.
\#isxdigit\# <ctype.h> Prfung auf hexadezimale Ziffer.

Querverweis   \#Standard-Funktionen\#
\end

screen( "Umwandlungsroutinen" )
Umwandlungsroutinen
----------------------------------------------------------------------

Interpretation von Stringinhalten als numerische Werte und umgekehrt,
sowie Umwandlung zwischen Gro- und Kleinbuchstaben.

\#atof\#    <stdlib.h> Umwandlung von ASCII-String in Fliekommazahl.
\#atoi\#    <stdlib.h> Umwandlung von ASCII-String in Integer-Zahl.
\#atol\#    <stdlib.h> Umwandlung von ASCII-String in Long-Integer-Zahl.
\#ecvt\#    <stdlib.h> Umwandlung von Fliekommazahl in einen ASCII-String.
\#ftoa\#    <stdlib.h> Umwandlung von Fliekommazahl in einen ASCII-String.
\#itoa\#    <stdlib.h> Umwandlung von Integer-Zahl in ASCII-String.
\#ltoa\#    <stdlib.h> Umwandlung von Long-Integer-Zahl in ASCII-String.
\#strtod\#  <stdlib.h> Umwandlung von String in double-Zahl.
\#strtol\#  <stdlib.h> Umwandlung von String in Long-Integer-Zahl.
\#strtoul\# <stdlib.h> Umwandlung von String in Long-Integer-Zahl
                   ohne Vorzeichen.
\#toascii\# <ctype.h>  Umwandlung von Zeichen in ASCII.
\#tolower\# <ctype.h>  Umwandlung von Buchstaben in Kleinbuchstaben.
\#toupper\# <ctype.h>  Umwandlung von Buchstaben in Grobuchstaben.
\#ultoa\#   <stdlib.h> Umwandlung von Long-Integer-Zahl ohne
                   Vorzeichen in ASCII-String.

Querverweis   \#Standard-Funktionen\#
\end

screen( "Mathematische Routinen" )
Mathematische Routinen
----------------------------------------------------------------------

Funktionen der h”heren Mathematik, Trigonometrie und Interpretation
von Stringinhalten als numerische Werte.

\#abs\#    <stdlib.h> Absolut-Wert einer Integer-Zahl berechnen.
\#acos\#   <math.h>   Arcus Cosinus einer Zahl berechnen.
\#acosh\#  <math.h>   Arcus Cosinus hyperbolicus einer Zahl berechnen.
\#asin\#   <math.h>   Arcus Sinus einer Zahl berechnen.
\#asinh\#  <math.h>   Arcus Sinus einer Zahl berechnen.
\#atan\#   <math.h>   Arcus Tangens einer Zahl berechnen.
\#atanh\#  <math.h>   Arcus Tangens hyperbolicus einer Zahl berechnen.
\#atan2\#  <math.h>   Arcus Tangens eines Quotientens berechnen.
\#ceil\#   <math.h>   Auf n„chst gr”ere ganze Zahl runden.
\#cos\#    <math.h>   Cosinus einer Zahl berechnen.
\#cosh\#   <math.h>   Cosinus hyperbolicus einer Zahl berechnen.
\#div\#    <stdlib.h> Quotient und Rest einer Integer-Division berechnen.
\#exp\#    <math.h>   Exponentialfunktion einer Zahl berechnen.
\#fabs\#   <math.h>   Absolut-Wert einer Fliekomma-Zahl berechnen.
\#floor\#  <math.h>   Auf n„chst kleinere ganze Zahl runden.
\#fmod\#   <math.h>   Quotient und Rest einer Fliekomma-Division
                  berechnen.
\#frexp\#  <math.h>   Fliekommazahl in Mantisse und bin„ren
                  Exponenten aufteilen.
\#labs\#   <stdlib.h> Absolut-Wert einer Long-Integer-Zahl berechnen.
\#ldexp\#  <math.h>   Zahl mit 2er-Exponenten multiplizieren.
\#ldiv\#   <stdlib.h> Quotient und Rest einer Long-Integer-Division
                  berechnen.
\#log\#    <math.h>   Natrlichen Logarithmus einer Zahl berechnen.
\#log10\#  <math.h>   Dekadischen Logarithmus einer Zahl berechnen.
\#modf\#   <math.h>   Fliekommazahl in Mantisse und Exponenten aufteilen.
\#pow\#    <math.h>   Potenz berechnen.
\#round\#  <math.h>   Runden von Fliekommazahlen
\#sin\#    <math.h>   Sinus einer Zahl berechnen.
\#sincos\# <math.h>   Sinus und Cosinus gleichzeitig.
\#sinh\#   <math.h>   Sinus hyperbolicus einer Zahl berechnen.
\#sqrt\#   <math.h>   Quadratwurzel einer Zahl berechnen.
\#tan\#    <math.h>   Tangens einer Zahl berechnen.
\#tanh\#   <math.h>   Tangens hyperbolicus einer Zahl berechnen.
\#trunc\#  <math.h>   Nachkommastellen "abschneiden"

Querverweis   \#Standard-Funktionen\#  \#__NFPUIN__\#
\end

screen( "Prozess-Routinen" )
Prozess-Routinen
----------------------------------------------------------------------

Aufruf/Start und Beendigung von Prozessen.

\#abort\#  <stdlib.h>  Programm-Abbruch.
\#atexit\# <stdlib.h>  Routinen beim Programm-Abbruch installieren.
\#exit\#   <stdlib.h>  Programm beenden.
\#exec\#   <process.h> Programm laden und ausfhren.
\#system\# <stdlib.h>  Befehl an TOS bergeben.

Querverweis   \#Standard-Funktionen\#
\end

screen( "Sprnge" )
Sprnge
----------------------------------------------------------------------

Die folgenden beiden Routinen bieten die M”glichkeit eines nicht-
lokalen goto.

\#longjmp\# <setjmp.h> Unbedingten Sprung sofort durchfhren.
\#setjmp\#  <setjmp.h> Sprungziel aufsetzen.

Querverweis   \#Standard-Funktionen\#
\end

screen( "Verschiedene Routinen" )
Verschiedene Routinen
----------------------------------------------------------------------

Verschiedene Routinen, die zum Sprachstandard geh”ren und sich
(zumindest teilweise) nicht einer der anderen Kategorien zuordnen
lassen.

\#assert\#     <assert.h> Fehlersuche mit gltigen C-Ausdrcken.
\#bsearch\#    <stdlib.h> Bin„rsuche in Array durchfhren.
\#getenv\#     <stdlib.h> Environment-Variablen ermitteln.
\#qsort\#      <stdlib.h> Array mit Quicksort sortieren.
\#rand\#       <stdlib.h> Random-Funktion aufrufen.
\#srand\#      <stdlib.h> Random-Funktion neu starten.
\#setmatherr\# <math.h>   Routine zur Behandlung von Rechenfehlern
\#offsetof\#   <stddef.h> Abstand eines Strukturelements vom Struktur-
                         anfang ermittlen.

Querverweis   \#Standard-Funktionen\#
\end

screen( "String- und Speichermanipulat" )
String- und Speichermanipulation
----------------------------------------------------------------------

Vergleich, Kopie, Verschieben und Absuchen von Strings/
Speicherbereichen sowie Verbinden von Stringteilen.

\#memchr\#  <string.h> Zeichen in Speicherbereich suchen.
\#memcpy\#  <string.h> Speicherbereiche kopieren (nicht berlappend).
\#memcmp\#  <string.h> Speicherbereiche vergleichen.
\#memmove\# <string.h> Speicherbereiche kopieren (berlappend).
\#memset\#  <string.h> Speicherbereich initialisieren.
\#strcat\#  <string.h> Strings zusammenh„ngen.
\#strchr\#  <string.h> Zeichen in String suchen.
\#strcmp\#  <string.h> Strings vergleichen.
\#strcpy\#  <string.h> String kopieren.
\#strcspn\# <string.h> L„nge des Bereichs ermitteln, der kein Zeichen
                   eines zweiten Strings enth„lt.
\#strdup\#  <string.h> String duplizieren.
\#stricmp\# <string.h> Strings vergleichen ohne Gro - Kleinschreibung.
\#strcmpi\# <string.h> identisch mit \#stricmp\#
\#strlen\#  <string.h> L„nge eines Strings ermitteln.
\#strlwr\#  <string.h> String in Kleinbuchstaben umwandeln.
\#strncat\# <string.h> Strings bis zu n Zeichen zusammenh„ngen.
\#strncmp\# <string.h> Strings bis zu n Zeichen vergleichen.
\#strncpy\# <string.h> Bis zu n Zeichen in String kopieren.
\#strnicmp\#<string.h> Strings bis zu n Zeichen vergleichen ohne
                   Gro - Kleinschreibung.
\#strncmpi\#<string.h> identisch mit \#strnicmp\#
\#strset\# <string.h>  String mit Zeichen fllen.
\#strnset\# <string.h> Stringteil mit Zeichen fllen.
\#strpbrk\# <string.h> String nach Zeichen eines zweiten Strings absuchen.
\#strrchr\# <string.h> Letzte Position eines Zeichens in einem String
                   ermitteln.
\#strrev\#  <string.h> String invertieren.
\#strspn\#  <string.h> L„nge eines Strings ermitteln, der nur die
                   Zeichen eines zweiten Strings enth„lt.
\#strstr\#  <string.h> String in einem String suchen.
\#strtod\#  <string.h> String als \link("%%GLOBAL%%")double\# interpretieren.
\#strtol\#  <string.h> String als \link("%%GLOBAL%%")long\# interpretieren.
\#strtoul\# <string.h> String als \link("%%GLOBAL%%")unsigned\# \link("%%GLOBAL%%")long\# interpretieren.
\#strtok\#  <string.h> String in Abschnitte (Token) unterteilen.
\#strupr\#  <string.h> String in Grobuchstaben umwandeln.

Querverweis   \#Standard-Funktionen\#
\end

screen( capsensitive("abort") )
Name           ¯abort®-beendet einen Proze.

Definition     void  abort( void );

Prototyp in    stdlib.h

Beschreibung   abort gibt die Meldung ABNORMAL PROGRAM TERMINATION
               via stderr aus und bricht das Programm ber einen
               Aufruf von _exit ab. Registrierte \#atexit\#()-
               Prozeduren werden nicht ausgefhrt. Der durch abort
               zurckgelieferte Exit-Code hat den Wert 3.

Ergebnis       Diese Funktion liefert naturgem„ keinen Wert zurck.

Gruppe         \#Prozess-Routinen\#

Querverweis    \#assert\#   \#exec\#   \#exit\#
\end

screen( capsensitive("abs") )
Name           ¯abs®-absoluter Wert.

Definition     int  abs( int i );

Prototyp in    stdlib.h

Beschreibung   abs liefert den Absolutwert des \link("%%GLOBAL%%")int\#-Arguments i.
               Es handelt es sich um einen ¯echten® Funktionsaufruf.

Ergebnis       abs liefert ein Resultat vom Datentyp \link("%%GLOBAL%%")int\# im Bereich
               von 0..32767. Der Wert -32768 hat fr den Datentyp
               \link("%%GLOBAL%%")int\# keine positive Entsprechung - abs(-32768) liefert
               deshalb den Wert -32768 zurck.

Gruppe         \#Mathematische Routinen\#

Querverweis:   \#labs\#   \#fabs\#   \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")#undef\#
\end

screen( capsensitive("acos") )
Name           ¯arcus cosine®- Arcuscosinus.

Definition     double  acos( double x );

Prototyp in    math.h

Beschreibung   acos ist die Umkehrfunktionen zu \#cos\#.
               acos erwarten einen Wert im Bereich von -1..+1 und
               liefert den dazugeh”rigen Winkel in der Einheit rad
               zurck. Argumente auerhalb dieses Bereichs erzeugen
               das Funktionsergebnis 0 und setzen \#errno\# auf den Wert
               EDOM.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Ergebnis       acos liefert Werte im Bereich von 0..ã.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#perror\#   \#strerror\#
\end

screen( capsensitive("asctime") )
Name           ¯ASCII time®- konvertiert Datum/Uhrzeit in einen
               ASCII-String.

Definition     char  *asctime( struct tm *tblock );

Prototyp in    time.h

Beschreibung   asctime erwartet als Argument einen Zeiger auf die
               Struktur \#tm\#.

Ergebnis       asctime liefert einen Zeiger auf einen statischen
               String ( der mit jedem Aufruf dieser Funktion neu
               gesetzt wird ) mit 26 Zeichen der das folgende
               Format hat:

               Mon Nov 21 11:31:54 1983\\n\\0

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#ctime\#   \#getdate\#   \#time\#
\end

screen( capsensitive("asin") )
Name           ¯arcus sine® Arcussinus.

Definition     double  asin( double x );

Prototyp in    math.h

Beschreibung   Erwartet einen "Sinuswert" (Bereich -1..+1) und liefert
               den dazugeh”rigen Winkel in Rad zurck (-ã/2 .. ã/2).
               asin ist die Umkehrfunktionen zu \#sin\#.

Ergebnis       Argumente auerhalb dieses Bereichs erzeugen das
               Funktionsergebnis 0 und setzen \#errno\# auf den Wert
               EDOM.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#perror\#   \#strerror\#
\end

screen( capsensitive("assert") )
Name           ¯assertion®- prft eine  Bedingung und bricht das
               Programm ab, wenn sie nicht zutrifft.

Definition     #include <stdio.h>
               void  assert( int test );

Prototyp in    assert.h

Beschreibung   assert ist ein Makro, das bei der Compilierung zu
               einer  if-Anweisung erweitert wird. Wenn test zur
               Laufzeit des Programms den Wert false ergibt,
               wird die Meldung.

               Assertion failed: test file <Datei> Line <Zeile>

               ber einen Aufruf von \#fprintf\# ausgegeben, danach
               erfolgt ein Abbruch des Programms via \#abort\#().
               Die ausgegebene Zeilennummer steht fr die Zeile,
               in der sich der Aufruf von assert im Quelltext
               befindet. Wenn das Symbol NDEBUG vor der Aufnahme von
               assert.h im Quelltext (oder via  Defines) definiert
               ist, entfernt der \link("%%GLOBAL%%")Pr„prozessor\# s„mtliche Aufrufe von
               assert.
Ergebnis       assert hat kein direktes Funktionsergebnis.

Gruppe         \#Verschiedene Routinen\#

Querverweis    \#abort\#   \#exit\#
\end

screen( capsensitive("atan") )
Name           ¯arc tangent®- Arcustangens.

Definition     double  atan( double x );

Prototyp in    math.h

Beschreibung   atan ist die Umkehrfunktion zu \#tan\#.
               atan erwartet einen "Tangenswert" und liefert den
               dazugeh”rigen Winkel in Rad (-ã/2 .. ã/2).
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#perror\#   \#strerror\#
\end

screen( capsensitive("atan2") )
Name           ¯arc tangent®- Arcustangens  von y/x.

Definition     double  atan2( double y, double x );

Prototyp in    math.h

Beschreibung   atan2 liefert den Arcustangens von y/x und erzeugt auch
               dann noch korrekte Resultate, wenn der sich ergebende
               Winkel nahe bei ã/2 oder -ã/2 liegt (den Polstellen der
               Tangensfunktion, fr Werte von x nahe Null).
               Wenn x und y gleich Null sind, wird \#errno\# auf
               den Wert EDOM gesetzt.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Ergebnis       Erwartet zwei "Tangenswerte" und liefert den
               dazugeh”rigen Winkel in Rad (-ã .. ã).

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#perror\#   \#strerror\#
\end

screen( capsensitive("atexit") )
Name           ¯at exit®- legt Routinen fest, die am Ende eines
               Programms aufgerufen werden sollen.

Definition     int  atexit( void (*func)( void ));

Prototyp in    stdlib.h

Beschreibung   šber atexit festgelegte Funktionen werden nach dem
               normalen Ende eines Programms in der Form
               *func(ohne Parameter)aufgerufen. Jeder Aufruf von
               atexit registriert eine weitere Funktion.
               Der Aufruf registrierter Funktionen geschieht in der
               durch die Aufrufe von atexit festgelegten Reihenfolge
               nach dem Prinzip ¯last in - first out® - die als letzte
               mit atexit festgelegte Funktion wird also zuerst
               aktiviert. Maximal k”nnen 32 ¯Exit-Funktionen®
               festgelegt werden (atexit != 0).

Ergebnis       atexit liefert den Wert 0 zurck, wenn die angegebene
               Funktion in den ¯Stack® aufgenommen werden konnte;
               falls bereits 32 Funktionen registriert sind (und damit
               kein weiterer Platz mehr zur Verfgung steht), ist das
               Ergebnis -1.

Gruppe         \#Prozess-Routinen\#

Querverweis    \#exec\#   \#exit\#
\end

screen( capsensitive("atof") )
Name           ¯ASCII to float®- konvertiert einen ASCII-String
               in eine Fliekommazahl.

Definition     double  atof( const char *str );

Prototyp in    stdlib.h

Beschreibung   atof interpretiert den ber str angegebenen \#String\#
               als  Fliekommazahl und liefert das Ergebnis dieser
               Interpretation als \link("%%GLOBAL%%")double\# zurck.

Ergebnis       Wenn der zu interpretierende String  nicht numerisch
               auswertbar ist, dann ist das Ergebnis 0.0.
               Bei einem šberlauf wird plus oder minus HUGE_VAL
               (in math.h definiert) zurckgegeben und \#errno\# auf
               den den Wert ERANGE gesetzt.

Gruppe         \#Umwandlungsroutinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#atoi\#   \#atol\#
\end

screen( capsensitive("ftoa") )
Name           ¯float to ASCII®- konvertiert eine Fliekommazahl
               in einen ASCII-String.

Definition     int  ftoa( double *value, char *resStr, int ndig,
                           int format, int *dec, int *sign );

Prototyp in    math.h

Beschreibung   ftoa konvertiert value in einen nullterminierten
               String mit ndig Ziffern und liefert einen Zeiger zu
               diesem String in resStr zurck. Der String enth„lt
               ausschlielich Ziffern: ber *dec wird die Position
               des Dezimalpunkts relativ zum Beginn des Strings
               zurckgeliefert (negative Werte bedeuten hier:
               Dezimalpunkt links vom Stringanfang). Wenn value
               negativ ist, dann setzt ftoa *sign auf einen Wert
               ungleich Null (fr positive Werte von value ist
               *sign == 0). Im Unterschied zu \#ecvt\# untersttzt
               ftoa mehrere Formate (anzugeben in format):
                0:  e-\#Format\#
                1:  f-\#Format\#
               -1:  g-\#Format\#

Ergebnis       ftoa liefert bei fehlerfreier Ausfhrung 0, ansonsten
               einen Wert !=0.

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#itoa\#   \#ltoa\#   \#ecvt\#
\end

screen( "String" )
Der String kann die folgenden Elemente enthalten - allerdings nur
in der gezeigten Reihenfolge:

               ù fhrende Leerzeichen und/oder Tabs;
               ù ein (optionales) Vorzeichen;
               ù eine Folge von Ziffern (Stellen vor dem Komma),
                 danach einen Dezimalpunkt und weitere Ziffern
                 (zumindest einer dieser beiden Teile mu
                 vorhanden sein);
               ù einen (optionalen) Exponenten, der mit einem e oder
                 E eingeleitet wird und ein (optionales) Vorzeichen
                 sowie einen (obligatorischen) Integer enth„lt.
                 atoi und atol interpretieren einen String als
                 signed int bzw. als signed long. Dezimalpunkte und
                 Exponenten sind nicht zul„ssig - die Liste gltiger
                 Elemente verkrzt sich hier auf:
               ù fhrende Leerzeichen und/oder Tabs;
               ù ein (optionales) Vorzeichen;
               ù eine Ziffernfolge.

               Bei allen Funktionen endet die Interpretation mit
               dem ersten nichtnumerischen Zeichen (also auch
               mit einem ¯weien Leerzeichen® innerhalb der
               Ziffernfolge), eine Prfung auf eventuelle šberl„ufe
               findet nicht statt.

Querverweis    \#atof\#, \#atoi\#, \#atol\#, \#scanf\#
\end

screen( capsensitive("atoi") )
Name           ¯ASCII to int®- konvertiert einen ASCII-String
               in einen Integer.

Definition     int  atoi( const char *str );

Prototyp in    stdlib.h

Beschreibung   atoi interpretiert den ber str angegebenen \#String\#
               als Integer und liefert das Ergebnis dieser
               Interpretation als int zurck.

Ergebnis       Wenn der zu interpretierende \#String\# nicht
               numerisch auswertbar ist, dann ist das Ergebnis 0.

Gruppe         \#Umwandlungsroutinen\#

Querverweis    \#atof\#   \#atol\#
\end

screen( capsensitive("atol") )
Name           ¯ASCII to long®- konvertiert einen ASCII-String
               in einen \link("%%GLOBAL%%")long\#.

Definition     long  atol( const char *str );

Prototyp in    stdlib.h

Beschreibung   atol interpretiert den ber str angegebenen \#String\#
               als long und liefert das Ergebnis dieser
               Interpretation als long zurck.

Ergebnis       Wenn der zu interpretierende \#String\# berhaupt nicht
               numerisch auswertbar ist, dann ist das Ergebnis 0.

Gruppe         \#Umwandlungsroutinen\#

Querverweis    \#atof\#   \#atoi\#
\end

screen( capsensitive("bsearch") )
Name           ¯binary search®- bin„res Absuchen einer Liste.

Definition     void  *bsearch( const void *key, const void *base,
                                size_t nmemb, size_t size, 
                                int (*compar)( ));

Prototyp in    stdlib.h

Beschreibung   bsearch sucht ein beliebiges Array ab, dessen Elemente
               in aufsteigender Reihenfolge sortiert sein mssen.
               Die Anzahl der Elemente dieses Arrays ist durch nmemb
               festgelegt. bsearch fhrt lediglich eine Suche aus.
               Der Parameter size gibt die Gr”e eines
               Tabelleneintrags (in Bytes) an. Der Parameter base mu
               auf das erste Element des Arrays zeigen, nmemb auf
               einen Integer, der die Indexnummer des momentan
               h”chsten Array-Elements enth„lt. size gibt die Gr”e
               eines einzelnen  Elements (in Byte) an, key zeigt auf
               die zu suchende Information. Der Parameter compar zeigt
               auf eine vom Programmierer erstellte Routine, der
               jeweils zwei Argumente in Form von Zeigern zum
               Vergleich bergeben werden: key (die zu suchende
               Information) und elem (das Element, mit dem der
               Vergleich  stattfinden soll). Die Routine mu die
               folgenden Werte zurckliefern:
               *key > *elem        Integer < 0
               *key == *elem           0
               *key < *elem        Integer > 0
               Auf welche Art und Weise die Vergleichsroutine
               arbeitet, ist allein Sache des Programmierers - Grenzen
               gibt es keine.

Ergebnis       Diese Funktion liefert einen Zeiger auf das erste
               Element des Arrays zurck, das mit den gesuchten
               Daten identisch ist. Falls der gesuchte Eintrag nicht
               existiert, liefert bsearch den Wert \link("%%GLOBAL%%")NULL\#.

Gruppe         \#Verschiedene Routinen\#

Querverweis    \#qsort\#   \#size_t\#
\end

screen( capsensitive("calloc") )
Name           ¯core allocation®- belegt Platz im Hauptspeicher.

Definition     void  *calloc( size_t nitems, size_t size );

Prototyp in    stdlib.h

Beschreibung   šber diese Funktionen wird der Heap verwaltet.
               calloc belegt einen Speicherbereich von nitems * size
               Bytes und liefert einen Zeiger auf die Startadresse
               dieses Bereichs zurck. Im Gegensatz zu \#malloc\# werden
               s„mtliche Speicherzellen des neu belegten Bereichs auf
               den Wert 0 initialisiert.

Ergebnis       calloc liefert einen typenlosen Zeiger, der explizit
               auf den verwendeten Zeigertyp konvertiert werden
               sollte. Wenn kein Speicherbereich ausreichender Gr”e
               zur Verfgung steht, dann ist das Funktionsergebnis
               \link("%%GLOBAL%%")NULL\#, es findet keine Belegung statt.

Gruppe         \link("Dynamische Verwaltung des Spe")Dynamische Verwaltung des Speichers\#

Querverweis    \#free\#   \#malloc\#   \#size_t\#
\end

screen( capsensitive("ceil") )
Name           ¯ceiling®(Decke)- rundet   das Argument zur
               n„chst gr”eren Integerzahl.

Definition     double  ceil( double x );

Prototyp in    math.h

Beschreibung   ceil rundet in Richtung h”herer Integerwerte auf:
               ceil( 3.2 )    ergibt 4.0
               ceil( -1.8 )   ergibt -1.0
               (-1.0 ist ein gr”erer Wert als -1.8).

Ergebnis       ceil liefert ihr ganzzahliges Ergebnis als \link("%%GLOBAL%%")double\#
               zurck.

Gruppe         \#Mathematische Routinen\#

Querverweis    \#floor\#   \#abs\#
\end

screen( capsensitive("chdir") )
Name           ¯change directory® - wechselt das momentan gesetzte
               Directory

Definition     int  chdir( char *path );

Prototyp in    ext.h

Beschreibung   chdir setzt das durch path bezeichnete Directory als
               Standard-Directory. Das Laufwerk wird dabei nicht
               gewechselt.

Ergebnis       Wenn das angegebene Directory gesetzt werden konnte,
               liefert chdir den Wert 0; ansonsten wird -1
               zurckgeliefert und \#errno\# bekommt den Wert ENOENT.

Gruppe         \#Pure-C-Spezialfunktionen\#
\end

screen( capsensitive("coreleft") )
Name           ¯core left® -  ermittelt den gr”ten zur Verfgung
               stehenden Speicherblock

Definition     size_t  coreleft( void );

Prototyp in    ext.h

Beschreibung   coreleft ermittelt den gr”ten zur Verfgung stehenden
               Speicherblock im RAM, der z.B. mittels \#malloc\# oder
               \#calloc\# reserviert werden kann.

Ergebnis       coreleft liefert die gefundene Anzahl in Byte.

Gruppe         \#Pure-C-Spezialfunktionen\#
\end

screen( capsensitive("clearerr") )
Name           ¯clear error®- setzt die Fehlerbedingung
               ¯Dateiende® fr eine bestimmte Datei zurck.

Definition     void  clearerr( FILE *stream );

Prototyp in    stdio.h

Beschreibung   clearerr setzt das Fehler-Flag und das Dateiende-
               Flag der ber stream angegebenen Datei zurck.
               (Das Dateiende-Flag wird beim Erreichen des
               Dateiendes automatisch gesetzt und bleibt es solange,
               bis entweder clearerr, \#fseek\# oder \#rewind\#
               angewendet werden oder die Datei geschlossen wird.)

Ergebnis       clearerr setzt das Fehler- und das Dateiende-Flag
               der angegebenen Datei zurck und hat ansonsten
               kein Ergebnis.

Gruppe         \#I/O-Routinen\#

Querverweis    \#ferror\#
\end

screen( capsensitive("clock") )
Name           ¯clock ticks® - ermittelt die Systemzeit.

Definition     clock_t  clock( void );

Prototyp in    time.h

Beschreibung   Die Funktion clock ermittelt die Systemzeit. Damit
               lassen sich sehr exakte Zeitmessungen durchfhren.
               Diese Funktion wird meistens fr Benchmarks verwendet.
               \#clock_t\# ist in time.h als long definiert. Die 
               Anzahl der "ticks" fr eine Sekunde ist mit \#CLK_TCK\#
               definiert.

Ergebnis       Die Funktion clock liefert -1, wenn die Zeit nicht
               ermittelt werden konnte, ansonsten die Systemzeit.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#time\#
\end

screen( capsensitive("close") )
Name           ¯close® -  schliet eine Datei.

Definition     int  close( int handle );

Prototyp in    stdio.h

Beschreibung   Die Funktion schliet eine mit handle bezeichnete
               Datei. (Ein ¯Handle® wird durch \#creat\# oder \#open\#
               erzeugt, d.h. einer Datei zugeordnet.)

Ergebnis       Die Funktion liefert den Wert 0 zurck, wenn die
               Operation fehlerfrei ausgefhrt werden konnte.
               Ansonsten ist das Ergebnis -1. Es wird jeweils ein
               gltiger Handle erwartet, der stellvertretend fr eine
               offene Datei steht. Falls dem nicht so ist, bekommt
               \#errno\# den Wert EBADF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#creat\#   \#fclose\#   \#fopen\#
\end

screen( capsensitive("cos") )
Name           ¯cosine® - liefert den Cosinus des Arguments zurck.

Definition     double  cos( double x );

Prototyp in    math.h

Beschreibung   cos erwartet einen Winkel in der Einheit rad (0 Grad =
               0 * ã, 90 Grad = ã/2, 180 Grad = ã, 270 Grad = 1.5 * ã,
               360 Grad = 2 * ã usw.) als Argument und liefert den
               dazugeh”rigen Cosinus zurck. šbergebene Werte werden
               automatisch auf den Bereich 0..2*ã reduziert.
               Der Wert von ã (3.1415...) ist in math.h als Konstante
               mit dem Namen M_PI definiert

Ergebnis       M”gliche Ergebnisse liegen im Bereich von -1 .. 1.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#acos\#
\end

screen( capsensitive("cosh") )
Name           ¯cosine hyperbolic® - liefert den hyperbolischen
               Cosinus des Arguments zurck.

Definition     double  cosh( double x );

Prototyp in    math.h

Beschreibung   cosh berechnet den Cosinus hyperbolicus des Arguments,

Ergebnis       Bei fehlerfreier Ausfhrung liefert die Funktion
               das entsprechende Ergebniss. Bei šberl„ufen wird
               HUGE_VAL (mit korrektem Vorzeichen) zurckgeliefert und
               \#errno\# bekommt den Wert ERANGE.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#exp\#
\end

screen( capsensitive("acosh") )
Name           ¯arcus cosine hyperbolic® - liefert den hyperbolischen
               Arcuscosinus des Arguments zurck.

Definition     double  acosh( double x );

Prototyp in    math.h

Beschreibung   acosh berechnet den Arcuscosinus hyperbolicus des
               Arguments.

Ergebnis       acosh erwartet einen Wert im Bereich von [1.0,
               +infinity] und liefert den dazugeh”rigen Wert im Be-
               reich von [0.0,+infinity].
               Argumente auerhalb des gltigen Bereichs erzeugen
               das Funktionsergebnis 0 und setzen \#errno\# auf den Wert
               EDOM.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#exp\#
\end

screen( capsensitive("creat") )
Name           ¯create® - erzeugt eine neue Datei bzw. berschreibt
               eine bereits vorhandene Datei.

Definition     int  creat( const char *filename );

Prototyp in    stdio.h

Beschreibung   creat erzeugt eine neue Datei, existiert bereits
               die durch filename bezeichnete Datei wird der vorherige
               Inhalt gel”scht. Attribute, die fr diese Datei
               definiert wurden, bleiben unver„ndert.
               Falls die Datei nur gelesen werden kann, bricht creat
               mit einem Fehler ab, die Datei bleibt unver„ndert.

Ergebnis       Wenn die angegebene Datei fehlerfrei er”ffnet werden
               konnte, liefert die Funktion einen ¯Handle® (d.h. einen
               positiven Integerwert) zurck. Im Fehlerfall wird das
               Ergebnis -1 geliefert und \#errno\# bekommt einen der
               folgenden Werte:
               ENOENT       EMFILE       EACCES

Gruppe         \#I/O-Routinen\#

Querverweis    \#close\#    \#open\#   \#read\#   \#write\#
\end

screen( capsensitive("ctime") )
Name           ¯convert time® - konvertiert Datum und Uhrzeit in
               einen String.

Definition     char  *ctime( time_t *timer );

Prototyp in    time.h

Beschreibung   ctime erwartet einen Zeiger auf Datum und Uhrzeit des
               Systems. \#time_t\# wird beispielsweise von der Funktion
               \#time\# geliefert. Das Ergebnis von ctime ist ein
               String mit 26 Zeichen, der das folgende Format hat:

               Mon Nov 21 11:31:54 1983\\n\\0

               Alle Felder dieses Strings haben eine konstante L„nge.

Ergebnis       ctime und liefert einen Zeiger auf einen statischen
               String zurck, der mit jedem Aufruf dieser Funktion
               erneut gesetzt wird.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#getdate\#   \#time\#   \#asctime\#
\end

screen( capsensitive("difftime") )
Name           ¯difference time® - berechnet den Unterschied zwischen
               zwei Zeitangaben in Sekunden.

Definition     double  difftime( time_t time1, time_t time2 );

Prototyp in    time.h

Beschreibung   difftime berechnet die zwischen time1 und time2
               liegende Zeit in Sekunden.

Ergebnis       difftime liefert die Differenz zweier Zeiten als
               \link("%%GLOBAL%%")double\# in der Einheit Sekunden zurck.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#getdate\#   \#ctime\#   \#asctime\#   \#time\#   \#time_t\#
\end

screen( capsensitive("div") )
Name           ¯divide® - dividiert zwei Integerwerte und liefert
               nicht nur den Quotienten, sondern auch den
               Divisionsrest zurck.

Definition     div_t  div( int numer, int denom );

Prototyp in    stdlib.h

Beschreibung   div dividiert die als numer (Dividend) und denom
               (Divisor) bergebenen Integerwerte und liefert
               eine Struktur des Typs \#div_t\# zurck.

Gruppe         \#Mathematische Routinen\#

Querverweis    \#ldiv\#
\end

screen( capsensitive("ecvt") )
Name           ¯e-convert® - konvertiert eine Fliekommazahl in einen
               String.

Definition     char  *ecvt( double value, int ndig, int *dec,
                             int *sign );

Prototyp in    stdlib.h

Beschreibung   ecvt konvertiert value in einen nullterminierten
               String mit ndig Ziffern und liefert einen Zeiger zu
               diesem String zurck. Der String enth„lt ausschlielich
               Ziffern: ber dec wird die Position des Dezimalpunkts
               relativ zum Beginn des Strings zurckgeliefert
               (negative Werte bedeuten hier: Dezimalpunkt links vom
               Stringanfang). Wenn value negativ ist, dann setzt ecvt
               sign auf einen Wert ungleich Null (fr positive Werte
               von value ist sign == 0). Die unterste Ziffer wird
               gerundet.

Ergebnis       ecvt liefert einen Zeiger zu einem benutzten und
               statischen String zurck.

Portabilit„t   Auf UNIX verfgbar, jedoch nicht im ANSI-Standard
               enthalten.

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#ftoa\#   \#fcvt\#   \#gcvt\#   \#sprintf\#
\end

screen( capsensitive("fcvt") )
Name           ¯f-convert® - konvertiert eine Fliekommazahl in einen
               String.

Definition     char  *fcvt( double value, int ndig, int *dec,
                             int *sign );

Prototyp in    stdlib.h

Beschreibung   fcvt konvertiert value in einen nullterminierten
               String mit ndig Ziffern und liefert einen Zeiger zu
               diesem String zurck. Der String enth„lt ausschlielich
               Ziffern: ber dec wird die Position des Dezimalpunkts
               relativ zum Beginn des Strings zurckgeliefert
               (negative Werte bedeuten hier: Dezimalpunkt links vom
               Stringanfang). Wenn value negativ ist, dann setzt fcvt
               sign auf einen Wert ungleich Null (fr positive Werte
               von value ist sign == 0). Die Zahl wird gem„ der in
               ndig angegebenen Genauigkeit gerundet.

Ergebnis       fcvt liefert einen Zeiger zu einem benutzten und
               statischen String zurck.

Portabilit„t   Auf UNIX verfgbar, jedoch nicht im ANSI-Standard
               enthalten.

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#ftoa\#   \#ecvt\#   \#gcvt\#   \#sprintf\#
\end

screen( capsensitive("gcvt") )
Name           ¯g-convert® - konvertiert eine Fliekommazahl in einen
               String.

Definition     char  *gcvt( double value, int ndec, char *buf );

Prototyp in    stdlib.h

Beschreibung   gcvt konvertiert value in einen nullterminierten
               String und speichert ihn in buf. Es werden ndec
               signifikante Ziffern im FORTRAN-F-Format erzeugt,
               sofern m”glich. Ansonsten wird der Wert im
               \link("Format-String (printf)")printf-E-Format\# zurckgegeben.

Ergebnis       gcvt liefert einen Zeiger auf den erzeugten String
               zurck.

Portabilit„t   Auf UNIX verfgbar, jedoch nicht im ANSI-Standard
               enthalten.

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#ftoa\#   \#ecvt\#   \#fcvt\#   \#sprintf\#
\end

screen( capsensitive("exec") )
Name           ¯execute® - Laden und Starten eines anderen Programms.

Definition     int  exec( char *pathname, char *cmdlstr,
                           char *envstr, int *retcode);

Prototyp in    process.h

Beschreibung   Die Funktion exec l„dt und startet andere Programme, die
               als child prosess bezeichnet werden.
Hinweis        exec schliet keine Dateien - s„mtliche durch den
               parent process ge”ffneten Dateien stehen auch dem child
               zur Verfgung. Der Parameter pathname gibt den Namen
               des child process an.
               Eventuelle Parameter fr dieses Programm k”nnen in
               cmdlstr bergeben werden. Mit envstr k”nnen
               Environment-Werte fr den child-process gesetzt werden.

Ergebnis       Konnte die exec-Funktion nicht ausgefhrt werden, dann
               wird -1 zurckgeliefert, und \#errno\# bekommt einen der
               folgenden Werte:
               EACCES   EMFILE   ENOENT   ENOMEM   EPLFMT

Gruppe         \#Prozess-Routinen\#

Querverweis    \#abort\#   \#atexit\#   \#exit\#   \#system\#
\end

screen( capsensitive("exit"),
		capsensitive("_exit") )
Name           ¯exit® - beendet das laufende Programm

Definition     void  exit( int status );
               void  _exit( int status );

Prototyp in    stdlib.h

Beschreibung   exit beendet das laufende Programm. Vor dem Rcksprung
               zum parent process werden s„mtliche Dateipuffer
               geschrieben, offene Dateien geschlossen und
               ( via \#atexit\# ) festgelegte Funktionen aufgerufen.
               Diese Funktion beendet das Programm mit dem als status
               angegebenen Exit-Code, der beispielsweise vom parent
               process geprft werden kann. Der Wert 0 steht
               hier normalerweise fr eine fehlerfreie Ausfhrung,
               Werte ungleich Null sollten Fehler signalisieren.
               Im unterschied zu exit werden bei _exit Funktionen,
               die mit \#atexit\# installiert wurden nicht aufgerufen.

Ergebnis       Weder exit noch _exit haben ein direktes Funktionsergebnis.

Gruppe         \#Prozess-Routinen\#

Querverweis    \#abort\#   \#atexit\#
\end

screen( capsensitive("exp") )
Name           ¯exponential® - berechnet e ^ x.

Definition     double  exp( double x );

Prototyp in    math.h

Bescheibung    exp liefert das Ergebnis der Berechnung e^x zurck,
               wobei e fr die Basis des natrlichen Logarithmus steht
               (2.718281...).

Ergebnis       Bei einem šberlauf liefert exp HUGE_VAL und setzt
               \#errno\# auf den Wert ERANGE. Im Falle eines Unterlaufs
               ist das Resultat 0.0 und errno wird nicht ge„ndert.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#frexp\#   \#ldexp\#   \#log\#   \#pow\#   \#sqrt\#
\end

screen( capsensitive("fabs") )
Name           ¯float abs® - absoluter Wert einer Fliekommazahl.

Definition     double  fabs( double x );

Prototyp in    math.h

Beschreibung   fabs liefert den Absolutwert des \link("%%GLOBAL%%")double\#-Arguments x
               zurck.

Ergebnis       fabs liefert den Absolutwert des \link("%%GLOBAL%%")double\#-Arguments x.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis:   \#labs\#   \#abs\#
\end

screen( capsensitive("fclose") )
Name           ¯file close® - schliet eine Datei.

Definition     int  fclose( FILE *stream );

Prototyp in    stdio.h

Beschreibung   fclose schliet die durch stream angegebene Datei,
               wobei zuvor ein entsprechender Aufruf von \#fflush\#
               erfolgt. Durch das System automatisch belegte Puffer
               werden durch fclose freigegeben.

Ergebnis       fclose liefert bei fehlerfreier Ausfhrung den Wert 0.
               Im Falle eines Fehlers liefert fclose den Wert EOF
               zurck.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fflush\#   \#close\#   \#fopen\#   \#setbuf\#   \#Fclose\#
\end

screen( capsensitive("feof") )
Name           ¯file eof® - prft, ob das Ende einer Datei
               erreicht ist.

Definition     int  feof( FILE *stream );

Prototyp in    stdio.h

Beschreibung   feof ist ein Makro und prft das Dateiende-Flag der
               ber stream angegebenen Datei. (Dieses Flag wird
               beim Erreichen des Dateiendes automatisch gesetzt und
               bleibt es solange, bis entweder \#clearerr\#, \#fseek\#
               oder \#rewind\# angewendet werden oder die Datei
               geschlossen wird.)

Ergebnis       feof liefert einen Wert ungleich 0 zurck, wenn
               das Dateiende-Flag des angegebenen stream gesetzt
               ist, ansonsten den Wert 0.

Gruppe         \#I/O-Routinen\#

Querverweis    \#ferror\#
\end

screen( capsensitive("ferror") )
Name           ¯file error® - prft Fehlerbedingungen bei der
               Bearbeitung von Dateien.

Definition     int  ferror( FILE *stream );

Prototyp in    stdio.h

Beschreibung   ferror ist ein Makro, der die ber stream angegebenen
               Datei auf Schreib- und Lesefehler prft. (Das Fehler-
               Flag einer Datei bleibt nach einem Fehler solange
               gesetzt, bis entweder \#clearerr\# oder \#rewind\#
               angewendet oder die Datei geschlossen wird.).

Ergebnis       ferror liefert einen Wert ungleich 0 zurck, wenn
               das Fehlerflag des angegebenen stream gesetzt ist,
               ansonsten den Wert 0.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fopen\#   \#getc\#   \#gets\#   \#open\#   \#putc\#   \#puts\#
\end

screen( capsensitive("fflush") )
Name           ¯file flush® - erzwingt das physikalische Schreiben
               eines Dateipuffers.

Definition     int  fflush( FILE *stream );

Prototyp in    stdio.h

Beschreibung   fflush erzwingt bei Ausgabedateien ein Schreiben
               eventueller Pufferinhalte, sorgt also bei
               Diskettendateien dafr, da ausgegebene Daten auch
               physikalisch geschrieben werden. Bei Eingabedateien
               wird ein eventueller Pufferinhalt gel”scht - der
               n„chste Lesebefehl erzwingt eine physikalische
               Leseaktion. Die durch stream bezeichnete Datei bleibt
               offen.

Ergebnis       fflush liefert bei fehlerfreier Ausfhrung den Wert 0.
               Im Falle eines Fehlers liefert fflush den Wert EOF
               zurck.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fclose\#   \#close\#   \#fopen\#   \#setbuf\#
\end

screen( capsensitive("fgetc") )
Name           ¯file get character® - liest ein Zeichen aus einer Datei.

Definition     int  fgetc( FILE *stream );

Prototyp in    stdio.h

Beschreibung   fgetc verh„lt sich exakt wie \#getc\#, nur da
               es sich hier um eine echte Funktion handelt.

Ergebnis       fgetc liefert bei fehlerfreier Ausfhrung das gelesene
               Zeichen als \link("%%GLOBAL%%")int\# zurck, wobei keine Vorzeichen-
               erweiterung stattfindet. Bei šberschreitung des
               Dateiendes (beim Lesen der Tastatur: der Eingabe von
               control-z) wird der Wert EOF zurckgeliefert.

Gruppe         \#I/O-Routinen\#

Querverweis    \#getc\#    \#ungetc\#   \#ferror\#   \#fopen\#   \#fread\#
               \#fseek\#   \#gets\#     \#putc\#     \#read\#    \#scanf\#
\end

screen( capsensitive("fgetpos") )
Name           ¯file get position® - aktuelle Datei-Position
               speichern.

Definition     int  fgetpos( FILE *stream, fpos_t *pos );

Prototyp in    stdio.h

Beschreibung   Die Funktion fgetpos speichert die aktuelle Position
               in der Datei stream im Parameter pos. Der gespeicherte
               Wert ist speziell kodiert und kann lediglich von der
               Funktion \#fsetpos\# verwendet werden.

Ergebnis       Die Funktion liefert den Wert 0, wenn die Datei-
               Position ermittelt werden konnte, ansonsten einen
               Fehlercode und \#errno\# wird auf EBADF oder EINVAL
               gesetzt.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fsetpos\#
\end

screen( capsensitive("fgets") )
Name           ¯file get string® - liest einen String aus einem
               Stream.

Definition     char  *fgets( char *str, int n, FILE *fp );

Prototyp in    stdio.h

Beschreibung   fgets liest eine Zeichenfolge die mit einen
               Zeilenvorschub endet vom Stream fp und speichert
               diese in der durch str angegebenen Stringvariablen.
               Der String darf maximal n Zeichen umfassen,
               ansonsten wird der String abgeschnitten. Der
               Zeilenvorschub bleibt im String erhalten. Ein
               Null-Byte wird angh„ngt, um das Stringende zu
               markieren.

Ergebnis       fgets liefert bei fehlerfreier Ausfhrung einen
               Zeiger auf str zurck. Wenn beim Lesen das
               Dateiende berschritten wird oder ein Fehler
               auftritt, ist das Resultat \link("%%GLOBAL%%")NULL\#.

Gruppe         \#I/O-Routinen\#

Querverweis    \#gets\#   \#ferror\#   \#fopen\#   \#fread\#   \#getc\#
               \#puts\#   \#scanf\#
\end

screen( capsensitive("fileno") )
Name           ¯file number® - liefert den Handle einer Datei zurck

Definition     int  fileno( FILE *stream );

Prototyp in    stdio.h

Beschreibung   fileno ist ein Makro und liefert den Handle der šber
               stream angegebenen Datei zurck. Wenn stream mehr als
               ein Handle zugeordnet ist, wird der Handle zurckge-
               liefert, der bei der Er”ffnung vergeben wurde.

Ergebnis       Solange stream eine offene Datei bezeichnet, wird der
               Handle als Integer zurckgeliefert. Spezielle Werte fr
               Fehler gibt es nicht - wenn stream keine offene Datei
               bzeichnet, ist das Ergebnis von fileno undefiniert.

Gruppe         \#I/O-Routinen\#

Querverweis    \#gets\#   \#ferror\#   \#fopen\#   \#fread\#   \#getc\#
               \#puts\#   \#scanf\#
\end

screen( capsensitive("filelength") )
Name           ¯file length® - ermittelt die L„nge einer Datei.

Definition     long  filelength( int handle );

Prototyp in    ext.h

Beschreibung   filelength liefert die L„nge der ber handle
               angegebenen Datei in Bytes zurck.

Ergebnis       filelength liefert bei fehlerfreier Ausfhrung den Wert
               in Bytes. Im Falle eines Fehlers ist das Resultat -1
               und \#errno\# erh„lt den Wert EBADF.

Gruppe         \#Pure-C-Spezialfunktionen\#

Querverweis    \#fseek\#   \#fstat\#
\end

screen( capsensitive("findfirst") )
Name           ¯find first entry® - sucht ein Directory nach
               einem Dateieintrag ab.

Definition     int  findfirst( const char *filename,
                                struct ffblk *fileRec, int attrib );
Prototyp in    ext.h

Beschreibung   findfirst sucht ein Directory nach dem ersten
               Vorkommen des Dateieintrags filename ab.
               filename kann optional eine Laufwerksbezeichnung
               und/oder einen Suchweg enthalten, Jokerzeichen
               (* und ?) sind erlaubt. findfirst sucht im ber
               filename angegebenen Directory bzw. dem momentan
               gesetzten Directory. Der erste Eintragsvergleich,
               der positiv ausf„llt, setzt die ber fileRec
               angegebene Struktur \#ffblk\# mit den entsprechenden
               Informationen. šber den Parameter attrib wird das
               Attribut des zu suchenden Eintrags angegeben.
               Die folgenden Konstanten sind in ext.h definiert und
               k”nnen ber OR-Operationen miteinander kombiniert
               werden:

               FA_RDONLY    0x01 schreibgeschtzt
               FA_HIDDEN    0x02 versteckt
               FA_SYSTEM    0x04 Systemdatei
               FA_LABEL     0x08 Label (Diskettenname)
               FA_DIREC     0x10 Directory
               FA_ARCH      0x20 Archivierungs-Bit

Ergebnis       Die Funktion liefert den Wert 0 zurck, wenn
               ein passender Eintrag  gefunden wurde.
               Wenn kein Eintrag vorhanden ist oder der angegebene
               filename aus irgendeinem Grund ungltig ist, wird -1
               als  Ergebnis geliefert und \#errno\# bekommt einen der
               Werte ENOENT oder ENMFILE.

Gruppe         \#Directory-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#findnext\#
\end

screen( capsensitive("findnext") )
Name           ¯find next® - sucht ein Directory
               (nach Aufruf von \#findfirst\#) nach weiteren
               Eintr„gen ab.

Definition     int  findnext( struct ffblk *fileRec );

Prototyp in    ext.h

Beschreibung   findnext sucht nach weiteren Eintr„gen innerhalb
               eines Directories:
               ù als Argument mu die Struktur des Typs \#ffblk\#
               bergeben werden, die durch \#findfirst\# gesetzt
               wurde.
               ù findnext liefert bei jedem Aufruf einen
               weiteren Dateieintrag ber \#ffblk\# zurck

Ergebnis       Die Funktion liefert den Wert 0 zurck, wenn
               ein weiterer Eintrag  gefunden wurde.
               Wenn kein weiterer Eintrag mehr vorhanden ist,
               wird -1 als  Ergebnis geliefert und \#errno\# bekommt
               einen der Werte ENOENT oder ENMFILE.

Gruppe         \#Directory-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#findfirst\#
\end

screen( capsensitive("stat") )
Name           ¯status® - liefert Informationen ber eine Datei oder
               ein Directory.

Definition     int  stat( char *path, \link("st_dev")struct stat\# *statbuf );

Prototyp in    ext.h

Beschreibung   stat setzt die Mitglieder einer Struktur des Typs
               \#stat\# mit Informationen ber die durch path ange-
               gebene Datei und ist auch auf Directories anwendbar.

Ergebnis       stat liefert bei fehlerfreier Ausfhrung den Wert 0
               zurck. Im Falle eines Fehlers ist das Resultat -1 und
               \#errno\# erh„lt den Wert ENOENT.

Querverweis    \#fstat\#
\end

screen( capsensitive("fstat") )
Name           ¯file status® - liefert Informationen ber eine Datei.

Definition     int  fstat( int handle, struct \#stat\# *statbuf );

Prototyp in    ext.h

Beschreibung   fstat setzt die Mitglieder einer Struktur des Typs
               \#stat\# mit Informationen ber die durch handle ange-
               gebene Datei und ist nur auf offene Dateien anwendbar.

Ergebnis       fstat liefert bei fehlerfreier Ausfhrung den Wert 0
               zurck. Im Falle eines Fehlers ist das Resultat -1 und
               \#errno\# erh„lt den entsprechenden Wert EBADF.

Querverweis    \#stat\#
\end

screen( capsensitive("getcurdir") )
Name           get current directory - ermittelt das momentan
               gesetzte Directory eines Laufwerks.

Definition     int  getcurdir( int drive, char *directory );

Prototyp in    ext.h

Beschreibung   getcurdir ermittelt das als Standard gesetzte Directory
               auf dem durch drive angegebenen Laufwerk. Wenn drive
               den Wert 0 hat, wird das momentan gesetzte Laufwerk
               verwendet, ansonsten gilt A = 1, B = 2 usw.
               Der durch directory bezeichnete String muá eine L„nge
               von MAXDIR (106 Zeichen) haben - hier tr„gt getcurdir
               den Namen des gesetzten Directories ein (ohne
               fhrende/folgende umgekehrte Schr„gstriche und
               ohne Laufwerksbezeichner/Doppelpunkt). Die Konstante
               MAXDIR ist in ext.h definiert.

Ergebnis       Bei fehlerfreier Ausfhrung liefert getcurdir den
               Wert 0 zurck, ansonsten den Wert -1.

Beispiel       #include <ext.h>
               #include <stdio.h>
               #include <string.h>

               char *pathnow (char *path)
               {
                   strcpy (path, " :\\");
                   path[0] = 'A' + getdisk();  /* Laufwerk */
                   getcurdir(0, path+3);
                   return(path);
               }

               main()
               {
                   char mypath[MAXDRIVE+MAXPATH];
                   printf("Momentan gesetztes Directory: %s\\n",
                          pathnow(mypath));
               }

Portabilit„t   Pure- und Turbo-C-spezifisch.

Querverweis    \#chdir\#, \#getcwd\#
\end

screen( capsensitive("getcwd") )
Name           get current working directory - liefert das momentan
               gesetzte Directory als vollst„ndigen Suchweg zurck.

Definition     char *getcwd(char *buf, int buflen);

Prototyp in    ext.h

Beschreibung   getcwd liefert das momentan gesetzte Directory
               (inklusive des Laufwerks) als String zurck, dessen
               Maximall„nge durch den Parameter buflen gesetzt wird
               (hier wird man normalerweise die Konstante MAXPATH
               verwenden).
               Wenn der als buf bergebene Zeiger den Wert NULL hat,
               belegt getcwd ber einen Aufruf von malloc selbst„ndig
               einen Bereich von buflen Bytes. Durch diese Automatik
               gibt es zwei m”gliche Arten des Aufrufs:

               char *bufpoint;
               char pathbuf[MAXPATH];

               getcwd(pathbuf,MAXPATH);
               bufpoint = getcwd(NULL,MAXPATH);

               Ein durch die zweite Form des Aufrufs automatisch
               belegter Speicherbereich kann via free wieder
               freigegeben werden.

Ergebnis       Bei fehlerfreier Ausfhrung liefert getcwd einen Zeiger
               auf den gesetzten String zurck. Im Falle eines Fehlers
               ist das Funktionsergebnis NULL, \#errno\# wird auf einen der
               folgenden Werte gesetzt:
               ENODEV Ger„t nicht bereit/nicht vorhanden
               ENOMEM nicht genug Platz im Hauptspeicher
                      (Fehlermeldung von malloc)
               ERANGE Ergebnis auáerhalb des Bereichs
                      (ungltige Angabe fr buflen).

Portabilit„t   Pure- und Turbo-C-spezifisch.

Querverweis    \#free\#, \#getcurdir\#, \#malloc\#
\end

screen( capsensitive("getdisk") )
Name           get disk - liefert das momentan gesetzte Laufwerk.

Definition     int  getdisk( void );

Prototyp in    ext.h

Beschreibung   getdisk ermittelt die Nummer des momentan gesetzten
               Laufwerks als Integer (0 entspricht Laufwerk A,
               1 entspricht Laufwerk B usw.).

Beispiel       Siehe \#getcurdir\#

Ergebnis       getdisk liefert das momentan gesetzte Laufwerk zurck.

Portabilit„t   Pure- und Turbo-C-spezifisch.

Querverweis    \#setdisk\# \#getcurdir\#
\end

screen( capsensitive("getdfree") )
Name           get disk free - ermittelt den freien Platz auf einer
               Diskette/Festplatte.

Definition     void  getdfree( unsigned char drive, \link("df_sclus")struct dfree\# *dtable );

Prototyp in    ext.h

Beschreibung   getdfree verwendet die Funktion, um Informationen ber
               den freien Platz auf dem durch drive angegebenen Lauf-
               werk in einer Struktur des Typs dfree zurckzuliefern.
               Wenn drive den Wert 0 hat, wird das momentan gesetzte
               Laufwerk bearbeitet, ansonsten gilt A = 1, B = 2 usw.

Ergebnis       getdfree hat kein direktes Funktionsergebnis. Im Falle
               eines Fehlers bekommt das Mitglied df_sclus den Wert
               -1 zugewiesen.

Portabilit„t   Pure- und Turbo-C-spezifisch.
\end

screen( capsensitive("signal") )
Name           ¯signal® - legt fest, wie das Programm auf Software-
               oder Hardware-Signale (Ausnahmezust„nde) reagiert.

Definition     \#sigfunc_t\# signal( int sig, \#sigfunc_t\# func );

Prototyp in    signal.h

Beschreibung   Hardware-Ausnahme-Zust„nde wie illegale Befehle,
               Bus- oder Adrefehler, ¯Interrupts® (z.B. vom
               Timer-Baustein), aber auch Software-¯Interrupts® wie
               der TRAP-Befehl l”sen ein Software-Signal (technisch:
               eine ¯Exception®) aus, auf die ein Pure-C-Programm in
               zwei Schritten reagiert:

               1. Prfung, welche Aktion auf dieses Signal hin
                  ausgefhrt werden soll, d.h. Auslesen einer Tabelle;
               2. Ausfhrung dieser Aktion, d.h. Aufruf einer
                  entsprechenden Routine.

               šber die Funktion signal() kann der Programmierer in
               diesen Ablauf eingreifen - mit ihr lassen sich nicht
               nur Eintr„ge der "Aktions-Tabelle" ver„ndern, sondern
               auch eigene Routinen installieren.

               signal.h definiert zwei Standard-Routinen (SIG_DFL,
               SIG_IGN) und zwei "magische" Konstanten (SIG_ERR,
               SIG_SYS) zur Behandlung von Signalen. Dabei sind
               SIG_DFL und SIG_IGN sowohl Parameter als auch Ergebnis,
               SIG_SYS nur Parameter und SIG_ERR nur Ergebnis von
               signal():

               SIG_DFL  (¯signal default®) - beendet das Programm
               SIG_IGN  (¯signal ignore®) - ignoriert das Signal,
                        das Programm wird fortgesetzt
               SIG_SYS  (¯signal system®) - setzt den Prozessor-
                        ¯Exception-Vektor® fr dieses Signal auf den
                        ursprnglichen Wert zurck, der vor dem
                        erstmaligen Aufruf von signal() gesetzt war
               SIG_ERR  (¯signal error®) - wird benutzt, um eine
                        Fehlerbedingung bei der Ausfhrung von signal()
                        anzuzeigen (d.h. einen Fehler beim Setzen eines
                        Eintrags)

               Die momentan definierten Signaltypen zusammen mit der
               "Standard-Aktion" des Programms sind:
               1. Alle ¯Exceptions® der 68000 CPU von Nr. 2 bis 79
                  sind fr signal() definiert, dabei sind die fr den
                  Atari relevanten als Konstanten in signal.h
                  vorhanden. Damit ist es m”glich, statt mit "Bomben"
                  individuell auf jede Fehler-Situation zu reagieren;
                  trotzdem fhren alle ¯Exceptions® standardm„ig zur
                  blichen Aktion: also Bomben, Betriebssystemaufruf
                  oder ¯Interrupt®-Behandlung.
                  Von ANSI bernommen wurden die Signale:

                  SIGSEGV  (¯segment violation®) - hier: Bus-Fehler.
                  SIGILL   (¯illegal operation®) - hier: Illegaler Befehl.

                  ACHTUNG: Bei Bus- und Adrefehlern ist die Adresse des 
                           folgenden Befehls nicht eindeutig feststellbar
                           (auf dem 68000), eine nochmalige Ausfhrung des
                           fehlerhaften Befehls ist auch nicht sinnvoll,
                           daher darf eine Routine zur Behandlung dieser
                           Fehler auf keinen Fall mit rts beendet werden;
                           nur ein longjmp() oder die Terminierung des
                           Programms sind erlaubt.

                  Bei den "richtigen" ¯Interrupts® (SIGSPURI, SIGAUTO1
                  - SIGAUTO7, SIGMFP0 - SIGMFP15) sollte man beachten,
                  daá das TOS im wesentlichen nicht reentrant ist,
                  deshalb sollten Betriebssystemaufrufe in diesen F„llen
                  unterbleiben; auerdem ist auf Krze zu achten, ANSI
                  erlaubt z.B. nur eine Zuweisung an einen "atomaren"
                  Datentyp (in signal.h als sig_atomic_t definiert).
                  Wichtig ist auch, da der interne Handler beim Auf-
                  treten einer ¯Exception® erst signal(act_sig, SIG_DFL)
                  ausfhrt (dazu unten mehr).
                  
                  HINWEIS: Das ¯Interrupt-In-Service®-Bit im MFP wird 
                           automatisch auf jeden Fall nach Ausfhrung
                           der Benutzer-Routine gel”scht. Bestimmte MFP-
                           ¯Interrupts® mssen erst mit Jenabint() ein-,
                           bzw. mit Jdisint() ausgeschaltet werden!
                  
                  2. Daneben gibt es noch vier zus„tzlich von ANSI vorge-
                  schriebene Signale, die bis auf SIGABRT und SIGINT von
                  dieser Implementation nicht erzeugt werden.
                  Diese verhalten sich wie folgt:

                  SIGABRT  (¯abort®) - gibt "ABNORMAL PROGRAM TERMINA"
                           "TION" ber GEMDOS aus und beendet das Pro-
                           gramm via _exit( 3 ). Wird auch durch abort()
                           erzeugt.
                  SIGINT   (¯interrupt®) - der Benutzer hat CTRL-d ge-
                           drckt, um das Programm zu unterbrechen;
                           beendet das Programm durch _exit( 2 ).
                  SIGFPE   (¯floating point error®) - tritt nur durch
                           raise() auf; fhrt zur Beendigung des Pro-
                           gramms durch _exit( 2 ).
                  SIGTERM  (¯termination®) - tritt nur durch raise()
                           auf; fhrt zur Beendigung des Programms
                           durch _exit( 2 ).

                  3. Zus„tzlich sind noch zwei unter UNIX bliche Signale
                  definiert, die standardm„ig SIG_DFL ausfhren:
                  SIGALRM und SIGKILL.
               
               Der Ablauf im Detail
               Wenn eine ¯Exception® auftritt (d.h. die vom Prozessor
               untersttzten Signale, also alle bis auf SIGINT, SIGTERM,
               SIGFPE, SIGABRT, SIGALRM und SIGKILL) wird, solange keine
               eigene Routine installiert wurde, direkt die bliche
               Aktion ausgefhrt (also Bomben, Betriebssystemaufruf,
               ¯Interrupt®-Behandlung).
               Fr alle Signale, egal wie erzeugt, gilt:
               
               Die Laufzeitbibliothek prft, ob fr den aufgetretenen
               Signaltyp eine Behandlungsroutine installiert ist.
               - wenn nein, wird das Programm beendet, so als ob
                 SIG_DFL gesetzt ist.
               - wenn ja, dann wird der "Aktions-Eintrag" fr diesen
                 Signaltyp auf SIG_DFL zurckgesetzt und die Behand-
                 lungsroutine mit dem Signaltyp als Parameter aufge-
                 rufen - das n„chste Signal derselben Art hat also
                 die Beendigung des Programms zur Folge.


Ergebnis       Bei fehlerfreier Ausfhrung liefert signal() den
               vorherigen "Aktions-Eintrag" zurck (d.h. einen
               Zeiger auf die Routine, die zuvor als Behandlungs-
               routine fr dieses Signal gesetzt war). Im Falle
               eines Fehlers ist das Ergebnis von signal() der
               Zeiger SIG_ERR, errno bekommt den Wert EINVAL.

Portabilit„t   ANSI C, UNIX

Querverweis    \#abort\#, \#_exit\#, \#longjmp\#, \#errno\#, \#raise\#,
               \#sigfunc_t\#
\end

screen( capsensitive("raise") )
Name           raise - Verschicken eines Software-Signals.

Definition     int  raise( int sig );

Prototyp in    signal.h

Beschreibung   raise schickt das Signal sig an das Program.
               Wenn das Programm eine Signal-Behandlung fr
               das Signal sig installiert hat, wird die Signal-
               Behandlungsroutine ausgefhrt. Andernfalls
               wird die \link("signal")Standardbehandlung\# durchgefhrt.

Ergebnis       raise liefert bei fehlerfreier Ausfhrung den
               Wert 0 zurck (natrlich nur, wenn die dadurch
               aufgerufene Behandlungsroutine das Programm nicht
               abbricht oder an einer anderen Stelle fortsetzt);
               fr undefinierte Werte von sig ist das Resultat
               von Null verschieden.

Querverweis    \#abort\#, \#_exit\#, \#longjmp\#, \#errno\#, \#signal\#,
               \#sigfunc_t\#
\end

screen( capsensitive("sleep") )
Name           sleep - h„lt die Ausfhrung des Programms fr einen
               bestimmten Zeitraum an.

Definition     void  sleep( unsigned seconds );

Prototyp in    ext.h

Beschreibung   sleep h„lt die Ausfhrung fr die durch seconds
               angegebene Anzahl von Sekunden an und verwendet die Uhr
               des Systems, ist also maschinenunabh„ngig.

Ergebnis       sleep hat kein direktes Funktionsergebnis.

Portabilit„t   Auf UNIX-Systemen verfgbar.

Querverweis    \#clock\#, \#delay\#
\end

screen( capsensitive("delay") )
Name           delay - wartet die angegebene Anzahl von Millisekunden.

Definition     void  delay( unsigned milliseconds );

Prototyp in    ext.h

Beschreibung   delay arbeitet im Gegensatz zu einer normalen
               Leerschleife unabh„ngig vom verwendeten Computermodell:
               beim Start des Programms wird mit Hilfe der Systemuhr
               festgestellt, wie schnell der Prozessor arbeitet, und
               ein entsprechender Z„hler festgelegt. Dieser Z„hler ist
               allerdings eine Ann„herung: ein Aufruf wie
                   delay(60000);
               l„át den Computer je nach Modell zwischen 59 und 61
               Sekunden warten - hundertprozentig genau ist delay also
               nicht.

Ergebnis       delay liefert keinen Wert zurck.

Portabilit„t   Pure- und Turbo-C-spezifisch.

Querverweis    \#sleep\#
\end

screen( capsensitive("floor") )
Name           ¯floor® - rundet in Richtung auf die n„chst-
               niedrigere ganze Zahl.

Definition     double  floor( double x );

Prototyp in    math.h

Beschreibung   floor rundet in Richtung niedrigerer Integerwerte ab:
               floor( 3.2 )   ergibt 3.0
               floor( -1.8 )  ergibt -2

Ergebnis       floor liefert ihr ganzzahliges Ergebnis als \link("%%GLOBAL%%")double\#
               zurck.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#ceil\#   \#abs\#
\end

screen( capsensitive("fmod") )
Name           ¯float modulus® - berechnet den Restwert der
               Division x/y.

Definition     double  fmod( double x, double y );

Prototyp in    math.h

Beschreibung   fmod liefert den Rest der Division x/y zurck,
               berechnet also x Modulo y. Ein Aufruf mit den
               Werten 23.345 und 1 ergibt 0.345, ein Aufruf mit
               den Werten 17.4 und 10 ergibt 7.4 usw. Etwas
               mathematischer formuliert: fmod liefert den
               Wert f der Gleichung x = iy + f zurck, wobei
               i einen Integer darstellt und f die Bedingung
               0 <= f < y erfllt.

Ergebnis       fmod liefert den Divisionsrest von x/y als \link("%%GLOBAL%%")double\#.
               Fr y = 0 erh„lt man 0.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#modf\#
\end

screen( capsensitive("fopen") )
Name           ¯file open® - er”ffnet eine Datei.

Definition     FILE  *fopen( const char *filename, const char *\#mode\# );

Prototyp in    stdio.h

Beschreibung   fopen er”ffnet die durch filename bezeichnete Datei und
               ordnet ihr einen Stream zu. Zurckgeliefert wird ein
               Zeiger auf diesen Stream, ber den weitere Operationen
               mit dieser Datei ausgefhrt werden k”nnen.

Ergebnis       Die Funktion liefert bei fehlerfreier Ausfhrung einen
               Zeiger auf einen Stream zurck. Im Falle eines
               Fehlers wird der Wert \link("%%GLOBAL%%")NULL\# zurckgeliefert.

Gruppe         \#I/O-Routinen\#

Querverweis    \#creat\#   \#fclose\#   \#ferror\#   \#fread\#   \#fseek\#
               \#getc\#    \#gets\#     \#open\#     \#putc\#    \#puts\#
               \#rewind\#  \#setbuf\#   \#freopen\#  \#Fopen\#
\end

screen( "mode" )
Der Parameter mode in \#fopen\# kann einen der folgenden Werte annehmen:

"r"    READ: Er”ffnung im \#Textmodus\# ausschlielich fr Lese-
       operationen - die angegebene Datei mu existieren.
"w"    WRITE: Erzeugung einer Datei im \#Textmodus\# fr
       Schreiboperationen - falls die Datei bereits existiert, wird
       ihr vorheriger Inhalt gel”scht.
"rb"   wie "r", jedoch im \#Bin„rmodus\#
"wb"   wie "w", jedoch im \#Bin„rmodus\#
"a"    APPEND: Er”ffnung fr Schreiboperationen. Falls die Datei
       bereits existiert, werden zus„tzliche Informationen an das
       momentane Dateiende angefgt, ansonsten wird sie automatisch
       erzeugt.
"r+"   Er”ffnung einer Datei fr Lese- und Schreiboperationen - die
       Datei mu bereits existieren.
"w+"   Er”ffnung einer neuen Datei fr Lese- und Schreiboperationen.
       Falls die Datei bereits existiert, wird ihr vorheriger Inhalt
       gel”scht.
"a+"   Er”ffnung einer Datei zum Lesen und ¯Anh„ngen® neuer Daten
       durch Schreiboperationen. Falls die Datei bereits existiert,
       bleibt ihr alter Inhalt erhalten - falls nicht, wird sie
       automatisch erzeugt.

Mit r+ und w+ er”ffnete Dateien k”nnen sowohl gelesen als auch
beschrieben werden - zwischen einem Wechsel von ¯Lesen® nach
¯Schreiben® und umgekehrt mu allerdings ein \#fseek\# oder \#rewind\#
stattfinden.
Leseoperationen, bei denen das Dateiende erreicht wird, bilden eine
Ausnahme: hier kann direkt eine Schreiboperation folgen.Der vorherige
Inhalt von mit a oder a+ er”ffneten Dateien ist gegen
Schreiboperationen geschtzt - ein rewind oder fseek ist zwar m”glich,
jede Schreiboperation setzt die momentane Position aber automatisch
wieder auf das momentane Dateiende. Anders gesagt:
Neu geschriebene Daten werden grunds„tzlich angeh„ngt - zum
šberschreiben bereits existierender Datens„tze mu die Datei mit r+
er”ffnet werden.

Querverweis     \#fopen\#   \#freopen\#
\end

screen( "Textmodus",
		"Bin„rmodus" )
Standardm„ig ist bei \#fopen\# der Textmodus eingestellt.
Wenn im String der zus„tzliche Parameter b erscheint,
wird die Datei im Bin„rmodus er”ffnet. Das bedeutet, da die
standardm„ige šbersetzung von CR/LF-Kombinationen in '\\n', wie sie
im Text-Modus vorgenommen wird, nicht stattfindet.

Textmodus:     $0D (CR) wird nicht gelesen.
               Fr jedes $0A (LF) wird $0D0A (CR LF) geschrieben.
Bin„rmodus:    Es wird Byte fr Byte gelesen und geschrieben.

Querverweis    \#fopen\#   \#freopen\#
\end

screen( capsensitive("fprintf") )
Name           ¯file print formatted® - formatierte Ausgabe zu einer
               Datei.

Definition     int  fprintf( FILE *stream, const char *format, ... );

Prototyp in    stdio.h

Beschreibung   Alle \#printf\#-Funktionen ¯drucken® in formatierter
               Form und erwarten zumindest einen \link("Format-String (printf)")Format-String\#
               (¯file printf®) - wie \#printf\#, die Ausgabe geschieht
               in den angegebenen Stream

Ergebnis       S„mtliche Varianten von \#printf\# liefern die Anzahl der
               ausgegebenen Zeichen als Funktionsergebnis zurck.
               Im Falle eines Fehlers ist das Funktionsergebnis EOF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fread\#    \#putc\#      \#puts\#       \#scanf\#    \#va_...\#
               \#printf\#   \#vfprintf\#  \#vsprintf\#   \#sprintf\#
\end

screen( capsensitive("fputc") )
Name           ¯file put character® - Ausgabe eines Zeichens
               zu einer Datei.

Definition     int  fputc( int ch, FILE *fp );

Prototyp in    stdio.h

Beschreibung   Die Funktion fputc gibt das Zeichen ch zu dem durch fp
               angegebenen stream aus.

Ergebnis       fputc liefert das bergebene Zeichen ch auch als
               Funktionsergebnis zurck. Im Falle eines Fehlers
               liefert die Funktionen den Wert EOF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#ferror\#   \#fopen\#    \#fread\#   \#getc\#     \#printf\#
               \#puts\#     \#setbuf\#   \#putc\#    \#putchar\#  \link("%%GLOBAL%%")Escapesequenzen\#
\end

screen( capsensitive("fputs") )
Name           ¯file put string® - Ausgabe eines Strings zu einer
               Datei.

Definition     int  fputs( const char *s, FILE *fp );

Prototyp in    stdio.h

Beschreibung   fputs schreibt den nullterminierten String s in den
               via fp angegebenen stream, wobei kein automatischer
               Zeilenvorschub angeh„ngt wird und das abschlieende
               Null-Byte des Strings nicht kopiert wird.

Ergebnis       Bei fehlerfreier Ausfhrung liefert fputs den Wert
               des zuletzt geschriebenen Zeichens zurck. Im Falle
               eines Fehlers liefert die Funktion den Wert EOF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#puts\#   \#ferror\#   \#fopen\#   \#fread\#   \#gets\#
               \#open\#   \#printf\#   \#putc\#    \link("%%GLOBAL%%")Escapesequenzen\#
\end

screen( capsensitive("fread") )
Name           ¯file read® - liest Daten von einer Datei.

Definition     size_t  fread( void *ptr, size_t elem_Size,
                               size_t count, FILE *stream );

Prototyp in    stdio.h

Beschreibung   fread liest count Datenelemente, die jeweils die Gr”e
               elem_Size haben, von der durch stream bezeichneten
               Datei in den Speicherbereich, auf den ptr zeigt.
               Die Funktionen liest count * elem_Size Bytes. ptr kann
               auf beliebige Datenkonstrukte (typischerweise Arrays)
               zeigen - solange es sich um einen typisierten Zeiger
               handelt, ist die Angabe von elem_Size durch
               sizeof(*ptr) m”glich.

Ergebnis       Die Funktion liefert bei fehlerfreier Ausfhrung
               die Anzahl der gelesenen Elemente (nicht: Bytes)
               zurck. Im Falle eines Fehlers oder dem Erreichen
               des Dateiendes, wird die Anzahl von Elementen zurck-
               geliefert, die noch fehlerfrei gelesen werden konnte.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fwrite\#   \#fopen\#   \#fgetc\#   \#gets\#    \#printf\#
               \#putc\#     \#puts\#    \#read\#    \#scanf\#   \#write\#
               \#size_t\#   \#Fread\#
\end

screen( capsensitive("free") )
Name           ¯free® - gibt einen dynamisch belegten Speicherblock
               wieder frei.

Definition     void  free( void *ptr );

Prototyp in    stdlib.h

Beschreibung   free gibt einen zuvor mit \#malloc\#, \#calloc\# oder
               \#realloc\# belegten Block wieder frei, wobei der
               bergebene Zeiger ptr auf die Startadresse dieses
               Bereichs zeigen mu.

Ergebnis       free hat kein direktes Funktionsergebnis.

Gruppe         \link("Dynamische Verwaltung des Spe")Dynamische Verwaltung des Speichers\#

Querverweis    \#setbuf\#
\end

screen( capsensitive("freopen") )
Name           ¯file re-open® - wechselt die einem stream zugeordnete
               Datei.

Definition     FILE  *freopen( const char *filename, const char *\#mode\#,
                                FILE *stream );

Prototyp in    stdio.h

Beschreibung   freopen er”ffnet die durch filename angegebene Datei
               und ordnet sie der Datei stream zu. Anders gesagt:
               freopen wechselt die stream zugeordnete Datei.
               In den meisten F„llen wird diese Funktion auf stdin,
               stdout und stderr zur Umleitung von Ein-/Ausgaben
               verwendet.
               Achtung: Die ¯alte® Datei wird immer geschlossen
                        - unabh„ngig davon, ob die Er”ffnung der
                        neuen Datei fehlerfrei verl„uft oder nicht.

Ergebnis       Die Funktion liefert bei fehlerfreier Ausfhrung einen
               Zeiger auf einen stream zurck (der identisch mit dem
               alten stream ist). Im Falle eines Fehlers wird der
               Wert \link("%%GLOBAL%%")NULL\# zurckgeliefert.

Gruppe         \#I/O-Routinen\#

Querverweis    \#creat\#    \#fclose\#   \#ferror\#   \#fread\#   \#fseek\#
               \#getc\#     \#gets\#     \#open\#     \#putc\#    \#puts\#
               \#rewind\#   \#setbuf\#   \#fopen\#
\end

screen( capsensitive("frexp") )
Name           ¯float remnant/exponent® - liefert die Mantisse und
               den bin„ren Exponenten einer Fliekommazahl in zwei
               getrennten Werten zurck.

Definition     double  frexp( double value, int *exponent );

Prototyp in    math.h

Beschreibung   frexp berechnet aus value eine Mantisse x
               (absoluter Wert gr”er 0.5 und kleiner 1.0) zusammen
               mit einen Eponenten der Basis 2, bildet also eine
               (bin„r) normalisierte Fliekommazahl. Anders gesagt:
               frexp erfllt die Gleichung value = x * 2 ^ n.

Ergebnis       Die Mantisse x wird als Funktionsergebnis zurck-
               geliefert.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#exp\#
\end

screen( capsensitive("fscanf") )
Name           ¯file scan formatted® - formatiertes Lesen einer
               Datei.

Definition     int  fscanf( FILE *stream, const char *format, ... );

Prototyp in    stdio.h

Beschreibung   fscanf liest stream in formatierter Form und erwartet
               zumindest einen \link("Format-String (printf)")Format-String\# (Parameter format),
               ber den die Anzahl der Eingaben und ihr Format
               festgelegt wird. Gelesene Eingaben werden in den
               Variablen der Parameterliste gespeichert

Ergebnis       fscanf liefert die Anzahl der fehlerfrei gelesenen
               Felder als Funktionsergebnis zurck, wobei mit *
               unterdrckte Felder nicht gez„hlt werden.
               Wenn berhaupt keine Zuweisungen erfolgt sind, hat das
               Ergebnis den Wert 0.
               Der Versuch, ber das Ende einer Datei bzw. ber das
               Ende eines Strings hinaus zulesen (\#sscanf\#), ergibt
               den Wert EOF als Funktionsergebnis.

Gruppe         \#I/O-Routinen\#

Querverweis    \#atof\#    \#getc\#    \#fread\#   \#printf\#   \#va_...\#
               \#scanf\#   \#sscanf\#  \#vfscanf\#
\end

screen( capsensitive("vfscanf") )
Name           ¯file scan formatted® - formatiertes Lesen einer
               Datei.

Definition     #include <stdarg.h>
               int  vfscanf( FILE *stream, const char *format,
                             \#va_list\# param );

Prototyp in    stdio.h

Beschreibung   Die v...scanf-Funktionen verhalten sich „hnlich wie
               ihre ...scanf-Gegenstcke, sie akzeptieren jedoch
               einen Pointer auf eine Liste von Argumenten anstelle
               der Liste selber.
               vfscanf liest stream in formatierter Form und erwartet
               zumindest einen \link("Format-String (printf)")Format-String\# (Parameter format),
               ber den die Anzahl der Eingaben und ihr Format
               festgelegt wird. Gelesene Eingaben werden in den
               Variablen der Parameterliste gespeichert.

Ergebnis       vfscanf liefert die Anzahl der fehlerfrei gelesenen
               Felder als Funktionsergebnis zurck, wobei mit *
               unterdrckte Felder nicht gez„hlt werden.
               Wenn berhaupt keine Zuweisungen erfolgt sind, hat das
               Ergebnis den Wert 0.
               Der Versuch, ber das Ende einer Datei bzw. ber das
               Ende eines Strings hinaus zulesen (\#sscanf\#), ergibt
               den Wert EOF als Funktionsergebnis.

Portabilit„t   vfscanf ist auf UNIX-Systemen verfgbar.

Gruppe         \#I/O-Routinen\#

Querverweis    \#atof\#    \#getc\#    \#fread\#   \#printf\#   \#va_...\#
               \#scanf\#   \#sscanf\#  \#fscanf\#
\end

screen( capsensitive("fseek") )
Name           ¯file seek® - setzt die momentane Position
               innerhalb einer Datei fr folgende Lese und/oder
               Schreibaktionen.

Definition     int  fseek( FILE *stream, long offset, int mode );

Prototyp in    stdio.h

Beschreibung   fseek setzt innerhalb der durch stream bezeichneten
               Datei die Position. Der Parameter offset gibt jeweils
               die zu setzende Entfernung in Bytes an, die Art der
               Positionierung wird ber drei in stdio.h definierte
               Konstanten fr mode festgelegt:

               SEEK_SET  (Wert 0) - relativ zum Dateianfang.
               SEEK_CUR  (Wert 1) - relativ zur vorherigen Position.
               SEEK_END  (Wert 2) - relativ zum Dateiende.

               In Dateien, die fr Lese- und Schreiboperationen
               er”ffnet worden sind, kann nach fseek zwischen
               ¯Lesen® und ¯Schreiben® gewechselt werden. Mit
               \#ungetc\# zurckgestellte Zeichen sind nach fseek
               nicht mehr erreichbar.

Portabilit„t   fseek ist auf allen UNIX-Systemen verfgbar und in
               ANSI C definiert.

Ergebnis       fseek liefert bei fehlerfreier Ausfhrung den Wert 0
               zurck, ansonsten einen Wert ungleich 0.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fopen\#   \#getc\#   \#lseek\#   \#setbuf\#   \#ungetc\#
               \#Fseek\#
\end

screen( capsensitive("fsetpos") )
Name           ¯file set position® - Datei-Position auf alten
               Wert zurcksetzen.

Definition     int  fsetpos( FILE *stream, fpos_t *pos );

Prototyp in    stdio.h

Beschreibung   Die Funktion fsetpos setzt den Datei-Zeiger der Datei
               stream auf eine mit \#fgetpos\# gespeicherte Position pos.
               Das End-Of-File-Flag wird gel”scht. Mit \#ungetc\#
               zurckgestellte Zeichen sind nach fsetpos nicht mehr
               erreichbar.

Ergebnis       Die Funktion liefert den Wert 0, wenn die Datei-Position
               ermittelt werden konnte, ansonsten einen Fehlercode.
               \#errno\# wird auf einen Wert ungleich 0 gesetzt.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fgetpos\#
\end

screen( capsensitive("ftell") )
Name           ¯file tell® - ermittelt die momentane Position
               innerhalb einer Datei.

Definition     long  ftell( FILE *stream );

Prototyp in    stdio.h

Beschreibung   ftell liefert die momentane Position innerhalb der
               durch stream bezeichneten Datei zurck (relativ
               zum Dateianfang, Z„hlung in einzelnen Bytes).

Ergebnis       Im Bin„rmodus liefert ftell die momentane Position
               innerhalb der angegebenen Datei als long zurck, im
               Textmodus jedoch nur eine "magic number", die nur fr
               \#fseek\# verwendet werden kann.
               Falls sich bei dieser Operation ein Fehler ereignen
               sollte, hat das Funktionsergebnis den Wert -1L und
               \#errno\# erh„lt einen positiven Wert.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fseek\#   \#rewind\#
\end

screen( capsensitive("fwrite") )
Name           ¯file write® - schreibt Daten in eine Datei.

Definition     size_t  fwrite( const void *ptr, size_t elem_Size,
                                size_t count, FILE *stream );

Prototyp in    stdio.h

Beschreibung   fwrite ist das Gegenstck zu \#fread\# und schreibt
               count Datenelemente mit jeweils elem_Size Bytes (die
               von einem Speicherbereich gelesen werden, dessen
               Startadresse durch ptr gegeben ist). Die Funktion
               schreibt count * elem_Size Bytes. ptr kann auf
               beliebige Datenkonstrukte (typischerweise Arrays)
               zeigen - solange es sich um einen typisierten Zeiger
               handelt, ist die Angabe von elem_Size durch
               \link("%%GLOBAL%%")sizeof\#(*ptr) m”glich.

Ergebnis       Die Funktion liefert bei fehlerfreier Ausfhrung die
               Anzahl der geschriebenen Elemente (nicht: Bytes)
               zurck. Im Falle eines Fehlers, wird die Anzahl von
               Elementen zurckgeliefert, die noch fehlerfrei
               geschrieben werden konnten.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fread\#   \#fopen\#   \#fgetc\#   \#gets\#    \#printf\#
               \#putc\#    \#puts\#    \#read\#    \#scanf\#   \#write\#
               \#size_t\#   \#Fwrite\#
\end

screen( capsensitive("getc") )
Name           ¯get character® - liest ein Zeichen von einem stream.

Definition     int  getc( FILE *stream );

Prototyp in    stdio.h

Beschreibung   getc ist ein Makro, der das jeweils n„chste Zeichen aus
               der durch stream bezeichneten Datei liest und
               zurckliefert.

Ergebnis       getc liefert bei fehlerfreier Ausfhrung das gelesene
               Zeichen als \link("%%GLOBAL%%")int\# zurck, wobei keine Vorzeichen-
               erweiterung stattfindet.
               Bei šberschreitung des Dateiendes (beim Lesen der
               Tastatur: der Eingabe von control-z) wird der Wert
               EOF zurckgeliefert.

Gruppe         \#I/O-Routinen\#

Querverweis    \#ungetc\#   \#ferror\#   \#fopen\#   \#fread\#   \#fseek\#
               \#gets\#     \#putc\#     \#read\#    \#scanf\#   \#getchar\#
               \#getch\#    \#getche\#   \#fgetc\#
\end

screen( capsensitive("getch") )
Name           ¯get character® - liest ein Zeichen von der Tastatur.

Definition     int  getch( void );

Prototyp in    ext.h

Beschreibung   getch liest ein Zeichen von der Tastatur, ohne es auf
               dem Bildschirm auszugeben.

Ergebnis       getch liefert bei fehlerfreier Ausfhrung das gelesene
               Zeichen als \link("%%GLOBAL%%")int\# zurck, wobei keine Vorzeichen-
               erweiterung stattfindet.

Gruppe         \#I/O-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#getc\#    \#getche\#   \#fgetc\#   \#ungetc\#   \#ferror\#
               \#fopen\#   \#fread\#   \#fseek\#    \#gets\#     \#putc\#
               \#read\#    \#scanf\#
\end

screen( capsensitive("getchar") )
Name           ¯get character® - liest ein Zeichen von stdin.

Definition     int  getchar( void );

Prototyp in    stdio.h

Beschreibung   getchar ist ein Makro, das schlicht als getc(stdin)
               definiert ist. getchar liest das jeweils n„chste
               Zeichen aus stdin.

Ergebnis       getchar liefert bei fehlerfreier Ausfhrung das
               gelesene Zeichen als \link("%%GLOBAL%%")int\# zurck, wobei keine
               Vorzeichenerweiterung stattfindet.
               Bei šberschreitung des Dateiendes (beim Lesen der
               Tastatur: der Eingabe von control-z) wird der Wert
               EOF zurckgeliefert.

Gruppe         \#I/O-Routinen\#

Querverweis    \#getc\#    \#fgetc\#   \#getch\#   \#getche\#   \#ungetc\#
               \#ferror\#  \#fopen\#   \#fread\#   \#fseek\#    \#gets\#
               \#putc\#    \#read\#    \#scanf\#
\end

screen( capsensitive("getche") )
Name           ¯get character® - liest ein Zeichen von der Tastatur
               und gibt es auf dem Bildschirm aus.

Definition     int  getche( void );

Prototyp in    ext.h

Beschreibung   getche liest ein Zeichen von der Tastatur und gibt es
               auf dem Bildschirm aus.

Ergebnis       getch liefert bei fehlerfreier Ausfhrung das gelesene
               Zeichen als \link("%%GLOBAL%%")int\# zurck, wobei keine Vorzeichen-
               erweiterung stattfindet.
               Bei šberschreitung des Dateiendes (beim Lesen der
               Tastatur: der Eingabe  von control-z) wird der Wert
               EOF zurckgeliefert.

Gruppe         \#I/O-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#getc\#    \#getch\#    \#fgetc\#   \#ungetc\#   \#ferror\#
               \#fopen\#   \#fread\#   \#fseek\#    \#gets\#     \#putc\#
               \#read\#    \#scanf\#
\end

screen( capsensitive("getdate") )
Name           ¯get date® - ermittelt das aktuelle Tagesdatum.

Definition     void  getdate( struct date *dateRec );

Prototyp in    ext.h

Beschreibung   Die Funktion getdate ermittelt das aktuelle Tagesdatum.
               Das Datum wird in der Struktur \#date\# dateRec bergeben.

Ergebnis       Die Funktion liefert kein Ergebnis.

Gruppe         \#Datum und Uhrzeit\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#time\#   \#ctime\#   \#setdate\#
\end

screen( capsensitive("getenv") )
Name           ¯get environment® - liest einen Eintrag aus der
               Tabelle Environment.

Definition     char  *getenv( const char *name );

Prototyp in    stdlib.h

Beschreibung   Die vom Betriebssytem eingerichtete Tabelle Environment
               besteht aus einer (unsortierten) Folge von Eintr„gen
               der Form:

               name=Zeichenfolge

               Der ¯bekannteste® Eintrag drfte PATH (Suchwege fr
               ausfhrbare Programme) sein.
               getenv sucht die Tabelle nach dem ber name
               angegebenen Eintrag ab und liefert einen Zeiger auf
               Zeichenfolge zurck.
               Hinweis: der von getenv zurckgelieferte Zeiger
               sollte nicht zur direkten Ver„nderung von Environment-
               Eintr„gen verwendet werden.

Ergebnis       getenv liefert einen Zeiger auf die zu name geh”rende
               Zeichenfolge zurck. Falls kein Eintrag des Namens
               name gefunden werden konnte, liefert getenv \link("%%GLOBAL%%")NULL\#.

Gruppe         \#Verschiedene Routinen\#
\end

screen( capsensitive("getftime") )
Name           ¯get file time® - liest Datum und Uhrzeit einer
               offenen Datei.

Definition     int  getftime( int handle, struct ftime *ftimep );

Prototyp in    ext.h

Beschreibung   getftime ermittelt Datum und Uhrzeit der durch handle
               bezeichneten (offenen) Datei. Datum und Uhrzeit werden
               durch die Struktur \#ftime\# beschrieben.

Ergebnis       Die Funktion liefert bei fehlerfreier Ausfhrung den
               Wert 0. Wenn der angegebene handle nicht existiert
               (d.h. keine entsprechende Datei offen ist), liefert
               getftime den Wert -1 als Ergebnis, \#errno\# bekommt den
               Wert EBADF oder EINVFNC.

Gruppe         \#I/O-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#setftime\#
\end

screen( capsensitive("ftimtotm") )
Name           ¯ftime format to tm format® - Konvertiert den Inhalt
               einer ftime-Struktur in eine tm-Struktur.

Definition     struct tm  *ftimtotm( struct ftime *f );

Prototyp in    ext.h

Beschreibung   ftimtotm konvertiert den Inhalt der Struktur vom
               Typ \#ftime\#, auf die f zeigt in das Format einer
               Struktur vom Typ \#tm\#.

Ergebnis       Die Funktion liefert einen Zeiger auf eine \#tm\#-Struktur.

Gruppe         \#I/O-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#getftime\#       \#asctime\#
\end

screen( capsensitive("gets") )
Name           ¯get string® - liest einen String.

Definition     char  *gets( char *str );

Prototyp in    stdio.h

Beschreibung   Die Funktion gets liest eine Zeichenfolge von der
               Standard-Datei stdin und speichert ihn in der durch
               str angegebenen Stringvariablen. Die Eingabe wird
               durch einen Zeilenvorschub beendet, der in *str
               als Nullzeichen () gespeichert wird.

Ergebnis       gets liefert bei fehlerfreier Ausfhrung
               einen Zeiger auf str zurck. Wenn beim Lesen das
               Dateiende berschritten wird oder ein Fehler auftritt,
               ist das Funktionsergebnis \link("%%GLOBAL%%")NULL\#.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fgets\#   \#ferror\#   \#fopen\#   \#fread\#   \#getc\#
               \#puts\#    \#scanf\#
\end

screen( capsensitive("gettime") )
Name           ¯get time® - ermittelt die Uhrzeit des Systems.

Definition     void  gettime( struct time *timeRec );

Prototyp in    ext.h

Beschreibung   Die Funktion gettime ermittelt die aktuelle Uhrzeit.
               Die Uhrzeit wird in der Struktur \#time\# bergeben.

Ergebnis       Die Funktion liefert kein Ergebnis.

Gruppe         \#Datum und Uhrzeit\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#time\#   \#ctime\#   \#settime\#   \#Gettime\#
\end

screen( capsensitive("isatty") )
Name           ¯is a teletype® - prft, ob ein Ger„t zeichen- oder
               blockorientiert arbeitet.

Definition     int  isatty( int handle );

Prototyp in    ext.h

Ergebnis       Die Funktion liefert ein Ergebnis ungleich 0, wenn
               das ber handle adressierte Ger„t zeichenorientiert
               arbeitet.

Gruppe         \#Pure-C-Spezialfunktionen\#
\end

screen( capsensitive("gmtime") )
Name           ¯Greenwich Mean Time® - rechnet Datum und Uhrzeit
               in die internationale Standardzeit um.

Definition     struct tm  *gmtime( time_t *clock );

Prototyp in    time.h

Beschreibung   gmtime konvertiert direkt in die international
               gltige Greenwich Mean Time (¯GMT®).
               Die globale long-Variable timezone enth„lt den
               Unterschied zwischen der lokalen Zeit und der GMT in
               Sekunden. Die globale Variable daylight darf nur dann
               auf einen Wert ungleich Null gesetzt werden, wenn die
               Standardwerte der USA fr Sommer- und Winterzeit
               angewendet werden k”nnen. Die Funktion arbeitet mit
               einer Tabelle, die die Zeitkorrekturen der Jahre 1974
               und 1975 enth„lt - falls n”tig, kann diese Tabelle
               entsprechend vergr”ert werden. Der Strukturtyp \#tm\#
               ist in time.h definiert.

Ergebnis       gmtime liefert einen Zeiger auf eine  statische
               Struktur, die durch jeden Aufruf dieser Funktion
               erneut gesetzt wird.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#localtime\#   \#getdate\#   \#time\#   \#time_t\#
\end

screen( capsensitive("isalpha") )
Name           ¯isalpha® - Funktion zur Klassifizierung von Zeichen.

Definition     int  isalpha( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prft, ob das bergebene Zeichen c
               ein Buchstabe ( a..z, A..Z ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isalnum") )
Name           ¯isalnum® - Funktion zur Klassifizierung von Zeichen.

Definition     int  isalnum( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prft, ob das bergebene Zeichen c
               ein Buchstabe oder eine Ziffer ( a..z, A..Z, 0..9 )
               ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isascii") )
Name           ¯isascii® - Funktion zur Klassifizierung von Zeichen.

Definition     int  isascii( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prft, ob das bergebene Zeichen c
               ein ASCII-Zeichen ( 0x00..0x7F ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurckgegeben, ansonsten Null.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("iscntrl") )
Name           ¯iscntrl® - Funktion zur Klassifizierung von Zeichen.

Definition     int  iscntrl( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prft, ob das bergebene Zeichen c
               ein Control-Zeichen ( 0x00..0x1F, 0x7F ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isdigit") )
Name           ¯isdigit® - Funktion zur Klassifizierung von Zeichen.

Definition     int  isdigit( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prft, ob das bergebene Zeichen c
               eine Ziffer ( 0..9 ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isgraph") )
Name           ¯isgraph® - Funktion zur Klassifizierung von Zeichen.

Definition     int  isgraph( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prft, ob das bergebene Zeichen c
               ein druckbares Zeichen ( 0x21..0x7E ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("islower") )
Name           ¯islower® - Funktion zur Klassifizierung von Zeichen.

Definition     int  islower( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prft, ob das bergebene Zeichen c
               ein kleingeschriebener Buchstabe ( a..z ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isodigit") )
Name           ¯isodigit® - Funktion zur Klassifizierung von Zeichen.

Definition     int  isodigit( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prft, ob das bergebene Zeichen c
               eine Oktalziffer ( 0..7 ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.
Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isprint") )
Name           ¯isprint® - Funktion zur Klassifizierung von Zeichen.

Definition     int  isprint( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prft, ob das bergebene Zeichen c
               ein druckbares Zeichen ( 0x20..0x7E ) ist. isprint
               verh„lt sich also quasi wie isgraph, mit der Aus-
               nahme, da hier das Leerzeichen ebenfalls als
               druckbar anerkannt wird.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("ispunct") )
Name           ¯ispunct® - Funktion zur Klassifizierung von Zeichen.

Definition     int  ispunct( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prft, ob das bergebene Zeichen c
               ein Punktierungszeichen ist. Dies ist der Fall, wenn
               entweder iscntrl oder isspace wahr ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isspace") )
Name           ¯isspace® - Funktion zur Klassifizierung von Zeichen.

Definition     int  isspace( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prft, ob das bergebene Zeichen c
               ein Leerzeichen, Tabulator, Zeilen- oder Seitenvor-
               schub ( 0x09..0x0D, 0x20 ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isupper") )
Name           ¯isupper® - Funktion zur Klassifizierung von Zeichen.

Definition     int  isupper( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prft, ob das bergebene Zeichen c
               ein Grobuchstabe ( A..Z ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("isxdigit") )
Name           ¯isxdigit® - Funktion zur Klassifizierung von Zeichen.

Definition     int  isxdigit( int c );

Prototyp in    ctype.h

Beschreibung   Diese Funktion prft, ob das bergebene Zeichen c
               eine Hexadezimalziffer ( 0..9, A..F, a..f ) ist.

Ergebnis       Wenn die Bedingung zutrifft, wird ein Wert ungleich
               Null zurckgegeben, ansonsten Null.
               Das Ergebnis ist nur definiert, falls isascii( c )
               ungleich Null oder c gleich EOF ist.

Gruppe         \link("Zeichen-Klassifizierungs-Rout")Zeichen-Klassifizierungs-Routinen\#

Querverweis    \#tolower\#   \#toupper\#
\end

screen( capsensitive("itoa") )
Name           ¯integer to ascii® konvertiert einen Integer in einen
               String.

Definition     char  *itoa( int value, char *string, int radix );

Prototyp in    stdlib.h

Beschreibung   itoa konvertiert den Integer value in einen
               nullterminierten String und speichert das Ergebnis
               in der durch String bezeichneten Variablen.
               Der Parameter radix legt die Basis fest auf der die
               konvertierung stattfinden soll - m”gliche Werte
               liegen im Bereich von 2 bis 36.
               itoa erzeugt maximal 16 Zeichen.

Ergebnis       itoa liefert einen Zeiger auf den gesetzten string
               zurck.

Gruppe         \#Umwandlungsroutinen\#

Querverweis    \#ltoa\#   \#ultoa\#
\end

screen( capsensitive("kbhit") )
Name           ¯keyboard hit® - prft, ob eine Taste gedrckt wurde.

Definition     int  kbhit( void );

Prototyp in    ext.h

Beschreibung   kbhit prft, ob ein Zeichen ber die Tastatur
               eingegeben wurde.

Ergebnis       Wenn eine noch nicht gelesene Eingabe vorliegt,
               liefert kbhit einen Wert ungleich Null, das Zeichen
               kann via \#getch\# gelesen werden. Liegt kein Zeichen
               an, dann liefert kbhit den Wert 0.

Gruppe         \#I/O-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#getc\#
\end

screen( capsensitive("labs") )
Name           ¯long absolute® - liefert den absoluten Wert eines
               long.

Definition     long  labs( long n );

Prototyp in    stdlib.h

Beschreibung   labs liefert den absoluten Wert des \link("%%GLOBAL%%")long\#-Arguments
               n zurck.
               Es handelt es sich um einen ¯echten® Funktionsaufruf.

Ergebnis       labs liefert den Absolutwert des long-Arguments n.
               Fehlerbedingungen sind nicht definiert.

Gruppe         \#Mathematische Routinen\#

Querverweis:   \#abs\#   \#fabs\#
\end

screen( capsensitive("ldexp") )
Name           ¯log double exp® - berechnet value * 2exp.

Definition     double  ldexp( double value, int exp );

Prototyp in    math.h

Beschreibung   ldexp liefert das Ergebnis der Berechnung value = 2 ^
               exponent zurck, ist  also das Gegenstck zu \#frexp\#.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#

Querverweis    \#exp\#
\end

screen( capsensitive("ldiv") )
Name           ¯long division® - berechnet den Rest und den Quotient
               von zwei long-Zahlen.

Definition     \#ldiv_t\#  ldiv( long n, long d );

Prototyp in    stdlib.h

Beschreibung   Die Funktion ldiv berechnet gleichzeitig Quotienten und
               Rest einer Division von zwei long-Zahlen.

Ergebnis       Das Ergebnis wird in der Struktur \#ldiv_t\# abgelegt.

Gruppe         \#Mathematische Routinen\#
\end

screen( capsensitive("localtime") )
Name           ¯local time® - konvertiert Datum/Uhrzeit in eine
                Struktur des Typs \#tm\#.

Definition     struct tm  *localtime( time_t *clock );

Prototyp in    time.h

Beschreibung   localtime konvertiert direkt in die international
               gltige Greenwich Mean Time (¯GMT®), und
               bercksichtigt Zeitzonen und die Sommerzeit.
               Die globale long-Variable timezone enth„lt den
               Unterschied zwischen der lokalen Zeit und der GMT in
               Sekunden. Die globale Variable daylight darf nur dann
               auf einen Wert ungleich Null gesetzt werden, wenn die
               Standardwerte der USA fr Sommer- und Winterzeit
               angewendet werden k”nnen. Die Funktion arbeitet mit
               einer Tabelle, die die Zeitkorrekturen der Jahre 1974
               und 1975 enth„lt - falls n”tig, kann diese Tabelle
               entsprechend vergr”ert werden. Der Strukturtyp \#tm\#
               ist in time.h definiert.

Ergebnis       localtime liefert einen Zeiger auf eine statische
               Struktur, die durch jeden Aufruf dieser Funktion
               erneut gesetzt wird.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#getdate\#   \#time\#   \#time_t\#   \#gmtime\#
\end

screen( capsensitive("log") )
Name           ¯logarithm® - berechnet den natrlichen Logarithmus des
               Arguments.

Definition     double  log( double x );

Prototyp in    math.h

Beschreibung   log liefert den natrlichen Logarithmis n des
               Argumentes x zurck, erfllt also die Gleichung
               x = e ^ n und ist die Umkehrfunktion von \#exp\#.

Ergebnis       Bei einem šberlauf liefert log HUGE_VAL und setzt
               \#errno\# auf den Wert ERANGE. Wenn x kleiner Null
               ist wird errno auf EDOM gesetzt. Fr x gleich Null
               erh„lt man als Resultat minus HUGEVAL und errno
               wird ERANGE zugewiesen.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#exp\#   \#log10\#
\end

screen( capsensitive("log10") )
Name           ¯logarithm 10® - berechnet den Logarithmus des
               Arguments zur Basis 10.

Definition     double  log10( double x );

Prototyp in    math.h

Beschreibung   log10 berechnet den Logarithmus n des Argumentes x
               zur Basis 10, erfllt also die Gleichung x = 10 ^ n.

Ergebnis       Bei einem šberlauf liefert log HUGE_VAL und setzt
               \#errno\# auf den Wert ERANGE. Wenn x kleiner Null
               ist wird errno auf EDOM gesetzt. Fr x gleich Null
               erh„lt man als Resultat minus HUGEVAL und errno
               wird ERANGE zugewiesen.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#

Querverweis    \#log\#   \#exp\#
\end

screen( capsensitive("longjmp") )
Name           ¯long jump® - fhrt ein ¯nicht-lokales® goto aus.

Definition     void  longjmp( jmp_buf env, int value );

Prototyp in    setjmp.h

Beschreibung   Ein Aufruf von longjmp stellt den Zustand wieder her,
               der durch \#setjmp\# gespeichert wurde.
               - der Prozessor setzt die Arbeit an der Stelle fort,
               an der sich der Aufruf von \#setjmp\# befindet.
               Um mit longjmp zu einem Punkt x zu springen, mssen
               die folgenden Schritte ausgefhrt werden:

               ù Deklaration einer globalen Variablen vom Typ jmp_buf,
                 die durch setjmp mit den entsprechenden Register-
                 Inhalten geladen wird.
               ù Ausfhrung von setjmp am Punkt x - also an dem Punkt,
                 zu dem hinterher gesprungen werden soll.

Ergebnis       Der ¯Aufruf® von \#setjmp\# via longjmp setzt das
               Funktionsergebnis von setjmp auf den Wert von value -
               wenn fr value 0 angegeben ist, dann verwendet Pure C
               automatisch den Wert 1.

Gruppe         \#Sprnge\#

Querverweis    \#setjmp\#
\end

screen( capsensitive("lseek") )
Name           ¯long seek® - setzt die momentane Position innerhalb
               einer Datei.

Definition     size_t  lseek( int handle, size_t offset, int whence );

Prototyp in    stdio.h

Beschreibung   lseek entspricht exakt der Funktion fseek - nur da
               hier nicht mit einem Stream, sondern mit einem Handle
               gearbeitet wird. Der Parameter offset gibt jeweils
               die zu setzende Entfernung in Bytes an, die Art der
               Positionierung wird ber drei in stdio.h definierte
               Konstanten fr whence festgelegt:
                    SEEK_SET  0    - relativ zum Dateianfang.
                                     Wenn offset den Wert 0 hat,
                                     wird die Position auf das
                                     erste Byte des Dateiinhalts
                                     gesetzt.
                    SEEK_CUR  1    - relativ zur vorherigen Position.
                                     Negative Werte von offset
                                     verschieben in Richtung
                                     Dateianfang.
                    SEEK_END  2    - relativ zum Dateiende. Wenn
                                     offset den Wert 0 hat, wird
                                     die Position auf das Dateiende
                                     gesetzt.
Portabilit„t   lseek ist auf allen UNIX-Systemen verfgbar.

Ergebnis       lseek liefert bei fehlerfreier Ausfhrung die neue
               Position innerhalb der Datei gemessen in Bytes.
               Bei Anwendung auf Ger„tedateien (wie Terminals,
               Schnittstellen usw.) ist das Funktionsergebnis
               undefiniert. Im Falle eines Fehlers wird der Wert -1
               zurckgeliefert, \#errno\# bekommt einen der folgenden
               Werte:
                       EBADF    EINVAL

Gruppe         \#I/O-Routinen\#

Querverweis    \#fopen\#   \#fseek\#   \#getc\#   \#setbuf\#   \#ungetc\#
\end

screen( capsensitive("ltoa") )
Name           ¯long to ascii® konvertiert einen long in einen
               String.

Definition     char  *ltoa( long value, char *string, int radix );

Prototyp in    stdlib.h

Beschreibung   ltoa konvertiert den long value in einen
               nullterminierten String und speichert das Ergebnis
               in der durch String bezeichneten Variablen.
               Der Parameter radix legt die Basis fest auf der die
               konvertierung stattfinden soll - m”gliche Werte
               liegen im Bereich von 2 bis 36.
               ltoa erzeugt maximal 32 Zeichen.

Ergebnis       ltoa liefert einen Zeiger auf den gesetzten string
               zurck.

Gruppe         \#Umwandlungsroutinen\#

Querverweis    \#itoa\#   \#ultoa\#
\end

screen( capsensitive("malloc") )
Name           ¯memory allocation® - Reservierung von Speicherplatz

Definition     void  *malloc( size_t size );

Prototyp in    stdlib.h

Beschreibung   šber diese Funktion wird der Heap verwaltet.
               malloc belegt einen Speicherbereich von size Bytes auf
               dem Heap und liefert einen Zeiger zurck, der auf die
               Startadresse des neu belegten Bereichs zeigt. Eine
               Initialisierung der durch malloc belegten Speicher-
               zellen findet nicht statt.

Ergebnis       malloc liefert einen typenlosen Zeiger, der explizit
               auf den verwendeten Zeigertyp konvertiert werden sollte.
               Wenn kein Speicherbereich ausreichender Gr”e zur
               Verfgung steht, dann ist das Funktionsergebnis \link("%%GLOBAL%%")NULL\#,
               es findet keine Belegung statt.

Gruppe         \link("Dynamische Verwaltung des Spe")Dynamische Verwaltung des Speichers\#

Querverweis    \#setbuf\#   \#calloc\#   \#realloc\#   \#free\#   \#size_t\#
               \#Malloc\#
\end

screen( capsensitive("setmatherr") )
Name           ¯set math error® - setzt eine Routine zur Behandlung
               von Fliekommafehlern.

Definition     void  setmatherr( int (*errorfunc)(struct exception *e ));

Prototyp in    math.h

Beschreibung   setmatherr setzt eine vom Programmierer frei
               definierbare Routine, die bei Auftreten eines
               Fliekommafehlers angsprungen werden soll. Diese
               Routine k”nnte beispielsweise die exception struktur,
               die bei solch einem Fehler angelegt wird, auswerten.

Ergebnis       Die Funktion liefert kein Ergebnis.

Gruppe         \#Verschiedene Routinen\#

Querverweis    \#exception\#   \#errno\#
\end

screen( capsensitive("offsetof") )
Name           ¯offset of® - ermittelt den Offset eines Strukturele-
               ments.

Definition     size_t  offsetof( type, identifier );

Prototyp in    stddef.h

Beschreibung   offsetof ermittelt den Abstand eines Strukturelements
               vom Strukturanfang.

Ergebnis       Die Funktion liefert den Abstand in Bytes. Falls es
               sich bei identifier um ein Bitfeld handelt, ist das
               Ergebnis undefiniert.

Gruppe         \#Verschiedene Routinen\#
\end

screen( capsensitive("memchr") )
Name           ¯memory character® - Sucht den Speicher nach einem
               Zeichen ab.

Definition     void  *memchr( const void *s, int val, size_t len );

Prototyp in    string.h

Beschreibung   memchr sucht die ersten len Bytes des Arrays s nach dem
               Wert val ab.

Ergebnis       memchr liefert die Adresse der ersten Fundstelle von c
               im Array s zurck - oder \link("%%GLOBAL%%")NULL\#, wenn c innerhalb der
               ersten len Bytes von s nicht vorkommt.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#
\end

screen( capsensitive("memcmp") )
Name           ¯memory compare® - Speicher vergleichen.

Definition     int  memcmp( const void *s1, const void *s2, size_t len );

Prototyp in    string.h

Beschreibung   memcmp vergleicht die ersten len Bytes der Arrays s1
               und s2 miteinander. memcmp behandelt die Bytes als
               unsigned char (der Wert 0xFF ist also gr”er als
               0x7F).

Ergebnis       memcmp bricht den Vergleich beim ersten nicht
               bereinstimmenden Zeichen ab.
               Das Vergleichsergebnis wird als int zurckgeliefert:
                <0  wenn s1 kleiner als s2 ist
                0 wenn die ersten n Zeichen von s1 und s2 gleich sind
                >0  wenn s1 gr”er als s2 ist

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#
\end

screen( capsensitive("memmove") )
Name           ¯memory move® - Speicherbereiche kopieren

Definition     void  *memmove( void *dest, const void *src, size_t len );

Prototyp in    string.h

Beschreibung   memmove kopiert len Bytes von src nach dest und
               bercksichtigt m”gliche šberlappungen von Quell-
               und Zielgebiet automatisch.
               memmove ist identisch mit \#memcpy\#.

Ergebnis       memmove liefert den bergebenen Parameter dest als
               Ergebnis zurck, d.h. einen Zeiger auf das Ziel-Array.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#
\end

screen( capsensitive("memset") )
Name           ¯memory set® - Speicherinhalt setzen

Definition     void  *memset( void *s, int val, size_t len );

Prototyp in    string.h

Beschreibung   memset setzt die ersten len Bytes des Arrays s auf den
               Wert von val.

Ergebnis       memset liefert den bergebenen Parameter s als Ergebnis
               zurck (d.h. ebenfalls einen Zeiger auf das Ziel-Array).

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#
\end

screen( capsensitive("memcpy") )
Name           ¯memory copy® - kopiert einen Speicherbereich

Definition     void  *memcpy( void *dest, const void *src, size_t len );

Prototyp in    string.h

Beschreibung   memcpy kopiert len Bytes von src nach dest und
               bercksichtigt m”gliche šberlappungen von Quell-
               und Zielgebiet automatisch.

Ergebnis       memcpy liefert den bergebenen Parameter dest als
               Ergebnis zurck, d.h. einen Zeiger auf das Ziel-Array.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#
\end

screen( capsensitive("mktime") )
Name           ¯make time® - Datum konvertieren.

Definition     time_t  mktime( struct tm *timeptr );

Prototyp in    time.h

Beschreibung   Die Funktion mktime konvertiert eine Uhrzeit/Datum
               Angabe von der Stuktur \#tm\# in das Format von \#time_t\#.

Ergebnis       Die Funktion liefert Datum/Uhrzeit als Datentyp \#time_t\#.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#ctime\#
\end

screen( capsensitive("modf") )
Name           ¯modulo float® - teilt eine Fliekommazahl in Mantisse
               und Exponenten auf.

Definition     double  modf( double value, double *ipart );

Prototyp in    math.h

Beschreibung   Das Funktionsergebnis ist der Dezimalbruchanteil
               von value, der ganzzahlige Anteil wird in ipart
               gespeichert. Fr einen Wert wie 234.778 wird  also
               0.778 zurckgeliefert, *ipart bekommt den Inhalt
               234.0.

Ergebnis       modf liefert den nicht-ganzzahligen Anteil des
               Arguments value als \link("%%GLOBAL%%")double\#.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#fmod\#
\end

screen( capsensitive("open") )
Name           ¯open® - er”ffnet eine Datei fr Lese- und
               Schreibaktionen.

Definition     int  open( char *filename, int access, ... );

Prototyp in    stdio.h

Beschreibung   open er”ffnet die durch filename angegebene Datei und
               bereitet - je nach den fr access angegebenen Werten
               - folgende Lese- und/oder Schreibaktionen vor. Fr den
               Parameter access sind zwei Arten von Konstanten in
               stdio.h definiert, die ber eine OR-Operation
               miteinander verbunden werden mssen:

               Flags fr Lesen und/oder Schreiben:
O_RDONLY       nur Lesen
O_WRONLY       nur Schreiben
O_RDWR         Lesen und Schreiben

               Flags fr die Art der Er”ffnung
O_APPEND       neu geschriebene Daten werden grunds„tzlich angeh„ngt,
               das šberschreiben bereits existierender Datens„tze ist
               nicht m”glich
O_CREAT        wenn die Datei noch nicht existiert, wird sie erzeugt.
               Falls die Datei bereits existiert, hat dieses Flag
               keine Wirkung
O_TRUNC        wenn die Datei bereits existiert, wird ihr vorheriger
               Inhalt gel”scht, eventuelle Dateiattribute bleiben
               unver„ndert
O_EXCL         wird ignoriert
Hinweise:      Fr jeden Aufruf von open mu genau eines der Flags
               O_RDONLY..O_RDWR angegeben sein - die weiteren Flags
               sind nicht obligatorisch und k”nnen beliebig
               miteinander kombiniert werden. Die optional mit ¯...®
               angegebenen Parameter sind lediglich aus Grnden der
               Kompatibilit„t zur IBM-Version von Pure C beibehalten
               worden. Die Parameter werden auf dem Atari ST/TT
               ignoriert.

Ergebnis       Wenn die Datei fehlerfrei er”ffnet werden konnte,
               liefert open den Handle dieser Datei zurck (einen int
               mit einem Wert gr”er 0, ber den weitere Operationen
               mit dieser Datei ausgefhrt werden). Die momentane
               Position innerhalb der neu er”ffneten Datei wird auf
               den Dateianfang gesetzt. Im Falle eines Fehlers liefert
               die Funktion den Wert -1 als Ergebnis und setzt die
               globale Variable \#errno\# auf einen der folgenden Werte:
               ENOENT         EMFILE         EACCES

Gruppe         \#I/O-Routinen\#

Querverweis    \#close\#   \#creat\#   \#ferror\#   \#fopen\#   \#lseek\#
               \#read\#    \#write\#
\end

screen( capsensitive("perror") )
Name           ¯print error® - gibt eine Systemfehlermeldung via
               stderr aus.

Definition     void  perror( char *s );

Prototyp in    stdio.h

Beschreibung   perror kann nach einem Fehler aufgerufen werden und
               gibt zwei Strings in die Standard-Datei stderr aus
               (der normalerweise der Bildschirm zugeordnet ist):
               ù den (vom Programmierer definierten) String s;
               ù danach einen Doppelpunkt, ein Leerzeichen und einen
                 String des Arrays sys_errlist;
               ù einen Zeilenvorschub.
               Das Array sys_errlist enth„lt s„mtliche Fehlermeldungen
               des Systems in der Reihenfolge aufsteigender
               Fehlernummern - perror verwendet den momentanen Wert
               der globalen Variablen \#errno\# zur Adressierung.
               Der Aufruf von perror sollte direkt nach einem Fehler
               geschehen, weil jede weitere Ein-/Ausgabe-Operation
               \#errno\# erneut setzt (bzw. l”scht).
               Normalerweise wird man den Namen des Programms als
               Argument an perror bergeben - zwingend ist das
               allerdings genausowenig wie die Verwendung der durch
               sys_errlist vorgegebenen Texte (diesem Zeiger-Array
               lassen sich auch eigene Meldungen zuweisen).
               Weitere Details zu \#errno\#, sys_errlist und sys_nerr
               (der h”chsten Fehlernummer) finden Sie in Kapitel 8.

Ergebnis       perror hat kein direktes Funktionsergebnis.

Gruppe         \#I/O-Routinen\#

Querverweis    \#feof\#   \#ferror\#
\end

screen( capsensitive("pow") )
Name           ¯power® - berechnet die y. Potenz von x, also x^y.

Definition     double  pow( double x, double y );

Prototyp in    math.h

Beschreibung   pow liefert das Ergebnis der Berechnung x^y.

Ergebnis       Falls sich das Argument x kleiner Null ist und y
               keine ganze Zahl, so wird \#errno\# auf EDOM gesetzt.
               Wenn beide Argumente Null sind, erh„lt man als
               Resultat 1. Bei einem šberlauf liefert pow HUGE_VAL
               und setzt \#errno\# auf den Wert ERANGE.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#exp\#   \#sqrt\#
\end

screen( capsensitive("pow10") )
Name           ¯power 10® - berechnet die p. Potenz 10, also 10^y.

Definition     double  pow10( int p );

Prototyp in    math.h

Beschreibung   pow10 liefert das Ergebnis der Berechnung 10^y.

Ergebnis       Bei einem šberlauf oder Unterlauf wird \#errno\# auf
               den Wert ERANGE gesetzt.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#exp\#   \#sqrt\#   \#pow\#
\end

screen( capsensitive("printf") )
Name           ¯print formatted® - formatierte Ausgaben.

Definition     int  printf( const char *format, ... );

Prototyp in    stdio.h

Beschreibung   Die printf-Funktion gibt formatierte Ausgaben auf
               dem Bildschirm aus. Sie erwartet dazu mindestens
               einen \link("Format-String (printf)")Format-String\# (Parameter format).

Ergebnis       printf liefert die Anzahl der ausgegebenen Zeichen als
               Funktionsergebnis zurck. Im Falle eines Fehlers
               ist das Funktionsergebnis EOF.

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#fread\#    \#putc\#       \#puts\#      \#scanf\#    \#va_...\#
               \#printf\#   \#vfprintf\#   \#vprintf\#   \#sprintf\#
               \#fprintf\#
\end

screen( "Format-String (printf)" )
Der Format-String ist in jeder Variante von printf obligatorisch
- ber ihn wird die Art der Konvertierung, die Formatierung und die
Anzahl der Parameter festgelegt. Parameter, die durch den Format-
String nicht erfat (d.h. berz„hlig) sind, werden schlicht ignoriert
- wenn printf aufgrund des Format-Strings dagegen mehr Parameter
erwartet als angegeben sind, ergeben sich bestenfalls merkwrdige,
meist aber katastrophale Resultate.
Der Format-String ist ein mit  terminierter String, der zwei Arten
von Informationen enth„lt:
 ù ¯normale Zeichen®, die schlicht direkt ausgegeben werden;
 ù Konvertierungs-Anweisungen, die die Auswertung korrespondierender
   Parameter und ihre Formatierung bestimmen.
Konvertierungs-Anweisungen lassen sich durch das folgende
Syntaxdiagramm darstellen:

% \#[Flags]\# \link("[Breite] (printf)")[Breite]\# \#[.Pr„zision]\# \link("[h|l|L] (printf)")[h|l|L]\# \link("Format")Typ\#

Jede Anweisung beginnt mit einem Prozentzeichen (%).
Querverweis:    \link("%%GLOBAL%%")Escapesequenzen\#
\end

screen( "[Flags]" )
[Flags]      eine (optionale) Zeichenfolge, ber die numerische
             Vorzeichen, Dezimalpunkte, fhrende und folgende Nullen,
             oktale und hexadezimale Pr„fixe sowie links- und
             rechtsbndige Ausgabe festgelegt werden;

printf erkennt vier verschiedene Zeichen als Flags an: Minus (-), Plus
(+), Doppelkreuz (#) und Leerzeichen( ). Flag-Zeichen k”nnen in
beliebiger Folge und Kombination erscheinen und haben die folgenden
Wirkungen:
- linksbndige Ausgabe - n”tigenfalls werden nach der Ausgabe
  Leerzeichen angefgt. Wenn dieses Flag nicht angegeben ist, arbeitet
  printf rechtsbndig, d.h. stellt Leerzeichen voran.
+ numerische Ausgabe mit Vorzeichen - positiven Werten wird ein
  Pluszeichen vorangestellt. Wenn dieses Flag nicht angegeben ist,
  stellt printf nur bei negativen Werten ein Minuszeichen voran, bei
  positiven Werten berhaupt nichts.
' ' (Leerzeichen) - positive Werte werden mit einem fhrenden
  Leerzeichen ausgegeben. Wenn weder dieses Flag noch ein + angegeben
  ist, dann stellt printf positiven Werten berhaupt nichts voran.
# Konvertierung des Arguments in ¯alternativer Form® (siehe folgende
  Tabelle).

Hinweis: Wenn sowohl ein Leerzeichen als auch ein Pluszeichen
angegeben sind, wird das Leerzeichen von printf ignoriert.

¯Alternative Formen®
Die Verwendung des Flags # zusammen mit einer Typ-Angabe hat folgende
Wirkungen:

c,s,d,i,u (keine)
o         solange der korrespondierende Parameter nicht den Wert 0
          hat, wird eine ¯0® vorangestellt;
x,X       Voranstellen von ¯0x® bzw. ¯0X®;
e,E,f     es wird immer ein Dezimalpunkt ausgegeben (normalerweise ist
          das bei diesen Formaten nur dann der Fall, wenn der Wert
          Stellen nach dem Komma enth„lt);
g,G       wie bei e und E - zus„tzlich werden folgende Nullen nicht
          unterdrckt.


                        \link("Format-String (printf)")Format-String\#
\end

screen( "[Breite] (printf)" )
[Breite]     eine (optionale) Angabe ber die minimal auszugebende
             Zeichenzahl (printf fllt n”tigenfalls mit Leerzeichen
             oder Nullen auf);


Breite
Diese Angabe legt die minimale Zahl auszugebender Zeichen fest und
kann in zwei Formen erfolgen: entweder direkt innerhalb des Format-
Strings oder ber ein Sternchen (*). Bei der Verwendung von * erwartet
printf einen zus„tzlichen Parameter, der in der Liste direkt vor dem
auszugebenden Wert stehen und den Typ int haben mu.
Wenn eine Ausgabe weniger Zeichen erzeugt als durch Breite angegeben
ist, dann fgt printf (abh„ngig von den Flags) fhrende/folgende
Leerzeichen hinzu - erzeugt die Ausgabe dagegen mehr Zeichen als durch
Breite angegeben, dann wird Breite einfach ignoriert. Anders gesagt:
Ausgaben werden durch Breite in keinem Fall begrenzt oder
abgeschnitten.
n   (Dezimalzahl) - printf gibt mindestens n Zeichen aus und stellt
    n”tigenfalls Leerzeichen voran (Standard) bzw. fgt folgende
    Leerzeichen an (Flag-);
0n  (Dezimalzahl mit vorangestellter Null) - printf gibt mindestens
    n Zeichen aus und stellt n”tigenfalls eine entsprechende Anzahl
    fhrender Nullen voran;
*   (Sternchen) - die Angabe fr Breite steht in der Parameterliste
    direkt vor dem auszugebenden Wert.


                        \link("Format-String (printf)")Format-String\#
\end

screen( "[.Pr„zision]" )
[.Pr„zision] eine (optionale) Angabe, wieviele Zeichen maximal
             ausgegeben werden sollen (bei Integern: die Minimalzahl
             von Ziffern);

Pr„zision
Diese Angabe wird immer mit einem Dezimalpunkt (.) eingeleitet und so
von einer eventuell vorangestellten Breite getrennt. Wie bei Breite
kann entweder eine direkte Angabe innerhalb des Format-Strings oder
ein Sternchen (*) verwendet werden. Im letzteren Fall erwartet printf
einen zus„tzlichen Parameter des Typs int, der direkt vor dem
auszugebenden Wert steht.
Wenn sowohl Breite als auch Pr„zision ber ein Sternchen angegeben
werden, dann mu die Parameterliste folgendermaen aussehen:

    ("%<Flags>*.*<Typ>", Breite, Pr„zision, Wert)
                        \link("Format-String (printf)")Format-String\#
\end

screen( "Format",
		"Typ (printf)" )
Typ Parameter Ausgabe

    numerische Werte

d   Integer   signed int (dezimal);
i   Integer   signed int (dezimal);
o   Integer   unsigned int (oktal);
u   Integer   unsigned int (dezimal);
x   Integer   unsigned int (hexadezimal), Buchstaben a..f;
X   Integer   unsigned int (hexadezimal), Buchstaben A..F.
              Die Formate x und X unterscheiden sich nur durch die
              Verwendung von Klein- bzw. Grobuchstaben.
f  Fliekomma vorzeichenbehafteter Wert der Form [-]dddd.dddd
              Die Anzahl der Nachkommastellen wird durch Pr„zision
              festgelegt (solange dieser Zusatz angegeben ist).
e  Fliekomma vorzeichenbehafteter Wert der Form [-]d.dddd e [+|-]ddd
              Hier steht grunds„tzlich eine Ziffer vor dem
              Dezimalpunkt, die Anzahl der Nachkommastellen wird durch
              Pr„zision festgelegt, der Exponent umfat immer drei
              Ziffern (notfalls mit fhrenden Nullen).
g  Fliekomma vorzeichenbehafteter Wert im e- oder f-Format (abh„ngig
              vom Wert und der Angabe Pr„zision). Folgende Nullen, ein
              Dezimalpunkt und ein Vorzeichen werden nur ausgegeben,
              wenn es notwendig ist. Das e-Format wird nur dann
              verwendet, wenn das Resultat einer f-Konvertierung mehr
              als Pr„zision Stellen ergibt oder mehr als vier fhrende
              Nullen erfordert.
E  Fliekomma dasselbe Format wie e, aber mit dem Zeichen E vor dem
              Exponenten;
G  Fliekomma dasselbe Format wie g, aber mit dem Zeichen E vor dem
              Exponenten, wenn dieses Format verwendet wird.

    Zeichen

c  Zeichen    einzelnes Zeichen;
s  String     Ausgabe bis zu einem Nullzeichen oder dem Erreichen der
              durch Pr„zision vorgegebenen Zeichenzahl;
%  (nichts)   Ausgabe des Zeichens %;

    Zeiger

n  *int       speichert in dem korrespondierenden Parameter die Anzahl
              der bis jetzt ausgegebenen Zeichen;
p  Zeiger     gibt den korrespondierenden Parameter als Zeiger in
              hexadezimaler Form aus.

                         \link("Format-String (printf)")Format-String\#
\end

screen( "[h|l|L] (printf)" )
h | l | L - explizite Gr”enangaben
Die Gr”enangaben h und l sind nur auf numerische Argumente anwendbar
fr die Formate c, s, p und n haben sie keine Wirkung.

h  das Argument wird als short interpretiert (Formate d, i, o, u, x
   und X);
l  das Argument wird als long (Formate d, i, o, u, x und X) bzw. als
   \link("%%GLOBAL%%")double\# interpretiert (Formate e, E, f, g und G).
L  das Argument wird als long double interpretiert.

Diese Angabe ist nur notwendig wenn die Gr”e der Parameter von der
Standardgr”e abweicht.

                       \link("Format-String (printf)")Format-String\#
\end

screen( capsensitive("putc") )
Name           ¯put character® - Ausgabe eines Zeichens in Datei

Definition     int  putc( int c, FILE *fp );

Prototyp in    stdio.h

Beschreibung   putc ist ein Makro, der das Zeichen c zu dem durch fp
               angegebenen stream ausgibt.

Ergebnis       putc liefert das bergebene Zeichen c auch als
               Funktionsergebnis zurck. Im Falle eines Fehlers
               liefert putc den Wert EOF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fputc\#   \#putchar\#   \#ferror\#   \#fopen\#    \#fread\#
               \#getc\#    \#printf\#    \#puts\#     \#setbuf\#   \link("%%GLOBAL%%")Escapesequenzen\#
\end

screen( capsensitive("putch") )
Name           ¯put character® - Ausgabe eines Zeichens auf dem
               Bildschirm

Definition     int  putch( int c );

Prototyp in    ext.h

Beschreibung   putch gibt ein Zeichen auf das Ger„t console
               (d.h. den Bildschirm) aus.

Ergebnis       putch liefert das als c bergebene Zeichen zurck.
               Im Fehlerfall erh„lt man EOF.

Gruppe         \#Pure-C-Spezialfunktionen\#

Querverweis    \#ferror\#   \#fopen\#    \#fread\#   \#getc\#    \#printf\#
               \#puts\#     \#setbuf\#   \#putc\#    \#fputc\#   \#putc\#
\end

screen( capsensitive("putchar") )
Name           ¯put character® - Ausgabe eines Zeichens auf das
               Standardausgabeger„t stdout

Definition     int  putchar( int c );

Prototyp in    stdio.h

Beschreibung   putchar ist ein Makro und als \#putc\#(c, stdout)
               definiert, gibt also ein Zeichen via stdout aus.

Ergebnis       putchar liefert das bergebene Zeichen c auch als
               Funktionsergebnis zurck. Im Falle eines Fehlers
               liefert putchar den Wert EOF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#ferror\#   \#fopen\#    \#fread\#   \#getc\#  \#printf\#
               \#puts\#     \#setbuf\#   \#putc\#    \#fputc\#
\end

screen( capsensitive("puts") )
Name           ¯put string® - Ausgabe einer Zeichenfolge.

Definition     int  puts( const char *s );

Prototyp in    stdio.h

Beschreibung   puts schreibt den nullterminierten String s
               zeichenweise zu stdout und beendet die Ausgabe mit
               einem (automatischen erzeugten) Zeilenvorschub.

Ergebnis       Bei fehlerfreier Ausfhrung liefert einen nicht-
               negativen Wert. Im Falle eines Fehlers liefert
               puts den Wert EOF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#ferror\#   \#fopen\#   \#fread\#   \#gets\#   \#open\#
               \#printf\#   \#putc\#    \link("%%GLOBAL%%")Escapesequenzen\#
\end

screen( capsensitive("qsort") )
Name           ¯quicksort® - sortiert die Elemente eines Arrays in
               aufsteigender Reihenfolge.

Definition     void  qsort( void *base, size_t nmemb, size_t size,
                             int (*compar)( ));

Prototyp in    stdlib.h

Beschreibung   qsort ist eine Implementation des ¯quicksort®-
               Algorithmus zum Sortieren der Elemente eines Arrays.
               Die Elemente k”nnen (wie bei bsearch) aus beliebigen
               Datenkonstrukten bestehen, weil die Funktion nur die
               Abfolge der Vergleiche festlegt. qsort erwartet die
               folgenden Parameter:
                 ù base   - einen Zeiger auf das Element 0 des zu
                            sortierenden Arrays;
                 ù nmemb  - die Anzahl der zu sortierenden Elemente;
                 ù size   - die Gr”e eines einzelnen Elements
                            (in Byte);
                 ù compar - einen Zeiger auf die Vergleichsfunktion.
               Die Vergleichsfunktion mu vom Programmierer folgender-
               maen definiert werden:

                  int <Name> (e_typ *elem1, e_typ *elem2);

               Sie bekommt bei jedem Aufruf durch qsort zwei Zeiger
               auf jeweils ein Element des zu sortierenden Arrays
               bergeben, mu die entsprechenden Elemente miteinander
               vergleichen und folgende Ergebnisse zurckliefern:

                 *elem1 <  *elem2   Wert < 0
                 *elem1 == *elem2   Wert 0
                 *elem1 >  *elem2   Wert > 0

               Theoretisch ist es m”glich, diese Definition
               ¯umzudrehen® (d.h. fr *elem1 < *elem2 einen Wert
               gr”er 0 und fr *elem1 > *elem2 einen Wert kleiner
               Null zurckzuliefern) - in diesem Fall wrde qsort
               die Array-Elemente in absteigender Reihenfolge
               sortieren.

Ergebnis       qsort hat kein direktes Funktionsergebnis.

Gruppe         \#Verschiedene Routinen\#

Querverweis    \#bsearch\#   \#size_t\#
\end

screen( capsensitive("rand") )
Name           ¯random® - liefert eine ¯Zufallszahl® zurck.

Definition     int  rand( void );

Prototyp in    stdlib.h

Beschreibung   rand verwendet ein multiplikatives Kongruenzverfahren
               (Multiplikation mit anschlieender Modulo-Operation),
               um ¯Zufallszahlen® im Bereich von 0..2^15-1 zu
               erzeugen. Die Periodendauer des Generators betr„gt
               2^32.
               Der ¯Zufallszahlen-Generator® wird beim Start des
               Programms mit dem Wert 1 initialisiert - ber einen
               Aufruf von \#srand\# kann jederzeit ein neuer (und
               beliebiger) Startwert gesetzt werden. Folgen von
               ¯Zufallszahlen® sind von einem gegebenen Startwert aus
               beliebig oft reproduzierbar.

Ergebnis       rand liefert einen int im Bereich von 0..32767 zurck.

Gruppe         \#Verschiedene Routinen\#

Querverweis    \#srand\#   \#random\#
\end

screen( capsensitive("read") )
Name           ¯read® - liest Daten von einer Datei

Definition     size_t  read( int handle, void *buf, size_t len );

Prototyp in    stdio.h

Beschreibung   Die Funktion read liest len Bytes aus der durch handle
               bezeichneten Datei in den durch buf angegebenen
               Speicherbereich. handle ist eine Referenznummer und
               wird der Datei via creat oder open zugeordnet.
               Bei Diskettendateien beginnt der Lesevorgang ab der
               momentanen Position innerhalb der Datei, die mit \#lseek\#
               gesetzt werden kann und w„hrend des Lesevorgangs um die
               Anzahl der gelesenen Bytes erh”ht wird.
               Bei Ger„tedateien ist eine ¯Position® nicht definiert -
               hier liest read direkt vom entsprechenden Ger„t.

Ergebnis       Bei fehlerfreier Ausfhrung liefert die Funktion die
               Anzahl der gelesenen Bytes als (positiven) Wert vom
               Type size_t zurck. Wenn das Dateiende erreicht bzw.
               berschritten wurde, liefert die Funktion den Wert 0.
               Im Falle eines Fehlers hat read das Ergebnis -1,
               \#errno\# wird auf einen der folgenden Werte gesetzt:
                               EACCES  EBADF

Gruppe         \#I/O-Routinen\#

Querverweis    \#creat\#   \#fread\#   \#getc\#   \#open\#   \#write\#
               \#size_t\#
\end

screen( capsensitive("realloc") )
Name           ¯re-alloc® - „ndert die Gr”e eines dynamisch
               reservierten Speicherplatzes

Definition     void  *realloc( void *block, size_t newsize );

Prototyp in    stdlib.h

Beschreibung   realloc „ndert die Gr”e eines durch \#malloc\# oder
               \#calloc\# reservierten Speicherbereichs. Der ver„nderte
               Bereich wird nicht neu initialisiert.

Ergebnis       Als Ergebnis erh„lt man einen typenlosen Zeiger auf
               die Adresse des angepaten Speicherbereichs, der
               explizit auf den verwendeten Zeigertyp konvertiert
               werden sollte. Wenn kein Speicherbereich ausreichender
               Gr”e zur Verfgung steht, dann ist das
               Funktionsergebnis \link("%%GLOBAL%%")NULL\#, es findet keine Belegung statt.

Gruppe         \link("Dynamische Verwaltung des Spe")Dynamische Verwaltung des Speichers\#

Querverweis    \#setbuf\#   \#malloc\#   \#calloc\#   \#size_t\#
\end

screen( capsensitive("remove") )
Name           ¯remove® - l”scht eine Datei

Definition     int  remove( const char *filename );

Prototyp in    stdio.h

Beschreibung   remove l”scht die durch filename angegebene Datei,
               wobei filename einen vollst„ndigen Suchweg und/oder
               einen Laufwerksbezeichner enthalten kann - die
               Jokerzeichen * und ? sind dagegen nicht erlaubt.
               Schreibgeschtzte Dateien und Directories k”nnen mit
               remove nicht gel”scht werden.

Ergebnis       Bei fehlerfreier Ausfhrung liefert remove den
               Wert 0 zurck. Im Falle eines Fehlers ist das
               Funktionsergebnis -1 und \#errno\# bekommt einen der
               folgenden Werte:
                                ENOENT  EACCES

Gruppe         \#I/O-Routinen\#

Querverweis    \#creat\#
\end

screen( capsensitive("rename") )
Name           ¯rename® - „ndert den Namen einer Datei

Definition     int  rename( const char *oldname, const char *newname );

Prototyp in    stdio.h

Beschreibung   rename gibt der durch oldname bezeichneten Datei
               den neuen Namen newname. Beide Namen k”nnen
               vollst„ndige Suchwege und/oder Laufwerksbezeichner
               enthalten. Die Angabe von Jokerzeichen (* und ?)
               ist nicht erlaubt - dafr ist es mit rename aber
               m”glich, Dateien von einem Directory in ein anderes
               zu bewegen, sofern sich Quelle und Ziel auf demselben
               Laufwerk befinden.

Ergebnis       Bei fehlerfreier Ausfhrung liefert rename den Wert 0
               zurck, ansonsten ist das Funktionsergebnis -1 und
               \#errno\# bekommt einen der folgenden Werte:
                           ENOENT     EACCES     ENOTSAM

Gruppe         \#I/O-Routinen\#
\end

screen( capsensitive("rewind") )
Name           ¯rewind® - setzt die momentane Position innerhalb einer
               Datei auf den Dateianfang

Definition     void  rewind( FILE *fp );

Prototyp in    stdio.h

Beschreibung   rewind ist „quivalent zu \#fseek\# mit SEEK_SET und
               einem offset von 0 - die momentane Position wird
               auf das erste Byte des Dateiinhalts gesetzt. Der
               einzige Unterschied besteht darin, da rewind nicht
               nur das Dateiende-Flag l”scht, sondern auch eventuell
               gesetzte Fehler-Flags. In Dateien, die fr Lese- und
               Schreiboperationen er”ffnet worden sind, kann nach
               rewind zwischen ¯Lesen® und ¯Schreiben® gewechselt
               werden. Mit \#ungetc\# zurckgestellte Zeichen sind nach
               rewind nicht mehr erreichbar.

Ergebnis       rewind hat kein direktes Funktionsergebnis.

Gruppe         \#I/O-Routinen\#

Querverweis    \#fopen\#   \#getc\#   \#lseek\#   \#setbuf\#   \#ungetc\#
               \#fseek\#
\end

screen( capsensitive("scanf") )
Name           ¯scan formatted® - formatierte Eingabe

Definition     int  scanf( const char *format, ... );

Prototyp in    stdio.h

Beschreibung   scanf liest Eingaben in formatierter Form und erwartet
               zumindest einen \link("Format-String (printf)")Format-String\# (Parameter format),
               ber den die Anzahl der Eingaben und ihr Format
               festgelegt wird. Gelesene Eingaben werden in den
               Variablen der Parameterliste gespeichert

Ergebnis       scanf liefert die Anzahl der fehlerfrei gelesenen
               Felder als Funktionsergebnis zurck, wobei mit *
               unterdrckte Felder nicht gez„hlt werden.
               Wenn berhaupt keine Zuweisungen erfolgt sind, hat
               das Ergebnis den Wert 0.
               Der Versuch, ber das Ende einer Datei bzw. ber das
               Ende eines Strings hinaus zulesen (\#sscanf\#), ergibt
               den Wert EOF als Funktionsergebnis.

Querverweis    \#fscanf\#   \#sscanf\#   \#vscanf\#

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#
\end

screen( capsensitive("vscanf") )
Name           ¯scan formatted® - formatierte Eingabe

Definition     #include <stdarg.h>
               int  vscanf( const char *format, \#va_list\# param );

Prototyp in    stdio.h

Beschreibung   Die v...scanf-Funktionen verhalten sich „hnlich wie
               ihre ...scanf-Gegenstcke, sie akzeptieren jedoch
               einen Pointer auf eine Liste von Argumenten anstelle
               der Liste selber.
               vscanf liest Eingaben in formatierter Form und erwartet
               zumindest einen \link("Format-String (printf)")Format-String\# (Parameter format),
               ber den die Anzahl der Eingaben und ihr Format
               festgelegt wird. Gelesene Eingaben werden in den
               Variablen der Parameterliste gespeichert

Ergebnis       vscanf liefert die Anzahl der fehlerfrei gelesenen
               Felder als Funktionsergebnis zurck, wobei mit *
               unterdrckte Felder nicht gez„hlt werden.
               Wenn berhaupt keine Zuweisungen erfolgt sind, hat das
               Ergebnis den Wert 0.
               Der Versuch, ber das Ende einer Datei bzw. ber das
               Ende eines Strings hinaus zulesen (\#vsscanf\#), ergibt
               den Wert EOF als Funktionsergebnis.

Portabilit„t   vsscanf ist auf UNIX-Systemen verfgbar.

Querverweis    \#fscanf\#   \#sscanf\#   \#scanf\#

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#
\end

screen( "Format-String (scanf)" )
Der Format-String ist ein nullterminierter String, in dem fr jede
einzulesende Variable eine Formatierungsanweisung vorhanden sein mu.

Formatierungsanweisungen lassen sich durch das folgende
Syntaxdiagramm darstellen:

 % \#[*]\# \link("[Breite] (printf)")[Breite]\# \link("[h|l|L] (printf)")[h|l|L]\# \link("Format")Typ\#

Jede Anweisung beginnt mit einem Prozentzeichen (%).
\end

screen( "[*]" )
[*]      unterdrckt eine Zuweisung ber den korrespondierenden
         Adress-Parameter;
Wenn der Operator * direkt auf das % einer Format-Anweisung folgt,
dann wertet scanf die restlichen Elemente dieser Anweisung aus und
analysiert die Eingabe, nimmt aber keine Zuweisung ber den
korrespondierenden Adress-Parameter vor.
(Hier wird zwar dasselbe Zeichen wie fr die Indirektion verwendet -
ansonsten haben diese beiden Dinge aber nicht das geringste
miteinander zu tun).
Die Unterdrckung von Zuweisungen bei scanf ist mit gewisser Vorsicht
zu genieen - eine direkte M”glichkeit zur Prfung, ob die ¯richtigen®
Teile einer Eingabe dadurch bersprungen wurden, gibt es nicht.

                          \link("Format-String (printf)")Format-String\#
\end

screen( "[Breite] (scanf)" )
[Breite] eine (optionale) Angabe ber die maximal zu lesende
         Zeichenzahl. (Wenn vor Erreichen dieser Zeichenzahl ein
         ¯weies Leerzeichen® oder ein anderes nicht auswertbares
         Zeichen gelesen wird, beendet \#scanf\# die Eingabe dieses
         Wertes von selbst;
         Auswirkungen hat eine derartige Angabe nur dann, wenn das
         entsprechende Feld nicht aufgrund einer anderen Bedingung
         als beendet betrachtet wird (z.B. durch ein ¯weies
         Leerzeichen® oder ein nicht auswertbares Zeichen wie ¯8®
         oder ¯9® bei der Eingabe einer Oktalzahl).

                            \link("Format-String (scanf)")Format-string\#
\end

screen( "[h|l|L] (scanf)" )
[h|l|L]  eine (optionale) Angabe ber die Gr”e der Variablen, auf die
         der korrespondierende Adress-Parameter zeigt (h = \link("%%GLOBAL%%")short\# \link("%%GLOBAL%%")int\#,
         l = \link("%%GLOBAL%%")long\# oder \link("%%GLOBAL%%")double\#, L = \link("%%GLOBAL%%")long\# \link("%%GLOBAL%%")double\#);
         Die Gr”enangaben h und l sind nur fr Eingaben von Integern
         und Fliekommawerten anwendbar - auf alle anderen Formate
         haben sie keine Wirkung.
h        fr die Formate d, i, o, u, und x: Konvertierung der Eingabe
         in das Format \link("%%GLOBAL%%")short\# \link("%%GLOBAL%%")int\#. Fr alle anderen Formate ohne Wirkung.
         In Pure C das gleiche wie \link("%%GLOBAL%%")int\#.
l        fr die Formate d, i, o, u, und x: Konvertierung der Eingabe
         in das Format \link("%%GLOBAL%%")long\#;
         fr die Formate e und f: Konvertierung der Eingabe in das
         Format \link("%%GLOBAL%%")double\#. Fr alle anderen Formate ohne Wirkung.
L        fr die Formate e und f: Konvertierung der Eingabe in das
         Format \link("%%GLOBAL%%")long\# \link("%%GLOBAL%%")double\#. Fr alle anderen Formate ohne Wirkung.

                           \link("Format-String (printf)")Format-String\#
\end

screen( "Typ (scanf)" )
Die Angabe des Typs ist obligatorisch.

Typ Eingabe       Adress-Parameter

    numerische Werte

d   dez. Integer  Zeiger auf int (int *arg)
o   okt. Integer  Zeiger auf int (int *arg)
i   dez. Integer  Zeiger auf int als Konstante (int *arg)
u   dez. Integer  Zeiger auf unsigned int (unsigned *arg)
x   hex. Integer  Zeiger auf unsigned int (unsigned *arg)
e   Fliekomma    Zeiger auf float im Exponentialformat (float *arg)
f   Fliekomma    Zeiger auf float (float *arg)
g   Fliekomma    Zeiger auf float (float *arg).

   Zeichen

c   Zeichen       Zeiger auf ein einzelnes Zeichen (char *arg).
                  Wenn hier eine Breite angegeben ist (z.B. %5c):
                  Zeiger auf ein char-Array entsprechender Gr”e
                  (char arg[Breite]);
s   String        Zeiger auf einen String (char arg[]);
                  oder %\#[Suchzeichen]\#
%   Zeichen %     keine Konvertierung, sondern Speicherung des
                  Zeichens %;

    Zeiger

n   (nichts)      Zeiger auf int (int *arg) - speichert die Anzahl bis
                  jetzt gelesener Zeichen an der Adresse, auf die der
                  Zeiger zeigt;
p   XXXXXXXX      Zeiger auf ein beliebiges Objekt - die Eingabe wird
                  in hexadezimaler Form interpretiert.

                            \link("Format-String (printf)")Format-String\#
\end

screen( "[Suchzeichen]" )
%[Suchzeichen]

%[abcd]  erlaubt nur Eingaben, die aus den Zeichen a, b, c und d
         bestehen - \#scanf\# betrachtet das Eingabefeld bei jedem
         anderen Zeichen als beendet;
%[^abcd] erlaubt Eingaben, die nicht eines der Zeichen a, b , c
         oder d enthalten. Das Eingabefeld wird durch ¯weie
         Leerzeichen® nicht beendet, sondern nur durch die
         angegebenen Zeichen (oder das Erreichen der mit Breite
         festgelegten Zeichenzahl).

Mehrere Bereiche werden ohne spezielle Trennzeichen direkt
aufeinanderfolgend angegeben. Einige Beispiele dazu:
%[A-Z]              s„mtliche Grobuchstaben
%[A-Za-z]           s„mtliche Gro- und Kleinbuchstaben
%[A-Za-z„”™š]    s„mtliche Buchstaben inklusive der Umlaute
                    und des 
%[-+*/]             die vier arithmetischen Operatoren
%[z-a]              die Zeichen ¯z®, ¯-® und ¯a®
%[+0-9-A-F]         das Zeichen ¯+®, die Ziffern von 0 bis 9, das
                    Zeichen ¯-® und die Buchstaben von A bis F
%[+0-9A-F-]         genau dieselben Zeichen wie im vorigen Beispiel
%[^-0-9+A-F]        s„mtliche Zeichen auer ¯-®, den Ziffern 0 bis 9,
                    dem Zeichen ¯+® und den Buchstaben A bis F.

                          \link("Format-String (printf)")Format-String\#
\end

screen( capsensitive("setbuf") )
Name           ¯set buffer® - Explizite Zuordnung eines Puffers zu
               einem stream.

Definition     void  setbuf( FILE *fp, void *buf );

Prototyp in    stdio.h

Beschreibung   setbuf ordnet der durch fp angegebenen Datei
               den Puffer buf anstelle des automatisch vergebenen
               Puffers zu. Die Minimalgr”e von buf ist durch die
               (in stdio.h definierte) Konstante BUFSIZ festgelegt.
               Durch die Angabe des Zeigerwertes \link("%%GLOBAL%%")NULL\# anstelle von
               buf arbeiten  folgende Ein-/Ausgaben ber den stream
               ungepuffert, d.h. Ausgaben geschehen sofort, Eingaben
               lesen direkt vom entsprechenden Ger„t.

               (Die ¯Pufferung® von Ein- und Ausgaben bedeutet:
               Ausgaben werden zeichenweise zwischengespeichert
               und blockweise geschrieben; Eingaben werden blockweise
               von der Datei bzw. dem Ger„t gelesen und danach
               zeichenweise aus dem Puffer geliefert.)

               stdin und stdout arbeiten ungepuffert, solange sie
               nicht umgeleitet sind - Umleitungen bewirken dagegen
               normalerweise eine Pufferung, die via setbuf ver-
               „ndert werden kann.

               setbuf darf nur direkt nach der Er”ffnung (oder
               direkt nach einem fseek) auf einen stream angewendet
               werden - ansonsten sind die Ergebnisse unvorhersag-
               bar. Die Anwendung dieser Funktion auf ungepufferte
               Dateien (bzw. auf Dateien, deren Puffer direkt nach
               der Er”ffnung oder einem fseek entfernt wurde) ist
               dagegen problemlos und jederzeit m”glich.

               Hinweis: Fr buf kann eine lokale Variable verwendet
               werden - allerdings sollte man in diesem Fall streng
               darauf achten, die Datei vor dem Ende der entsprechen-
               den Funktion wieder zu schlieen.

Ergebnis       setbuf hat kein direktes Funktionsergebnis.

Gruppe         \#I/O-Routinen\#

Querverweis    \#setvbuf\#   \#fopen\#   \#fclose\#   \#fseek\#   \#malloc\#
               \#open\#
\end

screen( capsensitive("setdate") )
Name           ¯set date® - Setzt das aktuelle Tagesdatum.

Definition     void  setdate( struct date *dateRec );

Prototyp in    ext.h

Beschreibung   Die Funktion setdate setzt das aktuelle Tagesdatum. Das
               Datum wird in der Struktur \#date\# bergeben.

Ergebnis       Die Funktion liefert kein Ergebnis.

Gruppe         \#Datum und Uhrzeit\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#time\#, \#ctime\#, \#getdate\#
\end

screen( capsensitive("setdisk") )
Name           ¯set disk® - Setzt das aktuelle Laufwerk

Definition     int  setdisk( int drive );

Prototyp in    ext.h

Beschreibung   Die Funktion setdisk wechselt das aktuelle Laufwerk.
               Fr das Laufwerk A: ist eine 0 zu bergeben, fr B: 
               eine 1 usw.

Ergebnis       setdisk liefert die Anzahl der verfgbaren Laufwerke
               zurck.

Portabilit„t   Pure- und Turbo-C-spezifisch.

Querverweis    \#getdisk\#
\end

screen( capsensitive("setftime") )
Name           ¯set file time® - Setzt Datum und Uhrzeit einer offenen
               Datei.

Definition     int  setftime( int handle, struct ftime *ftimep );

Prototyp in    ext.h

Beschreibung   Die Funktion setftime setzt Datum und Uhrzeit der durch
               handle bezeichneten Datei. Datum und Uhrzeit werden
               durch die Struktur \#ftime\# beschrieben.

Ergebnis       Die Funktion liefert bei fehlerfreier Ausfhrung den
               Wert 0. Wenn der angegebene handle nicht existiert
               (d.h. keine entsprechende Datei offen ist), liefert
               getftime den Wert -1 als Ergebnis, \#errno\# bekommt den
               Wert EBADF.

Gruppe         \#I/O-Routinen\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#getftime\#
\end

screen( capsensitive("setjmp") )
Name           ¯set jump® - Vorbereitung eines nicht-lokalen goto.

Definition     int  setjmp( jmp_buf env );

Prototyp in    setjmp.h

Beschreibung   speichert einen ¯Schnappschu® des momentanen
               Prozessor-Zustands (und des Stacks) in dem durch
               env angegebenen Puffer.
               Nach einem Aufruf von \#longjmp\# setzt der Prozessor
               die Arbeit an der Stelle fort, an der sich der Aufruf
               von setjmp befindet.

Beispiel:      #include <stdio.h>
               #include <stdlib.h>
               #include <setjmp.h>

               void function(void);

               jmp_buf buffer;   /*  wichtig: mu global sein, wenn
                                  *  aus einer Funktion heraus
                                  *  gesprungen werden soll.
                                  */
               int  main( void )
               {
               int  value;

                   if (( value = setjmp( buffer )) != 0 )
                   {
                       printf( "setjmp returned %d after using"
                               " longjmp\\n", value );
                       exit( 0 );
                   }
                   else
                   {
                       printf( "setjmp returned %d before using"
                               " longjmp\\n", value );
                   }
                   function( );

                   /*  Hierher sollte das Programm gar nicht kommen,
                    *  da function gar nicht zurckkehrt!
                    */

                   printf( "function shouldn' t return...\\n" );
               }

               void  function( void )
               {

               /*
                *  ...kehrt zu main zurck als w„re setjmp mit
                *  dem Wert 7 zurckgekehrt.
                */

                   longjmp(buffer, 7);
                   printf( "function shouldn' t return...\\n" );
               }

Ergebnis       Der direkte Aufruf von setjmp liefert immer den Wert 0
               zurck.

Gruppe         \#Sprnge\#

Querverweis    \#longjmp\#
\end

screen( capsensitive("settime") )
Name           ¯set time® - Setzt die Uhrzeit.

Definition     void  settime( struct time *timeRec );

Prototyp in    ext.h

Beschreibung   Die Funktion settime setzt die aktuelle Uhrzeit. Die
               Uhrzeit wird in der Struktur \#time\# bergeben.

Ergebnis       Die Funktion liefert kein Ergebnis.

Gruppe         \#Datum und Uhrzeit\#   \#Pure-C-Spezialfunktionen\#

Querverweis    \#time\#   \#ctime\#   \#gettime\#   \#Settime\#
\end

screen( capsensitive("setvbuf") )
Name           ¯set buffer® - Explizite Zuordnung eines Puffers zu
               einem stream.

Definition     int  setvbuf( FILE *fp, void *buf, int type,
                              size_t size );

Prototyp in    stdio.h

Beschreibung   setvbuf ordnet der durch fp angegebenen Datei
               den Puffer buf anstelle des automatisch vergebenen
               Puffers zu. Die Minimalgr”e von buf ist durch die
               (in stdio.h definierte) Konstante BUFSIZ festgelegt.
               Durch die Angabe des Zeigerwertes \link("%%GLOBAL%%")NULL\# anstelle von
               buf wird ber einen Aufruf von malloc ein Puffer der
               Gr”e size belegt und der Datei zugeordnet. size mu
               einen Wert gr”er Null haben.

               Der Parameter type von setvbuf mu ber eine der
               drei folgenden Konstanten festgelegt werden, die
               in stdio.h definiert sind:

               _IOFBF  (¯I/O fully buffered®) - Ein-/Ausgaben
               werden vollst„ndig gepuffert. Wenn der Puffer
               ¯leergelesen® ist, versucht der n„chste Eingabe-
               befehl, den Puffer wieder komplett mit Daten
               zu fllen (liest also BUFSIZ bzw. size Bytes).
               Ausgaben fllen den Puffer bis zum letzten Byte,
               erst danach wird der komplette Pufferinhalt
               geschrieben.

               _IOLBF  (¯I/O line buffered®) - Ausgaben werden
               zeilenweise gepuffert: der Pufferinhalt wird nach
               jeder Ausgabe eines Zeilenvorschubs physikalisch
               geschrieben. Eingaben arbeiten dagegen genauso
               wie bei vollst„ndiger Pufferung.

               _IONBF  (¯I/O not buffered®) - Ein-/Ausgaben
               geschehen ohne das dazwischenschalten eines
               Puffers, die Parameter buf und size werden von
               setvbuf ignoriert. Jeder Eingabebefehl liest direkt
               von der Datei, jeder Ausgabebefehl hat eine sofortige
               Schreibaktion zur Folge.

Ergebnis       setvbuf liefert bei fehlerfreier Ausfhrung den
               Wert 0. Ungltige Werte fr type oder size, fehlender
               Speicherplatz fr malloc oder die Anwendung auf eine
               nicht offene Datei erzeugen ein Funktionsergebnis
               ungleich 0.

Gruppe         \#I/O-Routinen\#

Querverweis    \#setbuf\#   \#fopen\#, \#fclose\#, \#fseek\#, \#malloc\#,
               \#open\#     \#size_t\#
\end

screen( capsensitive("sin") )
Name           ¯sine® - Liefert den Sinus des Arguments zurck

Definition     double  sin( double x );

Prototyp in    math.h

Beschreibung   sin erwartet einen Winkel in der Einheit rad (0 Grad =
               0 * ã, 90 Grad = ã/2, 180 Grad = ã, 270 Grad = 1.5 * ã,
               360 Grad = 2 * ã usw.) als Argument und liefert den
               dazugeh”rigen Sinus zurck. šbergebene Werte werden
               automatisch auf den Bereich 0..2 * ã reduziert.
               Der Wert von ã (3.1415...) ist in math.h als Konstante
               mit dem Namen M_PI definiert.

Ergebnis       M”gliche Ergebnisse liegen im Bereich von -1 .. 1.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#asin\#
\end

screen( capsensitive("sincos") )
Name           ¯sine, cosine® - Berechnet Sinus und Cosinus

Definition     void  sincos( double x, double *sin, double *cos );

Prototyp in    math.h

Beschreibung   sincos erwartet einen Winkel in der Einheit rad (0 Grad =
               0 * ã, 90 Grad = ã/2, 180 Grad = ã, 270 Grad = 1.5 * ã,
               360 Grad = 2 * ã usw.) als erstes Argument und berechnet
               sowohl den Sinus als auch den Cosinus des Winkels. Die
               Ergebnisse werden in den zweiten bzw. dritten Parameter
               geschrieben.

Ergebnis       Die Funktion hat kein Ergebnis.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#sin\#  \#cos\#
\end

screen( capsensitive("sinh") )
Name           ¯sine hyperbolic® - Liefert den Sinus hyperbolicus
               des Arguments zurck.

Definition     double  sinh( double x );

Prototyp in    math.h

Beschreibung   sinh berechnet den Sinus hyperbolicus des Arguments,

Ergebnis       Bei fehlerfreier Ausfhrung liefert die Funktion
               das entsprechende Ergebnis. Bei šberl„ufen wird
               HUGE_VAL (mit korrektem Vorzeichen) zurckgeliefert
               und \#errno\# bekommt den Wert ERANGE.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#exp\#
\end

screen( capsensitive("asinh") )
Name           ¯arcus sine hyperbolic® - Liefert den hyperbolischen
               Arcussinus des Arguments zurck.

Definition     double  asinh( double x );

Prototyp in    math.h

Beschreibung   asinh berechnet den Arcussinus hyperbolicus des
               Arguments.

Ergebnis       asinh liefert immer ein gltiges Ergebnis.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#
\end

screen( capsensitive("sprintf") )
Name           ¯string print formatted® - Formatierte Ausgabe in
               einen String

Definition     int  sprintf( char *buffer, const char *format, ... );

Prototyp in    stdio.h

Beschreibung   Alle \#printf\#-Funktionen ¯drucken® in formatierter
               Form und erwarten zumindest einen \link("Format-String (printf)")Format-String\#.
               (¯variable string printf®) - wie \#printf\#, die Ausgabe
               geschieht in den angegebenen (nullterminierten) String,
               der eine entsprechende L„nge haben mu.

Ergebnis       S„mtliche Varianten von \#printf\# liefern die Anzahl der
               ausgegebenen Zeichen als Funktionsergebnis zurck,
               wobei das abschlieende Nullzeichen bei sprintf nicht
               mitgez„hlt wird. Im Falle eines Fehlers ist das
               Funktionsergebnis EOF.

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#fread\#    \#putc\#       \#puts\#      \#scanf\#     \#va_...\#
               \#printf\#   \#vfprintf\#   \#vprintf\#   \#vprintf\#
               \#fprintf\#
\end

screen( capsensitive("sqrt") )
Name           ¯square root® - Liefert die Quadratwurzel des Arguments

Definition     double  sqrt( double x );

Prototyp in    math.h

Beschreibung   sqrt berechnet die Quadratwurzel des Argumentes x.

Ergebnis       Wenn x negativ ist, wird \#errno\# der Wert EDOM
               zugewiesen. 
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#exp\#   \#pow\#
\end

screen( capsensitive("srand") )
Name           ¯seed random [generator]® - Setzt einen Startwert fr
               die Erzeugung von ¯Zufallszahlen®

Definition     void  srand( unsigned seed );

Prototyp in    stdlib.h

Beschreibung   mit srand kann der Startwert fr \#rand\# gesetzt werden.
               Der ¯Zufallszahlen-Generator® wird beim Start des
               Programms mit dem Wert 1 initialisiert - ber einen
               Aufruf von srand kann jederzeit ein neuer (und
               beliebiger) Startwert gesetzt werden. Folgen von
               ¯Zufallszahlen® sind von einem gegebenen Startwert aus
               beliebig oft reproduzierbar.

Ergebnis       srand hat kein direktes Funktionsergebnis.

Gruppe         \#Verschiedene Routinen\#

Querverweis    \#rand\#
\end

screen( capsensitive("sscanf") )
Name           ¯string scan formatted® - Liest den Inhalt eines
               Strings als formatierte Eingabe

Definition     int  sscanf( char *buffer, const char *format, ... );

Prototyp in    stdio.h

Beschreibung   sscanf liest eine Stringvariable (d.h. den durch
               buffer angegebenen Speicherbereich) in formatierter
               Form und erwartet zumindest einen \link("Format-String (printf)")Format-String\#
               ber den die Anzahl der Eingaben und ihr Format
               festgelegt wird. Gelesene Eingaben werden in den
               Variablen der Parameterliste gespeichert

Ergebnis       sscanf liefert die Anzahl der fehlerfrei gelesenen
               Felder als Funktionsergebnis zurck, wobei mit *
               unterdrckte Felder nicht gez„hlt werden.
               Wenn berhaupt keine Zuweisungen erfolgt sind, hat das
               Ergebnis den Wert 0.
               Der Versuch, ber das Ende einer Datei bzw. ber das
               Ende eines Strings hinaus zulesen, ergibt
               den Wert EOF als Funktionsergebnis.

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#atof\#    \#getc\#    \#fread\#   \#printf\#   \#va_...\#
               \#scanf\#   \#fscanf\#  \#vsscanf\#
\end

screen( capsensitive("vsscanf") )
Name           ¯string scan formatted® - Liest den Inhalt eines
               Strings als formatierte Eingabe

Definition     #include <stdarg.h>
               int  vsscanf( char *string, const char *format,
                             \#va_list\# param );

Prototyp in    stdio.h

Beschreibung   Die v...scanf-Funktionen verhalten sich „hnlich wie
               ihre ...scanf-Gegenstcke, sie akzeptieren jedoch
               einen Pointer auf eine Liste von Argumenten anstelle
               der Liste selber.
               vsscanf liest eine Stringvariable (d.h. den durch
               buffer angegebenen Speicherbereich) in formatierter
               Form und erwartet zumindest einen \link("Format-String (printf)")Format-String\#
               ber den die Anzahl der Eingaben und ihr Format
               festgelegt wird. Gelesene Eingaben werden in den
               Variablen der Parameterliste gespeichert

Ergebnis       vsscanf liefert die Anzahl der fehlerfrei gelesenen
               Felder als Funktionsergebnis zurck, wobei mit *
               unterdrckte Felder nicht gez„hlt werden.
               Wenn berhaupt keine Zuweisungen erfolgt sind, hat das
               Ergebnis den Wert 0.
               Der Versuch, ber das Ende einer Datei bzw. ber das
               Ende eines Strings hinaus zulesen, ergibt
               den Wert EOF als Funktionsergebnis.

Portabilit„t   vsscanf ist auf UNIX-Systemen verfgbar.

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#atof\#    \#getc\#    \#fread\#   \#printf\#   \#va_...\#
               \#scanf\#   \#fscanf\#  \#sscanf\#
\end

screen( capsensitive("strerror") )
Name           ¯string error® - Liefert Strings mit System-
               fehlermeldungen

Definition     char  *strerror( int errnum );

Prototyp in    string.h

Beschreibung   strerror dient zur Abfrage, welche Fehlermeldung
               ausgegeben wird, wenn \#errno\# den Wert errnum annimmt.

Ergebnis       strerror liefert einen Zeiger auf die mit errnum
               angegebene Fehlermeldung.

Querverweis    \#perror\#

Gruppe         \#I/O-Routinen\#
\end

screen( capsensitive("strcat") )
Name           ¯string concatenate® - H„ngt einen String an einen
               anderen an

Definition     char  *strcat( char *dest, const char *src );

Prototyp in    string.h

Beschreibung   strcat h„ngt s„mtliche Zeichen von src an die bereits
               in dest vorhandenen Zeichen an (die L„nge von dest
               wird also um strlen(src) erh”ht).

Ergebnis       Zurckgeliefert wird ein Zeiger auf das erste Zeichen
               von dest.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strncat") )
Name           ¯string number concatenate® - H„ngt eine bestimmte
               Anzahl von Zeichen aus einem String an einen anderen
               an (Verbindung)

Definition     char  *strncat( char *dest, const char *src,
                                size_t maxlen );

Prototyp in    string.h

Beschreibung   strncat h„ngt die ersten maxlen Zeichen von src an die
               bereits in dest vorhandenen Zeichen an. Die Operation
               wird beendet, wenn entweder maxlen Zeichen kopiert
               wurden oder das Ende von src erreicht ist.
               Als letztes schreibt strncat grunds„tzlich ein
               Nullzeichen in dest.

Ergebnis       Danach wird ein Zeiger auf das erste Zeichen von dest
               zurckgeliefert.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#
\end

screen( capsensitive("strchr") )
Name           ¯string character® - Sucht einen String nach einem
               bestimmten Zeichen ab

Definition     char  *strchr( const char *s, int c );

Prototyp in    string.h

Beschreibung   strchr sucht den ber s angegebenen String nach dem
               Zeichen c ab, wobei die Suche mit dem ersten Zeichen
               von s beginnt.

Ergebnis       strchr liefert einen Zeiger auf die erste Fundstelle
               des Zeichens c zurck bzw. den Wert \link("%%GLOBAL%%")NULL\#, wenn der
               String dieses Zeichen nicht enth„lt. Das abschlieende
               Nullzeichen wird zum Stringinhalt gerechnet - ein
               Aufruf wie strchr( stringx, 0 ) liefert also einen
               Zeiger auf das Nullzeichen von stringx.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strrev") )
Name           ¯string reverse® - Dreht die Reihenfolge der Zeichen
               eines Strings um

Definition     char  *strrev( char *s );

Prototyp in    string.h

Beschreibung   strrev invertiert den ber s angegebenen String.

Ergebnis       Zurckgeliefert wird ein Zeiger auf das erste Zeichen
               von s.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strrchr") )
Name           ¯string right character® - Sucht einen String nach dem
               letzten Erscheinen eines bestimmten Zeichens ab
               (Absuche)

Definition     char  *strrchr( const char *s, int c );

Prototyp in    string.h

Beschreibung   strrchr sucht den ber s angegebenen String nach dem
               Zeichen c ab, wobei die Suche mit dem letzten Zeichen
               von s beginnt.

Ergebnis       strrchr liefert einen Zeiger auf die erste (¯rechteste®)
               Fundstelle des Zeichens c zurck bzw. den Wert \link("%%GLOBAL%%")NULL\#,
               wenn der String dieses Zeichen nicht enth„lt. Das
               abschlieende Nullzeichen wird zum Stringinhalt
               gerechnet und als erstes verglichen - ein Aufruf wie
               strrchr( stringx,0 ) liefert also einen Zeiger auf das
               Nullzeichen von stringx.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strcmp") )
Name           ¯string compare® - Vergleicht zwei Strings.

Definition     int  strcmp( const char *s1, const char *s2 );

Prototyp in    string.h

Beschreibung   strcmp vergleicht die Inhalte von s1 und s2 miteinander.

Ergebnis       Zurckgeliefert wird ein Wert kleiner 0, wenn s1
               kleiner als s2 ist - der Wert 0, wenn beide Strings
               exakt gleich sind; und ein Wert gr”er 0, wenn s1
               gr”er als s2 ist. Das Ergebnis hat den Typ int.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#  \#stricmp\#
\end

screen( capsensitive("strncmp") )
Name           ¯string number compare® -  Vergleicht eine bestimmte
               Anzahl von Zeichen miteinander.

Definition     int  strncmp( char *s1, char *s2, size_t maxlen );

Prototyp in    string.h

Beschreibung   strncmp vergleicht maximal die ersten maxlen Zeichen
               von s1 und s2 miteinander.

Ergebnis       Zurckgeliefert wird ein Wert kleiner 0, wenn s1
               kleiner als s2 ist - der Wert 0, wenn beide Strings
               exakt gleich sind; und ein Wert gr”er 0, wenn s1
               gr”er als s2 ist. Das Ergebnis hat den Typ int.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#  \#strnicmp\#
\end

screen( capsensitive("strcmpi"),
		capsensitive("stricmp") )
Name           ¯string compare ignore case® - Vergleicht zwei Strings
               ohne Unterscheidung zwischen Gro- und Kleinschreibung.

Definition     int  stricmp( const char *s1, const char *s2 );
               int  strcmpi( const char *s1, const char *s2 );

Prototyp in    string.h

Beschreibung   stricmp und strcmpi sind zwei identische Funktionen.
               Beide vergleichen zwei Strings miteinander, ohne
               zwischen Gro- und Kleinschreibung zu unterscheiden.
               Ansonsten wird der Vergleich wie bei \#strcmp\#
               durchgefhrt.
               Achtung: Deutsche Umlaute werden dennoch nach gro/
                        klein unterschieden (s. ATARI-Zeichensatz).

Ergebnis       Zurckgeliefert wird ein Wert kleiner 0, wenn s1
               kleiner als s2 ist - der Wert 0, wenn beide Strings
               exakt gleich sind; und ein Wert gr”er 0, wenn s1
               gr”er als s2 ist. Das Ergebnis hat den Typ int.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#   \#strcmp\#   \#stricmp\#   \#strcmpi\#
               \#strncmp\#   \#strnicmp\#   \#strncmpi\#
\end

screen( capsensitive("strnicmp"),
		capsensitive("strncmpi") )
Name           ¯string number compare ignore case® - Vergleicht eine
               bestimmte Anzahl von Zeichen miteinander ohne
               Unterscheidung zwischen Gro- und Kleinschreibung.

Definition     int  strnicmp( const char *s1, const char *s2,
                               size_t n );
               int  strncmpi( const char *s1, const char *s2,
                               size_t n );

Prototyp in    string.h

Beschreibung   strnicmp und strncmpi sind zwei identische Funktionen.
               Beide vergleichen die n ersten Zeichen zweier Strings
               miteinander, ohne zwischen Gro- und Kleinschreibung zu
               unterscheiden. Ansonsten wird der Vergleich wie bei
               \#strncmp\# durchgefhrt.
               Achtung: Deutsche Umlaute werden dennoch nach gro/
                        klein unterschieden (s. ATARI-Zeichensatz).

Ergebnis       Zurckgeliefert wird ein Wert kleiner 0, wenn s1
               kleiner als s2 ist - der Wert 0, wenn beide Strings
               exakt gleich sind; und ein Wert gr”er 0, wenn s1
               gr”er als s2 ist. Das Ergebnis hat den Typ int.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#size_t\#   \#strncmp\#
\end

screen( capsensitive("strcpy") )
Name           ¯string copy® - Kopiert einen String in einen
               anderen

Definition     char  *strcpy( char *dest, const char *src );

Prototyp in    string.h

Beschreibung   strcpy kopiert den Inhalt des ber src angegebenen
               Strings in den durch dest angegebenen Speicherbereich.
               Das abschlieende Nullzeichen von src wird als letztes
               Byte kopiert.

Ergebnis       die Startadresse von dest wird als Funktionsergebnis
               zurckgeliefert.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strncpy") )
Name           ¯string number copy® - Kopiert eine bestimmte Anzahl
               von Zeichen

Definition     char  *strncpy( char *dest, const char *src,
                                size_t maxlen );

Prototyp in    string.h

Beschreibung   strncpy kopiert maxlen Zeichen des ber src angegebenen
               Strings in den durch dest angegebenen Speicherbereich.
               strncpy kopiert immer genau maxlen Zeichen - wenn src
               weniger als maxlen Zeichen enth„lt, wird eine
               entsprechende Anzahl von Nullzeichen in dest angeh„ngt
               wenn src mehr als maxlen Zeichen umfat, bleibt der
               nach dest kopierte String ohne ein abschlieendes
               Nullzeichen.

Ergebnis       strncpy liefert in allen F„llen einen Zeiger auf das
               erste Byte von dest zurck.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
Querverweis    \#size_t\#
\end

screen( capsensitive("strlen") )
Name           ¯string length® - Sucht nach dem Ende eines Strings
               und liefert seine L„nge zurck

Definition     \#size_t\#  strlen( const char *s );

Prototyp in    string.h

Beschreibung   Der angegebene String wird nicht ver„ndert.

Ergebnis       strlen liefert die L„nge des angegebenen Strings
               als unsigned long. Die Null wird nicht mitgez„hlt.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strstr") )
Name           ¯string string® - Sucht einen String nach dem Vorkommen
               eines anderen Strings ab

Definition     char  *strstr( const char *s1, const char *s2 );

Prototyp in    string.h

Beschreibung   strstr sucht den ber s1 angegebenen String nach
               dem ersten Vorkommen von s2 ab (im Gegensatz zu
               strspn und strcspn findet hier ein direkter Vergleich
               statt - die Reihenfolge der Zeichen in s1 und s2
               spielt also eine Rolle).

Ergebnis       Zurckgeliefert wird ein Zeiger auf den Beginn von s2
               in s1 bzw. der Zeigerwert \link("%%GLOBAL%%")NULL\#, wenn s2 in s1 berhaupt
               nicht vorkommt.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#strcspn\#
\end

screen( capsensitive("strlwr") )
Name           ¯string lowercase® - ndert alle Grobuchstaben in
               Kleinbuchstaben

Definition     char  *strlwr( char *s );

Prototyp in    string.h

Beschreibung   strlwr ver„ndert s„mtliche Grobuchstaben des via s
               bergebenen Strings in Kleinbuchstaben (die deutschen
               Umlaute werden nicht bercksichtigt).
Ergebnis       strlwr liefert einen Zeiger auf das erste Zeichen
               dieses Strings zurck.
Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strupr") )
Name           ¯string uppercase® - Verwandelt alle Kleinbuchstaben
               in Grobuchstaben

Definition     char  *strupr( char *s );

Prototyp in    string.h

Beschreibung   strupr ver„ndert s„mtliche Kleinbuchstaben des via s
               bergebenen Strings in Grobuchstaben (die deutschen
               Umlaute werden nicht bercksichtigt).

Ergebnis       strupr liefert einen Zeiger auf das erste Zeichen
               dieses Strings zurck.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strcspn") )
Name           ¯string counter set position® - Liefert die L„nge
               des Teilstrings von s1 zurck, der keines der Zeichen
               von s2 enth„lt

Definition     size_t  strcspn(const char *s1, const char *s2);

Prototyp in    string.h

Beschreibung   strcspn vergleicht s1 ab dem ersten Zeichen mit
               dem in s2 enthaltenen Zeichensatz. Wenn das
               Zeichen nicht in s2 enthalten ist, geht der
               Vergleich mit dem n„chsten Zeichen von s1
               weiter - solange, bis entweder das letzte Zeichen
               von s1 verglichen wurde (Funktionsergebnis: L„nge
               von s1) oder sich eine šbereinstimmung ergibt
               (Funktionsergebnis: Position des ersten gefundenen
               Zeichens - also die L„nge des Teilstrings von s1,
               der keines der Zeichen von s2 enth„lt. Die Reihen-
               folge der Zeichen in s2 spielt keine Rolle.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strdup") )
Name           ¯string duplicate® - Dupliziert einen String

Definition     char  *strdup( const char *s );

Prototyp in    string.h

Beschreibung   strdup dupliziert einen String an eine andere Adresse.
               Der Speicher wird per malloc dynamisch angelegt.

Ergebnis       Zurckgeliefert wird ein Zeiger auf das erste Zeichen
               des duplizierten Strings.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strset") )
Name           ¯string set® - Fllt einen String mit einem
               Zeichen

Definition     char  *strset( char *s, int c );

Prototyp in    string.h

Beschreibung   strset berschreibt alle Zeichen des via s
               bergebenen Strings mit dem Zeichen c.

Ergebnis       Zurckgeliefert wird ein Zeiger auf das erste
               Zeichen von s.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#strnset\#
\end

screen( capsensitive("strnset") )
Name           ¯string number set® - Fllt einen Stringteil mit einem
               Zeichen

Definition     char  *strnset( char *s, int c, size_t n );

Prototyp in    string.h

Beschreibung   strnset berschreibt die ersten n Zeichen des via
               s bergebenen Strings mit dem Zeichen c. n wird
               automatisch begrenzt, d.h. strnset schreibt nicht
               ber das Stringende ('') hinaus.

Ergebnis       Zurckgeliefert wird ein Zeiger auf das erste
               Zeichen von s.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#strset\#
\end

screen( capsensitive("strpbrk") )
Name           ¯string pointer break® - Sucht einen String nach dem
               ersten Auftreten bestimmter Zeichen ab

Definition     char  *strpbrk( const char *s1, const char *s2 );

Prototyp in    string.h

Beschreibung   strpbrk sucht den ber s1 angegebenen String nach
               dem ersten Vorkommen eines der in s2 enthaltenen
               Zeichen ab.

Ergebnis       Zurckgeliefert wird ein Zeiger auf die erste
               Fundstelle bzw. der Wert \link("%%GLOBAL%%")NULL\#, wenn keines der
               durch s2 festgelegten Zeichen in s1 enthalten ist.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strspn") )
Name           ¯string set position® - Berechnet die L„nge des
               Teilstrings, der ausschlielich aus Zeichen eines
               zweiten Strings besteht.

Definition     size_t  strspn( const char *s1, const char *s2 );

Prototyp in    string.h

Beschreibung   strspn ist das Gegenstck zu \#strcspn\#:
               Beginnend mit dem ersten Zeichen wird der Inhalt
               von s1 mit dem ber s2 angegebenen Zeichensatz
               verglichen. Wenn das Zeichen in s2 enthalten ist,
               geht es mit dem n„chsten Zeichen von s1 weiter,
               solange, bis entweder das Ende von s1 erreicht ist
               (Funktionsergebnis: L„nge von s1) oder der Vergleich
               fehlschl„gt (Funktionsergebnis: Position des ersten
               nicht bereinstimmenden Zeichens - also die L„nge
               des Teilstrings von s1, der ausschlielich aus
               Zeichen besteht, die in s2 enthalten sind).
               Die Reihenfolge der Zeichen in s2 spielt keine Rolle.
               Wenn bereits das erste Zeichen von s1 nicht in s2
               enthalten ist, dann liefert strspn das Ergebnis 0.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strtok") )
Name           ¯string token® - Sucht einen String nach der ersten
               von mehreren Zeichenfolgen ab

Definition     char  *strtok( char *s1, const char *s2 );

Prototyp in    string.h

Beschreibung   strtok betrachtet den ber s1 angegebenen String als
               Folge von ¯Tokens®, die voneinander durch die in s2
               definierten Zeichenfolgen getrennt sind. Wenn s1
               beispielsweise den Inhalt "ein String,mit,,Tokens"
               hat und s2 den Inhalt " , ", dann liefern
               aufeinanderfolgende Aufrufe von strtok die ¯Tokens®
               ein, String, mit und Tokens.

Ergebnis       Der erste Aufruf von strtok liefert einen Zeiger auf
               den Beginn des ersten gefundenen ¯Tokens® in s1 zurck
               und setzt ein Nullzeichen unmittelbar hinter das Ende
               (in unserem Beispiel also direkt hinter die
               Zeichenfolge ein.
               Folgende Aufrufe von strtok mit dem Wert \link("%%GLOBAL%%")NULL\#
               anstelle des Arguments s1 liefern Zeiger auf weitere
               Tokens zurck, bis der ursprngliche String zuende
               gelesen ist. s1 wird w„hrend der Analyse durch das
               Einfgen von Nullzeichen ver„ndert, s2 kann bei jedem
               Aufruf von strtok beliebig gewechselt werden.
               Wenn kein (weiteres) ¯Token® gefunden wird, liefert
               strtok das Ergebnis \link("%%GLOBAL%%")NULL\#.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strtod") )
Name           (¯string to double®) - Interpretiert einen String
               als einen \link("%%GLOBAL%%")double\#-Wert

Definition     double  strtod( const char *s, char **endptr );

Prototyp in    stdlib.h

Beschreibung   strtod interpretiert den via s bergebenen String
               als \link("%%GLOBAL%%")double\#. Der Stringinhalt mu das folgende Format
               haben (vgl. \#atof\#):

               [wl] [+|-] [ddd] [.ddd] [e|E [+|-] ddd]

               [wl] steht hier fr ¯weie Leerzeichen®, [+|-] fr ein
               (optionales) Vorzeichen und [ddd] fr ein oder mehrere
               Dezimalziffern. Wenn ein Exponent angegeben wird, dann
               kann dieser Exponent ein Vorzeichen enthalten.
               Beispiele fr gltige Angaben sind:
               +1234.1981e-1, 502.3489576, -.34576e8
               strtod bricht die Analyse beim ersten Zeichen ab, das
               nicht mehr als zu einer Fliekommazahl geh”rig
               interpretiert werden kann.
               Solange der Parameter endptr nicht als \link("%%GLOBAL%%")NULL\# angegeben
               ist, wird er von strtod auf das Zeichen innerhalb von s
               gesetzt, durch das die Analyse abgebrochen wurde.

Ergebnis       strtod liefert das Ergebnis der Interpretation als
               \link("%%GLOBAL%%")double\# zurck - wenn sich die bergebene Zeichenkette
               berhaupt nicht analysieren l„t, dann ist das
               Ergebnis HUGE_VAL und \#errno\# wird entsprechend gesetzt.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#

Querverweis    \#strtol\#   \#strtoul\#
\end

screen( capsensitive("strtol") )
Name           ¯string to long® - Interpretiert einen String als
               einen long-Wert

Definition     long  strtol( const char *s, char **endptr, int radix );

Prototyp in    string.h

Beschreibung   strtol interpretiert den via s bergebenen String als
               long im durch radix angegebenen Zahlensystem.
               (radix = 10: Interpretation als Dezimalzahl;
               radix = 16:  Interpretation als Hexadezimalzahl usw.).
               Zul„ssige Werte fr diesen Parameter liegen im Bereich
               von 2..36.
               Die in s enthaltene Zeichenfolge mu das folgende
               Format haben (vgl. \#atol\#):

               [wl] [+|-] [0] [x|X] [ddd]

               [wl] steht hier fr ¯weie Leerzeichen®, [+|-] fr ein
               optionales Vorzeichen. Eine Ziffernfolge, die mit 0
               (oktal), 0x oder 0X (hexadezimal) beginnt, wird von
               strtol automatisch in diesem Format interpretiert,
               wenn fr radix der Wert 0 angegeben ist. (Fr alle
               anderen Werte von radix wird eine fhrende Null
               schlicht ignoriert, ein fhrendes 0x oder 0X ist
               ¯ungltig® und erzeugt das Funktionsergebnis 0).

               strtol bricht die Analyse beim ersten Zeichen ab, das
               nicht mehr als dem Wert zugeh”rig interpretiert werden+
               kann. Wenn fr den Parameter endptr die Adresse eines
               Zeigers angegeben wurde (und nicht der Wert \link("%%GLOBAL%%")NULL\#),
               dann wird dieser Zeiger auf die Adresse des nicht
               analysierbaren Zeichens in s gesetzt.
               Als ¯nicht zugeh”rig® gelten alle Zeichen, die bei
               einem durch radix festgelegten Zahlensystem keine
               gltigen Ziffern darstellen (im Dezimalsystem: alle
               Zeichen auer '0'..'9'; im Oktalsystem: nur die
               Ziffern '0'..'7'; bei einem Wert von 5 fr radix nur
               die Ziffern '0'..'4' usw.).

Ergebnis       strtol liefert das Ergebnis der Interpretation als long
               zurck. Wenn der String berhaupt nicht numerisch
               auswertbar ist oder fr radix ein Wert auerhalb der
               Grenzen 2..36 angegeben wurde, dann ist das Ergebnis 0,
               **endptr wird (soweit nicht als \link("%%GLOBAL%%")NULL\# angegeben) auf
               das erste Zeichen von s gesetzt.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strtoul") )
Name           ¯string to unsigned long® - Interpretiert einen String
               als einen unsigned long-Wert

Definition     unsigned long  strtoul( const char *s, char **endptr,
                                        int radix );

Prototyp in    string.h

Beschreibung   strtoul interpretiert den via s bergebenen String als
               unsigned long im durch radix angegebenen Zahlensystem.
               (radix = 10: Interpretation als Dezimalzahl;
               radix = 16:  Interpretation als Hexadezimalzahl usw.).
               Zul„ssige Werte fr diesen Parameter liegen im Bereich
               von 2..36. Die in s enthaltene Zeichenfolge mu das
               folgende Format haben (vgl. \#atol\#):

               [wl] [+|-] [0] [x|X] [ddd]

               [wl] steht hier fr ¯weie Leerzeichen®, [+|-] fr ein
               optionales Vorzeichen. Eine Ziffernfolge, die mit 0
               (oktal), 0x oder 0X (hexadezimal) beginnt, wird von
               strtoul automatisch in diesem Format interpretiert,
               wenn fr radix der Wert 0 angegeben ist. (Fr alle
               anderen Werte von radix wird eine fhrende Null
               schlicht ignoriert, ein fhrendes 0x oder 0X ist
               ¯ungltig® und erzeugt das Funktionsergebnis 0).

               strtoul bricht die Analyse beim ersten Zeichen ab, das
               nicht mehr als dem Wert zugeh”rig interpretiert werden
               kann. Wenn fr den Parameter endptr die Adresse eines
               Zeigers angegeben wurde (und nicht der Wert \link("%%GLOBAL%%")NULL\#), dann
               wird dieser Zeiger auf die Adresse des nicht
               analysierbaren Zeichens in s gesetzt.
               Als ¯nicht zugeh”rig® gelten alle Zeichen, die bei
               einem durch radix festgelegten Zahlensystem keine
               gltigen Ziffern darstellen (im Dezimalsystem: alle
               Zeichen auer '0'..'9'; im Oktalsystem: nur die
               Ziffern '0'..'7'; bei einem Wert von 5 fr radix nur
               die Ziffern '0'..'4' usw.).

Ergebnis       strtoul liefert das Ergebnis der Interpretation als
               unsigned long  zurck. Wenn der String berhaupt nicht
               numerisch auswertbar ist oder fr radix ein Wert
               auerhalb der Grenzen 2..36 angegeben wurde, dann ist
               das Ergebnis 0L, **endptr wird (soweit nicht als \link("%%GLOBAL%%")NULL\#
               angegeben) auf das erste Zeichen von s gesetzt.

Gruppe         \link("String- und Speichermanipulat")String- und Speichermanipulation\#
\end

screen( capsensitive("strftime") )
Name           ¯string format time® - Spezielle Formatierung eines
               Strings fr die Ausgabe von Uhrzeit und Datum

Definition     size_t  strftime( char *s, size_t max_size,
                                  const char *format,
                                  const struct tm *timeptr );
Prototyp in    time.h

Beschreibung   Die Funktion strftime schreibt h”chstens max_size
               Zeichen in den String s. Der String format dient zur
               Formatierung der Zeitangabe in der Struktur \#tm\#.
               Die Zeichen im String werden wie bei der Funktion
               printf behandelt, wobei jedoch folgende spezielle
               Formatier-Angaben verwendet werden:

                      %a  abgekrzter Wochentag
                      %A ausgeschriebener Wochentag
                      %b abgekrzter Monatsname
                      %B voller Monatsname
                      %c Datum und Uhrzeit
                      %d Tag im Monat (1-31)
                      %H Stunde (0-23)
                      %I Stunde (0-12)
                      %j Tag im Jahr (1-366)
                      %m Monat (1-12)
                      %M Minute (00-59)
                      %p AM/PM
                      %S Sekunde (00-59)
                      %w Wochentag (0-6)
                      %W Woche im Jahr (0-52)
                      %x lokale Datumsdarstellung
                      %X lokale Zeit-Darstellung
                      %y Jahr ohne Jahrhundert (0-99)
                      %Y Jahr mit Jahrhundertangabe
                      %Z Name der Zeitzone (z.B. MEZ)
                      %% das ¯%®-Zeichen

Ergebnis       strftime liefert als Ergebnis die Gesamtl„nge des
               Strings.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#ctime\#   \#size_t\#   \#localtime\#   \#gmtime\#
\end

screen( capsensitive("system") )
Name           ¯system® - šbergibt einen Befehl an einen Kommando-
               interpreter zur Ausfhrung

Definition     int  system( const char *command );

Prototyp in    stdlib.h

Beschreibung   Die Kommandozeile command wird an einen Kommando-
               interpreter bergeben und in einer impelementations-
               abh„ngigen Art und Weise ausgefhrt. Vorausetzung fr
               die Benutzung dieser Funktion ist, da Sie eine Shell
               verwenden, die die Systemvariable _shell_p oder das
               Setzen von Environmentvariablen untersttzt. _shell_p
               enth„lt die Adresse einer Routine, die eine Shell
               starten kann. Die Environmentvariable "SHELL" spezifi-
               ziert den Pfadnamen einer Shell.

Ergebnis       Falls kein Kommandointerpreter verfgbar ist, wird 0
               zurckgeliefert.
               Wird fr command NULL bergeben, erh„lt man einen Wert
               != 0 zurck, wenn ein Kommandointerpreter verfgbar
               ist. In allen anderen F„llen erh„lt man einen
               implementationsabh„ngigen Rckgabewert.

Beispiel       #include <stdlib.h>

               int  main( void )
               {
                   if( system( NULL ) != 0 )
                       system("del *.*");

                   return( 0 );
               }

Gruppe         \#Prozess-Routinen\#
\end

screen( capsensitive("tan") )
Name           ¯tangent® - Liefert den Tangens des Arguments

Definition     double  tan( double x );

Prototyp in    math.h

Beschreibung   tan erwartet einen Winkel in der Einheit rad (0 Grad =
               0 * ã, 90 Grad = ã/2, 180 Grad = ã, 270 Grad = 1.5 * P,
               360 Grad = 2 * ã usw.) als Argument und liefert den
               dazugeh”rigen Tangens zurck. šbergebene Werte werden
               automatisch auf den Bereich 0..2 * ã reduziert.
               Der Wert von ã (3.1415...) ist in math.h als Konstante
               mit dem Namen M_PI definiert

Ergebnis       tan liefert Werte unbegrenzter Gr”e, solange das
               Argument nicht zu dicht an P/2 oder -P/2 liegt - falls
               das Funktionsergebnis nicht mehr berechnet werden kann,
               wird der Wert 0 zurckgeliefert und \#errno\# bekommt den
               folgenden Wert ERANGE.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#perror\#   \#strerror\#   \#atan\#   \#atan2\#
\end

screen( capsensitive("tanh") )
Name           ¯tangent hyperbolic® - Liefert den Tangens hyperbolicus
               des Arguments

Definition     double  tanh( double x );

Prototyp in    math.h

Beschreibung   tanh berechnet den Tangens hyperbolicus des Arguments,

Ergebnis       Bei fehlerfreier Ausfhrung liefert die Funktion
               das entsprechende Ergebnis. Bei šberl„ufen wird
               HUGE_VAL (mit korrektem Vorzeichen) zurckgeliefert und
               \#errno\# bekommt den Wert ERANGE.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#atan\#   \#atan2\#
\end

screen( capsensitive("atanh") )
Name           ¯arcus tangent hyperbolic® - Liefert den Arcus Tangens
               hyperbolicus des Arguments

Definition     double  atanh( double x );

Prototyp in    math.h

Beschreibung   atanh berechnet den Arcus Tangens hyperbolicus des
               Arguments und erwartet Werte im Bereich von [-1,+1].

Ergebnis       Bei fehlerfreier Ausfhrung liefert die Funktion
               das entsprechende Ergebnis. Bei ungltigen Eingabe-
               werten erh„lt \#errno\# den Wert EDOM.
               Die Behandlung von Fehlern kann ber die Routine
               \#setmatherr\# modifiziert werden.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#atan\#   \#tanh\#   \#atan2\#
\end

screen( capsensitive("xdcnv") )
Name           ¯double extended to 8-Byte-double® - Konvertiert einen
               double(10 Byte) ins 8-Byte \link("%%GLOBAL%%")Fliekommaformat\#

Definition     void  xdcnv( double *oldval, void *rep8bytes );

Prototyp in    math.h

Beschreibung   xdcnv konvertiert den ber val angegebenen double ins
               8-Byte \link("%%GLOBAL%%")Fliekommaformat\# an die mit rep8bytes angegebene
               Adresse.

Ergebnis       Die Funktion liefert kein Ergebnis.

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#dxcnv\#
\end

screen( capsensitive("dxcnv") )
Name           ¯8-Byte-double to extended double® - Konvertiert einen
               double im 8-Byte \link("%%GLOBAL%%")Fliekommaformat\# ins 10 Byte
               \link("%%GLOBAL%%")Fliekommaformat\#

Definition     void  dxcnv( void *rep8bytes, double *val );

Prototyp in    math.h

Beschreibung   dxcnv konvertiert den ber die Adresse rep8bytes
               bergebenen 8-Byte double ins 10-Byte \link("%%GLOBAL%%")Fliekommaformat\#

Ergebnis       Die Funktion schreibt den konvertierten double an die
               Adresse val.

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#xdcnv\#
\end

screen( capsensitive("fpumode") )
Name           ¯floatingpoint unit mode® - Liefert den Status des
               Fliekomma-Koprozessors

Definition     int  fpumode( int disable );

Prototyp in    math.h

Beschreibung   Wird disable = 1 bergeben, so wird der Koprozessor
               von den \#Gleitkomma-Befehle\#n nicht angesprochen.
               Mit disable = 0 kann er wieder angesprochen werden,
               sofern er vorhanden ist.

Ergebnis       Die Funktion liefert den Status des Fliekomma-
               Koprozessors:
                   1:  MC 68881 vorhanden und aktiv
                   0:  MC 68881 nicht vorhanden oder nicht aktiv

Gruppe         \#Gleitkomma-Befehle\#

Querverweis    \#xdcnv\#
\end

screen( capsensitive("time") )
Name           ¯time® - Liefert Datum und Uhrzeit des Systems

Definition     time_t  time( time_t *timer );

Prototyp in    time.h

Beschreibung   time setzt die via timer bergebene Variable auf die
               Anzahl der Sekunden, die seit dem 1. Januar 1970,
               0 Uhr 00:00 (¯Greenwich Mean Time®) verstrichen sind.
               Die Angabe des Zeigerwertes \link("%%GLOBAL%%")NULL\# fr timer ist zul„ssig
               in diesem Fall liefert time das Funktionsergebnis ohne
               Speicherung.

Ergebnis       time liefert die Anzahl der seit dem 1.1.1970
               verstrichenen Sekunden auch als Funktionsergebnis
               zurck.

Gruppe         \#Datum und Uhrzeit\#

Querverweis    \#ctime\#   \#time_t\#  \link("time, struct time")struct time\#
\end

screen( capsensitive("tmpnam") )
Name           ¯temporary file name® - Liefert einen String, der als
               tempor„rer Dateiname verwendet werden kann

Definition     char  *tmpnam( char *str );

Prototyp in    stdio.h

Beschreibung   Die Funktion tmpnam erzeugt einen String, der als
               Dateiname verwendet werden kann und garantiert nicht
               mit einer bereits existierenden Datei identisch ist.
               Die Funktion kann mehrmals hintereinander aufgerufen
               werden und erzeugt dann immer neue Dateinamen. Wie oft
               diese Funktion aufgerufen werden kann, h„ngt von der
               Konstanten TMP_MAX ab. Wenn tmpnam ”fter als in
               TMP_MAX angegeben aufgerufen wird, ist das Ergebnis
               nicht definiert. tmpnam verwendet den unter str
               angelegten Puffer. Wenn als Parameter str der Wert
               \link("%%GLOBAL%%")NULL\# bergeben wurde, dann legt tmpnam den Puffer
               fr den Dateinamen selbst„ndig an.

Ergebnis       Die Funktion liefert als Ergebnis einen Zeiger auf
               einen tempor„ren Dateinamen.

Gruppe         \#I/O-Routinen\#

Querverweis    \#tmpfile\#
\end

screen( capsensitive("tmpfile") )
Name           ¯temporary file® - Erzeugt eine tempor„re Datei

Definition     FILE  *tmpfile( void );

Prototyp in    stdio.h

Beschreibung   Die Funktion tmpfile legt eine tempor„re Bin„rdatei an,
               die mit dem Zugriffsmodus Read/Write er”ffnet wird. Die
               Datei wird wieder entfernt, wenn die Datei geschlossen
               wird.

Ergebnis       Die Funktion liefert als Ergebnis den Handle der
               tempor„r angelegten Datei. Wenn die Datei nicht
               angelegt werden konnte, dann erh„lt man als Ergebnis
               einen \link("%%GLOBAL%%")NULL\#-Zeiger.

Gruppe         \#I/O-Routinen\#

Querverweis    \#tmpnam\#
\end

screen( capsensitive("toascii") )
Name           ¯to ASCII® - Konvertierung von Zeichen in das
               ASCII-Format

Definition     int  toascii( int c );

Prototyp in    ctype.h

Beschreibung   toascii begrenzt den Wert c (durch eine AND-Operation
               mit 0x7f) auf den Bereich 0..127.

Ergebnis       toascii liefert das Ergebnis dieser Begrenzung als
               Integer zurck.

Querverweis    \#tolower\#   \#toupper\#

Gruppe         \#Umwandlungsroutinen\#
\end

screen( capsensitive("tolower") )
Name           ¯to lowercase® - Prft auf ¯Grobuchstabe® und wandelt
               gegebenenfalls in einen Kleinbuchstaben um

Definition     int  tolower( int c );

Prototyp in    ctype.h

Beschreibung   tolower ist eine Funktion, die das bergebene Zeichen c
               in einen Kleinbuchstaben verwandelt. Damit diese
               Funktion korrekt arbeitet, mu c einen Wert im Bereich
               von 0..255 oder den Wert EOF haben.

Ergebnis       Die Funktion liefern das Ergebnis ihrer Konvertierung
               als int zurck.

Gruppe         \#Umwandlungsroutinen\#

Querverweis    \#toupper\#
\end

screen( capsensitive("toupper") )
Name           ¯to uppercase® - Prft auf ¯Kleinbuchstabe® und wandelt
               gegebenenfalls in einen Grobuchstaben um

Definition     int  toupper( int c );

Prototyp in    ctype.h

Beschreibung   toupper ist eine Funktion, die das bergebene Zeichen c
               in einen Grobuchstaben verwandelt. Damit diese
               Funktion korrekt arbeitet, mu c einen Wert im Bereich
               von 0..255 oder den Wert EOF haben.

Ergebnis       Die Funktion liefert das Ergebnis ihrer Konvertierung
               als int zurck.

Gruppe         \#Umwandlungsroutinen\#

Querverweis    \#tolower\#
\end

screen( capsensitive("ungetc") )
Name           ¯unget character® - Stellt ein aus einem stream
               gelesenes Zeichen zurck

Definition     int  ungetc( int c, FILE *stream );

Prototyp in    stdio.h

Beschreibung   ungetc stellt ein Zeichen fr eine erneute
               Leseoperation zurck, ist also tats„chlich das
               Gegenteil von \#getc\#. Praktisch zu jedem Zeitpunkt
               kann ein Zeichen zurckgestellt und sp„ter mit
               \#getc\# wieder gelesen werden. Es wird immer nur ein
               Zeichen gespeichert. Die Anwendung von \#fseek\# oder
               \#rewind\# auf eine Datei l”scht deren Puffer und damit
               auch ein eventuell mit ungetc zurckgestelltes Zeichen.

Ergebnis       ungetc liefert das zurckgestellte Zeichen als
               Funktionsergebnis, wenn die Aktion fehlerfrei
               ausgefhrt werden konnte - falls der entsprechende
               Puffer bereits besetzt ist, dann erh„lt man den
               Wert EOF.

Gruppe         \#I/O-Routinen\#

Querverweis    \#getch\#   \#fgetc\#   \#getchar\#   \#ferror\#   \#fopen\#
               \#fread\#   \#fseek\#   \#gets\#      \#putc\#     \#read\#
               \#scanf\#
\end

screen( capsensitive("ultoa") )
Name           ¯unsigned long to ascii® - Konvertiert einen unsigned
               long in einen String.

Definition     char  *ultoa( unsigned long value, char *string,
                              int radix );

Prototyp in    stdlib.h

Beschreibung   ultoa konvertiert den unsigned long value in einen
               nullterminierten String und speichert das Ergebnis
               in der durch String bezeichneten Variablen.
               Der Parameter radix legt die Basis fest auf der die
               konvertierung stattfinden soll - m”gliche Werte
               liegen im Bereich von 2 bis 36.
               ultoa erzeugt maximal 32 Zeichen.

Ergebnis       ultoa liefert einen Zeiger auf den gesetzten string
               zurck.

Gruppe         \#Umwandlungsroutinen\#

Querverweis    \#itoa\#   \#ltoa\#
\end

screen( capsensitive("unlink") )
Name           ¯unlink® - L”scht eine Datei.

Definition     int  unlink( const char *filename );

Prototyp in    stdio.h

Beschreibung   unlink l”scht die durch filename angegebene Datei,
               wobei filename einen vollst„ndigen Suchweg und/oder
               einen Laufwerksbezeichner enthalten kann. Die Joker-
               zeichen '*' und '?' sind in filename nicht erlaubt.
               Schreibgeschtzte Dateien und Directories k”nnen
               mit unlink nicht gel”scht werden. Um eine schreib-
               geschtzte Datei zu l”schen, mu zuerst das ent-
               sprechende Attribut entfernt werden.

Ergebnis       Bei fehlerfreier Ausfhrung liefert unlink den Wert 0
               zurck. Im Falle eines Fehlers ist das Funktions-
               ergebnis -1 und \#errno\# bekommt einen der folgenden
               Werte:
                              ENOENT    EACCES

Gruppe         \#I/O-Routinen\#

Querverweis    \#remove\#
\end

screen( capsensitive("va_list") )
va_list ist ein typloser Zeiger, der in STDARG.H definiert ist:

typedef void    *va_list;
\end

screen( capsensitive("va_...") )
Makros fr Funktionen mit variabler Parameterzahl
----------------------------------------------------------------------

Die Makros der Namensfamilie va_... erm”glichen es, Deklarationen
und Aufrufe von Funktionen mit variabler Parameterzahl ( z.B. printf )
in portabler Form zu halten.
Es wird in jedem Fall davon ausgegangen, da die entsprechende
Funktion eine bestimmte Anzahl obligatorischer Parameter erwartet.
Zus„tzliche Parameter k”nnen schrittweise erfat werden - auch dann,
wenn die Funktion selbst nicht ¯wei®, wieviele weitere Angaben zu
bearbeiten sind.
Um eine variable Anzahl von Parametern innerhalb einer Funktion zu
bearbeiten, sind die folgenden Schritte notwendig:
ù Deklaration der Funktion mit mindestens einem fixen Parameter.
  Auf den oder die fixen Parameter folgen ein Komma und drei Punkte,
  also
  Ergebnistyp <Name>(parm1, parm2, ...)
  Die fixen Parameter k”nnen innerhalb der Funktion wie gew”hnlich
  ber ihre Namen angesprochen werden.
ù Deklaration einer Zeigervariablen des (in stdarg.h definierten)
  Typs \#va_list\# innerhalb der Funktion sowie Deklaration lokaler
  Variablen, die in ihrem Typ den erwarteten variablen Parametern
  entsprechen.
ù Aufruf von \#va_start\# mit zwei Parametern: dem Namen des zuvor
  deklarierten Zeigers (Typ va_list) und dem Namen des letzten fixen
  Parameters - in unserem Beispiel also
  \#va_start\#(argpoint, parm2);
  Dieser Aufruf ermittelt anhand des angegebenen letzten fixen
  Parameters, wo der erste variable Parameter gespeichert ist, und
  setzt argpoint entsprechend.
ù Aufruf von \#va_arg\# mit zwei Parametern: dem zuvor mit \#va_start\#
  initialisierten Zeiger (argpoint) und dem Typ des ersten erwarteten
  variablen Parameters. Dieser Aufruf liefert den Wert des ersten
  variablen Parameters zurck und erh”ht argpoint entsprechend:

    onearg = va_arg(argpoint, int);

  Weitere Aufrufe von \#va_arg\# - wieder mit argpoint, der angegebene
  Typ kann theoretisch ein anderer sein - liefern weitere variable
  Parameter zurck. Eine spezielle Erkennung fr ¯letzter Parameter®
  gibt es nicht - hier mu irgendein Wert (wie 0, -1, \link("%%GLOBAL%%")NULL\# etc.)
  vereinbart werden.
ù Nach der Auswertung s„mtlicher Parameter mu ein Aufruf von \#va_end\#
  mit dem Zeiger (argpoint) als Parameter erfolgen. Dieser Aufruf
  setzt den Zeiger auf \link("%%GLOBAL%%")NULL\# zurck - wenn er fehlt, ergibt sich unter
  Umst„nden ein ausgesprochen merkwrdiges Verhalten des Programms.

Querverweis \#printf\#, \#scanf\#
\end

screen( capsensitive("va_arg") )
Name           ¯variable argument® - Liefert einen variablen Parameter
               einer Funktion zurck.

Definition     type  va_arg( \#va_list\# param, type );

Prototyp in    stdarg.h

Beschreibung   va_arg erwartet einen (zuvor via va_start
               initialisierten) Zeiger des Typs \#va_list\# (param) sowie
               einen Variablentyp (type), interpretiert den jeweils
               n„chsten variablen Parameter der Funktion als Wert des
               angegebenen Typs und liefert ihn zurck. Danach wird
               der Zeiger um sizeof(type) erh”ht.

Ergebnis       va_arg liefert den jeweils n„chsten variablen
               Parameter der Funktion in dem durch type angegebenen
               Format zurck.

Gruppe         \link("Behandlung variabler Argument")Behandlung variabler Argumente\#

Querverweis    \#va_...\#   \#va_start\#   \#va_end\#   \#va_list\#
\end

screen( capsensitive("va_end") )
Name           ¯variable [argument] end® - Beendet die Auswertung
               variabler Parameter einer Funktion.

Definition      void  va_end( \#va_list\# param );

Prototyp in    stdarg.h

Beschreibung   va_end setzt den als param angegebenen Zeiger des Typs
               \#va_list\# auf \link("%%GLOBAL%%")NULL\# zurck. Danach k”nnte der Kreislauf
               wiederholt werden (Aufruf von \#va_start\#, danach
               \#va_arg\# usw).

Ergebnis       va_end hat kein direktes Funktionsergebnis

Gruppe         \link("Behandlung variabler Argument")Behandlung variabler Argumente\#

Querverweis    \#va_...\#   \#va_arg\#   \#va_start\#  \#va_list\#
\end

screen( capsensitive("va_start") )
Name           ¯variable [argument] start® - Beginn der Auswertung
               variabler Argumente einer Funktion.

Definition     void  va_start( va_list param, lastfix );

Prototyp in    stdarg.h

Beschreibung   va_start erwartet die Angabe eines Zeigers des Typs
               va_list (param) sowie den Namen des letzten fixen
               Parameters der Funktion (fixend) und setzt param auf
               den Beginn des ersten variablen Parameters der
               Funktion.

Ergebnis       va_start hat kein direktes Funktionsergebnis

Gruppe         \link("Behandlung variabler Argument")Behandlung variabler Argumente\#

Querverweis    \#va_...\#   \#va_arg\#   \#va_end\#
\end

screen( capsensitive("vfprintf") )
Name           ¯variable file print formatted® - Formatierte Ausgabe
               zu einer Datei

Definition     #include <stdarg.h>
               int  vfprintf( FILE *fp, const char *format,
                               va_list arglist );

Prototyp in    stdio.h

Beschreibung   Alle \#printf\#-Funktionen ¯drucken® in formatierter
               Form und erwarten zumindest einen \link("Format-String (printf)")Format-String\#
               (¯variable file printf®) - wie \#fprintf\#, aber mit
               šbergabe der Parameter via va_list.

Ergebnis       S„mtliche Varianten von \#printf\# liefern die Anzahl der
               ausgegebenen Zeichen als Funktionsergebnis zurck.
               Im Falle eines Fehlers ist das Funktionsergebnis EOF.

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#fread\#    \#putc\#      \#puts\#       \#scanf\#    \#va_...\#
               \#printf\#   \#vprintf\#   \#vsprintf\#   \#sprintf\#,
               \#fprintf\#
\end

screen( capsensitive("vprintf") )
Name           ¯variable print formatted® - Formatierte Ausgabe
               zu stdout

Definition     #include <stdarg.h>
               int  vprintf( const char *format, va_list arglist );

Prototyp in    stdio.h

Beschreibung   Alle \#printf\#-Funktionen ¯drucken® in formatierter
               Form und erwarten zumindest einen \link("Format-String (printf)")Format-String\#
               (¯variable printf®) - wie \#printf\#, aber mit šbergabe der
               Parameter via va_list.

Ergebnis       S„mtliche Varianten von \#printf\# liefern die Anzahl der
               ausgegebenen Zeichen als Funktionsergebnis zurck.
               Im Falle eines Fehlers ist das Funktionsergebnis EOF.

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#fread\#    \#putc\#       \#puts\#       \#scanf\#    \#va_...\#
               \#printf\#   \#vfprintf\#   \#vsprintf\#   \#sprintf\#
               \#fprintf\#
\end

screen( capsensitive("vsprintf") )
Name           ¯variable string print formatted® - Formatierte Ausgabe
               in einen String

Definition     #include <stdarg.h>
               int  vsprintf( char *buffer, const char *format,
                               va_list arglist );

Prototyp in    stdio.h

Beschreibung   Alle \#printf\#-Funktionen ¯drucken® in formatierter
               Form und erwarten zumindest einen \link("Format-String (printf)")Format-String\#
               (¯variable string printf®) - wie \#sprintf\#, aber mit
               šbergabe der Parameter via va_list.

Ergebnis       S„mtliche Varianten von \#printf\# liefern die Anzahl der
               ausgegebenen Zeichen als Funktionsergebnis zurck,
               wobei das abschlieende Nullzeichen bei vsprintf nicht
               mitgez„hlt wird. Im Falle eines Fehlers ist das
               Funktionsergebnis EOF.

Gruppe         \#I/O-Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#fread\#    \#putc\#       \#puts\#      \#scanf\#    \#va_...\#
               \#printf\#   \#vfprintf\#   \#vprintf\#   \#sprintf\#
               \#fprintf\#
\end

screen( capsensitive("write") )
Name           ¯write® - schreibt Daten in eine Datei

Definition     size_t  write( int handle, void *buf, size_t len );

Prototyp in    stdio.h

Beschreibung   Die Funktion write liest len Bytes ab der durch buf
               angegebenen Adresse aus dem Speicher und schreibt sie
               in die durch handle bezeichnete Datei. handle ist eine
               vom \#Betriebssystem\# vergebene Referenznummer, die durch
               creat oder open erzeugt wird.

               Wenn die Datei im Modus ¯Append® (O_APPEND) er”ffnet
               wurde, setzt write die momentane Position automatisch
               auf das Dateiende (bereits existierende Daten k”nnen
               also nicht berschrieben werden). Bei Diskettendateien
               schreibt write ansonsten ab der momentanen Position
               (siehe \#lseek\#), bei Ger„te-Dateien wird direkt zum
               jeweiligen Ger„t geschrieben (bzw. in den dazugeh”rigen
               Puffer - siehe setbuf).

Ergebnis       Die Funktion liefert die Anzahl der tats„chlich ge-
               schriebenen Bytes zurck (wobei write die aus Zeilen-
               vorschben erzeugten CR/LF-Kombinationen als ein Byte
               z„hlt). Ein Funktionsergebnis von weniger als len steht
               normalerweise fr ¯Diskette voll®. Im Falle eines
               Fehlers wird der Wert -1 zurckgeliefert und \#errno\#
               bekommt einen der folgenden Werte:
                               EACCES    EBADF

Gruppe         \#I/O-Routinen\#
Querverweis    \#creat\#   \#lseek\#   \#open\#   \#read\#
\end

screen( capsensitive("errno") )
errno ist in ERRNO.H definiert und kann folgende Werte annehmen:

EPERM   1  /* file permission denied     Dateizugriff nicht erlaubt  */
ENOENT  2  /* file not found             Suchweg/Datei nicht gefunden*/
EIO     5  /* general i/o error          Ein-/Ausgabefehler          */
EBADF   9  /* invalid file handle        Ungltiges Handle           */
EILLSPE 10 /* illegal file specification Unerlaubte Spezifikation    */
EINVMEM 11 /* invalid heap block         Ungltiger Heapblock        */
ENOMEM  12 /* heap overflow              Heapberlauf                */
EACCES  13 /* file access mode error     Zugriff nicht erlaubt       */
EEXIST  17 /* file already exists        Datei existiert schon       */
EPLFMT  18 /* program load format error  Ladefehler wegem falschem   */
           /*                            Programmformat              */
ENODEV  19 /* device error               Devicefehler                */
ENOTDIR 20 /* path not found             Pfad nicht gefunden         */
EINVAL  22 /* invalid parameter          ungltiger Parameter        */
ENFILE  23 /* file table overflow        Zuviele Dateien             */
EMFILE  24 /* too many open files        Zuviele offene Dateien      */
ENOSPC  28 /* disk full                  Diskette voll               */
ESPIPE  29 /* seek error                 Seekfehler                  */
EROFS   30 /* read only device           Nur lesen erlaubt           */
EDOM    33 /* domain error               Argumente auerhalb des     */
           /*                            zul„ssigen Bereichs         */
ERANGE  34 /* range error                Ergebnis auerhalb des      */
           /*                            Bereichs                    */
ENMFILE 35 /* no more matching file      keine weitere Datei
                                         vorhanden (\#findnext\#)        */
\end

screen( capsensitive("__NFPUIN__") )
Dieses Makro bewirkt, das einige Fliekommafunktionen nicht in den 
entsprechenden FPU-befehl  bersetzt werden, falls der Schalter -8
bei den \link("%%GLOBAL%%")Compileroptionen\# gesetzt ist.
Folgende Fliekommafunktionen k”nnen bersetzt werden:

/* Arithmetische Befehle: */
\#fabs\#       \link("%%GLOBAL%%")fgetexp\#    \link("%%GLOBAL%%")fgetman\#    \link("%%GLOBAL%%")fint\#       \link("%%GLOBAL%%")fintrz\#
\#fmod\#       \link("%%GLOBAL%%")frem\#       \#ldexp\#      \link("%%GLOBAL%%")fsgldiv\#    \link("%%GLOBAL%%")fsglmul\#

/* Potenzen und Logarithmen: */
\#exp\#        \link("%%GLOBAL%%")fetoxm1\#    \#log\#        \link("%%GLOBAL%%")flognp1\#    \#log10\#
\#sqrt\#       \#pow10\#      \#pow\#

/* Trigonometrie: */
\#acos\#       \#asin\#       \#atan\#       \#cos\#        \#sin\#
\#tan\#

/* Hyperbelfunktionen: */
\#atanh\#      \#cosh\#       \#sinh\#       \#tanh\#
\end

screen( capsensitive("round") )
Name           ¯round® - Runden einer Fliekommazahl

Definition     double  round( double x );

Prototyp in    math.h

Beschreibung   round rundet eine Fliekommazahl nach dem ¯round to
               nearest®-Algorithmus. Das heit, es wird zur n„chst
               gelegenen ganzen Zahl auf- bzw. abgerundet. Ist der
               Nachkommaanteil genau 0.5, so wird die gerade Zahl
               gerundet, beispielsweise
                      146.67       ergibt       146.0
                      146.5        ergibt       146.0
                      147.5        ergibt       148.0

Ergebnis       Als Ergebnis erh„lt man die gerundete Zahl.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#trunc\#
\end

screen( capsensitive("trunc") )
Name           ¯truncate® - Ganzzahligen Anteil einer Fliekommazahl
               ermitteln.

Definition     double  trunc( double x );

Prototyp in    math.h

Beschreibung   trunc ermittelt den ganzzahligen Anteil einer Flie-
               kommazahl, sprich, es schneidet die Nachkommastellen
               ab. Zum Beispiel:
                      146.67       ergibt       146.0
                      -1.5         ergibt       -1.0

Ergebnis       Als Ergebnis erh„lt man den ganzahligen Anteil der
               Fliekommazahl.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#round\#
\end

screen( capsensitive("random") )
Name           ¯random® - Zufallszahl ermitteln.

Definition     int  random( int num );

Prototyp in    stdlib.h

Beschreibung   random ist als Makro definiert und liefert eine
               Zufallszahl aus dem Bereich von Null bis num - 1.

Ergebnis       Als Ergebnis erh„lt man eine ganzzahlige Zufalls-
               zahl zwischen 0 und num - 1.

Gruppe         \#Mathematische Routinen\#   \#Gleitkomma-Befehle\#

Querverweis    \#rand\#   \#srand\#
\end

screen( "BIOS" )
BIOS

Die BIOS-Funktionen stellen die unterste Schnittstelle des
\#Betriebssystem\#s zur Hardware des Atari ST dar. Diese Funktionen,
die in Assembler alle ber den 680X0-Trap #13 angesprochen werden,
erscheinen etwas zusammengewrfelt. Nur wenige dieser Funktionen
sollten in Applikationsprogrammen verwendet werden, da wesentlich
leistungsf„higere Funktionen auf h”herer Ebene als bessere Alterna-
tive verfgbar sind. In der nachfolgenden šbersicht finden Sie alle
BIOS-Funktionen des Atari ST. Die erste Zahl gibt die Funktionsnummer
des Traps an.

0  \#Getmpb\#   Speicherparameterblock ermitteln.
1  \#Bconstat\# Status eines Eingabeger„ts ermitteln.
2  \#Bconin\#   Zeichen von Eingabeger„t einlesen.
3  \#Bconout\#  Zeichen auf Ausgabeger„t ausgeben.
4  \#Rwabs\#    Sektoren auf Laufwerken lesen und schreiben.
5  \#Setexc\#   Exceptionvektoren ermitteln und festlegen.
6  \#Tickcal\#  Timer-Konstante ermitteln.
7  \#Getbpb\#   BIOS-Parameterblock eines Ger„ts ermitteln.
8  \#Bcostat\#  Status eines Ausgabeger„ts ermitteln.
9  \#Mediach\#  Ermitteln, ob die Diskette gewechselt wurde.
10 \#Drvmap\#   Angeschlossene Laufwerke ermitteln.
11 \#Kbshift\#  Tastaturstatus ermitteln.

Querverweis     \#VT-52-Terminal\#
\end

screen( "VT-52-Terminal",
		capsensitive("screen") )
Die Ausgabefunktionen des \link("GEMDOS")Gemdos\# bzw. \link("BIOS")Bios\# k”nnen ein
VT-52 Videoterminal emulieren. Dabei stehen folgende Steuercodes 
in der \link("%%GLOBAL%%")#include\#-datei screen.h zur Verfgung:

\#Bell\#                    Bell
\#Tab\#                     Tabulator
\#Return\#                  Carriage return
\#Line_feed\#               Line feed
\#Next_line\#               CR/LF

\#Cur_up\#                  Cursor up
\#Scroll_up\#               Cursor up and insert
\#Cur_down\#                Cursor down
\#Cur_right\#               Cursor right
\#Cur_left\#                Cursor left
\#Cur_home\#                Cursor home

\#Clear_home\#              Clear screen
\#Clear_down\#              Clear to end of screen
\#Clear_up\#                Clear to start of screen
\#Clear_line\#              Clear line
\#Clear_eol\#               Clear to end of line
\#Clear_sol\#               Clear to start of line

\#Ins_line\#                Insert line
\#Del_line\#                Delete line

\#Save_pos\#                Save cursor position
\#Load_pos\#                Restore cursor position
\#Goto_pos\#                Set cursor position

\#Ink\#                     Foreground color
\#Paper\#                   Background color
\#Rev_on\#                  Reverse video
\#Rev_off\#                 Normal video

\#Cur_on\#                  Show cursor
\#Cur_off\#                 Hide cursor

\#Wrap_on\#                 Wrap on
\#Wrap_off\#                Wrap off

Zus„tzlich wurden in SCREEN.H einige ntzliche \link("%%GLOBAL%%")Funktionen-Makros\#
mit aufgenommen:
\#Blink_on\#                Blink on
\#Blink_off\#               Blink off
\#Set_blink\#               Set blink rate
\#Get_blink\#               Get Blink rate
\end

screen( capsensitive("bios") )
Name           ¯bios® - BIOS-Trap ausfhren.

Definition     long bios (void, ...) ;

Prototyp in    tos.h

Beschreibung   Die Routine bios fhrt einen TRAP 14 durch. Die
               bergebenen Parameter h„ngen von der jeweiligen BIOS-
               Funktion ab.
Ergebnis       Die Funktion liefert als Ergebnis einen Wert vom
               Datentyp long.
Querverweis    Bibliotheksfunktionen: \#gemdos\#   \#xbios\#
               Betriebssystem: \link("BIOS")Bios\#
\end

screen( capsensitive("Bconin") )
Name           ¯BIOS console input® - Zeichen einlesen.

Biosnummer     2

Definition     long Bconin (int dev) ;

Prototyp in    tos.h
Beschreibung   Die BIOS-Routine Bconin liest ein Zeichen von einem
               Peripherieger„t dev ein. Als dev k”nnen am Atari ST
               folgende Ger„te angegeben werden.
0              prn: (Drucker)
1              aux: (serielle Schnittstelle
2              con: (Console)
3              MIDI-Schnittstelle
4              intelligente Tastatur
5              Bildschirm
Ab TOS030 (TT):
6              ST kompatible RS232-Port (Modem 1)
7              SCC Kanal B (Modem 2)
8              TTMFP serial Port (Modem 3)
9              SCC Kanal A (Modem 4)
               Eine falsche Angabe fr dev kann zum Absturz des
               Systems fhren.
Ergebnis       Die Funktion liefert als Ergebnis das eingelesene
               Zeichen. Beim Lesen von der Tastatur ist der
               entsprechende Scan-Code Von Funktionstasten und Cursor-
               Funktionen zu beachten.
Querverweis    \#Bconout\#   \#Keytbl\#   \#Bconmap\#
\end

screen( capsensitive("Bconout") )
Name           ¯BIOS console output® - Zeichen ausgeben.

Biosnummer     3

Definition     void Bconout (int dev, int c) ;

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Bconout schreibt das Zeichen c auf das
               Peripherieger„t dev. Als dev k”nnen am Atari ST
               folgende Ger„te angegeben werden.
0              prn: (Drucker)
1              aux: (serielle Schnittstelle
2              con: (Console, \#VT-52-Terminal\#)
3              MIDI-Schnittstelle
4              intelligente Tastatur
5              Bildschirm
Ab TOS030 (TT):
6              ST kompatible RS232-Port (Modem 1)
7              SCC Kanal B (Modem 2)
8              TTMFP serial Port (Modem 3)
9              SCC Kanal A (Modem 4)

               Eine falsche Angabe fr dev kann zum Absturz des
               Systems fhren. S„mtliche Codes von 0x00 bis 0xFF
               werden beim Zeichen c als druckbare Zeichen
               interpretiert.
Ergebnis       Die Funktion liefert kein Ergebnis.
Querverweis    \#Bconin\#   \#Bconstat\#   \#Bconmap\#
\end

screen( capsensitive("Bconstat") )
Name           ¯Bios console status® - Eingabestatus eines Peripherie-
               ger„tes.

Biosnummer     1

Definition     int Bconstat (int dev) ;

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Bconstat ermittelt den Eingabestatus
               eines Standardperipherieger„tes dev. Als dev k”nnen am
               Atari ST folgende Ger„te angegeben werden.
0              prn: (Drucker)
1              aux: (serielle Schnittstelle
2              con: (Console)
3              MIDI-Schnittstelle
4              intelligente Tastatur
5              Bildschirm
Ab TOS030 (TT):
6              ST kompatible RS232-Port (Modem 1)
7              SCC Kanal B (Modem 2)
8              TTMFP serial Port (Modem 3)
9              SCC Kanal A (Modem 4)
               Eine falsche Angabe fr dev kann zum Absturz des
               Systems fhren.
Ergebnis       Die Funktion liefert als Ergebnis -1, wenn Zeichen im
               Puffer liegen und 0, wenn dies nicht der Fall ist.
Querverweis    \#Bconin\#   \#Bconout\#   \#Bconmap\#
\end

screen( capsensitive("Bcostat") )
Name           ¯bios output status® - Status eines Standardausgabe-
               ger„tes ermitteln.

Biosnummer     8

Definition     long Bcostat (int dev) ;

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Bcostat ermittelt den Status eines
               Standardausgabeger„tes dev. Als dev k”nnen am Atari ST
               folgende Ger„te angegeben werden.
0              prn: (Drucker)
1              aux: (serielle Schnittstelle
2              con: (Console)
3              MIDI-Schnittstelle
4              intelligente Tastatur
5              Bildschirm
Ab TOS030 (TT):
6              ST kompatible RS232-Port (Modem 1)
7              SCC Kanal B (Modem 2)
8              TTMFP serial Port (Modem 3)
9              SCC Kanal A (Modem 4)
Ergebnis       Die Funktion liefert als Ergebnis den Status des Aus-
               gabeger„ts, n„mlich -1, wenn Zeichen geschrieben werden
               k”nnen, und 0, wenn der Puffer voll ist.
Querverweis    \#Bconout\#   \#Bconmap\#
\end

screen( capsensitive("Drvmap") )
Name           ¯drive map® - ermittelt die angeschlossenen Laufwerke.

Biosnummer     10

Definition     long Drvmap(void) ;

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Drvmap ermittelt die angeschlossenen
               Laufwerke. Fr jedes angeschlossene Laufwerk wird ein
               Bit gesetzt. Angefangen von Bit 0 (Laufwerk A:) bis hin
               zu Bit 15 (Laufwerk P:) werden alle Laufwerke
               aufgefhrt.
Ergebnis       Die Funktion liefert als Ergebnis einen Bitvektor fr
               die angeschlossenen Laufwerke.
\end

screen( capsensitive("Getbpb") )
Name           ¯get bios parameter block® - BIOS-Parameterblock eines
               Ger„tes ermitteln.

Biosnummer     7

Definition     \#BPB\# *Getbpb( int dev );

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Getbpb ermittelt den BIOS-Parameter-
               block des Ger„ts dev. 

Ergebnis       Die Funktion liefert als Ergebnis die Adresse des BIOS-
               Parameterblocks.
\end

screen( capsensitive("Getmpb") )
Name           ¯get memory parameter block® - Speicherparameter-
               Block kopieren.

Biosnummer     0

Definition     void Getmpb( MPB *ptr );

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Getmpb kopiert den Speicherparameter-
               block in den Bereich ptr. ptr mu auf einen 12 Byte
               groen Speicherbereich zeigen:
typedef struct
{
    void     *mfl;      /* Liste des freien Speicher */
    void     *mal;      /* Liste des belegten Speicher */
    void     *rover;    /* verschiebbarer Zeiger */
} MPB;
               Die verketteten Listen sind nur im Supervisor-Modus
               zug„nglich. Achtung: In bisherigen Versionen des TOS
               arbeitet diese Funktion fehlerhaft.
Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Kbshift") )
Name           ¯keyboard shift status® - ermittelt oder „ndert den
               Status der Spezial-Tasten.

Biosnummer     11

Definition     long Kbshift(int mode) ;

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Kbshift ermittelt oder „ndert den
               aktuellen Tastatur-Status. Wenn mode negativ ist, wird
               der Status lediglich ermittelt. Wenn mode 0 oder gr”er
               0 ist, dann wird der entsprechende Status neu gesetzt.
               Die einzelnen Bits sind wie folgt definiert:
Bit            Bedeutung
0              Shift-Taste rechts
1              Shift-Taste links
2              Control-Taste
3              Alternate-Taste
4              Caps Lock
5              Maustaste rechts
6              Maustaste links
7              reserviert (0)
Ergebnis       Die Funktion liefert als Ergebnis den gesetzten
               Tastatur-Status.
\end

screen( capsensitive("Mediach") )
Name           ¯media change® - stellt fest ob der Datentr„ger
               gewechselt wurde.

Biosnummer     9

Definition     long Mediach (int dev) ;

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Mediach stellt fest, ob der Daten-
               tr„ger gewechselt wurde.
Ergebnis       Die Funktion liefert als Ergebnis einen Integer-Wert
               mit folgender Bedeutung:
0              Diskette wurde nicht gewechselt
1              Diskette wurde vieleicht gewechselt
2              Diskette wurde gewechselt.
\end

screen( capsensitive("Rwabs") )
Name           ¯read write absolute® - direkter Lese-/Schreibzugriff
               auf ein Laufwerk.

Biosnummer     4

Definition     long Rwabs (int rwflag, void *buff, int cnt, int recnr,
                           int dev) ;

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Rwabs liest oder schreibt Daten direkt
               vom bzw. auf das Laufwerk, das mit dev angegeben wurde.
               Der Parameter rwflag bestimmt, ob gelesen (0) oder
               geschrieben (1) werden soll. Darberhinaus gibt es noch
               zwei weitere Werte fr diesen Parameter, um einen
               Diskettenwechsel zu ignorieren: Lesen (2) und Schreiben
               (3). Es werden cnt Zeichen vom Puffer buff bertragen.
               In recnr wird der Startsektor auf dem Laufwerk
               angegeben.
Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn der
               Zugriff erfolgreich war, ansonsten eine negative Zahl.
\end

screen( capsensitive("Setexc") )
Name           ¯set exception vector® - Interrupt-Vektoren setzen.

Biosnummer     5

Definition     void (*Setexc( int number, void (*exchdlr)() )) ();

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Setexc setzt einen neuen Interrupt-
               vektor fr den Interrupt mit der Nummer number auf die
               Adresse vektor. Wenn als Vektor-Adresse -1 bergeben
               wird, dann wird kein neuer Vektor gesetzt, sondern
               lediglich die alte Vektor-Adresse wird gelesen.
Ergebnis       Die Funktion liefert als Ergebnis die gesetzte Adresse.
\end

screen( capsensitive("Tickcal") )
Name           ¯tick calculation® - Zeitdifferenz zwischen zwei Timer-
               Aufrufen ermitteln.

Biosnummer     6

Definition     long Tickcal(void);

Prototyp in    tos.h

Beschreibung   Die BIOS-Routine Tickcal liefert die Anzahl an Milli-
               sekunden, die zwischen zwei Timerticks verstreichen.
Ergebnis       Die Funktion liefert als Ergebnis die Anzahl der Milli-
               sekunden.
\end

screen( capsensitive("Bell") )
Name           ¯Bell® - Systemglocke.

Definition     #define Bell() Cconout( '\\a' )

Definition in  screen.h

Beschreibung   Bell ist ein  Funktionen-Makro, das die Systemglocke
               ert”nen l„t. Damit k”nnen Sie sehr leicht ein akus-
               tisches Signal verwenden.
Querverweis    \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
               \link("%%GLOBAL%%")Funktionen-Makros\#
\end

screen( capsensitive("Tab") )
Name           ¯Tabulator® - Cursor zur n„chsten Tabulatorposition.

Definition     #define Tab() Cconout( '\\t' )

Definition in  screen.h

Beschreibung   Tab ist ein Funktionen-Makro, das den Cursor an die
               n„chste Tabulatorposition setzt.
Querverweis    \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
               \link("%%GLOBAL%%")Funktionen-Makros\#
\end

screen( capsensitive("Return") )
Name           ¯Carriage Return® - Cursor zum Anfang der Zeile.

Definition     #define Return() Cconout( '\\r' )

Definition in  screen.h

Beschreibung   Tab ist ein Funktionen-Makro, das den Cursor an den
               Anfang der aktuellen Zeile setzt.
Querverweis    \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
               \link("%%GLOBAL%%")Funktionen-Makros\#
\end

screen( capsensitive("Line_feed") )
Name           ¯Line feed® - Zeilenvorschub

Definition     #define Line_feed() Cconout( '\\n' )

Definition in  screen.h

Beschreibung   Line_feed ist ein Funktionen-Makro, das den Cursor in
               die n„chste Zeile setzt (Zeilenvorschub).
Querverweis    \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
               \link("%%GLOBAL%%")Funktionen-Makros\#
\end

screen( capsensitive("Next_line"),
		capsensitive("NEXT_LINE") )
Name           ¯CR/LF® - Cursor in eine neue Zeile.

Definition     #define NEXT_LINE   "\\r\\n"
               #define Next_line() Cconws( NEXT_LINE )

Definition in  screen.h

Beschreibung   Next_line ist ein Funktionen-Makro, mit der der TOS-cursor
               an den Anfang der n„chsten Zeile positioniert werden kann.  
               NEXT_LINE ist  ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz fr ¯CR/LF® definiert.  Damit haben Sie  die
               M”glichkeit, diese Sequenz in eigenen Stringkonstanten  zu
               verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Cur_up"),
		capsensitive("CUR_UP") )
Name           ¯Cursor up® - Cursor eine Zeile nach oben.

Definition     #define CUR_UP   "\\33A"
               #define Cur_up() Cconws( CUR_UP )

Definition in  screen.h

Beschreibung   Cur_up ist ein  Funktionen-Makro,  mit der der  TOS-cursor  
               um eine Zeile nach oben positioniert werden kann. Befindet
               sich  der  Cursor bereits in der  obersten Zeile, passiert
               nichts.
               CUR_UP   ist   ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz fr ¯Cursor up® definiert.  Damit haben  Sie 
               die M”glichkeit, diese Sequenz in eigenen Stringkonstanten
               zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Scroll_up"),
		capsensitive("SCROLL_UP") )
Name           ¯Cursor up and insert® - Cursor eine Zeile nach oben und
               scrollen.

Definition     #define SCROLL_UP   "\\33I"
               #define Scroll_up() Cconws( SCROLL_UP )

Definition in  screen.h

Beschreibung   Scroll_up ist ein Funktionen-Makro, mit der der TOS-cursor
               um eine Zeile nach oben positioniert werden kann. Befindet
               sich  der  Cursor bereits in der  obersten Zeile, wird der
               Bildschirminhalt um  eine Zeile  nach unten gescrollt  und
               eine Leerzeile eingefgt.
               SCROLL_UP ist  ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz fr  ¯Cursor up and insert® definiert. Damit
               haben  Sie  die  M”glichkeit,  diese  Sequenz  in  eigenen 
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Cur_down"),
		capsensitive("CUR_DOWN") )
Name           ¯Cursor down® - Cursor eine Zeile nach unten.

Definition     #define CUR_DOWN   "\\33B"
               #define Cur_down() Cconws( CUR_DOWN )

Definition in  screen.h

Beschreibung   Cur_down ist ein Funktionen-Makro,  mit der der TOS-cursor  
               um eine Zeile nach unten positioniert werden kann. Befindet
               sich  der  Cursor bereits in der  untersten Zeile, passiert
               nichts.
               CUR_DOWN  ist  ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz fr ¯Cursor down® definiert. Damit haben Sie 
               die M”glichkeit, diese Sequenz in eigenen Stringkonstanten
               zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Cur_right"),
		capsensitive("CUR_RIGHT") )
Name           ¯Cursor right® - Cursor eine Spalte nach rechts.

Definition     #define CUR_RIGHT   "\\33C"
               #define Cur_right() Cconws( CUR_RIGHT )

Definition in  screen.h

Beschreibung   Cur_right ist ein Funktionen-Makro,  mit der der TOS-cursor  
               um  eine Spalte nach rechts  positioniert werden kann.  Be-
               findet sich  der Cursor bereits in der ganz rechten Spalte,
               passiert nichts.
               CUR_RIGHT ist  ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz  fr ¯Cursor right®  definiert.  Damit haben 
               Sie die M”glichkeit, diese Sequenz  in eigenen Stringkons-
               tanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Cur_left"),
		capsensitive("CUR_LEFT") )
Name           ¯Cursor left® - Cursor eine Spalte nach links.

Definition     #define CUR_LEFT   "\\33D"
               #define Cur_left() Cconws( CUR_LEFT )

Definition in  screen.h

Beschreibung   Cur_left  ist ein Funktionen-Makro,  mit der der TOS-cursor  
               um  eine Spalte nach  links  positioniert werden kann.  Be-
               findet sich  der Cursor bereits in der  ganz linken Spalte,
               passiert nichts.
               CUR_LEFT  ist  ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz  fr  ¯Cursor left®  definiert.  Damit haben 
               Sie die M”glichkeit, diese Sequenz  in eigenen Stringkons-
               tanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("CUR_HOME"),
		capsensitive("Cur_home") )
Name           ¯Cursor home® - Cursor in die obere linke Ecke.

Definition     #define CUR_HOME   "\\33H"
               #define Cur_home() Cconws( CUR_HOME )

Definition in  screen.h

Beschreibung   Cur_home  ist ein Funktionen-Makro,  mit der der TOS-cursor  
               in die obere linke Ecke des Bildschirms positioniert werden 
               kann.
               CUR_HOME  ist  ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz  fr  ¯Cursor home®  definiert.  Damit haben 
               Sie die M”glichkeit, diese Sequenz  in eigenen Stringkons-
               tanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Clear_home"),
		capsensitive("CLEAR_HOME") )
Name           ¯Clear screen® - Bildschirm l”schen.

Definition     #define CLEAR_HOME   "\\33E"
               #define Clear_home() Cconws( CLEAR_HOME )

Definition in  screen.h

Beschreibung   Clear_home ist ein Funktionen-Makro,  mit der der gesamte
               Bildschirm gel”scht und der TOS-Cursor in die obere linke
               Ecke des Bildschirms positioniert werden kann.
               CLEAR_HOME ist ein  Konstanten-Makro,  welches  die VT-52 
               Steuersequenz fr ¯Clear screen®  definiert.  Damit haben 
               Sie die M”glichkeit, diese Sequenz  in eigenen Stringkons-
               tanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Clear_down"),
		capsensitive("CLEAR_DOWN") )
Name           ¯Clear to end of screen® - Bildschirm ab Cursor l”schen.

Definition     #define CLEAR_DOWN   "\\33J"
               #define Clear_down() Cconws( CLEAR_DOWN )

Definition in  screen.h

Beschreibung   Clear_down ist ein Funktionen-Makro, mit der der Bildschirm
               ab der Cursorposition gel”scht werden kann.
               CLEAR_DOWN ist ein   Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz fr ¯Clear to end of screen® definiert. Damit
               haben Sie die M”glichkeit, diese Sequenz in eigenen String-
               konstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("CLEAR_UP"),
		capsensitive("Clear_up") )
Name           ¯Clear to start of screen® - Bildschirm bis Cursor l”schen.

Definition     #define CLEAR_UP   "\\33d"
               #define Clear_up() Cconws( CLEAR_UP )

Definition in  screen.h

Beschreibung   Clear_up ist ein Funktionen-Makro, mit der der Bildschirm
               bis zur Cursorposition gel”scht werden kann.
               CLEAR_UP ist  ein  Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz  fr ¯Clear to start of screen®  definiert.
               Damit haben Sie die M”glichkeit, diese Sequenz in eigenen 
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Clear_line"),
		capsensitive("CLEAR_LINE") )
Name           ¯Clear line® - Aktuelle Zeile l”schen.

Definition     #define CLEAR_LINE   "\\33l"
               #define Clear_line() Cconws( CLEAR_LINE )

Definition in  screen.h

Beschreibung   Clear_line ist ein Funktionen-Makro, mit der die aktuelle
               Zeile gel”scht werden kann. Die nachfolgenden Zeilen wer-
               den nicht nachgeschoben.  Der Cursor  wird zum Anfang der
               Zeile gesetzt.
               CLEAR_LINE ist ein Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz fr ¯Clear line® definiert. Damit haben Sie
               die M”glichkeit,  diese Sequenz in eigenen Stringkonstan-
               ten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("CLEAR_EOL"),
		capsensitive("Clear_eol") )
Name           ¯Clear to end of line® - Aktuelle Zeile ab Cursor l”schen.

Definition     #define CLEAR_EOL   "\\33K"
               #define Clear_eol() Cconws( CLEAR_EOL )

Definition in  screen.h

Beschreibung   Clear_eol ist ein Funktionen-Makro, mit der die aktuelle
               Zeile ab der Cursorposition gel”scht werden kann.
               CLEAR_EOL ist ein Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz fr  ¯Clear to end of line® definiert. Da-
               mit haben Sie die M”glichkeit,  diese Sequenz in eigenen
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Clear_sol"),
		capsensitive("CLEAR_SOL") )
Name           ¯Clear to start of line® - Aktuelle Zeile ab Cursor l”schen.

Definition     #define CLEAR_SOL   "\\33o"
               #define Clear_sol() Cconws( CLEAR_SOL )

Definition in  screen.h

Beschreibung   Clear_sol ist ein Funktionen-Makro, mit der die aktuelle
               Zeile bis zur Cursorposition gel”scht werden kann.
               CLEAR_SOL ist ein Konstanten-Makro,  welches  die  VT-52 
               Steuersequenz   fr  ¯Clear to start of line®  definiert. 
               Damit haben Sie die M”glichkeit, diese Sequenz in eigenen
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Ins_line"),
		capsensitive("INS_LINE") )
Name           ¯Insert line® - Zeile einfgen.

Definition     #define INS_LINE   "\\33k"
               #define Ins_line() Cconws( INS_LINE )

Definition in  screen.h

Beschreibung   Ins_line ist ein Funktionen-Makro,  mit der  eine neue
               Zeile an der Cursorposition eingefgt werden kann. Der
               Cursor wird an den Anfang der neuen Zeile gesetzt.
               INS_LINE ist ein Konstanten-Makro,  welches die  VT-52 
               Steuersequenz fr ¯Insert line® definiert. Damit haben
               Sie die M”glichkeit,  diese Sequenz in eigenen String-
               konstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("DEL_LINE"),
		capsensitive("Del_line") )
Name           ¯Delete line® - Zeile entfernen.

Definition     #define DEL_LINE   "\\33M"
               #define Del_line() Cconws( DEL_LINE )

Definition in  screen.h

Beschreibung   Del_line ist ein Funktionen-Makro, mit der die aktuelle
               Zeile  gel”scht  werden kann.  Die nachfolgenen  Zeilen
               werden nachgeschoben, der Cursor wird an den Anfang der
               Zeile gesetzt.
               DEL_LINE ist ein Konstanten-Makro,  welches die  VT-52 
               Steuersequenz fr ¯Delete line® definiert. Damit haben
               Sie die M”glichkeit,  diese Sequenz in eigenen String-
               konstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("SAVE_POS"),
		capsensitive("Save_pos") )
Name           ¯Save cursor position® - Cursor "merken".

Definition     #define SAVE_POS   "\\33j"
               #define Save_pos() Cconws( SAVE_POS )

Definition in  screen.h

Beschreibung   Save_pos ist ein Funktionen-Makro, mit der die aktuelle
               Cursorposition  in einen  internen  Puffer  gespeichert
               wird. Die gespeicherte Cursorposition  kann sp„ter  mit
               \#Load_pos\# resaturiert werden.
               SAVE_POS ist ein  Konstanten-Makro,  welches die  VT-52 
               Steuersequenz  fr  ¯Save cursor position®   definiert. 
               Damit haben Sie  die M”glichkeit,  diese Sequenz in ei-
               genen Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Load_pos"),
		capsensitive("LOAD_POS") )
Name           ¯Restore cursor position® - Cursor restaurieren.

Definition     #define LOAD_POS   "\\33k"
               #define Load_pos() Cconws( LOAD_POS )

Definition in  screen.h

Beschreibung   Load_pos ist ein Funktionen-Makro, mit der der Cursor
               wieder an  die Stelle positioniert  werden kann,  die 
               vorher mit \#Save_pos\# "gemerkt" wurde.
               LOAD_POS ist ein Konstanten-Makro,  welches die VT-52 
               Steuersequenz fr ¯Restore cursor position® definiert. 
               Damit haben Sie die M”glichkeit, diese Sequenz in ei-
               genen Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Goto_pos"),
		capsensitive("GOTO_POS") )
Name           ¯Set cursor position® - Cursor positionieren.

Definition     #define GOTO_POS         "\\33Y"
               #define Goto_pos( x, y ) (Cconws( GOTO_POS ),\\
                                         Cconout( ' ' + x ),\\ 
                                         Cconout( ' ' + y ))

Definition in  screen.h

Beschreibung   Goto_pos ist ein Funktionen-Makro,  mit der der  Cursor
               an x-te Zeile und  y-te Spalte positioniert werden kann.
               Beachten Sie bitte, da die Z„hlung bei 0 beginnt.
               GOTO_POS ist ein  Konstanten-Makro,   welches die VT-52 
               Steuersequenz fr ¯Set cursor position®  definiert. Da-
               mit haben Sie die M”glichkeit, diese Sequenz in eigenen 
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("INK"),
		capsensitive("Ink") )
Name           ¯Foreground color® - Textfarbe setzen.

Definition     #define INK      "\\33b"
               #define Ink( c ) (Cconws( INK ), Cconout( c ))

Definition in  screen.h

Beschreibung   Ink ist ein Funktionen-Makro, mit der die  Textfarbe ge-
               setzt werden kann. Die Anzahl der verfgbaren Farben ist
               aufl”sungsabh„ngig.
               INK  ist ein Konstanten-Makro,  welches die VT-52 Steuer-
               sequenz fr ¯Foreground color® definiert. Damit haben Sie
               die M”glichkeit,  diese Sequenz in eigenen Stringkonstan-
               ten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("PAPER"),
		capsensitive("Paper") )
Name           ¯Background color® - Hintergrundfarbe setzen.

Definition     #define PAPER      "\\33c"
               #define Paper( c ) (Cconws( PAPER ), Cconout( c ))

Definition in  screen.h

Beschreibung   Paper ist ein Funktionen-Makro, mit der die Hintergrund-
               farbe gesetzt  werden kann.  Die Anzahl der  verfgbaren 
               Farben ist aufl”sungsabh„ngig.
               PAPER ist ein Konstanten-Makro, welches die VT-52 Steuer-
               sequenz fr ¯Background color® definiert. Damit haben Sie
               die M”glichkeit,  diese Sequenz in eigenen Stringkonstan-
               ten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Rev_on"),
		capsensitive("REV_ON") )
Name           ¯Reverse video® - Reverse Schrift einschalten.

Definition     #define REV_ON    "\\33p"
               #define Rev_on() Cconws( REV_ON )

Definition in  screen.h

Beschreibung   Rev_on ist ein Funktionen-Makro,  mit der die  reverse 
               Schrift (Hintergrund- und Textfarbe vertauscht) einge-
               schaltet  werden kann.  Dieser Modus kann mit  \#Rev_off\#
               wieder ausgeschaltet weden.
               REV_ON  ist ein  Konstanten-Makro,  welches die  VT-52 
               Steuersequenz fr ¯Reverse video® definiert. Damit ha-
               ben Sie  die  M”glichkeit,  diese Sequenz  in  eigenen
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("REV_OFF"),
		capsensitive("Rev_off") )
Name           ¯Normal video® - Reverse Schrift ausschalten.

Definition     #define REV_OFF    "\\33q"
               #define Rev_off()  Cconws( REV_OFF )

Definition in  screen.h

Beschreibung   Rev_off ist ein Funktionen-Makro, mit der die  reverse 
               Schrift (\#Rev_on\#) wieder ausgeschaltet werden kann.
               REV_OFF ist ein  Konstanten-Makro,  welches die  VT-52 
               Steuersequenz fr ¯Normal video® definiert.  Damit ha-
               ben Sie  die  M”glichkeit,  diese Sequenz  in  eigenen
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("CUR_ON"),
		capsensitive("Cur_on") )
Name           ¯Show cursor® - Cursor einschalten.

Definition     #define CUR_ON    "\\33e"
               #define Cur_on()  Cconws( CUR_ON )

Definition in  screen.h

Beschreibung   Cur_on ist ein Funktionen-Makro, mit der der Cursor
               eingeschaltet werden kann.
               CUR_ON ist ein  Konstanten-Makro,  welches die  VT-52 
               Steuersequenz fr ¯Show cursor® definiert.  Damit ha-
               ben Sie  die M”glichkeit,  diese Sequenz  in  eigenen
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("CUR_OFF"),
		capsensitive("Cur_off") )
Name           ¯Hide cursor® - Cursor einschalten.

Definition     #define CUR_OFF    "\\33f"
               #define Cur_off()  Cconws( CUR_OFF )

Definition in  screen.h

Beschreibung   Cur_off ist ein Funktionen-Makro, mit der der Cursor
               ausgeschaltet werden kann.
               CUR_OFF ist ein  Konstanten-Makro, welches die  VT-52 
               Steuersequenz fr ¯Hide cursor® definiert.  Damit ha-
               ben Sie  die M”glichkeit,  diese Sequenz  in  eigenen
               Stringkonstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("WRAP_ON"),
		capsensitive("Wrap_on") )
Name           ¯Wrap on® - Zeilenumbruch einschalten.

Definition     #define WRAP_ON    "\\33v"
               #define Wrap_on()  Cconws( WRAP_ON )

Definition in  screen.h

Beschreibung   Wrap_on  ist ein Funktionen-Makro, mit der der Zeilen-
               umbruch  eingeschaltet werden kann.  Dies bewirkt, da
               bei  Erreichen des  Endes einer Zeile  automatisch zum
               Anfang der n„chsten Zeile gesprungen wird. 
               WRAP_ON ist ein  Konstanten-Makro,  welches die  VT-52 
               Steuersequenz  fr ¯Wrap on®  definiert.  Damit  haben 
               Sie  die M”glichkeit, diese Sequenz  in eigenen String-
               konstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("WRAP_OFF"),
		capsensitive("Wrap_off") )
Name           ¯Wrap off® - Zeilenumbruch ausschalten.

Definition     #define WRAP_OFF    "\\33w"
               #define Wrap_off()  Cconws( WRAP_OFF )

Definition in  screen.h

Beschreibung   Wrap_off ist ein Funktionen-Makro, mit der der Zeilen-
               umbruch (\#Wrap_on\#) ausgeschaltet werden kann.
               WRAP_OFF ist ein  Konstanten-Makro, welches die  VT-52 
               Steuersequenz  fr ¯Wrap off® definiert.  Damit  haben 
               Sie  die M”glichkeit, diese Sequenz  in eigenen String-
               konstanten zu verwenden.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Blink_on") )
Name           ¯Blink on® - Cursorblinken einschalten.

Definition     #define Blink_on()  Cursconf( 2, 0 )

Definition in  screen.h

Beschreibung   Blink_on ist ein Funktionen-Makro, mit der das Blinken
               des Cursors eingeschaltet werden kann. Hierzu wird die
               \#XBIOS\#-funktion \#Cursconf\# verwendet.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Blink_off") )
Name           ¯Blink off® - Cursorblinken ausschalten.

Definition     #define Blink_off()  Cursconf( 3, 0 )

Definition in  screen.h

Beschreibung   Blink_off ist ein Funktionen-Makro, mit der das Blinken
               des Cursors eingeschaltet werden kann. Hierzu  wird die
               \#XBIOS\#-funktion \#Cursconf\# verwendet.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Set_blink") )
Name           ¯Set blink rate® - Cursorblinkfrequenz einstellen.

Definition     #define Set_blink( rate ) Cursconf( 4, rate )

Definition in  screen.h

Beschreibung   Set_blink ist ein Funktionen-Makro, mit der die Frequenz
               des Cursorblinkens eingestellt werden kann. Hierzu  wird
               die \#XBIOS\#-funktion \#Cursconf\# verwendet.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( capsensitive("Get_blink") )
Name           ¯Get blink rate® - Cursorblinkfrequenz abfragen.

Definition     #define Set_blink() Cursconf( 5, 0 )

Definition in  screen.h

Beschreibung   Get_blink ist ein Funktionen-Makro, mit der die Frequenz
               des  Cursorblinkens abgefragt  werden kann. Hierzu  wird
               die \#XBIOS\#-funktion \#Cursconf\# verwendet.
Querverweis    \link("%%GLOBAL%%")Funktionen-Makros\#   \link("%%GLOBAL%%")Konstanten-Makros\#
               \link("%%GLOBAL%%")Escapesequenzen\#     \#VT-52-Terminal\#
\end

screen( "XBIOS" )
XBIOS
----------------------------------------------------------------------

Diese Funktionen erm”glichen den geordneten Zugriff auf die verschie-
denen Spezial-Chips im Atari-ST. Sie werden ber den 680X0-Trap #14
aufgerufen.
Das XBIOS l„t sich in folgende Funktionsgruppen einteilen:

               \#Tastaturfunktionen\#
               \#Bildschirmfunktionen\#
               \#Druckerfunktionen\#
               \#Laufwerksfunktionen\#
               \#Datum, Uhrzeit und Zeitgeber\#
               \#Interruptfunktionen\#
               \#Schnittstellenprogrammierung\#
               \#Spezialbefehle\#

Ab Falcon 030:

               \#DSP-Programmierung\#
               \#Soundroutinen\#
\end

screen( "Tastaturfunktionen" )
Tastaturfunktionen
----------------------------------------------------------------------

Die folgenden Funktionen regeln die direkte Programmierung der Tasta-
tur. Mit \#Keytbl\# kann man eine eigene Tastaturtabelle installieren.
Die Funktion \#Bioskeys\# dient zur Reinitialisierung der Tastatur:
Die Tastatur wird in den Urzustand versetzt. Mit \#Kbrate\# kann man
das Ansprechverhalten der Tastatur einstellen. Es geht dabei darum,
ab welchem Zeitpunkt in den Auto-Repeat-Modus (automatische Tastatur-
wiederholung) umgeschaltet wird, und wie schnell der Auto-Repeat-Modus
durchgefhrt wird.

16 \#Keytbl\#   Neue Tabelle fr Tastaturcodes vorgeben
24 \#Bioskeys\# BIOS-Tabelle fr Tastaturcodes zurcksetzen
35 \#Kbrate\#   Auto-Repeat der Tastatur „ndern oder ermitteln
\end

screen( "Bildschirmfunktionen" )
Bildschirmfunktionen
----------------------------------------------------------------------

Zur direkten Programmierung des Bildschirms stehen mehrere Funktionen
zur Verfgung. Mit \#Initmouse\# und \#Cursconf\# kann man sowohl die Ein-
stellung des Grafik- als auch des Textcursors beeinflussen. Fr beson-
ders schnelle Animationen erweisen sich die beiden Funktionen \#Logbase\#
und \#Physbase\# als vorteilhaft: Auf dem logischen Bildschirm wird im
Hintergrund gezeichnet, dann schaltet man den physikalischen Bild-
schirm mit \#Setscreen\# um.

0   \#Initmouse\#   Mauszeiger initialisieren.
2   \#Physbase\#    Anfangsadresse des physikalischen Bildschirmspeichers
                ermitteln (der dargestellte Bildschirm).
3   \#Logbase\#     Anfangsadresse des logischen Bildschirmspeichers er-
                mitteln (der Bildschirm, auf dem gezeichnet wird).
4   \#Getrez\#      Aufl”sung ermitteln.
5   \#Setscreen\#   Festlegen der Bildschirmaufl”sung und der Bildschirm-
                adressen.
6   \#Setpalette\#  Farbpalette ausw„hlen.
7   \#Setcolor\#    Farbe einstellen.
21  \#Cursconf\#    Cursordarstellung „ndern oder ermitteln.
37  \#Vsync\#       Vertikales Synchronisationssignal abfragen.


Ab TOS030 (Atari TT) verfgbar:

80  \#EsetShift\#   Shift Mode Register setzen.
81  \#EgetShift\#   Shift Mode Register lesen.
82  \#EsetBank\#    Farbtabelle setzen.
83  \#EsetColor\#   Farbtabelleneintrag setzen.
84  \#EsetPalette\# Farbtabelle laden.
85  \#EgetPalette\# Farbtabelle lesen.
86  \#EsetGray\#    Farbinterpretation setzen.
87  \#EsetSmear\#   Farbverwischung setzen.


Ab Falcon 030 verfgbar:

88  \#Vsetmode\#    Videohardwareregister setzen.
89  \#mon_type\#    Monitortyp ermitteln.
90  \#VsetSync\#    Synchronisationsart setzen.
91  \#VgetSize\#    Gr”e des Bildschirmpuffers ermitteln.
93  \#VsetRGB\#     RGB-Wert einer Farbe setzen.
94  \#VgetRGB\#     RGB-Wert einer Farbe ermitteln.
150 \#VsetMask\#    Transparenz fr True-Color setzen.
\end

screen( "Druckerfunktionen" )
Druckerfunktionen
----------------------------------------------------------------------

20 \#Scrdmp\# Bildschirminhalt ausdrucken.
33 \#Setprt\# Druckereinstellung ermitteln oder „ndern.
36 \#Prtblk\# Hardcopy-Funktion mit Parameterblock.
\end

screen( "Laufwerksfunktionen" )
Laufwerksfunktionen
----------------------------------------------------------------------

8  \#Floprd\#   Einzelne Sektoren lesen.
9  \#Flopwr\#   Einzelne Sektoren schreiben.
10 \#Flopfmt\#  Spur auf einer Diskette formatieren.
18 \#Protobt\#  Bootsektor fr Diskette im Speicher generieren.
19 \#Flopver\#  Sektoren mit Speicherinhalt vergleichen.


Ab TOS030 (Atari TT) verfgbar:

42 \#DMAread\#  Sektoren von Festplatte lesen.
43 \#DMAwrite\# Sektoren auf Festplate schreiben.
\end

screen( "Datum, Uhrzeit und Zeitgeber" )
Datum, Uhrzeit und Zeitgeber im \#XBIOS\#
----------------------------------------------------------------------

22 \#Settime\# Datum und Uhrzeit einstellen.
23 \#Gettime\# Datum und Uhrzeit ermitteln.
31 \#Xbtimer\# Systemzeitgeber initialisieren.
\end

screen( "Interruptfunktionen" )
Interruptfunktionen
----------------------------------------------------------------------

26 \#Jdisint\#  Interrupts sperren.
27 \#Jenabint\# Interrupts freigeben.
\end

screen( "Schnittstellenprogrammierung" )
Schnittstellen-Programmierung
----------------------------------------------------------------------

14 \#Iorec\#    Interruptpuffer fr RS232, Tastatur-Chip und
            MIDI-Schnittstelle abfragen.
15 \#Rsconf\#   Konfiguration der RS232-Schnittstelle.
12 \#Midiws\#   Strings lesen und schreiben auf MIDI-Schnittstelle.
13 \#Mfpint\#   Programmierung des Multifunktionsperipherie-Chips.
25 \#Ikbdws\#   Programmierung des Tastatur-Chips.
28 \#Giaccess\# Register des GI-Soundchips lesen und schreiben.
29 \#Offgibit\# Bit im Port A-Register des GI-Chips l”schen.
30 \#Ongibit\#  Bit im Port A-Register des GI-Chips setzen.
32 \#Dosound\#  Sound-Befehle abschicken.
34 \#Kbdvbase\# Puffer und Interruptvektoren fr Maus-, MIDI-
            und Tastaturschnittstelle abfragen.


Ab TOS030 (Atari TT) verfgbar:

44 \#Bconmap\#  Ausw„hlen einer seriellen Schnittstelle.
\end

screen( "Spezialbefehle" )
Spezialbefehle
----------------------------------------------------------------------

1  \#Ssbrk\#    Speicherplatz reservieren (nur intern verwendet).
17 \#Random\#   Zufallszahlengenerator.
38 \#Supexec\#  Unterprogramm im Supervisormodus starten.
39 \#Puntaes\#  AES im ROM abschalten.
64 \#Blitmode\# Blitterkonfiguration „ndern oder ermitteln.
\end

screen( capsensitive("xbios") )
Name           ¯xbios® - XBIOS-Trap ausfhren.

Definition     long xbios (void, ...) ;

Prototyp in    tos.h

Beschreibung   Die Routine xbios fhrt einen TRAP 13 durch. Die
               bergebenen Parameter h„ngen von der jeweiligen \#XBIOS\#-
               Funktion ab.

Ergebnis       Die Funktion liefert als Ergebnis einen Wert vom
               Datentyp long.

Querverweis    Bibliotheksfunktionen: \#bios\#   \#gemdos\#
               Betriebssystem: \#XBIOS\#
\end

screen( "Soundroutinen" )
Soundroutinen                                         PCTOSLIB.LIB
------------------------------------------------------------------

Die PCTOSLIB.LIB enth„lt die folgenden Routinen zur Soundprogram-
mierung. Diese Routinen sind nur auf Computern der Falcon-Serie
verfgbar:

     \#buffoper\#       Aufnahme-/Wiedergabemodus setzen
     \#buffptr\#        Aufnahme-/Wiedergabeposition ermitteln
     \#devconnect\#     Audio-Subsystem-Komponenten verbinden
     \#dsptristate\#    Externe DSP-Hardware koordinieren
     \#gpio\#           šber externe DSP-Buchse kommunizieren
     \#locksnd\#        Soundsystem fr andere Anwendungen sperren
     \#setbuffer\#      Aufnahme-/Wiedergabepuffer setzen
     \#setinterrupt\#   Interrupt am Ende einer Aufnahme bzw.
                    einer Wiedergabe festlegen
     \#setmontracks\#   Wiedergabespur fr internen Lautsprecher
                    festlegen
     \#setmode\#        Aufnahme-/Wiedergabemodus w„hlen
     \#settracks\#      Spurenanzahl festlegen
     \#sndstatus\#      Status des A/D- und D/A-Wandlers ermitteln
     \#soundcmd\#       Parameter des A/D- und D/A-Wandlers setzen
                    oder ermitteln
     \#unlocksnd\#      Soundsystem fr andere Anwendungen freigeben
\end

screen( "DSP-Programmierung" )
DSP-Programmierung                                    PCTOSLIB.LIB
------------------------------------------------------------------

Die PCTOSLIB.LIB enth„lt die folgenden Routinen zur Programmie-
rung des Signal-Prozessors DSP56001, der in die Falcon-Computer
eingebaut ist:

    \#Dsp_Available\#             Freien Speicher ermitteln
    \#Dsp_BlkBytes\#              Byteweiser Datentransfer
    \#Dsp_BlkHandShake\#          Datentransfer mit Handshake
    \#Dsp_BlkUnpacked\#           Datentransfer von DSP-Worten mit
                              maximal 4 Byte L„nge
    \#Dsp_BlkWords\#              Wortweiser Datentransfer
    \#Dsp_DoBlock\#               Datentransfer
    \#Dsp_ExecBoot\#              Bootprogramm fr DSP laden
    \#Dsp_ExecProg\#              DSP-Programm starten
    \#Dsp_FlushSubroutines\#      Unterprogramme l”schen
    \#Dsp_GetProgAbility\#        Identifikation erfragen
    \#Dsp_GetWordSize\#           L„nge von DSP-Worten ermitteln
    \#Dsp_Hf0\#                   Bit 3 des HSR setzen bzw. l”schen
    \#Dsp_Hf1\#                   Bit 4 des HSR setzen bzw. l”schen
    \#Dsp_Hf2\#                   Bit 3 des HCR ermitteln
    \#Dsp_Hf3\#                   Bit 4 des HCR ermitteln
    \#Dsp_HStat\#                 Wert des ISR-Registers ermitteln
    \#Dsp_InqSubrAbility\#        Unterprogrammkennung ermitteln
    \#Dsp_InStream\#              Datentransfer zum DSP via Interrupt
    \#Dsp_IOStream\#              Datentransfer vom und zum DSP via
                              Interrupt
    \#Dsp_LoadProg\#              DSP-Programm laden und starten
    \#Dsp_LoadSubroutine\#        Unterprogramm installieren
    \#Dsp_Lock\#                  Verfgbarkeit des DSP ermitteln
    \#Dsp_LodToBinary\#           .LOD- in Bin„rformat konvertieren
    \#Dsp_MultBlocks\#            Datentransfer vom und zum DSP
    \#Dsp_OutStream\#             Datentransfer vom DSP via Interrupt
    \#Dsp_RemoveInterrupts\#      šbertragungsroutinen entfernen
    \#Dsp_RequestUniqueAbility\#  Identifikation erteilen
    \#Dsp_Reserve\#               Speicher reservieren
    \#Dsp_RunSubroutine\#         Unterprogramm ausfhren
    \#Dsp_SetVectors\#            Eigene šbertragungsroutinen instal-
                              lieren
    \#Dsp_TriggerHC\#             Host Command ausfhren
    \#Dsp_Unlock\#                DSP freigeben
\end

screen( capsensitive("Dsp_DoBlock") )
Dsp_DoBlock                                           PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_DoBlock( char *data_in, long size_in,
                                  char *data_out, long size_out );

Prototyp in       tos.h

Beschreibung      Die Funktion kopiert size_in DSP-Worte aus dem
                  Puffer data_in zum DSP. Nachdem alle Daten
                  bertragen wurden, wartet die Funktion bis die
                  Daten verarbeitet wurden. Dann werden size_out
                  DSP-Worte in den Puffer data_out zurckkopiert,
                  unabh„ngig davon, wieviel Daten wirklich vor-
                  liegen. Sollen keine Daten gesendet werden, mu
                  man size_in auf Null setzen. Gleiches gilt fr
                  das Empfangen, in diesem Fall wird size_out
                  Null zugewiesen. size_in und size_out sind auf
                  64 KByte begrenzt.
                  
Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_BlkHandShake\#   \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkWords\#       \#Dsp_BlkBytes\#
                  \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_BlkHandShake") )
Dsp_BlkHandShake                                      PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_BlkHandShake( char *data_in,
                                           long size_in,
                                           char *data_out,
                                           long size_out );

Prototyp in       tos.h

Beschreibung      Die Funktion kopiert size_in DSP-Worte aus dem
                  Puffer data_in zum DSP. Nachdem alle Daten
                  bertragen wurden, wartet die Funktion bis die
                  Daten verarbeitet wurden. Dann werden size_out
                  DSP-Worte in den Puffer data_out zurckkopiert,
                  unabh„ngig davon, wieviel Daten wirklich vor-
                  liegen. Sollen keine Daten gesendet werden, mu
                  man size_in auf Null setzen. Gleiches gilt fr
                  das Empfangen, in diesem Fall wird size_out
                  Null zugewiesen. size_in und size_out sind auf
                  64 KByte begrenzt. Daten werden nur ausgetauscht,
                  wenn der DSP-Proze dazu bereit ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkWords\#       \#Dsp_BlkBytes\#
                  \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_BlkUnpacked") )
Dsp_BlkUnpacked                                       PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_BlkUnpacked( long *data_in,
                                          long size_in,
                                          long *data_out,
                                          long size_out );

Prototyp in       tos.h

Beschreibung      Diese Funktion arbeitet nur mit DSP-Worten, die
                  h”chstens 4 Byte lang sind. Die L„nge der DSP-
                  Worte kann mit \#Dsp_GetWordSize\# bestimmt werden.
                  data_in und data_out sind long-Felder. size_in
                  und size_out beziehen sich auf die Gr”e der
                  Felder in Langworten. Je nach DSP-Wortl„nge
                  werden nur die unteren Bytes longs bertragen.
                  Die Funktion kopiert size_in DSP-Worte aus dem
                  Puffer data_in zum DSP. Nachdem alle Daten
                  bertragen wurden, wartet die Funktion bis die
                  Daten verarbeitet wurden. Dann werden size_out
                  DSP-Worte in den Puffer data_out zurckkopiert,
                  unabh„ngig davon, wieviel Daten wirklich vor-
                  liegen. Sollen keine Daten gesendet werden, mu
                  man size_in auf Null setzen. Gleiches gilt fr
                  das Empfangen, in diesem Fall wird size_out
                  Null zugewiesen. size_in und size_out sind auf
                  64 KByte begrenzt.
                  Es wird nicht garantiert, da die h”herwertigen
                  Bytes der empfangenen longs Null sind, wenn
                  die DSP-Wortl„nge kleiner als 4 ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkHandShake\#
                  \#Dsp_BlkWords\#       \#Dsp_BlkBytes\#
                  \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_BlkWords") )
Dsp_BlkWords                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_BlkWords( void *data_in,
                                       long size_in,
                                       void *data_out,
                                       long size_out );

Prototyp in       tos.h

Beschreibung      Die Funktion kopiert size_in vorzeichenbehaf-
                  tete 16-Bit-Worte aus dem Puffer data_in zum
                  DSP. Die Worte werden vor der šbertragung vor-
                  zeichenrichtig auf DSP-Wortbreite erweitert.
                  Nachdem alle Daten bertragen wurden, wartet
                  die Funktion bis die Daten verarbeitet wurden.
                  Dann werden size_out 16-Bit-DSP-Worte in den
                  Puffer data_out zurckkopiert, unabh„ngig da-
                  von, wieviel Daten wirklich vorliegen. Sollen
                  keine Daten gesendet werden, mu man size_in
                  auf Null setzen. Gleiches gilt fr das Empfan-
                  gen, in diesem Fall wird size_out Null zuge-
                  wiesen. size_in und size_out sind auf 64 KByte
                  begrenzt. Daten werden nur ausgetauscht, wenn
                  der DSP-Proze dazu bereit ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkHandShake\#   \#Dsp_BlkBytes\#
                  \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_BlkBytes") )
Dsp_BlkBytes                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_BlkBytes( void *data_in,
                                       long size_in,
                                       void *data_out,
                                       long size_out );

Prototyp in       tos.h

Beschreibung      Die Funktion kopiert size_in vorzeichenlose
                  Bytes aus dem Puffer data_in zum DSP. Nachdem
                  alle Daten bertragen wurden, wartet die Pro-
                  zedur bis die Daten verarbeitet wurden. Dann
                  werden size_out 8-Bit-DSP-Worte in den Puffer
                  data_out zurckkopiert, unabh„ngig davon, wie-
                  viel Daten wirklich vorliegen. Sollen keine
                  Daten gesendet werden, mu man size_in auf
                  Null setzen. Gleiches gilt fr das Empfangen,
                  in diesem Fall wird size_out Null zugewiesen.
                  size_in und size_out sind auf 64 KByte be-
                  grenzt. Daten werden nur ausgetauscht, wenn der
                  DSP-Proze dazu bereit ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkHandShake\#   \#Dsp_BlkWords\#
                  \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("DSPBLOCK") )
DSPBLOCK                                              PCTOSLIB.LIB
------------------------------------------------------------------

In der Headerdatei TOS.H ist die folgende Struktur DSPBLOCK zur
Parameterbergabe an die Funktion \#Dsp_MultBlocks\# definiert:

     typedef struct
     {
         int     blocktype;   /* Typ der Daten im Puffer: */
                              /*   0 : LongInt            */
                              /*   1 : Integer            */
                              /*   2 : Byte               */
         long    blocksize;   /* Puffergr”e              */
         void    *blockaddr;  /* Zeiger auf den Puffer    */
     } DSPBLOCK;
\end

screen( capsensitive("Dsp_MultBlocks") )
Dsp_MultBlocks                                        PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_MultBlocks( long numsend,
                                        long numreceive,
                                        \#DSPBLOCK\# *sendblocks,
                                        \#DSPBLOCK\# *receiveblocks );

Beschreibung      Die Funktion Dsp_MultBlocks sendet und empf„ngt
                  Daten vom DSP. numsend ist die Anzahl der zu
                  sendenden und numreceive die Anzahl der zu
                  empfangenden Bl”cke. sendblocks und receiveblocks
                  sind Zeiger auf Strukturen, die die Puffer und
                  Bl”cke beschreiben.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkHandShake\#   \#Dsp_BlkWords\#
                  \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_BlkBytes\#
\end

screen( capsensitive("Dsp_InStream") )
Dsp_InStream                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_InStream( char *data_in,
                                       long block_size,
                                       long num_blocks,
                                       long *blocks_done );

Prototyp in       tos.h

Beschreibung      Die Funktion kopiert mittels DSP-Interrupt-
                  behandlung num_blocks Datenbl”cke mit einer
                  Gr”e von block_size DSP-Worten aus dem Puffer
                  data_in zum DSP. Bei jedem Interrupt wird ein
                  Block bertragen, unabh„ngig davon, ob der DSP
                  empfangsbereit ist. Gleichzeitig wird der Z„hler
                  blocks_done, der die Anzahl der bertragenen
                  Bl”cke wiedergibt, inkrementiert. Da die Daten
                  per Interrupt bertragen werden, mu die Proze-
                  dur nicht warten. šber blocks_done kann das Pro-
                  gramm im weiteren Verlauf feststellen, ob die
                  šbertragung beendet ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkHandShake\#   \#Dsp_BlkWords\#
                  \#Dsp_BlkBytes\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_SetVectors\#     \#Dsp_RemoveInterrupts\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_OutStream") )
Dsp_OutStream                                         PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_OutStream( char *data_out,
                                        long block_size,
                                        long num_blocks,
                                        long *blocks_done );

Prototyp in       tos.h

Beschreibung      Die Funktion kopiert mittels DSP-Interrupt-
                  behandlung num_blocks Datenbl”cke mit einer
                  Gr”e von block_size DSP-Worten vom DSP in
                  dem Puffer data_out. Bei jedem Interrupt wird
                  ein Block bertragen. Gleichzeitig wird der
                  Z„hler blocks_done, der die Anzahl der ber-
                  tragenen Bl”cke wiedergibt, inkrementiert.
                  Da die Daten per Interrupt bertragen werden,
                  mu die Funktion nicht warten. šber blocks_done
                  kann das Programm im weiteren Verlauf feststel-
                  len, ob die šbertragung beendet ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkHandShake\#   \#Dsp_BlkWords\#
                  \#Dsp_BlkBytes\#       \#Dsp_InStream\#
                  \#Dsp_IOStream\#       \#Dsp_GetWordSize\#
                  \#Dsp_SetVectors\#     \#Dsp_RemoveInterrupts\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_IOStream") )
Dsp_IOStream                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_IOStream( char *data_in,
                                       char *data_out,
                                       long block_insize,
                                       long block_outsize,
                                       long num_blocks,
                                       long *blocks_done );

Prototyp in       tos.h

Beschreibung      Die Funktion sendet und empf„ngt gleichzeitig
                  mittels DSP-Interruptbehandlung num_blocks
                  Datenbl”cke mit einer Gr”e von block_insize
                  bzw. block_outsize DSP-Worten vom DSP. Die
                  gesendeten Daten werden dem Puffer data_in
                  entnommen, die empfangenen Daten werden im
                  Puffer data_out abgelegt. Bei jedem Interrupt
                  wird ein Block gesendet und einer empfangen
                  (eine Ausnahme bilden der erste und der letzte
                  Interrupt). Gleichzeitig wird der Z„hler
                  blocks_done, der die Anzahl der bertragenen
                  Bl”cke wiedergibt, inkrementiert. Da die Daten
                  per Interrupt bertragen werden, mu die Funktion
                  nicht warten. šber blocks_done kann das Programm
                  im weiteren Verlauf feststellen, ob die šbertra-
                  gung beendet ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkHandShake\#   \#Dsp_BlkWords\#
                  \#Dsp_BlkBytes\#       \#Dsp_InStream\#
                  \#Dsp_OutStream\#      \#Dsp_GetWordSize\#
                  \#Dsp_SetVectors\#     \#Dsp_RemoveInterrupts\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_SetVectors") )
Dsp_SetVectors                                        PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_SetVectors( void (*receiver)( ),
                                         long (*transmitter)( ));

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_SetVectors installiert
                  Routinen, die aufgerufen werden, wenn der
                  DSP ber einen Interrupt Daten bertragen
                  will. receiver ist ein Zeiger auf eine Routine,
                  die aufgerufen wird, nachdem der DSP Daten ver-
                  schickt hat, und transmitter ein Zeiger auf eine
                  Routine, die aufgerufen wird, bevor der DSP
                  Daten empf„ngt. Die Empfangsroutine receiver
                  erh„lt als Parameter auf dem Stack einen
                  long, der vom DSP gesendet wurde. Die Sende-
                  routine transmitter bergibt einen long an
                  den DSP in Register D0. Dieser mu ungleich
                  Null sein, damit er, d.h. dessen niederwertigen
                  drei Bytes an den DSP bertragen wird. Beide
                  Routinen werden mit dem Assemblerbefehl RTS
                  abgeschlossen.
                  Wird fr receiver oder transmitter 0 ber-
                  geben, so wird der entsprechende Interrupt ge-
                  sperrt. Um eine Routine wieder zu entfernen, mu
                  man \#Dsp_RemoveInterrupts\# aufrufen.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_RemoveInterrupts\#
\end

screen( capsensitive("Dsp_RemoveInterrupts") )
Dsp_RemoveInterrupts                                  PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_RemoveInterrupts( int mask );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_RemoveInterrupts unterbindet
                  die Generierung von DSP-Interrupts. Der Para-
                  meter mask bestimmt, welche Interrupts betroffen
                  sind:

                  ------------------------------------------------
                  mask  Bedeutung
                  ------------------------------------------------
                  1     Keine Interrupts zum Senden von Daten
                        durch den DSP
                  2     Keine Interrupts zum Empfangen von Daten
                        durch den DSP
                  3     Keine Interrupts zum Senden oder Empfangen
                        von Daten durch den DSP
                  ------------------------------------------------

                  Die Funktion entfernt ebenfalls Routinen, die
                  mit Dsp_SetVectors installiert wurden.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_InStream\#       \#Dsp_OutStream\#
                  \#Dsp_IOStream\#       \#Dsp_SetVectors\#
\end

screen( capsensitive("Dsp_GetWordSize") )
Dsp_GetWordSize                                       PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_GetWordSize( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_GetWordSize ermittelt die
                  Gr”e in Byte, die ein DSP-Wort lang ist.
                  Diese Funktion ist notwendig, um die Puffer
                  fr die Datenbertragung ausreichend zu dim-
                  ensionieren.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_DoBlock\#        \#Dsp_BlkUnpacked\#
                  \#Dsp_BlkHandShake\#   \#Dsp_BlkWords\#
                  \#Dsp_BlkBytes\#       \#Dsp_InStream\#
                  \#Dsp_IOStream\#       \#Dsp_OutStream\#
                  \#Dsp_MultBlocks\#
\end

screen( capsensitive("Dsp_Lock") )
Dsp_Lock                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_Lock( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Lock ermittelt, ob der DSP
                  fr Anwendungen verfgbar ist und nicht durch
                  jemand anders blockiert wird. Wird als Er-
                  gebnis -1 zurckgegeben, so wird der DSP
                  bereits durch einen anderen Proze benutzt.
                  Null dagegen kennzeichnet die Verfgbarkeit
                  des DSPs und blockiert ihn gleichzeitig fr
                  andere, bis ein Aufruf von \#Dsp_Unlock\# erfolgt.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_Unlock\#         \#Dsp_Available\#
                  \#Dsp_Reserve\#        \#Dsp_LoadProg\#
                  \#Dsp_ExecProg\#       \#Dsp_ExecBoot\#
\end

screen( capsensitive("Dsp_Unlock") )
Dsp_Unlock                                            PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_Unlock( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Unlock gibt den DSP fr andere
                  Prozesse frei.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_Lock\#           \#Dsp_Available\#
                  \#Dsp_Reserve\#        \#Dsp_LoadProg\#
                  \#Dsp_ExecProg\#       \#Dsp_ExecBoot\#
\end

screen( capsensitive("Dsp_Available") )
Dsp_Available                                         PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_Available( long *xavailable,
                                        long *yavailable );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Available ermittelt den freien
                  X- und Y-Speicher. Freier Speicher beginnt stets
                  an der physikalischen Adresse 0. Die unteren
                  64 Worte sind fr Interrupt-Vektoren reserviert.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_Lock\#           \#Dsp_Unlock\#
                  \#Dsp_Reserve\#        \#Dsp_LoadProg\#
                  \#Dsp_ExecProg\#       \#Dsp_ExecBoot\#
\end

screen( capsensitive("Dsp_Reserve") )
Dsp_Reserve                                           PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_Reserve( long xreserve, long yreserve );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Reserve reserviert xreserve
                  Worte X-Speicher und yreserve Worte Y-Speicher.
                  Die Speicheranforderung darf den verfgbaren
                  Speicher auf keinen Fall bertreffen. Diese
                  Funktion ist notwendig, damit DSP-Prozesse
                  nicht durch DSP-Unterprogramme berschrieben
                  werden. Die Reservierung bleibt bis zum n„chsten
                  Aufruf von Dsp_Reserve bestehen. Das Funktions-
                  resultat Null zeigt die erfolgreiche Reservie-
                  rung an, -1 steht fr einen Fehler.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_Lock\#           \#Dsp_Unlock\#
                  \#Dsp_Available\#      \#Dsp_LoadProg\#
                  \#Dsp_ExecProg\#       \#Dsp_ExecBoot\#
\end

screen( capsensitive("Dsp_LoadProg") )
Dsp_LoadProg                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_LoadProg( char *file, int ability,
                                                  char *buffer );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_LoadProg l„dt das DSP-Pro-
                  gramm mit dem Namen filename. Das Programm
                  mu im .LOD-Format vorliegen und darf den
                  durch \#Dsp_Reserve\# reservierten Speicher
                  nicht berschreiten. Der Parameter ability
                  identifiziert das Programm. buffer zeigt auf
                  einen Speicherbereich, in dem das generierte
                  Programm zwischengespeichert werden kann.
                  Die Gr”e des Speicherbereichs berechnet sich
                  nach der Formel

                       DSP-Wortgr”e * ( Anzahl der
                         Programm- und Datenworte in der
                         .LOD-Datei + ( DSP-Wortgr”e *
                           Anzahl der Bl”cke in der .LOD-
                           Datei ))

                  Danach wird das Programm ausgefhrt.
                  Der Rckgabewert Null signalisiert den er-
                  folgreichen Programmstart, ansonsten erh„lt
                  man -1.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_Lock\#           \#Dsp_Unlock\#
                  \#Dsp_Available\#      \#Dsp_Reserve\#
                  \#Dsp_ExecProg\#       \#Dsp_ExecBoot\#
                  \#Dsp_LodToBinary\#
\end

screen( capsensitive("Dsp_ExecProg") )
Dsp_ExecProg                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_ExecProg( char *codeptr,
                                       long codesize,
                                       int ability );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_ExecProg startet das im Bin„r-
                  Format an der Stelle codeptr vorliegende DSP-
                  Programm der L„nge codesize. Seine Gr”e darf
                  den durch \#Dsp_Reserve\# reservierten Speicher
                  nicht berschreiten. Der Parameter ability
                  identifiziert das Programm.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_Lock\#           \#Dsp_Unlock\#
                  \#Dsp_Available\#      \#Dsp_Reserve\#
                  \#Dsp_LoadProg\#       \#Dsp_ExecBoot\#
                  \#Dsp_LodToBinary\#
\end

screen( capsensitive("Dsp_ExecBoot") )
Dsp_ExecBoot                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_ExecBoot( char *codeptr,
                                       long codesize,
                                       int ability );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_ExecBoot l„dt ein Boot-Programm
                  in die 512 Worte des internen DSP-Speichers. Vor
                  dem Laden wird ein Reset auf dem DSP ausgefhrt.
                  Das DSP-Programm mu im Bin„r-Format vorliegen.
                  Der Parameter codeptr zeigt auf den Programm-
                  start. Die L„nge des Programms wird durch den
                  Parameter codesize bestimmt. ability identifi-
                  ziert das Programm.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_Lock\#           \#Dsp_Unlock\#
                  \#Dsp_Available\#      \#Dsp_Reserve\#
                  \#Dsp_LoadProg\#       \#Dsp_ExecProg\#
                  \#Dsp_LodToBinary\#
\end

screen( capsensitive("Dsp_LodToBinary") )
Dsp_LodToBinary                                       PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  Dsp_LodToBinary( char *file,
                                          char *codeptr );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_LodToBinary konvertiert den
                  Inhalt der .LOD-Datei mit dem Namen filename
                  ins Bin„rformat. Das so erzeugte DSP-Programm
                  wird an der Adresse codeptr abgelegt. Dieser
                  Speicherbereich mu ausreichend gro dimen-
                  sioniert sein. Danach kann das Programm mit
                  \#Dsp_ExecProg\# oder \#Dsp_ExecBoot\# ausgefhrt werden.
                  Bei erfolgreicher Konvertierung erh„lt man
                  als Resultat die L„nge des Programms in DSP-
                  Worten oder beim Auftreten eines Fehlers einen
                  negative Wert.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_Lock\#           \#Dsp_Unlock\#
                  \#Dsp_Available\#      \#Dsp_Reserve\#
                  \#Dsp_LoadProg\#       \#Dsp_ExecBoot\#
                  \#Dsp_ExecProg\#
\end

screen( capsensitive("Dsp_TriggerHC") )
Dsp_TriggerHC                                         PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_TriggerHC( int vector );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_TriggerHC fhrt Vector vector
                  aus. Nur die zwei Vektoren $13 und $14 stehen
                  DSP-Programmen zur freien Verfgung.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.
\end

screen( capsensitive("Dsp_RequestUniqueAbility") )
Dsp_RequestUniqueAbility                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_RequestUniqueAbility( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_RequestUniqueAbility erteilt
                  einem DSP-Proze eine fr die gesammte System-
                  laufzeit eindeutige Identifikation, mittels
                  derer man feststellen kann, ob der zum Proze
                  geh”rige Code resident im DSP vorhanden ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_GetProgAbility\#
\end

screen( capsensitive("Dsp_GetProgAbility") )
Dsp_GetProgAbility                                    PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_GetProgAbility( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_GetProgAbility erteilt
                  einem DSP-Proze eine Identifikation, mittels
                  derer man feststellen kann, ob der zum Proze
                  geh”rige Code bereits im DSP vorhanden ist.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_RequestUniqueAbility\#
\end

screen( capsensitive("Dsp_FlushSubroutines") )
Dsp_FlushSubroutines                                  PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  Dsp_FlushSubroutines( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_FlushSubroutines entfernt alle
                  Unterprogramme aus dem DSP-Speicher und erh”ht
                  somit den verfgbaren freien Speicher.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_LoadSubroutine\# \#Dsp_InqSubrAbility\#
                  \#Dsp_RunSubroutine\#
\end

screen( capsensitive("Dsp_LoadSubroutine") )
Dsp_LoadSubroutine                                    PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_LoadSubroutine( char *codeptr,
                                            long codesize,
                                            int ability );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_LoadSubroutine installiert das
                  DSP-Unterprogramm aus dem Puffer codeptr im
                  DSP-Speicher. Das Unterprogramm ist codesize
                  DSP-Worte lang und hat die Identifikation
                  ability. Als Resultat erh„lt man eine positive
                  Kennung, mittels derer das Unterprogramm mit
                  der Funktion \#Dsp_RunSubroutine\# aufgerufen werden
                  kann. Null zeigt an, da das Unterprogramm nicht
                  installiert werden konnte. Das Unterprogramm
                  bleibt solange resident im DSP-Speicher bis
                  kein Platz mehr fr neue Unterprogramme ist
                  und es verdr„ngt wird oder die Funktion
                  Dsp_FlushSubroutines aufgerufen wird.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_RunSubroutine\#  \#Dsp_FlushSubroutines\#
                  \#Dsp_InqSubrAbility\#
\end

screen( capsensitive("Dsp_InqSubrAbility") )
Dsp_InqSubrAbility                                    PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_InqSubrAbility( int ability );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_InqSubrAbility bestimmt die
                  Kennung des Unterprogramms mit der Funktio-
                  nalit„t abilitiy. Als Resultat erh„lt man die
                  Kennung des Unterprogramms. Ist das entspre-
                  chende Unterprogramm nicht im DSP-Speicher
                  vorhanden, wird Null zurckgegeben. In diesem
                  Fall mu das Unterprogramm mit \#Dsp_LoadSubroutine\#
                  installiert werden.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_RunSubroutine\#  \#Dsp_FlushSubroutines\#
                  \#Dsp_LoadSubroutine\#
\end

screen( capsensitive("Dsp_RunSubroutine") )
Dsp_RunSubroutine                                     PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_RunSubroutine( int handle );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_RunSubroutine fhrt das Unter-
                  programm mit der Kennung handle aus. Die Ken-
                  nung fr ein Unterprogramm findet man mittels
                  Dsp_InqSubrAbility oder Dsp_LoadSubroutine
                  heraus. Wird Null zurckgegeben, konnte das
                  Unterprogramm gestartet werden. Andernfalls
                  erh„lt man ein negatives Resultat.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_InqSubrAbility\# \#Dsp_FlushSubroutines\#
                  \#Dsp_LoadSubroutine\#
\end

screen( capsensitive("Dsp_Hf0") )
Dsp_Hf0                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_Hf0( int flag );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Hf0 ermittelt bzw. setzt den
                  Wert des Bits 3 des HSR. Der Parameter flag
                  hat die folgende Bedeutung:

                  ------------------------------------------------
                  flag  Bedeutung
                  ------------------------------------------------
                  0     Bit 3 des HSR l”schen
                  1     Bit 3 des HSR setzen
                  -1    Bit 3 des HSR unver„ndert lassen
                  ------------------------------------------------

                  Als Resultat erh„lt man den Wert des Bit 3 des
                  HSR.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_Hf1\#            \#Dsp_Hf2\#
                  \#Dsp_Hf3\#            \#Dsp_HStat\#
\end

screen( capsensitive("Dsp_Hf1") )
Dsp_Hf1                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_Hf1( int flag );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Hf1 ermittelt bzw. setzt den
                  Wert des Bits 4 des HSR. Der Parameter flag
                  hat die folgende Bedeutung:

                  ------------------------------------------------
                  flag  Bedeutung
                  ------------------------------------------------
                  0     Bit 4 des HSR l”schen
                  1     Bit 4 des HSR setzen
                  -1    Bit 4 des HSR unver„ndert lassen
                  ------------------------------------------------

                  Als Resultat erh„lt man den Wert des Bit 4 des
                  HSR.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_Hf0\#            \#Dsp_Hf2\#
                  \#Dsp_Hf3\#            \#Dsp_HStat\#
\end

screen( capsensitive("Dsp_Hf2") )
Dsp_Hf2                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_Hf2( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Hf2 ermittelt den Wert des
                  Bits 3 des HCR.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_Hf0\#            \#Dsp_Hf1\#
                  \#Dsp_Hf3\#            \#Dsp_HStat\#
\end

screen( capsensitive("Dsp_Hf3") )
Dsp_Hf3                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Dsp_Hf3( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_Hf3 ermittelt den Wert des
                  Bits 4 des HCR.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_Hf0\#            \#Dsp_Hf1\#
                  \#Dsp_Hf2\#            \#Dsp_HStat\#
\end

screen( capsensitive("Dsp_HStat") )
Dsp_HStat                                             PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       char  Dsp_HStat( void );

Prototyp in       tos.h

Beschreibung      Die Funktion Dsp_HStat ermittelt den Wert des
                  ISR-Registers. Somit kann man feststellen, ob
                  Daten empfangen oder gesendet werden k”nnen.

Hinweis           Die Funktion ist nur auf Computern mit dem
                  Signalprozessor DSP65001 verfgbar.

Querverweise      \#Dsp_Hf0\#            \#Dsp_Hf1\#
                  \#Dsp_Hf2\#            \#Dsp_Hf3\#
\end

screen( capsensitive("VERTFLAG"),
		capsensitive("FALC_VGA"),
		capsensitive("OVERSCAN"),
		capsensitive("TV"),
		capsensitive("BPS16"),
		capsensitive("PAL"),
		capsensitive("COL80"),
		capsensitive("STMODES"),
		capsensitive("BPS8"),
		capsensitive("NUMCOLS"),
		capsensitive("BPS1"),
		capsensitive("BPS2"),
		capsensitive("COL40"),
		capsensitive("BPS4") )
Konstanten zur Videohardware des Falcons              PCTOSLIB.LIB
------------------------------------------------------------------

Zur vereinfachten Programmierung des Videohardwareregisters des
Falcons mittels der Funktion \#Vsetmode\# sind in der Headerdatei
tos.h die folgenden Konstanten definiert, die mit | kombiniert
werden:

    #define VERTFLAG  0x0100  /* Interlace aktivieren          */
    #define STMODES   0x0080  /* ST-kompatible Grafik          */
    #define OVERSCAN  0x0040  /* Overscan aktivieren           */
    #define PAL       0x0020  /* PAL-Modus                     */
    #define FALC_VGA  0x0010  /* VGA-Modus                     */
    #define TV        0x0000  /* TV-Modus                      */

    #define COL80     0x0080  /* Bildbreite mind. 640 Pixel    */
    #define COL40     0x0000  /* Bildbreite 320 Pixel          */

    #define BPS16     4       /* 16 Farbebenen: 65536 Farben   */
    #define BPS8      3       /*  8 Farbebenen:   256 Farben   */
    #define BPS4      2       /*  4 Farbebenen:    16 Farben   */
    #define BPS2      1       /*  2 Farbebenen:     4 Farben   */
    #define BPS1      0       /*  1 Farbebenen:     2 Farben   */

Mit der folgenden Konstante kann die Anzahl der Farbebenen aus-
maskiert werden:

    #defineNUMCOLS    7       /* if (( mode & NUMCOLS ) == 0 ) */
                              /*   puts( "monochrome mode" );  */
\end

screen( capsensitive("Vsetmode") )
Vsetmode                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  Vsetmode( int modecode );

Prototyp in       tos.h

Beschreibung      Die Funktion Vsetmode programmiert das Video-
                  hardwareregister der Falcon-Computer. Die Bits
                  des Parameters mode haben folgende Bedeutung:

                  ------------------------------------------------
                  Bits   Bedeutung
                  ------------------------------------------------
                  0-2    Anzahl der Farbebenen:
                           0:    1 Ebene        2 Farben
                           1:    2 Ebenen       4 Farben
                           2:    4 Ebenen      16 Farben
                           3:    8 Ebenen     256 Farben
                           4:   16 Ebenen   65536 Farben

                  3      Gesetzt:  Bildbreite mindestens 640 Pixel
                         Gel”scht: Bildbreite 320 Pixel

                  4      Gesetzt:  VGA-Modus
                         Gel”scht: TV-Modus (auch Atari-SC-Monitore)

                  5      Gesetzt:  PAL-Modus
                         Gel”scht: NTSC-Modus

                  6      Gesetzt: Overscan aktiv

                  7      Gesetzt: ST-kompatible Grafik

                  8      Gesetzt: Interlace-Modus aktiv
                  ------------------------------------------------

                  Zur \link("VERTFLAG")einfacheren Kodierung\# sind vordefinierte
                  Konstanten vorhanden.
                  Als Resultat erh„lt man den alten Inhalt des
                  Videohardwareregisters.

Hinweis           Es findet keine šberprfung auf die Richtigkeit
                  der Kodierung fr den angeschlossenen Monitor
                  statt. Also Vorsicht!
                  Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#VsetSync\#           \#mon_type\#
                  \#VgetSize\#           \#VgetRGB\#
                  \#VsetRGB\#            \#VsetMask\#
\end

screen( capsensitive("mon_type") )
mon_type                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       int  mon_type( void );

Prototyp in       tos.h

Beschreibung      Die Funktion mon_type ermittelt den angeschlos-
                  senen Monitortyp. Als Resultat erh„lt man einen
                  der folgenden Werte:

                  ------------------------------------------------
                  Resultat  Bedeutung
                  ------------------------------------------------
                  0         ST-Monochrommonitor
                  1         ST-Farbmonitor
                  2         VGA-Monitor
                  3         TV-Ger„t
                  ------------------------------------------------

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#VsetSync\#           \#Vsetmode\#
                  \#VgetSize\#           \#VgetRGB\#
                  \#VsetRGB\#            \#VsetMask\#
\end

screen( capsensitive("VsetSync") )
VsetSync                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  VsetSync( int flag );

Prototyp in       tos.h

Beschreibung      Die Funktion VsetSync legt fest, auf welche Art
                  Synchronisation erfolgen soll. Der Parameter
                  flag wird wie folgt kodiert:

                  ------------------------------------------------
                  Bit    Bedeutung fr gesetzte Bits
                  ------------------------------------------------
                  0      Externer Takt
                  1      Vertikale Synchronisation
                  2      Horizontale Synchronisation
                  ------------------------------------------------

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#mon_type\#           \#Vsetmode\#
                  \#VgetSize\#           \#VgetRGB\#
                  \#VsetRGB\#            \#VsetMask\#
\end

screen( capsensitive("VgetSize") )
VgetSize                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  VgetSize( int mode );

Beschreibung      Die Funktion VgetSize ermittelt die Gr”e des
                  Bildschirmpuffers in Bytes fr den Grafikmodus
                  \#mode\#.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#mon_type\#           \#Vsetmode\#
                  \#VsetSync\#           \#VgetRGB\#
                  \#VsetRGB\#            \#VsetMask\#
\end

screen( capsensitive("VgetRGB") )
VgetRGB                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  VgetRGB( int index, int count, long *array );

Beschreibung      Die Funktion VgetRGB ermittelt die RGB-Werte
                  fr count Farben ab dem Farbindex index. Die
                  resultierenden Werte werden in array abgelegt.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#mon_type\#           \#Vsetmode\#
                  \#VsetSync\#           \#VgetSize\#
                  \#VsetRGB\#            \#VsetMask\#
\end

screen( capsensitive("VsetRGB") )
VsetRGB                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  VsetRGB( int index, int count, long *array );

Beschreibung      Die Funktion VsetRGB setzt die RGB-Werte
                  fr count Farben ab dem Farbindex index. Die
                  Farbwerte sind in array abgelegt.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#mon_type\#           \#Vsetmode\#
                  \#VsetSync\#           \#VgetSize\#
                  \#VgetRGB\#            \#VsetMask\#
\end

screen( capsensitive("VsetMask") )
VsetMask                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       void  VsetMask( int ormask, int andmask,
                                                 int overlay );

Beschreibung      Die Funktion VsetMask setzt Masken, die benutzt
                  werden, um die durch die VDI-Funktion \#vs_color\#
                  gesetzten Farben zu modifizieren. vs_color er-
                  mittelt zu seinem Parameter einen RGB-Wert.
                  Dieser wird bitweise mit ormask verodert und
                  mit andmask verundet. Somit k”nnen Farben im
                  True-Color-Modus transparent erscheinen.
                  Ist overlay ungleich Null, wird in den Overlay-
                  modus geschalten bzw. mit Null zurck.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#mon_type\#           \#Vsetmode\#
                  \#VsetSync\#           \#VgetSize\#
                  \#VgetRGB\#            \#VsetRGB\#
\end

screen( capsensitive("locksnd") )
locksnd                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  locksnd( void );

Prototyp in       tos.h

Beschreibung      Die Funktion locksnd sperrt das Soundsystem fr
                  andere Anwendungen.
                  Ist das Soundsystem bereits vergeben, so erh„lt
                  man als Ergebnis ein negatives Resultat oder
                  im Erfolgsfall den Wert 1.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("unlocksnd") )
unlocksnd                                             PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  unlocksnd( void );

Prototyp in       tos.h

Beschreibung      Die Funktion unlocksnd gibt das Soundsystem fr
                  andere Anwendungen frei, nachdem es zuvor ge-
                  sperrt wurde.
                  War das Soundsystem bereits verfgbar, so erh„lt
                  man als Ergebnis ein negatives Resultat oder
                  im Erfolgsfall den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#locksnd\#
\end

screen( capsensitive("soundcmd") )
soundcmd                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  soundcmd( int mode, int data );

Prototyp in       tos.h

Beschreibung      Die Funktion soundcmd setzt bzw. ermittelt die
                  Parameter des A/D- und D/A-Wandlers. Der Para-
                  meter mode bestimmt das Kommando und data die
                  vorzunehmende Einstellung.

                  ------------------------------------------------
                  mode  Bedeutung
                  ------------------------------------------------
                  0     Abschw„chung des linken Ausgabekanals um
                        1,5 Db Einheiten:
                            data = Einheiten << 4;

                  1     Abschw„chung des rechten Ausgabekanals um
                        1,5 Db Einheiten:
                            data = Einheiten << 4;

                  2     Verst„rkung des linken Ausgabekanals um
                        1,5 Db Einheiten:
                            data = Einheiten << 4;

                  3     Verst„rkung des rechten Ausgabekanals um
                        1,5 Db Einheiten:
                            data = Einheiten << 4;

                  4     Eingabequellen des 16-Bit-Hardware-
                        addierers. Bit 0 von data repr„sentiert
                        den A/D-Wandler und Bit 1 den Multiplexer

                  5     Eingabequellen des A/D-Wandlers. Bit 0
                        steht fr den rechten und Bit 1 fr den
                        linken Kanal. Ist ein Bit gesetzt, wird
                        werden die Daten dem Soundchip entnommen,
                        sonst dem Mikrophon.

                  6     Kompatibilit„t zum STE-Soundsystem. data
                        wird als Vorteiler genommen, falls der
                        mittels \#devconnect\# eingestellte Vorteiler
                        gleich Null ist:
                            0      Vorteiler ist 1280
                            1      Vorteiler ist 640
                            2      Vorteiler ist 320
                            3      Vorteiler ist 160
                  ------------------------------------------------

                  Wird fr den Parameter data der Wert -1 ber-
                  geben, so bleibt die Einstellung unver„ndert.
                  Als Resultat erh„lt man stets die aktuelle
                  Einstellung.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#unlocksnd\#
                  \#locksnd\#
\end

screen( capsensitive("setbuffer") )
setbuffer                                             PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  setbuffer( int reg, void *begaddr,
                                             void *endaddr );

Prototyp in       tos.h

Beschreibung      Die Funktion setbuffer setzt den Puffer fr
                  die Wiedergabe- (reg = 0) bzw. Aufnahmedaten
                  (reg = 1). Der Parameter begaddr zeigt auf
                  den Anfang des Puffers und endaddr auf das
                  letzte Byte + 1 des Puffers.
                  Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#locksnd\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("setmode") )
setmode                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  setmode( int mode );

Prototyp in       tos.h

Beschreibung      Die Funktion setmode gibt die Art des Aufnahme-
                  und Wiedergabemodus an:

                  ------------------------------------------------
                  mode  Bedeutung
                  ------------------------------------------------
                  0      8 Bit Stereo
                  1     16 Bit Stereo
                  2      8 Bit Mono
                  ------------------------------------------------

                  Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#locksnd\#
                  \#setbuffer\#          \#setinterrupt\#
                  \#setmontracks\#       \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("settracks") )
settracks                                             PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  settracks( int playtracks, int rectracks );

Prototyp in       tos.h

Beschreibung      Die Funktion settracks setzt die Anzahl der
                  Aufnahme- (rectracks) und Wiedergabespuren
                  (playtracks). Es stehen maximal je 4 Spuren
                  zur Verfgung. Als Argument wird die Anzahl
                  - 1 bergeben!
                  Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#locksnd\#
                  \#setbuffer\#          \#setinterrupt\#
                  \#setmontracks\#       \#setmode\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("setmontracks") )
setmontracks                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  setmontracks( int montrack );

Prototyp in       tos.h

Beschreibung      Die Funktion setmontracks legt fest, da die
                  Ausgabe einer bestimmten Spur ber den in-
                  ternen Lautsprecher erfolgen soll. Dieser
                  kann jeweils nur eine Spur wiedergeben.

Parameter         montrack bestimmt eine der vier m”glichen Spu-
                  ren. Diese sind von 0 bis 3 durchnumeriert.

Resultat          Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#locksnd\#
                  \#setbuffer\#          \#setinterrupt\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("setinterrupt") )
setinterrupt                                          PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  setinterrupt( int src_inter, int cause );

Prototyp in       tos.h

Beschreibung      Die Funktion setinterrupt bestimmt, welcher
                  Interrupt nach dem Aufnehmen bzw. Abspielen
                  ausgel”st werden soll.

Parameter         ------------------------------------------------
                  src_inter  Bedeutung
                  ------------------------------------------------
                  0          Timer-A-Interrupt
                  1          MFP-Interrupt 7
                  ------------------------------------------------

                  ------------------------------------------------
                  cause      Bedeutung
                  ------------------------------------------------
                  0          Kein Interrupt
                  1          Interrupt nach dem Abspielen
                  2          Interrupt nach dem Aufnehmen
                  3          Interrupt nach Aufnehmen und Ab-
                             spielen
                  ------------------------------------------------

Resultat          Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#locksnd\#
                  \#setbuffer\#          \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("buffoper") )
buffoper                                              PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  buffoper( int mode );

Prototyp in       tos.h

Beschreibung      Die Funktion buffoper legt den Aufnahme- und
                  Wiedergabemodus fest.

Parameter         Wird fr mode der Wert -1 bergeben, wird die
                  aktuelle Einstellung ermittelt. Sonst wird
                  mode wie folgt kodiert:

                  ------------------------------------------------
                  Bit  Operation
                  ------------------------------------------------
                  0    Wiedergabe
                  1    Wiedergabewiederholung
                  2    Aufnahme
                  1    Aufnahmewiederholung
                  ------------------------------------------------

                  Gesetzte Bits schalten eine Operation ein, ge-
                  l”schte Bits aus.

Resultat          Im Erfolgsfall liefert die Funktion den Wert 0.
                  Wurde fr mode -1 bergeben, erh„lt man die
                  aktuelle Einstellung, deren Kodierung der des
                  Parameters mode entspricht.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#buffptr\#            \#devconnect\#
                  \#dsptristate\#        \#gpio\#
                  \#locksnd\#            \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("dsptristate") )
dsptristate                                           PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  dsptristate( int dspxmit, int dsprec );

Prototyp in       tos.h

Beschreibung      Die Funktion dsptristate koppelt Leitungen vom
                  Multiplexer ab, wenn externe Hardware am SSI-
                  Port des DSP angeschlossen wird.

Parameter         ------------------------------------------------
                  Parameter  Bedeutung
                  ------------------------------------------------
                  dspxmit    Der Wert 0 koppelt den Multiplexer
                             von der entsprechenden Leitung ab,
                             1 erlaubt die Verbindung

                  dsprec     Der Wert 0 koppelt den Multiplexer
                             von der entsprechenden Leitung ab,
                             1 erlaubt die Verbindung
                  ------------------------------------------------

Resultat          Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#gpio\#
                  \#locksnd\#            \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("gpio") )
gpio                                                  PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  gpio( int mode, int data );

Prototyp in       tos.h

Beschreibung      Die Funktion gpio dient der Kommunikation ber
                  die externen DSP-Buchse.

Parameter         ------------------------------------------------
                  mode  Bedeutung
                  ------------------------------------------------
                  0     Setzen der Ein-/Ausgaberichtung
                        Die unteren drei Bits von data repr„sen-
                        tieren die Mehrzweckleitungen. Ein ge-
                        setztes Bit steht fr eine Ausgabe- und
                        ein gel”schtes fr eine Eingabeleitung.

                  1     Lesen der Mehrzweckleitungen
                        Den Status der Leitungen erh„lt man als
                        Funktionsresultat.

                  2     Schreiben auf den Mehrzweckleitungen
                        Der Parameter data enth„lt den neuen
                        Status der Mehrzweckleitungen.
                  ------------------------------------------------

Resultat          Im Erfolgsfall liefert die Funktion den Wert 0.
                  Hatte der Parameter mode den Wert 1, so erh„lt
                  man den Status der Mehrzweckleitungen.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#locksnd\#            \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("devconnect") )
devconnect                                            PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  devconnect( int src, int dst,
                                     int srcclk, int prescale,
                                     int protocol );

Prototyp in       tos.h

Beschreibung      Die Funktion devconnect verbindet Komponenten
                  des Audio-Subsystems.

Parameter         ------------------------------------------------
                  Parameter  Bedeutung
                  ------------------------------------------------
                  src        Quellkomponente:
                               0   DMA-Ausgabe
                               1   DSP-Ausgabe
                               2   Externer Eingabekanal
                               3   A/D-Wandler - Mikrophon

                  dst        Bitvektor der Zielkomponenten:
                               Bit 0   DMA-Eingabe
                               Bit 1   DSP-Eingabe
                               Bit 2   Externer Ausgabekanal
                               Bit 3   D/A-Wandler - Lautsprecher

                  srcclk     Takt fr die Quellkomponente:
                               0   Interner 25,175 MHz Takt
                               1   Externer Takt
                               2   Interner 32 MHz Takt

                  prescale   Taktvorteiler. Die Sample-Rate ergibt
                             sich aus dem Takt geteilt durch 256
                             und geteilt durch Vorteiler + 1. Die
                             Werte fr den Vorteiler rangieren
                             von 0 bis 11.
                             Wird fr den Vorteiler 0 bergeben,
                             wird in den \link("soundcmd")STE-Kompatibilit„tsmodus\#
                             geschaltet.

                  protocol   Wird 0 bergeben, findet eine šber-
                             tragung mit Handshaking statt, bei
                             1 erfolgt kein Handshaking.
                  ------------------------------------------------

Resultat          Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#dsptristate\#        \#gpio\#
                  \#locksnd\#            \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("sndstatus") )
sndstatus                                             PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  sndstatus( int reset );

Prototyp in       tos.h

Beschreibung      Die Funktion sndstatus ermittelt den aktuellen
                  Status des A/D- und D/A-Wandlers. Sie kann
                  diesen ebenfalls neu initialisieren.

Parameter         Hat res den Wert 1 wird der A/D- und D/A-Wand-
                  ler neu initialisiert (unteranderem werden die
                  šberlaufbits gel”scht). Andernfalls wird der
                  aktuelle Status ermittelt

Resultat          Liegt kein Fehler vor erh„lt man als Ergebnis
                  den Wert Null. Ansonsten stellt das Resultat
                  einen Bitvektor dar, der sich wie folgt ent-
                  schlsselt:

                  ------------------------------------------------
                  Bits  Bedeutung
                  ------------------------------------------------
                  0-3   1  Ungltiges Kontrollfeld
                        2  Ungltiges Syncformat
                        3  Ungltiger Takt

                  4     Linker šberlauf

                  5     Rechter šberlauf
                  ------------------------------------------------

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#buffoper\#           \#buffptr\#
                  \#devconnect\#         \#dsptristate\#
                  \#gpio\#               \#locksnd\#
                  \#setbuffer\#          \#setinterrupt\#
                  \#setmontracks\#       \#setmode\#
                  \#settracks\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("buffptr") )
buffptr                                               PCTOSLIB.LIB
------------------------------------------------------------------

Deklaration       long  buffptr( long *ptr );

Prototyp in       tos.h

Beschreibung      Die Funktion buffptr ermittelt die aktuelle
                  Wiedergabe- und Aufnahmepositionen in den ent-
                  sprechenden Puffern.

Parameter         bptr zeigt auf einen mindestens 4 Langworte
                  groen Puffer. In diesen werden die Positions-
                  zeiger angelegt. Der erste long des Puffer
                  enth„lt einen Zeiger auf die aktuelle Wieder-
                  gabeposition und der zweite long einen
                  Zeiger auf die aktuelle Abspielposition.

Resultat          Im Erfolgsfall liefert die Funktion den Wert 0.

Hinweis           Die Funktion ist nur auf Computern der Falcon-
                  Serie verfgbar.

Querverweise      \#buffoper\#           \#devconnect\#
                  \#dsptristate\#        \#gpio\#
                  \#locksnd\#            \#setbuffer\#
                  \#setinterrupt\#       \#setmontracks\#
                  \#setmode\#            \#settracks\#
                  \#sndstatus\#          \#soundcmd\#
                  \#unlocksnd\#
\end

screen( capsensitive("Bioskeys") )
Name           ¯BIOS standard keys® - Tastatur reinitialisieren.

Xbiosnummer    24

Definition     void Bioskeys(void);

Prototyp in    tos.h

Beschreibung   Bioskeys ist eine \#XBIOS\#-Routine zur Re-Initialisierung
               der Tastatur-Codes. Dies ist meist nur dann n”tig, wenn
               die Tastatur mit Hilfe der Funktion Keytbl
               umprogrammiert wurde.
Ergebnis       Die Funktion liefert kein Ergebnis.
Beispiel       Siehe Keytbl
Querverweis    \#Keytbl\#
\end

screen( capsensitive("Blitmode") )
Name           ¯blitter mode® - Blitter-Chip konfigurieren.

Xbiosnummer    64

Definition     int Blitmode(int mode);

Prototyp in    tos.h

Beschreibung   Blitmode ist eine \#XBIOS\#-Routine um den Blitter einzu-
               schalten oder seine Existenz festzustellen. Wenn im
               Parameter mode der Wert -1 angegeben wird, dann erh„lt
               man den Status des Blitter-Chips. Bei allen anderen
               Werten wird der Blitter konfiguriert:
               Bit            Beschreibung
               0              Blitter oder Line A umschalten
               1-14           reserviert (immer 0)
               15             immer 0
               Achtung: Diese Funktion gibt es zwar nur im Blitter-TOS.
               Sie liefert aber, wenn man sie nur als Nachfrage-
               Funktion verwendet, auch im alten TOS den korrekten
               Wert. (Bit 1 = 0: Blitter nicht vorhanden).
Ergebnis       Die Funktion liefert als Ergebnis im Bit 0 den Status
               des Blitters
                     0:  Blitter aus
                     1:  Blitter an
               und im Bit 1, ob ein Blitter vorhaden ist:
                     0:  Blitter nicht vorhanden
                     1:  Blitter vorhanden.
\end

screen( capsensitive("Cursconf") )
Name           ¯cursor configuration® - legt die Arbeitsweise des
               Cursors fest.

Definition     int Cursconf( int func, int rate );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Cursconf ver„ndert das Aussehen und
               wahlweise die Blinkgeschwindigkeit des Cursors. Der
               Parameter func kann folgende Werte annehmen:
0              Cursor abschalten
1              Cursor einschalten
2              Cursor blinkt
3              Cursor blinkt nicht
4              Die Blinkgeschwindigkeit des Cursors wird auf rate
               gesetzt.
5              Liefert die aktuelle Blinkfrequenz
               Der Parameter rate soll in Schritten der Wiederholfre-
               quenz des Bildschirms verwendet werden.
Ergebnis       Die Funktion liefert nur dann ein definiertes Ergebnis,
               n„mlich die Blinkfrequenz, wenn im Parameter func die
               Zahl 5 bergeben wurde.
\end

screen( capsensitive("Dosound") )
Name           ¯Dosound® - programmiert den Sound-Generator.

Xbiosnummer    32

Definition     void *Dosound( void *buf );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Dosound startet einen Proze zur
               Steuerung des Soundgenerators. Der Puffer buf enth„lt
               Befehle fr die Programmierung des Sound-Generators.
Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Flopfmt") )
Name           ¯Floppy format® - formatiert einzelne Spuren auf einer
               Diskette.

Xbiosnummer    10

Definition     int Flopfmt( void *buf, long filler, int devno,
                            int spt, int trackno, int sideno,
                            int interlv, long magic, int virgin );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Flopfmt formatiert eine oder mehrere
               Spuren auf einer Diskette. In dem durch buf adres-
               sierten Speicherbereich mu das Abbild von mindestens
               spt Sektoren Platz finden, so da eine Spur trackno auf
               der Seite sideno direkt formatiert werden kann. Der
               Parameter filler wird auer bei STs mit Blitter-TOS
               nicht verwendet, w„hrend interlv den physikalischen
               Abstand von logisch hintereinander geschriebenen Sek-
               toren festlegt. Der Parameter magic mu die Hexadezi-
               malzahl 0x87654321 enthalten. Der Parameter virgin ent-
               h„lt den Wert, der in neuen Sektoren abgelegt werden
               soll. Dazu wird normalerweise die Konstante 0xE5E5 ver-
               wendet.
Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn kein
               Fehler passiert ist, ansonsten einen Fehlercode.
Querverweis    \#Flopwr\#
\end

screen( capsensitive("DMAread") )
Name           ¯DMA read® - liest einzelne Sektoren von einer
               DMA-Einheit.

Xbiosnummer    42

Definition     int  DMAread( long sector, int count, 
                              void *buffer, int devno );

Prototyp in    tos.h

Beschreibung   Die \link("XBIOS")XBios\#-Routine DMAread liest einzelne oder mehrere
               Sektoren von der DMA-Einheit devno. sector ist die
               Nummer des ersten Sektors, count die Anzahl der zu
               lesenden Sektoren, buffer ist ein Zeiger auf das
               Standard-RAM des TT, in das die Daten gelesen werden
               soll.
               Folgende Werte sind fr denvo erlaubt:
                     0 -  7        ACSI Ger„te
                     8 - 15        SCSI Ger„te
                     Andere        Reserviert
Hinweis        Dise Funktion ist nur im TOS030 des TT vefgbar.
Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn kein
               Fehler passiert ist, ansonsten einen Fehlercode.
Querverweis    \#DMAwrite\#, \#Floprd\#, \#Flopwr\#
\end

screen( capsensitive("DMAwrite") )
Name           ¯DMA read® - schreibt einzelne Sektoren auf eine
               DMA-Einheit.

Xbiosnummer    43

Definition     int  DMAwrite( long sector, int count, 
                              void *buffer, int devno );

Prototyp in    tos.h

Beschreibung   Die \link("XBIOS")XBios\#-Routine DMAwrite schreibt einzelne oder
               mehrere Sektoren auf die DMA-Einheit devno. sector
               ist die Nummer des ersten Sektors, count die Anzahl der
               zu schreibenden Sektoren, buffer ist ein Zeiger auf das
               Standard-RAM des TT, aus dem die Daten geschrieben
               werden soll.
               Folgende Werte sind fr denvo erlaubt:
                     0 -  7        ACSI Ger„te
                     8 - 15        SCSI Ger„te
                     Andere        Reserviert
Hinweis        Dise Funktion ist nur im TOS030 des TT vefgbar.
Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn kein
               Fehler passiert ist, ansonsten einen Fehlercode.
Querverweis    \#DMAread\#, \#Floprd\#, \#Flopwr\#
\end

screen( capsensitive("Floprd") )
Name           ¯Floppy read® - liest einzelne Sektoren von einer
               Platteneinheit.

Xbiosnummer    8

Definition     int Floprd(void *buf, long filler, int devno,
                          int sectno, int trackno, int sideno,
                          int count);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Floprd liest einen oder mehrere Sek-
               toren von einer Platteneinheit. Der Inhalt der Sektoren
               wird in den durch buf adressierten Speicherbereich
               geladen. Der Parameter filler findet bei Computern ohne
               Blitter-TOS keinerlei Verwendung. Das jeweilige Ger„t
               wird unter devno angegeben. Mit dem Sektor sectno, der
               Spurnummer trackno, der Seite sideno wird der Start-
               punkt festgelegt, ab dem count Sektoren gelesen werden
               sollen.
Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn kein
               Fehler passiert ist, ansonsten einen Fehlercode.
Querverweis    \#DMAread\#, \#DMAwrite\#, \#Flopwr\#
\end

screen( capsensitive("Floprate") )
Name           ¯Floppy rate® - liest oder setzt die seek rate eines
               Floppylaufwerks.

Xbiosnummer    41

Definition     int Floprate( int devno, int newrate );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Floprate liefert die augeblickliche
               seek rate, wenn fr newrate -1 bergeben wird. Sonst
               wird die seek rate auf den Wert in newrate gesetzt.
               Gltige seek rate Werte sind:
               
               Wert   seek rate
               ----------------
               00      6 ms
               01     12 ms
               02      2 ms
               03      3 ms
               
               Es wird keine Bereichsberprfung fr devno und 
               newrate vorgenommen.
Hinweis        Floprate wird erst ab TOS 1.4 untersttzt
Ergebnis       Die Funktion liefert die seek rate als Ergebnis.
Querverweis    \#Flopwr\#, \#Floprd\#, \#Flopver\#, \#Flopfmt\#
\end

screen( capsensitive("Flopver") )
Name           ¯Flop verifify® - berprft Disketten.

Xbiosnummer    19

Definition     int Flopver(void *buf, long filler, int devno, int sect
no, int trackno, int sideno, int count);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Flopver untersucht einzelne Sektoren
               auf Disketten im Hinblick darauf, da sie einwandfrei
               gelesen werden k”nnen. Im Parameter buf wird ein 1024-
               Byte groer Puffer zur Auflistung eventuell besch„-
               digter Sektoren zur Verfgung gestellt. Der Eintrag
               filler wird auer im Blitter-TOS nicht verwendet.
               device enth„lt die Nummer des entsprechenden Laufwerks.
               sectno, trackno und sideno geben Sektor, Spur und Seite
               an. Die Anzahl der Sektoren wird in count bergeben.
Ergebnis       Die Funktion liefert als Ergebnis 0, wenn alle angege-
               benen Sektoren lesbar sind, und einen von 0 verschiede-
               nen Fehlercode, wenn einzelne Sektoren nicht gelesen
               werden konnten.
\end

screen( capsensitive("Flopwr") )
Name           ¯Floppy write® - schreibt einzelne Sektoren auf eine
               Platteneinheit.

Xbiosnummer    9

Definition     int Flopwr(void *buf, long filler, int devno,
                          int sectno, int trackno, int sideno,
                          int count);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Flopwr schreibt einen oder mehrere
               Sektoren auf eine Platteneinheit. Der Inhalt der
               Sektoren wird durch den mit buf adressierten Speicher-
               bereich berschrieben. Der Parameter filler findet
               keinerlei Verwendung. Das jeweilige Ger„t wird unter
               devno angegeben. Mit dem Sektor sectno, der Spurnummer
               trackno, der Seite sideno wird der Startpunkt fest-
               gelegt, ab dem count Sektoren geschrieben werden sollen.
Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn kein
               Fehler passiert ist, ansonsten einen Fehlercode.
Querverweis    \#DMAread\#, \#DMAwrite\#, \#Floprd\#
\end

screen( capsensitive("Getrez") )
Name           ¯get resolution® - ermittelt die Aufl”sung des Bild-
               schirms.

Xbiosnummer    4

Definition     int Getrez(void);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Getrez ermittelt die Aufl”sung des
               Bildschirms.
Ergebnis       Die Funktion liefert als Ergebnis folgende Werte:
2              hohe Aufl”sung
1              mittlere Aufl”sung
0              niedrige Aufl”sung
\end

screen( capsensitive("Gettime") )
Name           ¯get time® - Zeit ermitteln.

Xbiosnummer    23

Definition     unsigned long Gettime(void);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Gettime ermittelt Datum und Uhrzeit.
               Das 32-Bit-Ergebnis time wird wie folgt aufgesplittet:
Bit            Beschreibung
0-4            Sekunden in Einheiten von 2 (0-29)
5-10           Minuten (0-59)
11-15          Stunden (0-23)
16-20          Tag im Monat (1-31)
21-24          Monat (1-12)
25-31          Jahr (0-119, 0 steht fr 1980)
Ergebnis       Die Funktion liefert Datum und Uhrzeit als Ergebnis.
Gruppe         \#Datum und Uhrzeit\#   \#Pure-C-Spezialfunktionen\#
Querverweis    \#time\#   \#ctime\#   \#settime\#   \#gettime\#
\end

screen( capsensitive("Giaccess") )
Name           ¯access GI sound chip® - erm”glicht den Zugriff auf die
               Register des GI-Sound-Chips.

Xbiosnummer    28

Definition     char Giaccess(int data, int regno);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Giaccess erm”glicht den Zugriff auf
               die Register des GI-Sound-Chips.
Ergebnis       Die Funktion liefert als Ergebnis den Inhalt des ange-
               gebenen Registers.
\end

screen( capsensitive("Ikbdws") )
Name           ¯write string to keyboard® - programmiert den Tastatur-
               Chip.

Xbiosnummer    25

Definition     void Ikbdws(int count, void *ptr);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Ikbdws bergibt einen String, der
               unter ptr abgelegt wurde, an die intelligente Tastatur.
               Die L„nge des Strings wird in count festgelegt.
Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Initmouse") )
Name           ¯initialize mouse® - initialisiert die Maus.

Xbiosnummer    0

Definition     void Initmouse( int type, \#MOUSE\# *par,
                               void (*mousevec)() );

Prototyp in    tos.h

Beschreibung   Initmouse ist eine \#XBIOS\#-Routine zur Low-Level-
               Initialisierung der Maus. Der Parameter type legt die
               Betriebsart der Maus fest:
0              Maus abschalten
1              Relativ-Modus
2              Absolut-Modus
3              reserviert
4              Tastatursteuerung
               Das Argument par enth„lt die Adresse eines 14-Byte
               langen Parameter-Blocks. Die Bytes 0 bis 3 werden in
               allen Betriebsarten verwendet. Die Bytes von 4 bis 11
               werden nur dann verwendet, wenn die Maus im Absolut-
               Modus arbeiten soll.
0              Falls 0 Y-Achse oben 0, ansonsten unten 0
1              Parameter fr Maustasten festlegen
2              Parameter fr X-Achsen-Abgrenzung festlegen
3              Parameter fr Y-Achsen-Abgrenzung festlegen
4              H”herwertiges Byte fr die X-Achse
5              Niederwertiges Byte fr die X-Achse
6              H”herwertiges Byte fr die Y-Achse
7              Niederwertiges Byte fr die Y-Achse
8              H”herwertiges Byte fr die X-Koordinate der
               Anfangsposition
9              Niederwertiges Byte fr die X-Koordinate der
               Anfangsposition
A              H”herwertiges Byte fr die Y-Koordinate der
               Anfangsposition
B              Niederwertiges Byte fr die Y-Koordinate der
               Anfangsposition
               Unter addr erh„lt man die Adresse des Interrupt-Vektors
               der Maus.
Ergebnis       Die Funktion liefert kein Ergebnis.
Querverweis    \#MOUSE\#
\end

screen( capsensitive("Iorec") )
Name           ¯input output record® - Adresse des Ein-/Ausgabepuffers
               ermitteln.

Xbiosnummer    14

Definition     IOREC *Iorec( int dev );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Iorec liefert die Adresse des Ein-/
               Ausgabe-Puffers eines seriellen Ger„tes. Der Parameter
               dev kann folgende Werte annehmen:
0              RS-232
1              Tastatur
2              MIDI-Port
               Der resultierende Pointer zeigt auf folgende Struktur:
Ergebnis       Die Funktion liefert als Ergebnis einen Zeiger auf die
               Struktur \#IOREC\#.
Querverweis    \#IOREC\#   \#Bconmap\#
\end

screen( capsensitive("Jdisint") )
Name           ¯disable interrupt® - Unterbrechungen des multi-
               funktionalen Peripheriebausteins sperren.

Xbiosnummer    26

Definition     void Jdisint (int number);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Jdisint sperrt eine bestimmte Art von
               Interrupt, die mit number angegeben wird, am Multi-
               funktionsperipheriebaustein. Der Parameter number
               bezieht sich auf folgende Interrupts:
number         Beschreibung
0              I/O-Port Bit 0 Busy par. Schnittstelle
1              RS-232 DCD
2              RS-232 CTS
3              Blitter
4              Timer D, RS232-232 Baud-Generator
5              Timer C, 200-Hz System-Uhr
6              Tastatur und MIDI
7              FDC und DMA
8              Timer B Zeilenrcklauf
9              RS-232 Sendefehler
10             RS-232 Sendepuffer leer
11             RS-232 Empfangspuffer voll
12             RS-232 Puffer voll
13             Timer A
14             RS-232 RI
15             Monochrom-Monitor Detect
Ergebnis       Die Funktion liefert kein Ergebnis.
Querverweis    \#Jenabint\#   \#Mfpint\#
\end

screen( capsensitive("Jenabint") )
Name           ¯enable interrupt® - Unterbrechungen des multi-
               funktionalen Peripheriebausteins freigeben.

Xbiosnummer    27

Definition     void Jenabint (int number);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Jenabint gibt eine bestimmte Art von
               Interrupt, die mit number angegeben wird, am Multi-
               funktionsperipheriebaustein wieder frei. Der Parameter
               number bezieht sich auf folgende Interrupts:
number         Beschreibung
0              I/O-Port Bit 0 Busy par. Schnittstelle
1              RS-232 DCD
2              RS-232 CTS
3              Blitter
4              Timer D, RS232-232 Baud-Generator
5              Timer C, 200-Hz System-Uhr
6              Tastatur und MIDI
7              FDC und DMA
8              Timer B Zeilenrcklauf
9              RS-232 Sendefehler
10             RS-232 Sendepuffer leer
11             RS-232 Empfangspuffer voll
12             RS-232 Puffer voll
13             Timer A
14             RS-232 RI
15             Monochrom-Monitor Detect
Ergebnis       Die Funktion liefert kein Ergebnis.
Querverweis    \#Jdisint\#   \#Mfpint\#
\end

screen( capsensitive("Kbdvbase") )
Name           ¯keyboard vectors® - liefert einen Zeiger auf die
               Tastatur-Interruptvektoren.

Xbiosnummer    34

Definition     \#KBDVBASE\# *Kbdvbase(void);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Kbdvbase liefert einen Zeiger auf
               eine \#KBDVBASE\# Struktur.
Querverweis    \#KBDVBASE\#
\end

screen( capsensitive("Bconmap") )
Name           ¯Select serial port® - w„hlt eine Default-Schnittstelle 
               aus.

Xbiosnummer    44

Definition     long  Bconmap( int devno );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Bconmap w„hlt eine der seriellen 
               Schnittstellen fr die Biosausgabe aus. devno kann dabei 
               folgende Werte annehmen:
               -1        keine nderung,
                6        ST-kompatibler RS232-Port,
                7        SCC Kanal B,
                8        TTMFP RS232-Port,
                9        SCC Kanal A,
               >10       eigene Treiber.
Hinweis        Diese Funktion ist nur im TOS030 des TT vefgbar.
Ergebnis       Bconmap liefert die alte Einstellung. Falls devno gleich
               -2 ist liefert die Funktion einen Zeiger auf \#BCONMAP\#
               zurck. Wird die Funktion auf einem ST verwendet, liefert 
               sie die Konstante 44 zurck.
Querverweis:   \#BCONMAP\#, \#Bconout\#, \#Bconin\#, \#Bcostat\#, \#Bconstat\#, 
               \#Iorec\#, \#Rsconf\#
\end

screen( capsensitive("Kbrate") )
Name           ¯keyboard rate® - legt die Autorepeat-Rate der Tastatur
               fest.

Xbiosnummer    35

Definition     int Kbrate (int initial, int repeat);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Kbrate ermittelt oder „ndert die
               aktuelle Auto-Repeat-Geschwindigkeit der Tastatur.
               Die Geschwindigkeit wird als Vielfaches der System-
               einheit von 20 Millisekunden festgelegt. initial legt
               die Zeitdauer fest, nach der Auto-Repeat-Modus
               einsetzen soll, repeat bestimmt die Pausen zwischen
               einer Wiederholung. Wenn beide Parameter mit -1 ber-
               geben wurden, dann wird die aktuelle Einstellung
               gelesen.
Ergebnis       Die Funktion liefert als Ergebnis die Einstellung des
               Auto-Repeat-Modus.
\end

screen( capsensitive("Keytbl") )
Name           ¯key table® - definiert die Umsetzungstabelle der
               Tastatur von Scan-Codes in Tastatur-Codes.

Xbiosnummer    16

Definition     \#KEYTAB\# *Keytbl( void *unshift, void *shift,
                               void *capslock );

Prototyp in    tos.h

Beschreibung   Keytbl ist eine \#XBIOS\#-Funktion mit deren Hilfe eine
               neue Tastatur-Tabelle fr die Umsetzung von Scan-Codes
               in Tastatur-Codes vorgenommen werden kann. Beim
               Atari ST erzeugt jeder Tastendruck einen Scan-Code.
               Dabei k”nnen bei jeder Taste drei verschiedene Scan-
               Codes herauskommen, je nachdem, ob die Shift-Taste ge-
               drckt ist oder ob die Capslock-Taste eingeschaltet
               ist. Dieser Scan-Code wird anschlieend mit Hilfe einer
               128 Byte langen Tabelle in einen ASCII-Code umgewandelt.
Ergebnis       Die Funktion liefert als Ergebnis einen Zeiger auf die
               Struktur \#KEYTAB\#.
Querverweis    \#Bioskeys\#
\end

screen( capsensitive("Logbase") )
Name           ¯logical screen RAM base® - ermittelt die logische
               Anfangsadresse des Videospeichers.

Xbiosnummer    3

Definition     void *Logbase(void);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Logbase ermittelt die logische
               Anfangsadresse des momentan als Videospeicher
               verwendeten RAM-Bereichs.
Ergebnis       Die Funktion liefert als Ergebnis die Anfangsadresse
               des logischen Bildschirmspeichers.
Querverweis    \#Physbase\#   \#Setscreen\#
\end

screen( capsensitive("Mfpint") )
Name           ¯init MFP interrupt® - Interrupt initialisieren.

Xbiosnummer    13

Definition     void Mfpint( int number, void (*vector)() );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Mfpint initialisiert den Multi-
               funktions-Interrupt fr die angeschlossenen Peripherie-
               Ger„te. Damit k”nnen Hardware-Interrupts abgefangen
               werden. Das Argument vektor gibt die Interrupt-Service-
               Routine an. Im Parameter interrupt wird die Nummer des
               Interrupt von 0 bis 15 angegeben:
number         Beschreibung
0              I/O-Port Bit 0 Busy par. Schnittstelle
1              RS-232 DCD
2              RS-232 CTS
3              Blitter
4              Timer D, RS232-232 Baud-Generator
5              Timer C, 200-Hz System-Uhr
6              Tastatur und MIDI
7              FDC und DMA
8              Timer B Zeilenrcklauf
9              RS-232 Sendefehler
10             RS-232 Sendepuffer leer
11             RS-232 Empfangspuffer voll
12             RS-232 Puffer voll
13             Timer A
14             RS-232 RI
15             Monochrom-Monitor Detect
Ergebnis       Die Funktion liefert kein Ergebnis.
Querverweis    \#Jdisint\#   \#Jenabint\#
\end

screen( capsensitive("Midiws") )
Name           ¯Midi write string® - gibt eine Zeichenfolge ber die
               Midi-Schnittstelle aus.

Xbiosnummer    12

Definition     void Midiws (int cnt, void *ptr) ;

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Midiws gibt einen String ber die
               Midi-Schnittstelle aus. Der Parameter cnt enth„lt die
               Anzahl der Zeichen - 1 und ptr enth„lt die Adresse des
               Strings.
Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Offgibit") )
Name           ¯GI bit off® - l”scht ein Bit im Register A des
               Soundchips.

Xbiosnummer    29

Definition     void           Offgibit (int bitno);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Offgibit l”scht ein Bit im Register
               A des Soundchips GI. bitno gibt den Wert an, mit dem das
               Register verUNDet werden soll.
               
               Die Bits in diesem Register haben folgende Bedeutung:
               Bit            Beschreibung
               0              Floppy Sideselect
               1              Drive Select A
               2              Drive Select B
               3              RS-232 RTS
               4              RS-232 DTR
               5              Centronics Strobe
               6              PIN 3 Monitor Buchse
               7              unbenutzt 
                              ab TOS030 des TT jedoch 
                              Modem 4 (1) oder LAN (0).

Ergebnis       Die Funktion liefert kein Ergebnis.
Querverweis    \#Ongibit\#
\end

screen( capsensitive("Ongibit") )
Name           ¯GI bit on® - setzt ein Bit im Register A des
               Soundchips.

Xbiosnummer    30

Definition     void Ongibit (int bitno);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Ongibit setzt ein Bit im Register A
               des Soundchips GI. bitno gibt den Wert an, mit dem das
               Register verODERt  werden soll.
Ergebnis       Die Funktion liefert kein Ergebnis.
Querverweis    \#Offgibit\#
\end

screen( capsensitive("Physbase") )
Name           ¯physical screen ram base® - ermittelt die Anfangs-
               adresse des Video-Speichers.

Xbiosnummer    2

Definition     void *Physbase(void);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Physbase ermittelt die physikalische
               Anfangsadresse des momentan als Videospeicher ver-
               wendeten RAM-Bereichs.
Ergebnis       Die Funktion Physbase liefert als Ergebnis die Adresse
               des physikalischen Bildschirmspeichers.
Querverweis    \#Logbase\#   \#Setscreen\#
\end

screen( capsensitive("Protobt") )
Name           ¯prototype boot sector® - Standard-Boot-Sektor.

Xbiosnummer    18

Definition     void Protobt( void *buf, long serialno, int disktype,
                             int execflag );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Protobt legt einen Boot-Sektor auf
               einer Diskette an. Das Argument buf verweist auf einen
               512 Byte groen Puffer mit dem Inhalt des Boot-Sektors.
               Der Parameter serialno dient dazu, eine Seriennummer im
               Bootsektor abzuspeichern. Wenn die Variable serialno
               gr”er als 0x01000000 ist, dann wird eine Zufallszahl
               abgelegt. Mit disktype wird eine der folgenden
               Diskettenarten ausgew„hlt:
0              40 Spuren, einseitig
1              40 Spuren, doppelseitig
2              80 Spuren, einseitig
3              80 Spuren, doppelseitig
               Der Parameter execflag legt schlielich fest, ob die
               Informationen im Boot-Sektor als Programm ausgefhrt
               werden k”nnen.
Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Prtblk") )
Name           ¯print screen dump® - Hardcopy-Ausdruck.

Xbiosnummer    36

Definition     void Prtblk( \#PBDEF\# *par );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Prtblk druckt einen bestimmten
               Bereich im Speicher aus. Der Zeiger par wird die
               Struktur des Bildschirmaufbaus angegeben.
Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn der
               Ausdruck erfolgreich war, ansonsten einen von 0
               verschiedenen Wert.
\end

screen( capsensitive("Puntaes") )
Name           ¯punt AES® - AES abschalten.

Xbiosnummer    39

Definition     void Puntaes(void);

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Puntaes schaltet das AES-Betriebs-
               system ab. Diese Funktion darf nicht verwendet werden,
               wenn sich das AES im ROM befindet.
Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Random") )
Name           ¯random generator® - Zufallsgenerator.

Xbiosnummer    17

Definition     long Random ( void ) ;

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Random liefert eine 24-Bit-Zufalls-
               zahl. Sie basiert auf einem Zeitgeber im Atari ST. Die
               Funktion liefert nach dem Einschalten immer ver-
               schiedene Werte.
Ergebnis       Die Funktion liefert als Ergebnis eine 24-Bit-Zufalls-
               zahl.
\end

screen( capsensitive("Rsconf") )
Name           ¯RS-232 configuration® - konfiguriert die RS-232-
               Schnittstelle.

Xbiosnummer    15

Definition     long  Rsconf( int baud, int ctr, int ucr, int rsr,
                               int tsr, int scr );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine konfiguriert die serielle Schnitt-
               stelle. Im Normal-Betrieb werden nur die Parameter baud
               und ctr verwendet, wobei die anderen Parameter alle mit
               -1 bergeben werden mssen. Der Parameter baud kann
               folgende Werte annehmen:
Wert           Baudrate
0              19200
1               9600
2               4800
3               3600
4               2400
5               2000
6               1800
7               1200
8                600
9                300
10               200
11               150
12               134
13               110
14                75
15                50
(ab TOS 1.4: wird fr baud -2 angegeben, wird der Rest ignoriert
 und als Ergebnis die letzte mir Rsconf eingestellte Baudrate
 zurckgegeben)
               Der Parameter ctr legt den Handshake fest:
Bit            Beschreibung
0              Kein Handshake
1              XON/XOFF
2              RTS/CTS
3              XON/XOFF und RTS/CTS
               Mit ucr wird das USART Steuer-Register belegt:
Bit            Beschreibung
0              unbenutzt
1              0 ungerade, 1 gerade Parit„t
2              0 keine Parit„t, 1 mit Parit„t
3,4            Start-/Stop-Bits, sowie deren Format:
               00             synchron   Start=0, Stop =0
               10             asynchron  Start=1, Stop =1
               01             asynchron  Start=1, Stop =1,5
               11             asynchron  Start=1, Stop =2
5,6            Wortl„nge:
               00             8 Bit
               10             7 Bit
               01             6 Bit
               11             5 Bit
7              Baudrate aus der šbertragungssteuerung
               Im Parameter rsr sind die Status-Bits des Empfangs-
               status-Registers enthalten.:
Bit            Beschreibung
0              Empfang einschalten
1              Vergleich mit Synchron-Register einschalten
2              Im Synchron-Betrieb wird angezeigt, da das
               empfangene Zeichen identisch mit dem Zeichen
               im Synchron-Register ist. Im asynchronen Modus
               wird der Empfang eines Start-Bits signalisiert.
3              Im Synchron-Betrieb wird angezeigt, da das
               empfangene Zeichen identisch mit dem Zeichen
               im Synchron-Register ist. Im asynchronen Modus
               wird der Empfang eines BREAK-Zeichens signalisiert.
4              šbertragungsfehler, denn das Stop-Bit ist 0,
               w„hrend das Zeichen nicht NUL ist.
5              Parit„tsfehler
6              Puffer-šberlauf
7              Puffer voll
               tsr steuert das Transmitter-Status-Registers. Die
               einzelnen Bits haben folgende Bedeutung:
Bit            Beschreibung
0              Senden einschalten
1,2            Ausgabe-Modus (high oder low)
               00             Hochohmig
               01             High-Pegel
               10             Low-Pegel
               11             Loop-back
3              Im synchronen Betriebsmodus wird das Bit nicht
               verwendet, im asynchronen Betrieb sendet es
               das Signal BREAK.
4              Ende der šbertragung (end of transmission)
               anzeigen
5              Nach der n„chsten šbertragung sofort auf Empfang
               umschalten
6              Zeichen im šbertragungspuffer versenden, bevor
               das neue Zeichen in den šbertragungspuffer
               geschrieben wird.
7              Puffer leer
               scr initialisiert das synchrone Zeichen-Register.
               Dieser Parameter sollte auf 0 gesetzt werden.

Ergebnis       Es werden die altern Registerwerte von ucr, rsr,
               tsr und scr zurckgegeben.

Querverweis    \#Bconmap\#
\end

screen( capsensitive("Scrdmp") )
Name           ¯screen dump® - druckt den Bildschirminhalt aus.

Xbiosnummer    20

Definition     void  Scrdmp( void );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Scrdmp druckt den Inhalt des Bild-
               schirms als Hardcopy aus. Bei der Verwendung dieser
               Funktion mu ein Drucker angeschlossen sein.

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Setcolor") )
Name           ¯Setcolor® - legt eine von 16 Farben fest.

Xbiosnummer    7

Definition     int  Setcolor( int colornum, int color );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Setcolor legt die Farbe einer von 16
               Farbauswahlm”glichkeiten fest.

Ergebnis       Die Funktion liefert den bisherigen Wert des Farb-
               registers.

Querverweis    \#Setpalette\#
\end

screen( capsensitive("Setpalette") )
Name           ¯set palette® - w„hlt 16 Farben aus.

Xbiosnummer    6

Definition     void  Setpalette( void *pallptr );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Setpalette w„hlt 16 Farben mit Hilfe
               einer Bit-Ebenen-Definition aus. Der Parameter pallptr
               zeigt auf ein Feld mit 16 Integer-Werten, in denen die
               einzelnen Farben definiert werden.

Ergebnis       Die Funktion liefert keinen Wert.
\end

screen( capsensitive("Setprt") )
Name           ¯Setprinter® - initialisiert den Drucker.

Xbiosnummer    33

Definition     int  Setprt( int config );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Setprt initialisiert den Drucker.
               Folgende Bit-Parameter k”nnen in config angegeben
               werden:

                    0x01           Typenraddrucker
                    0x02           Monochrom-Drucker
                    0x04           1 Epson-Drucker, 0 Atari-Drucker
                    0x08           1 Sch”nschrift, 0 Konzept-Schrift
                    0x10           1 serielle Schnittstelle,
                                   0 parallele Schnittstelle
                    0x20           1 Einzelblatt, 0 Endlospapier

               Bei config = -1 wird die aktuelle Konfiguration
               zurckgegeben.

Ergebnis       Die Funktion liefert als Ergebnis die alte
               Konfiguration.
\end

screen( capsensitive("Setscreen") )
Name           ¯set screen® - initialisiert den Bildschirm.

Xbiosnummer    5

Definition     void  Setscreen( void *laddr, void *paddr, int rez );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Setscreen initialisiert den Bild-
               schirm. Die Parameter laddr und paddr legen die
               Anfangsadresse des Bildschirmspeichers und rez die
               Aufl”sung des Bildschirms fest. rez kann folgende
               Werte erhalten:

                        0              niedrige Aufl”sung
                        1              mittlere Aufl”sung
                        2              hohe Aufl”sung

               Wird fr einen der Parameter der Wert -1 bergeben,
               so wird der entsprechende aktuelle Einstellung
               beibehalten.

Ergebnis       Die Funktion liefert kein Ergebnis.

Querverweis    \#Physbase\#   \#Logbase\#   \#Getrez\#
\end

screen( capsensitive("Settime") )
Name           ¯set time® - Zeit einstellen.

Xbiosnummer    22

Definition     void  Settime( unsigned long time );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Settime stellt Datum und Uhrzeit neu
               ein. Der 32-Bit Parameter time wird wie folgt
               aufgesplittet:

                  0-4        Sekunden in Einheiten von 2 (0-29)
                  5-8        Minuten (0-59)
                  9-15       Stunden (0-23)
                  16-20      Tag im Monat (1-31)
                  21-26      Monat (1-12)
                  27-31      Jahr (0-119, 0 steht fr 1980)

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Ssbrk") )
Name           ¯set memory break point® - Speicherplatz reservieren.

Xbiosnummer    1

Definition     void  *Ssbrk( int count );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Ssbrk reserviert Speicherplatz. Die
               Anzahl der Bytes mu dabei in count bergeben werden.
               Diese Funktion mu vor der Initialisierung des
               Betriebssystems aufgerufen werden, und sollte daher in
               Anwenderprogrammen nicht verwendet werden. In allen
               Atari-ROM-Versionen ist diese Funktion lediglich als
               ¯Dummy®-Routine implementiert.

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Supexec") )
Name           ¯supervisor execute® - fhrt Routine im Supervisor-
               Modus aus.

Xbiosnummer    38

Definition     void  Supexec( long (*func)( ));

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Supexec fhrt die Routine unter addr
               im Supervisor-Modus aus.

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Vsync") )
Name           ¯vertical sync® - wartet auf das n„chste vertikale
               Sync-Signal.

Xbiosnummer    37

Definition     void  Vsync( void );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Vsync wartet auf den n„chsten
               Bildschirm-Refresh, damit lassen sich Bildschirm-
               operationen mit dem Betriebssystem synchronisieren.

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("EsetShift") )
Name           ¯Set shift mode register® - Setzt das Shift Mode Register.

Xbiosnummer    80

Definition     int  Esetshift( int shftMode );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine EsetShift schreibt in das Shift 
               Mode Register des TT den Wert shftMode. shftMode
               ist ein Bitfeld mit folgender Bedeutung:
               
               |S|00|H|0|MMM|0000|BBBB| 
                |    |    |         |
                |    |    |         +-- Bank                  \#EsetBank\#
                |    |    +------------ Aufl”sung             \#Setscreen\#
                |    |                    000  320 * 200 * 4
                |    |                    001  640 * 200 * 2
                |    |                    010  640 * 400 * 1
                |    |                    100  640 * 480 * 4
                |    |                    110 1280 * 960 * 1
                |    |                    111  320 * 480 * 8
                |    +----------------- Hyper Mode            \#EsetGray\#
                +---------------------- Sample & Hold

Hinweis        Diese Funktion ist nur im TOS030 des TT verfgbar.

Ergebnis       Die Funktion liefert den vorherigen Wert des 
               Registers.

Querverweis    \#EgetShift\#
\end

screen( capsensitive("EgetShift") )
Name           ¯Get current shift mode value® - Liest das Shift
               Mode Register.

Xbiosnummer    81

Definition     int  EgetShift( void );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine  EgetShift liest das Shift
               Mode Register aus und liefert den Inhalt des Regis-
               ters als Ergebnis zurck.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfgbar.

Ergebnis       Die Funktion liefert den Wert des Registers.

Querverweis    \#EsetShift\#
\end

screen( capsensitive("EsetBank") )
Name           ¯Set color look up bank® - Setzt Bank fr Farbtabelle.

Xbiosnummer    82

Definition     int  EsetBank( int bankNum );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine EsetBank setzt die Banknummer
               fr die Farbtabelle des TT auf den Wert bankNum.
               Der erlaubte Wert von bankNum liegt zwischen 0
               und 15. Ist bankNum negativ, wird die aktuelle 
               Einstellung nicht ver„ndert.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfgbar.

Ergebnis       Die Funktion liefert die vorherige Einstellung.
\end

screen( capsensitive("EsetColor") )
Name           ¯Set color entry® - Schreibt einen Eintrag in die
               Farbtabelle.

Xbiosnummer    83

Definition     int  EsetColor( int colorNum, int color );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine EsetColor setzt den Farbeintrag
               colorNum in der Farbtabelle auf den  Wert color.
               Ein negativer Wert ver„ndert den Eintag nicht.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfgbar.

Ergebnis       Die Funktion liefert die vorherige Einstellung.

Querverweis    \#Setcolor\#
\end

screen( capsensitive("EsetPalette") )
Name           ¯Set palette registers® - Setzt mehrere Eintr„ge in
               der Farbtabelle.

Xbiosnummer    84

Definition     void  EsetPalette( int colorNum, int count,
                                   int *palettePtr );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine EsetPalette setzt count Farbein-
               tr„ge ab colorNum in der Farbtabelle auf die Werte
               im Array palettePtr.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfgbar.

Ergebnis       Die Funktion hat kein Ergebnis.

Querverweis    \#EgetPalette\#
\end

screen( capsensitive("EgetPalette") )
Name           ¯Get look up table registers® - Liest mehrere Eintr„ge
               aus der Farbtabelle.

Xbiosnummer    85

Definition     void  EgetPalette( int colorNum, int count,
                                   int *palettePtr );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine EgetPalette liest count Farbein-
               tr„ge ab colorNum aus der Farbtabelle in das Array 
               palettePtr

Hinweis        Diese Funktion ist nur im TOS030 des TT verfgbar.

Ergebnis       Die Funktion hat kein Ergebnis.

Querverweis    \#EsetPalette\#
\end

screen( capsensitive("EsetGray") )
Name           ¯Set/clear gray mode® - Schaltet die Farbinterpretation
               ein bzw. aus.

Xbiosnummer    86

Definition     int  EsetGray( int swtch );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine EsetGray schaltet die Farbinter-
               pretation in der Farbtabelle als Graustufe ein (1)
               bzw. aus (0). Ein negativer Wert ver„ndert die Ein-
               stellung nicht.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfgbar.

Ergebnis       Die Funktion liefert die bisherige Einstellung.
\end

screen( capsensitive("EsetSmear") )
Name           ¯Set/clear video smear mode® - Schaltet die Farb-
               verwischung ein bzw. aus.

Xbiosnummer    87

Definition     int  EsetSmear( int swtch );

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine EsetSmear schaltet die Farbver-
               wischung ein (1) bzw. aus (0).  Ein negativer Wert
               ver„ndert die Einstellung nicht.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfgbar.

Ergebnis       Die Funktion liefert die bisherige Einstellung.
\end

screen( capsensitive("Xbtimer") )
Name           ¯timer init® - initialisiert die Zeitgeber im MFP-Chip.

Xbiosnummer    31

Definition     void  Xbtimer( int timer, int control, int data,
                                void (*vector)( ));

Prototyp in    tos.h

Beschreibung   Die \#XBIOS\#-Routine Xbtimer initialisiert einen von vier
               Zeitgebern (A-D) im Multifunktionsperipheriechip 68901.
               Die Zeitgeber, die mit Hilfe des Parameters timer
               ausgew„hlt werden, haben folgende Aufgaben:

                         A              Applikationen
                         B              Grafik
                         C              Systemzeit
                         D              Baudrate

               Der Parameter data enth„lt den Wert, der in das Timer-
               Register geladen werden soll. vektor verweist auf den
               neuen Interrupt-Handler. control l„dt das Steuer-
               Register des Zeitgebers.

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( "GEMDOS" )
GEMDOS
----------------------------------------------------------------------

Das GEMDOS ist, abgesehen von den hardware-abh„ngigen \#BIOS\# und \#XBIOS\#,
das eigentliche Betriebssystem des Atari. Seine Funktionen werden ber
den 680X0-Trap #1 aufgerufen.
Die \#Betriebssystem\#funktionen lassen sich sehr leicht aufgrund des
ersten Buchstabens des Funktionsnamen in die Kategorien

            \#Zeichenweise Ein-/Ausgabe\#  (C...),
            \#Programmausfhrung\#         (P...),
            \#Dateifunktionen\#            (F...),
            \#Verzeichnisfunktionen\#      (D...),
            \#Speicherbereichsverwaltung\# (M...),
            \#Datum und Uhrzeit\#          (T...),
und         \#Systemfunktionen\#           (S...)

einteilen.
In einem Netzwerk stehen noch zus„tzliche \#Netzwerkfunktionen\#
zur Verfgung.
\end

screen( "Zeichenweise Ein-/Ausgabe" )
Zeichenweise Ein-/Ausgabe
----------------------------------------------------------------------

Zu allen Ein-/Ausgabe-Funktionen auf die Standardger„te CON: (Tastatur
und Bildschirm), PRN: (Drucker an der parallelen Schnittstelle)  und
AUX: (Ger„te an der seriellen Schnittstelle) stehen auch die ent-
sprechenden Statusfunktionen zur Verfgung.

1  \#Cconin\#  Zeichen von Standardeingabeger„t einlesen.
2  \#Cconout\# Zeichen auf Standardausgabeger„t schreiben.
3  \#Cauxin\#  Zeichen von serieller Schnittstelle lesen.
4  \#Cauxout\# Zeichen auf serielle Schnittstelle schreiben.
5  \#Cprnout\# Zeichen auf Drucker ausgeben.
6  \#Crawio\#  Zeichen direkt von Tastatur lesen oder auf Bildschirm
           ausgeben.
7  \#Crawcin\# Zeichen ohne Darstellung am Bildschirm und ohne
           Interpretation von Steuerzeichen einlesen.
8  \#Cnecin\#  Zeichen ohne Darstellung am Bildschirm einlesen.
9  \#Cconws\#  String auf Standardausgabeger„t ausgeben.
10 \#Cconrs\#  String von Standardeingabeger„t einlesen.
11 \#Cconis\#  Tastatur-Puffer nach anliegenden Zeichen abfragen.
16 \#Cconos\#  Ausgabe-Status des Standardausgabeger„ts berprfen.
17 \#Cprnos\#  Drucker-Status ermitteln.
18 \#Cauxis\#  Eingabe-Status der seriellen Schnittstelle ermitteln.
19 \#Cauxos\#  Ausgabe-Status der seriellen Schnittstelle ermitteln.

Die Ausgaberoutinen des Gemdos emulieren ein \#VT-52-Terminal\#.
\end

screen( "Programmausfhrung" )
Programmausfhrung
----------------------------------------------------------------------

Programme laden und ausfhren oder beenden.

0  \#Pterm0\#   Programm beenden und 0 an Aufrufer zurckgeben.
49 \#Ptermres\# Programm beenden, aber im Speicher behalten.
75 \#Pexec\#    Weiteres Programm laden und ausfhren.
76 \#Pterm\#    Programm beenden und frei w„hlbaren Wert an Aufrufer
            zurckgeben.
\end

screen( "Dateifunktionen" )
Ein-/Ausgabefunktionen fr Dateien, Zugriff auf Dateien
----------------------------------------------------------------------


26  \#Fsetdta\#   Diskettenbertragungsadresse „ndern.
47  \#Fgetdta\#   Diskettenbertragungsadresse ermitteln.
60  \#Fcreate\#   Datei anlegen.
61  \#Fopen\#     Datei ”ffnen.
62  \#Fclose\#    Datei schlieen.
63  \#Fread\#     Aus Datei lesen.
64  \#Fwrite\#    In Datei schreiben.
65  \#Fdelete\#   Datei l”schen.
66  \#Fseek\#     Zeiger auf bestimmte Position innerhalb einer Datei setzen.
67  \#Fattrib\#   Dateiattribute „ndern oder ermitteln.
69  \#Fdup\#      Dateihandle duplizieren.
70  \#Fforce\#    Umlenken von Ein-/Ausgaben von Standardkan„len auf belie-
              bige andere.
78  \#Fsfirst\#   Ersten Eintrag in Verzeichnis suchen.
79  \#Fsnext\#    N„chsten Eintrag in Verzeichnis suchen.
86  \#Frename\#   Datei umbenennen.
87  \#Fdatime\#   nderungsdatum einer Datei ermitteln oder „ndern.
\end

screen( "Netzwerkfunktionen" )
Netzwerkfunktionen
----------------------------------------------------------------------

Zusatzfunktionen fr Netzwerkbetrieb.

92  \#Flock\#     File Record im Netzwerk sperren oder freigeben.
\end

screen( "Verzeichnisfunktionen" )
Verzeichnisfunktionen
----------------------------------------------------------------------

Dateiverzeichnisse und Laufwerke verwalten.

14 \#Dsetdrv\#  Aktuelles Laufwerk „ndern.
25 \#Dgetdrv\#  Aktuelles Laufwerk ermitteln.
54 \#Dfree\#    Freie und Gesamtkapazit„t eines Laufwerks ermitteln.
57 \#Dcreate\#  Verzeichnis anlegen.
58 \#Ddelete\#  Verzeichnis l”schen.
59 \#Dsetpath\# Aktuelles Verzeichnis „ndern.
71 \#Dgetpath\# Aktuelles Verzeichnis ermitteln.
\end

screen( "Speicherbereichsverwaltung" )
Speicherbereichsverwaltung
----------------------------------------------------------------------

Speicherbereiche reservieren, anpassen und freigeben.

72 \#Malloc\#  Speicherbereich reservieren bzw. freien Speicherplatz
           erfragen.
73 \#Mfree\#   Speicherbereich freigeben.
74 \#Mshrink\# Reservierten Speicherbereich verkleinern.


Ab TOS030 (Atari TT) verfgbar:

20 \#Maddalt\# Alternativen Speicher anmelden.
68 \#Mxalloc\# Speicherbereich reservieren.
\end

screen( "Datum und Uhrzeit (GEMDOS)" )
Datum und Uhrzeit im GEMDOS
----------------------------------------------------------------------

Datum und Uhrzeit einstellen oder ermitteln.

42 \#Tgetdate\# Datum ermitteln
43 \#Tsetdate\# Datum einstellen.
44 \#Tgettime\# Uhrzeit ermitteln.
45 \#Tsettime\# Uhrzeit einstellen.
\end

screen( "Systemfunktionen" )
Systemfunktionen
----------------------------------------------------------------------

Die Supervisor-Funktion ist eine der wichtigsten Funktionen fr die
direkte Programmierung der Hardware. Nur mit ihrer Hilfe ist es
m”glich, auf die Systemvariablen zuzugreifen.

32 \#Super\#    Supervisormodus ermitteln oder „ndern.
48 \#Sversion\# Versionsnummer von GEM ermitteln.
\end

screen( capsensitive("gemdos") )
Name           ¯gemdos® - GEMDOS-Trap ausfhren.

Definition     long  gemdos( void, ... );

Prototyp in    tos.h

Beschreibung   Die Routine gemdos fhrt einen TRAP 1 durch. Die
               bergebenen Parameter h„ngen von der jeweiligen GEMDOS-
               Funktion ab.

Ergebnis       Die Funktion liefert als Ergebnis einen Wert vom
               Datentyp long.

Querverweis    Bibliotheksfunktionen: \#bios\#   \#xbios\#
               Betriebssystem: \link("GEMDOS")Gemdos\#
\end

screen( capsensitive("Cauxin") )
Name           ¯character auxiliary input® - Eingabe ber serielle
               Schnittstelle.

Gemdosnummer   3

Definition     int  Cauxin( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cauxin liest ein Zeichen von der
               seriellen Schnittstelle aux: ein. Die Funktion wartet
               solange, bis ein Zeichen eingegeben wurde.

Ergebnis       Die Funktion liefert als Ergebnis das eingelesene
               Zeichen.

Querverweis    \#Cauxout\#
\end

screen( capsensitive("Cauxis") )
Name           ¯character auxiliary input status® - berprft den Ein-
               gabestatus der seriellen Schnittstelle.

Gemdosnummer   18

Definition     int  Cauxis( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cauxis berprft den Status der
               seriellen Schnittstelle aux: dahingehend, ob Zeichen
               im Eingabepuffer vorliegen.

Ergebnis       Die Funktion liefert als Ergebnis -1, wenn Zeichen im
               Puffer stehen, ansonsten ein 0.

Querverweis    \#Cauxos\#
\end

screen( capsensitive("Cauxos") )
Name           ¯character auxiliary output status® - berprft den
               Ausgabestatus der seriellen Schnittstelle.

Gemdosnummer   19

Definition     int  Cauxos( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cauxos berprft den Status der
               seriellen Schnittstelle aux: dahingehend, ob Zeichen
               ber die serielle Schnittstelle ausgegeben werden
               k”nnen.

Ergebnis       Die Funktion liefert als Ergebnis -1, wenn die serielle
               Schnittstelle zum Senden bereit ist, ansonsten ein 0.

Querverweis    \#Cauxis\#
\end

screen( capsensitive("Cauxout") )
Name           ¯character auxiliary output® - schreibt ein Zeichen auf
               die serielle Schnittstelle.

Gemdosnummer   4

Definition     void  Cauxout( int c );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cauxout schreibt ein Zeichen auf die
               serielle Schnittstelle aux.

Ergebnis       Die Funktion liefert kein Ergebnis.

Querverweis    \#Cauxin\#
\end

screen( capsensitive("Cconin") )
Name           ¯character console input® - liest ein Zeichen vom
               Standardeingabeger„t.

Gemdosnummer   1

Definition     long  Cconin( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cconin liest ein Zeichen vom Stand-
               ardeingabeger„t. Als Standardeingabeger„t dient in der
               Regel die Tastatur.

Ergebnis       Die Funktion liefert als Ergebnis den ASCII-Code des
               Zeichens im niederwertigen Wort. Wenn das eingelesene
               Zeichen von der Tastatur kommt, beinhalten die unteren
               acht Bits des h”herwertigen Worts den Scancode der
               Tastatur.

Querverweis    \#Cconout\#   \#Cconis\#
\end

screen( capsensitive("Cconis") )
Name           ¯character console is waiting® - prft nach, ob ein
               Zeichen im Standardeingabepuffer vorliegt.

Gemdosnummer   11

Definition     int  Cconis( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cconis berprft, ob Zeichen im
               Standardeingabe-Puffer vorliegen.

Ergebnis       Die Funktion liefert als Ergebnis -1, wenn Zeichen im
               Puffer vorliegen, ansonsten eine 0.

Querverweis    \#Cconin\#
\end

screen( capsensitive("Cconout") )
Name           ¯character console output® - schreibt ein Zeichen auf
               das Standardausgabeger„t.

Gemdosnummer   2

Definition     void  Cconout( int c );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cconout schreibt das Zeichen c auf
               das Standardausgabeger„t. Als Standardausgabeger„t
               dient in der Regel der Bildschirm.

Ergebnis       Die Funktion liefert kein Ergebnis.

Querverweis    \#Cconin\#, \#Cconos\#, \#VT-52-Terminal\#
\end

screen( capsensitive("Cconos") )
Name           ¯character console output status® - prft den Status
               des Standardausgabeger„tes.

Gemdosnummer   16

Definition     int  Cconos( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cconos berprft, ob das Standard-

               ausgabeger„t bereit ist, Zeichen anzunehmen.
Ergebnis       Die Funktion liefert als Ergebnis den Status des
               Standardausgabeger„ts. Wenn das Standardausgabeger„t
               bereit ist Zeichen auszugeben, wird -1 zurckgegeben,
               ansonsten eine 0.

Querverweis    \#Cconout\#
\end

screen( capsensitive("Cconrs") )
Name           ¯character console read string® - liest einen String
               von der Standardeingabe.

Gemdosnummer   10

Definition     void  Cconrs( \#LINE\# *buf );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cconrs liest einen String von der
               Standardeingabe. W„hrend der Eingabe kann der String
               editiert werden. Das erste Zeichen im Puffer buf
               enth„lt die maximale L„nge des Strings, die im Puffer
               belegt werden kann, damit die Eingaben aufgenommen
               werden k”nnen. Das zweite Zeichen des Puffers enth„lt
               nach Abschlu der Routine die tats„chliche L„nge der
               Eingabe. Diese Struktur ist als Datentyp \#LINE\# in TOS.H
               deklariert.

Ergebnis       Die Funktion hat kein Ergebnis.

Querverweis    \#Cconws\#   \#LINE\#
\end

screen( capsensitive("Cconws") )
Name           ¯character console write string® - schreibt einen
               String auf das Standardausgabeger„t.

Gemdosnummer   9

Definition     int  Cconws( const char *buf );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cconws schreibt einen String auf das
               Standardausgabeger„t. Der String in buf mu mit dem
               ASCII-Zeichen Null beendet werden.

Ergebnis       Die Funktion liefert als Ergebnis die Anzahl der
               tats„chlich ausgegebenen Zeichen.

Querverweis    \#Cconrs\#, \#VT-52-Terminal\#
\end

screen( capsensitive("Cnecin") )
Name           ¯character no echo input® - liest ein Zeichen vom
               Standardeingabeger„t.

Gemdosnummer   8

Definition     long  Cnecin( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cnecin liest ein Zeichen direkt von
               der Standardeingabe, ohne da das Zeichen auf dem
               Standardausgabeger„t ausgegeben wird.

Ergebnis       Die Funktion liefert als Ergebnis das eingelesene
               Zeichen.

Querverweis    \#Cconin\#   \#Crawcin\#   \#Crawio\#
\end

screen( capsensitive("Cprnos") )
Name           ¯character printer output status® - prft den Status
               der Druckerschnittstelle.

Gemdosnummer   17

Definition     int  Cprnos( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cprnos berprft, ob die Drucker-
               schnittstelle bereit ist, Zeichen anzunehmen.

Ergebnis       Die Funktion liefert als Ergebnis den Drucker-Status.
               Wenn der Drucker bereit ist, wird ein Wert ungleich 0
               zurckgegeben, ansonsten eine 0.

Querverweis    \#Cconos\#
\end

screen( capsensitive("Cprnout") )
Name           ¯character printer output® - schreibt ein Zeichen auf
               die Druckerschnittstelle.

Gemdosnummer   5

Definition     int  Cprnout( int c );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Cprnout schreibt das Zeichen c auf
               die Druckerschnittstelle prn:.

Ergebnis       Die Funktion liefert als Ergebnis -1, wenn das Zeichen
               korrekt ausgedruckt werden konnte. Im Fehlerfall wird 0
               zurckgegeben.

Querverweis    \#Cprnos\#
\end

screen( capsensitive("Crawcin") )
Name           ¯character raw input® - liest ein Zeichen ungepuffert
               vom Standardeingabeger„t.

Gemdosnummer   7

Definition     long  Crawcin( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Crawcin liest ein Zeichen unge-
               puffert von der Standardeingabe. Die Zeichen werden
               nicht interpretiert. Das heit, da <Control-C>,
               <Control-S> und <Control-Q> ignoriert werden.
               Wie bei Cnecin wird das von der Tastatur gelesene
               Zeichen nicht auf dem Bildschirm dargestellt.

Ergebnis       Die Funktion liefert als Ergebnis das eingelesene
               Zeichen.

Querverweis    \#Cconin\#   \#Cconout\#   \#Crawio\#
\end

screen( capsensitive("Crawio") )
Name           ¯character raw input output® - erm”glicht ungepufferte
               Ein-/Ausgaben.

Gemdosnummer   6

Definition     long  Crawio( int w );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Crawio fhrt ungepufferte Ein-Ausga-
               ben durch. Wenn als Argument w die Zahl 0xFF bergeben
               wurde, dann wird ein Zeichen vom Standardeingabeger„t
               eingelesen. Wenn w einen anderen Wert hat, wird das
               Zeichen auf das Standardausgabeger„t geschrieben.

Ergebnis       Die Funktion liefert als Ergebnis das eingelesene
               Zeichen.

Querverweis    \#Cconin\#   \#Cconout\#   \#VT-52-Terminal\#
\end

screen( capsensitive("Dcreate") )
Name           ¯create directory® - Verzeichnis anlegen.

Gemdosnummer   57

Definition     int  Dcreate( const char *path );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Dcreate legt ein Verzeichnis mit dem
               Pfadnamen path an. Der String path mu mit dem ASCII-
               Zeichen NUL abgeschlossen sein.

Ergebnis       Die Funktion liefert als Ergebnis eine negative Zahl,
               wenn es zu einem Fehler kam.

Querverweis    \#Ddelete\#
\end

screen( capsensitive("Ddelete") )
Name           ¯delete directory® - Verzeichnis l”schen.

Gemdosnummer   58

Definition     int  Ddelete( const char *path );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Ddelete l”scht ein Verzeichnis mit
               dem Pfadnamen path, das keine weiteren Dateien oder
               Unterverzeichnisse enthalten darf. Der String path mu
               mit dem ASCII-Zeichen NUL abgeschlossen sein.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn das Ver-
               zeichnis gel”scht werden konnte, und eine negative
               Zahl, wenn es zu einem Fehler kam.

Querverweis    \#Dcreate\#
\end

screen( capsensitive("Dfree") )
Name           ¯free disk space® - ermittelt die Kapazit„tsauslastung
               eines Laufwerks.

Gemdosnummer   54

Definition     int  Dfree( \#DISKINFO\# *buf, int driveno );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Dfree ermittelt Kapazit„t und Bele-
               gung eines Laufwerks driveno. Um die Informationen
               weiterzureichen, ben”tigt man einen 16 Byte groen
               Puffer, der wie folgt strukturiert ist:
                   Byte           Beschreibung
                   0-3            Anzahl freier Cluster
                   4-7            Gesamtanzahl an Clustern
                   8-11           Gr”e eines Sektors in Bytes
                   12-15          Sektoren pro Cluster
               Diese Struktur ist als Datentyp \#DISKINFO\# in der Dekla-
               rationsdatei tos.h enthalten.

Ergebnis       Die Funktion liefert bei korrekter Ausfhrung eine 0,
               und eine negative Zahl, wenn es zu einem Fehler kam.
\end

screen( capsensitive("Dgetdrv") )
Name           ¯disk get drive® - ermittelt das aktuelle Laufwerk.

Gemdosnummer   25

Definition     int  Dgetdrv( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Dgetdrv ermittelt das aktuelle Lauf-
               werk.

Ergebnis       Die Funktion liefert als Ergebnis eine Zahl, die das
               aktuelle Laufwerk bezeichnet:

                                 0      A:
                                 1      B:
                                 2      C:
                                 usw.

Querverweis    \#Dsetdrv\#
\end

screen( capsensitive("Dgetpath") )
Name           ¯get path® - aktuelles Verzeichnis ermitteln.

Gemdosnummer   71

Definition     int  Dgetpath( char *path, int driveno );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Dgetpath ermittelt das aktuelle Ver-
               zeichnis auf dem Laufwerk driveno. Die Bezeichnungen
               der Laufwerke werden im Parameter driveno wie folgt
               codiert:
                           0      aktuelles Laufwerk
                           1      A:
                           2      B:
                           3      C:
                           usw.

               Der Pfad wird im Puffer path als String abgelegt. Da
               ein Pfad in GEMDOS bis zu 128 Zeichen lang sein kann,
               sollte der Puffer entsprechend viel Platz bieten.

Ergebnis       Die Funktion liefert als Ergebnis 0, wenn kein Fehler
               auftrat ansonsten einen Fehlercode.

Querverweis    \#Dsetpath\#
\end

screen( capsensitive("Dsetdrv") )
Name           ¯disk set drive® - legt das aktuelle Laufwerk fest.

Gemdosnummer   14

Definition     long  Dsetdrv( int drv );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Dsetdrv macht das Laufwerk drv zum
               aktuellen Laufwerk. drv kann eine Integer-Zahl zwischen
               0 und 15 sein:
                                0      A:
                                1      B:
                                2      C:
                                usw.

Ergebnis       Die Funktion liefert als Ergebnis eine Bit-Tabelle mit
               allen angeschlossenen Laufwerken. Jedes angeschlossene
               Laufwerk wird mit einem gesetzten Bit angezeigt.

Querverweis    \#Dgetdrv\#
\end

screen( capsensitive("Dsetpath") )
Name           ¯set path® - legt das aktuelle Verzeichnis fest.

Gemdosnummer   59

Definition     int  Dsetpath( const char *path );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Dsetpath setzt das aktuelle Ver-
               zeichnis. Der Pfad path mu ein String sein, der mit
               dem ASCII-Zeichen Null abgeschlossen sein mu.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn das Ver-
               zeichnis existiert, ansonsten eine negative Zahl.

Querverweis    \#Dgetpath\#
\end

screen( capsensitive("Fattrib") )
Name           ¯file attribute® - Dateiattribut ermitteln oder setzen.

Gemdosnummer   67

Definition     int  Fattrib( const char *filename,
                                 int wflag, int attrib );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fattrib ermittelt oder setzt die
               Attribute der mit filename bezeichneten Datei. Je nach
               dem, ob der Parameter wflag eine 0 oder 1 enth„lt, wird
               das Attribut gelesen bzw. neu festgelegt. Das Attribut
               setzt sich aus folgenden Flags zusammen:

                 FA_READONLY     Datei darf nur gelesen werden.
                 FA_HIDDEN       Datei wird beim Auflisten des
                                 Dateiverzeichnisses nicht angezeigt.
                 FA_SYSTEM       Systemdatei.
                 FA_VOLUME       Diskettenname (11 Bytes).
                 FA_SUBDIR       Unterverzeichnis.
                 FA_ARCHIVE      Datei wurde ver„ndert.

Ergebnis       Die Funktion liefert als Ergebnis das Attribut, wenn
               das Attribut gelesen werden sollte, ansonsten ist die
               Bedeutung nicht festgelegt.
\end

screen( capsensitive("Fclose") )
Name           ¯file close® - Datei schlieen.

Gemdosnummer   62

Definition     int  Fclose( int handle );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fclose schliet eine Datei mit dem
               Dateibezeichner handle. Im Netzwerk wird das aktive
               Locking aufgehoben.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn die
               Datei geschlossen werden konnte, ansonsten eine
               negative Zahl.

Querverweis    \#Fopen\#
\end

screen( capsensitive("Fcreate") )
Name           ¯file create® - Datei anlegen.

Gemdosnummer   60

Definition     int  Fcreate( const char *fname, int attr );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fcreate legt eine Datei an. Der
               Pfadname der Datei, fname, mu ein mit dem ASCII-
               Zeichen NUL abgeschlossener String sein. Der Parameter
               attr legt das Attribut der Datei fest. attr kann mit
               folgenden Flags ge-odert werden.

                 FA_READONLY     Datei darf nur gelesen werden.
                 FA_HIDDEN       Datei wird beim Auflisten des
                                 Dateiverzeichnisses nicht angezeigt.
                 FA_SYSTEM       Systemdatei.
                 FA_VOLUME       Diskettenname (11 Bytes).

               Im Netzwerk setzt das erzeugen einer Datei die
               Exclusivit„t.

Ergebnis       Die Funktion liefert als Ergebnis einen long-Wert.
               Ist dieser negativ, so ist ein Fehler aufgetreten.
               Andernfalls enth„lt das niederwertige Wort, das
               man durch Casten des Funktionsresultats erh„lt,
               einen Handle, der in den nachfolgenden Schreib-/
               Lese-Operationen verwendet werden kann.

Querverweis    \#Fopen\#
\end

screen( capsensitive("Fdatime") )
Name           ¯file date and time® - Uhrzeit und Datum einer Datei
               ermitteln oder setzen.

Gemdosnummer   87

Definition     int  Fdatime( \#DOSTIME\# *timeptr, int handle, int wflag );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fdatime liest oder setzt Datum und
               Uhrzeit der mit handle bezeichneten Datei. Der
               Parameter wflag bestimmt, ob Datum und Uhrzeit der
               Datei gelesen (0) oder geschrieben (1) werden sollen.
               Der Parameter timeptr zeigt auf die Struktur DOSTIME.

Ergebnis       Die Funktion liefert als Ergebnis Datum und Uhrzeit.
               Wenn Datum und Uhrzeit nicht modifiziert oder ermittelt
               werden konnten, den Wert 0 in time und date.
\end

screen( capsensitive("Fdelete") )
Name           ¯file delete® - Datei l”schen.

Gemdosnummer   65

Definition     int  Fdelete( const char *fname );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fdelete l”scht die mit fname be-
               zeichnete Datei.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn die
               Datei gel”scht werden konnte, und ein von 0 ver-
               schiedenes Ergebnis, wenn die Datei nicht gel”scht
               werden konnte.

Querverweis    \#Fcreate\#
\end

screen( capsensitive("Fdup") )
Name           ¯file duplicate® - Datei-Handle duplizieren.

Gemdosnummer   69

Definition     long  Fdup( int handle );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fdup erzeugt ein neues Datei-Handle
               fr die mit handle bezeichnete Datei.

Ergebnis       Die Funktion liefert als Ergebnis einen long-Wert.
               Ist dieser negativ, so ist ein Fehler aufgetreten.
               Andernfalls enth„lt das niederwertige Wort, das
               man durch Casten des Funktionsresultats erh„lt,
               einen Handle, der in den nachfolgenden Schreib-/
               Lese-Operationen verwendet werden kann.

Querverweis    \#Fforce\#
\end

screen( capsensitive("Fforce") )
Name           ¯file force® - Standard-Datei umleiten.

Gemdosnummer   70

Definition     int  Fforce( int stch, int nonstdh );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fforce leitet die Ein- und Ausgaben
               einer Standarddatei stch in die mit nonstdh bezeich-
               nete Datei um.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn die Um-
               leitung vorgenommen werden konnte, ansonsten einen
               Fehlercode.

Querverweis    \#Fdup\#
\end

screen( capsensitive("Fgetdta") )
Name           ¯get disk transfer address® - ermittelt den šbertra-
               gungsbereich fr Diskettenoperationen.

Gemdosnummer   47

Definition     \#DTA\#  *Fgetdta( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fgetdta ermittelt die Adresse eines
               Buffers fr \#Fsfirst\# und \#Fsnext\#. Auf die ermittelte
               Struktur kann man mit dem in tos.h deklarierten Daten-
               typ \#DTA\# zugreifen.

Ergebnis       Die Funktion liefert als Ergebnis die Adresse des Dis-
               kettenbertragungsbereichs.

Querverweis    \#Fsetdta\#   \#DTA\#   \#Fsfirst\#   \#Fsnext\#
\end

screen( capsensitive("Fopen") )
Name           ¯file open® - ”ffnet eine Datei.

Gemdosnummer   61

Definition     long  Fopen( const char *fname, int mode );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fopen ”ffnet die im String fname an-
               gegebene Datei. Der Parameter mode bestimmt den Zu-
               griffsmodus auf die Datei:
                                FO_READ     Lesen
                                FO_WRITE    Schreiben
                                FO_RW       Lesen und Schreiben
               Im Netzwerk:
                               -1           shared write
                               -2           shared read/write
               sowie MS-DOS Open-Calls.

Ergebnis       Die Funktion liefert als Ergebnis einen long-Wert.
               Ist dieser negativ, so ist ein Fehler aufgetreten.
               Andernfalls enth„lt das niederwertige Wort, das
               man durch Casten des Funktionsresultats erh„lt,
               einen Handle, der in den nachfolgenden Schreib-/
               Lese-Operationen verwendet werden kann.

Querverweis    \#Fcreate\#
\end

screen( capsensitive("Fread") )
Name           ¯file read® - Datei lesen.

Gemdosnummer   63

Definition     long  Fread( int handle, long count, void *buf );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fread liest count Zeichen von der
               mit handle bezeichneten Datei in den Puffer buf.

Ergebnis       Die Funktion liefert als Ergebnis die Anzahl der
               gelesenen Zeichen, wenn der Leseproze erfolgreich
               durchgefhrt werden konnte, ansonsten einen Fehlercode
               mit einer negativen Zahl.

Querverweis    \#Fwrite\#
\end

screen( capsensitive("Frename") )
Name           ¯file rename® - Datei umbenennen.

Gemdosnummer   86

Definition     int  Frename( int zero, const char *oldname,
                              const char *newname );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Frename dient zum Umbenennen von
               Dateien. Die Datei mit dem Namen oldname wird in den
               neuen Dateinamen newname umbenannt. Es k”nnen komplette
               Pfade mit Dateinamen bergeben werden.
               So kann man mit Frename ganz einfach eine Datei von
               einem Ordner in einen anderen schieben. Der Parameter
               zero ist fr TOS reserviert und mu den Wert 0
               enthalten. Ab TOS 1.4 k”nnen auch Ordner umbenannt
               werden.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn die
               Datei umbenannt werden konnte, ansonsten einen von 0
               verschiedenen Wert.
\end

screen( capsensitive("Fseek") )
Name           ¯file seek® - Dateiposition verschieben.

Gemdosnummer   66

Definition     long  Fseek( long offset, int handle, int seekmode );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fseek verschiebt die aktuelle Datei-
               position der Datei handle um offset Bytes. Mit dem
               Parameter seekmode w„hlt man den Ausgangspunkt:

                            seekmode       Bedeutung
                            0              Dateianfang
                            1              aktuelle Position
                            2              Dateiende

               Von diesem Ausgangspunkt aus verschiebt man den Datei-
               zeiger um den angegebenen offset.

Ergebnis       Die Funktion liefert als Ergebnis die neue Dateiposi-
               tion mit dem Datentyp long.
\end

screen( capsensitive("Fsetdta") )
Name           ¯set disk transfer address® - Setzen der Adresse fr
               den šbertragungsbereich fr Diskettenoperationen.

Gemdosnummer   26

Definition     void  Fsetdta( \#DTA\# *buf );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fsetdta legt die Diskettenbertra-
               gungs-Adresse fest. Der Puffer buf mu mindestens 44
               Bytes gro sein, um die Informationen aufnehmen zu
               k”nnen, die als Struktur \#DTA\# abgelegt werden.
               Diese Struktur ist in tos.h deklariert.
               Beim Programmstart liegt die DTA in der Kommandozeile
               und sollte vor dem ersten Diskettenzugriff mit Fsetdta
               an eine andere Stelle gelegt werden.

Ergebnis       Die Funktion liefert kein Ergebnis.

Querverweis    \#Fgetdta\#   \#Fsfirst\#
\end

screen( capsensitive("Fsfirst") )
Name           ¯search first file® - ersten Dateieintrag suchen.

Gemdosnummer   78

Definition     int  Fsfirst( const char *filename, int attr );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fsfirst sucht den ersten Dateiein-
               trag mit dem Attribut attr unter dem Pfadnamen file-
               name. Der Pfadname kann auch die Joker '*' und '?'
               enthalten.
               Nach Abschlu der Funktion steht der Verzeichniseintrag
               unter der Diskettenbertragungsadresse DTA, die mit
               Fgetdta und Fsetdta ermittelt bzw. festgelegt werden
               kann. Die Informationen k”nnen dann der Struktur \#DTA\#
               entnommen werden.
               Der Parameter attr enth„lt eine Kombination der
               folgenden Attribute.

                 FA_READONLY     Datei darf nur gelesen werden.
                 FA_HIDDEN       Datei wird beim Auflisten des
                                 Dateiverzeichnisses nicht angezeigt.
                 FA_SYSTEM       Systemdatei.
                 FA_VOLUME       Diskettenname (11 Bytes).
                 FA_SUBDIR       Unterverzeichnis.
                 FA_ARCHIVE      Datei wurde ver„ndert.

Ergebnis       Die Funktion liefert als Ergebnis 0, wenn eine Datei
               gefunden werden konnte, ansonsten einen Fehlercode.

Querverweis    \#Fgetdta\#   \#Fsetdta\#   \#Fsnext\#
\end

screen( capsensitive("Fsnext") )
Name           ¯search next file® - n„chsten Dateieintrag suchen.

Gemdosnummer   79

Definition     int  Fsnext( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fsnext sucht den n„chsten Dateiein-
               trag der mit Fsfirst mit dem Attribut attr unter dem
               Pfadnamen fspec gesucht wurde.
               Nach Abschlu der Funktion steht der Verzeichniseintrag
               unter der Diskettenbertragungsadresse DTA, die mit
               Fgetdta und Fsetdta ermittelt bzw. festgelegt werden
               kann. Die Informationen k”nnen dann der Struktur \#DTA\#
               entnommen werden.

Ergebnis       Die Funktion liefert als Ergebnis 0, wenn eine Datei
               gefunden werden konnte, ansonsten einen Fehlercode.

Querverweis    \#Fgetdta\#   \#Fsetdta\#   \#Fsfirst\#
\end

screen( capsensitive("Fwrite") )
Name           ¯file write® - auf Datei schreiben.

Gemdosnummer   64

Definition     long  Fwrite( int handle, long count, void *buf );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Fwrite schreibt count Zeichen vom
               Puffer buf in die mit handle bezeichnete Datei.

Ergebnis       Die Funktion liefert als Ergebnis die Anzahl der
               geschriebenen Zeichen, falls der Schreibvorgang
               erfolgreich war, ansonsten ist count vom Ergebnis
               verschieden, bei einer negativen Zahl ist es zu einem
               schweren Fehler gekommen. In der Regel ist die Diskette
               voll oder nicht mehr eingelegt.

Querverweis    \#Fread\#
\end

screen( capsensitive("Malloc") )
Name           ¯memory allocation® - Speicherplatz reservieren.

Gemdosnummer   72

Definition     void  *Malloc( long number );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Malloc reserviert einen Speicherbe-
               reich der Gr”e number. Mit dem Wert -1 kann man den
               maximal verfgbaren Speicherbereich berechnen.

Ergebnis       Die Funktion liefert als Ergebnis die Anfangsadresse
               des reservierten Bereichs als typenlosen Zeiger.
               Malloc liefert als Ergebnis eine 0, wenn nicht mehr
               gengend Speicher vorhanden ist.

Querverweis    \#Mfree\#    \#Mxalloc\#    \#Maddalt\#
\end

screen( capsensitive("Mxalloc") )
Name           ¯Allocate memory (with preference)® - Speicherplatz
               reservieren.

Gemdosnummer   68

Definition     void  *Mxalloc( long amount, int mode );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Mxalloc reserviert einen
               Speicherbereich der Gr”e amount. Der Parameter
               mode gibt an welche Speicherart angefordert
               werden soll:

                        0       ST-RAM
                        1       Alternatives RAM
                        2       egal, ST RAM bevorzugt
                        3       egal, alternatives RAM bevorzugt

               Mit dem Wert -1 fr amount kann man die L„nge des
               gr”ten zusammenh„ngend verfgbaren Speicherblocks
               erfragen.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfgbar.

Ergebnis       Die Funktion liefert als Ergebnis die Anfangsadresse
               des reservierten Bereichs als typenlosen Zeiger.
               Mxalloc liefert als Ergebnis eine 0, wenn nicht mehr
               gengend Speicher vorhanden ist.

Querverweis    \#Mfree\#    \#Malloc\#    \#Maddalt\#
\end

screen( capsensitive("Maddalt") )
Name           ¯Inform GEMDOS of alternative memory® - Alternativen
               Speicher anmelden.

Gemdosnummer   20

Definition     long  Maddalt( void *start, long size );

Prototyp in    tos.h

Beschreibung   Mit Maddalt kann man Speicher beim GEMDOS anmelden,
               der durch das BIOS nicht erkannt wird.
               start beschreibt die Startadresse des Speichers und
               size seine L„nge. Der Speicher mu aus einem zusammen-
               h„ngenden Block bestehen.
               Wurde Speicher einmal mit Maddalt angemeldet, so
               geh”rt er dem GEMDOS und kann diesem nicht mehr
               weggenommen werden. Reservierungen des Speichers
               sollten ausschlielich ber Malloc bzw. Mxalloc
               oder Pexec geschehen.

Hinweis        Diese Funktion ist nur im TOS030 des TT verfgbar.

Ergebnis       Im Erfolgsfall wird Null zurckgegeben, ansonsten
               ein Fehlercode.

Querverweis    \#Mfree\#   \#Malloc\#   \#Mxalloc\#
\end

screen( capsensitive("Mfree") )
Name           ¯memory free® - Speicherplatz freigeben.

Gemdosnummer   73

Definition     int  Mfree( void *block );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Mfree gibt einen mit Malloc reser-
               vierten Speicherbereich wieder frei.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn der
               Speicherplatz wieder frei gegeben wurde, ansonsten
               einen von 0 verschiedenen Wert.

Querverweis    \#Malloc\#   \#Mxalloc\#    \#Maddalt\#
\end

screen( capsensitive("Mshrink") )
Name           ¯memory shrink® - Speicherbereich verkrzen.

Gemdosnummer   74

Definition     int  Mshrink( int zero, void *block, long newsiz );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Mshrink verkrzt einen bereits
               reservierten Speicherbereich block auf die neue Gr”e
               newsiz. Der Parameter zero mu immer mit 0 bergeben
               werden.

Ergebnis       Die Funktion liefert als Ergebnis eine 0, wenn der
               Speicher angepat werden konnte, ansonsten einen von 0
               verschiedenen Wert.

Querverweis    \#Malloc\#   \#Mfree\#
\end

screen( capsensitive("Flock") )
Name           ¯file record locking® - Record-Locking im Netzwerken.

Gemdosnummer   92

Definition     long Flock( int handle, int mode, long start, long length );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Flock sperrt length Bytes ab
               der Position start in der durch handle angegebenen
               Datei (falls mode == 0), bzw. hebt eine bestehende
               Blockierung auf (mode == 1).

Ergebnis       Die Funktion liefert bei fehlerfreier Ausfhrung
               den Wert 0.

Querverweis    \#Fcreate\#, \#Fopen\#, \#Fclose\#, \#Fdelete\#, \#Ptermres\#
\end

screen( capsensitive("Pexec") )
Name           ¯program execution® - Programm laden und ausfhren.

Gemdosnummer   75

Definition     long  Pexec( int mode, char *ptr1,
                               void *ptr2, void *ptr3 );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Pexec l„dt und startet das im Pfad
               ptr1 angegebene Programm mit der Kommandozeile ptr2 und
               dem Environment ptr3, wenn der Parameter mode den Wert
               0 enth„lt. Wenn in mode der Wert 3 steht, wird das
               Programm nur als Overlay geladen. Wenn mode den Wert 4
               enth„lt, soll ein geladenes Programm gestartet werden;
               Parameter 2 und 4 men 0 sein . Wenn mode 5 ist, soll
               eine neue Basepage angelegt werden. Ab TOS 1.4 gibt es
               noch mode 6, der mode 4 entspricht, mit der Ausnahme,
               da die Speicherzuordnung an den Tochterprozess ver-
               erbt wird.

Ergebnis       Die Funktion liefert als Ergebnis den Abschlucode des
               Child-Prozesses. Wenn ein Overlay geladen wurde,
               enth„lt das Ergebnis die Basepage des Overlays. Die
               Basepage hat die Struktur \#BASPAG\#.
               Bei einem negativen Resultat ist ein Fehler aufgetreten.
\end

screen( capsensitive("Pterm") )
Name           ¯process termination® - beendet ein TOS-Programm.

Gemdosnummer   76

Definition     void  Pterm( int retcode );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Pterm beendet ein TOS-Programm und
               kehrt nicht wieder zurck. Der Abschlucode retcode
               kann von anderen Programmen weiterverwendet werden.

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Pterm0") )
Name           ¯process termination® - beendet ein TOS-Programm.

Gemdosnummer   0

Definition     void  Pterm0( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Pterm0 beendet ein TOS-Programm und
               kehrt nicht wieder zurck. Die Routine liefert den
               Return-Code 0 zurck.

Ergebnis       Die Funktion liefert kein Ergebnis.
\end

screen( capsensitive("Ptermres") )
Name           ¯terminate and stay resident® - Programm beenden, aber
               im Speicher behalten.

Gemdosnummer   49

Definition     void  Ptermres( long keepcnt, int retcode );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Ptermres beendet ein Programm, das
               Programm wird jedoch im Speicher gehalten. Dazu mu man
               unter keepcnt angeben, wieviele Bytes des Programms im
               Speicher gehalten werden sollen.
               Der Abschlucode retcode kann von nachfolgenden
               Programmen ausgewertet werden. Im Netzwerk werden
               alle Lockings des Prozesses aufgehoben.

Ergebnis       Die Funktion liefert kein Ergebnis.

Querverweis    \#Pexec\#   \#Pterm\#   \#Pterm0\#  \#_PgmSize\#
\end

screen( capsensitive("Super") )
Name           ¯supervisor ® - Supervisor-Modus umschalten.

Gemdosnummer   32

Definition     long  Super( void *stack );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Super schaltet zwischen User-
               und Supervisior-Modus um bzw. fragt den aktuellen
               Betriebsmodus ab. Die Adresse des Supervisor-Stacks
               kann beim Umschalten ver„ndert werden.
               bergibt man fr den Parameter stack den Wert 1, so
               wird der aktuelle Betriebsmodus erfragt. Der Wert 0
               schaltet zwischen User und Supervisor-Modus um. Alle
               anderen Werten werden als neue Adresse fr den
               Supervisor-Stack betrachtet.
               Im Supervisor-Modus kann auf alle geschtzten
               Speicherstellen zugegriffen werden.

Ergebnis       Sollte der Zustand ermittelt werden, erh„lt man
               als Resultat 0 fr den User- und -1 fr den Super-
               visor-Modus.
               Ansonsten liefert die Funktion als Ergebnis die
               Adresse des alten Supervisor-Stacks, sofern in den
               Supervisor-Modus umgeschaltet wurde.

Beispiel       #include <tos.h>

               int  main( void )
               {
               long   old_super_stack;

                   old_super_stack = Super( 0L );

                   /* Supervisor-Aktionen ... */

                   Super((void *) old_super_stack );

                   return( 0 );
               }
\end

screen( capsensitive("Sversion") )
Name           ¯operating system version® - ermittelt die Versions-
               nummer des Betriebssystems.

Gemdosnummer   48

Definition     int  Sversion( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Sversion ermittelt die Versionsnum-
               mer des Betriebssystems.

Ergebnis       Die Funktion liefert als Ergebnis die Version des
               Betriebssystems. Die Versionsnummer besteht aus zwei
               Zahlen: Das h”herwertige enth„lt die Hauptversions-
               nummer, w„hrend das niederwertige Byte kleinere
               šberarbeitungen kennzeichnet.
\end

screen( capsensitive("Tgetdate") )
Name           ¯get date® - Tagesdatum ermitteln.

Gemdosnummer   42

Definition     unsigned int  Tgetdate( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Tgetdate ermittelt das aktuelle
               Tagesdatum.

Ergebnis       Die Funktion liefert als Ergebnis eine Integer-Zahl mit
               dem Tagesdatum. Das Datum ist wie folgt codiert:

                         Bits           Bedeutung
                         0-4            Tag (1-31)
                         5-8            Monat (1-12)
                         9-15           Jahr (0-119, 0= 1980)

Querverweis    \#Tsetdate\#
\end

screen( capsensitive("Tsetdate") )
Name           ¯set date® - Tagesdatum setzen.

Gemdosnummer   43

Definition     unsiged int  Tsetdate( unsigned int date );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Tsetdate setzt das aktuelle Tagesda-
               tum. Der Parameter date ist wie folgt codiert:

                         Bits           Bedeutung
                         0-4            Tag (1-31)
                         5-8            Monat (1-12)
                         9-15           Jahr (0-119, 0= 1980)

Ergebnis       Die Funktion liefert als Ergebnis das tats„chlich
               gesetzte Datum.

Querverweis    \#Tgetdate\#
\end

screen( capsensitive("Tgettime") )
Name           ¯get time® - ermittelt die Uhrzeit.

Gemdosnummer   44

Definition     unsigned int  Tgettime( void );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Tgettime ermittelt die Uhrzeit.

Ergebnis       Die Funktion liefert als Ergebnis die Uhrzeit. Sie ist
               wie folgt codiert:

                         Bits      Bedeutung
                         0-4       Sekunden im Zweierschritt (0-29)
                         5-10      Minuten (0-59)
                         11-15     Stunden (0-23)

Querverweis    \#Tsettime\#
\end

screen( capsensitive("Tsettime") )
Name           ¯set time® - setzt die Uhrzeit.

Gemdosnummer   45

Definition     unsiged int  Tsettime( unsigned int time );

Prototyp in    tos.h

Beschreibung   Die GEMDOS-Routine Tsettime setzt die Uhrzeit. Der
               Parameter time mu wie folgt codiert werden:

                         Bits      Bedeutung
                         0-4       Sekunden im Zweierschritt (0-29)
                         5-10      Minuten (0-59)
                         11-15     Stunden (0-23)

Ergebnis       Die Funktion liefert als Ergebnis die tats„chlich
               gesetzte Uhrzeit.

Querverweis    \#Tgettime\#
\end
