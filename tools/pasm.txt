PASM.HLP wurde bersetzt am 3.Februar 1992.

(c) 1990 Borland International, Inc.Index der verfgbaren Schlsselw”rter:

     EA..F       EB..F       EC..F      ED..F

     EE..F       EF..F       EG..F      EH..F

     EI..F       EJ..F       EK..F      EL..F

     EM..F       EN..F       EO..F      EP..F

     EQ..F       ER..F       ES..F      ET..F

     EU..F       EV..F       EW..F      EX..F

     EY..F       EZ..F

     ESonstigesFPure Assembler auf einen Blick
----------------------------------------------------------------------

EAufruf und OptionenF

EFormale BeschreibungF

EBefehleF

EDirektivenF

EMakrosF

ECodeoptimierungF

EFehlermeldungenF

EAbkrzungenFFormale Beschreibung des Pure Assemblers
----------------------------------------

EZeichensatzF                  EKommentareF

EBezeichnerF                   ERegister-SpezifikationenF

ELabelsF                       EGr”en-SpezifikationenF

ENumerische KonstantenF        EAdressierungsartenF

EStringkonstantenF             EPositionsz„hlerF

EAusdrckeF                    EFliekomma-AusdrckeF

EPriorit„ten der OperatorenFDie MC680x0 Prozessor-Familie
----------------------------------------------------------------------

Weitere Informationen ber die MC680x0  Prozessor-Familie  k”nnen
Sie aus den Motorola Handbchern  zu  den  jeweiligen Prozessoren
beziehen.

- Motorola MC68000/68010 16-bit Microprocessor Programmer's
  Reference Manual
- Motorola MC68020 32-bit Microprocessor User's Manual
- Motorola MC68030 32-bit Microprocessor User's Manual
- Motorola MC68040 32-bit Microprocessor User's Manual
- Motorola MC68851 Paged Memory Management Unit User's Manual
- Motorola MC68881 Floating Point Coprocessor User's ManualAufruf und Optionen
----------------------------------------------------------------------

Der Assembleraufruf erfolgt mit einer Kommandozeile der Form

    PASM [options] source[.extension]

Die Optionen werden durch ein vorangestelltes Minuszeichen
gekennzeichnet, beispielsweise -1. Falls Optionen keine
weiteren Argumente verlangen, k”nnen mehrere Optionen zusammen-
gefat werden, beispielsweise -1V. Nachstehende Tabelle enth„lt
eine Aufstellung aller Optionen, inklusive deren Beschreibung.
Als n„chstes folgt der Name der Quelldatei. Wenn der Name der
Quelldatei keine Extension enth„lt, geht der Assembler davon
aus, da es sich um die Extension .S handelt. Andernfalls mu
die Extension explizit angegeben werden. Die erzeugte Objektdatei
erh„lt den Namen der Quelldatei versehen mit der Extension .O.

Option           Bedeutung
----------------------------------------------------------------
-1               Diese Option w„hlt den Befehlssatz fr die
                 Prozessoren MC68010 und MC68012 aus. Vorein-
                 gestellt ist der Befehlssatz fr MC68000 und
                 MC68008.

-2               Mit dieser Option wird auf den Befehlssatz fr
                 den MC68020 umgeschaltet.

-3               Um den Befehlssatz des MC68030 zu aktivieren,
                 mssen Sie diesen Schalter angeben.

-4               Damit Sie die Befehle des MC68040 nutzen k”nnen,
                 mu die Kommandozeile diesen Schalter enthalten.

-5               Diese Option erlaubt die Benutzung der Befehle
                 des Coprozessors MC68851. Eine Coprozessor-ID
                 l„t sich fur den MC68851 nicht angeben, da er
                 wegen seiner hardwarem„igen Voreinstellung mit
                 der ID 0 betrieben werden mu.

-8[=ID]          Dieser Schalter gestattet den Gebrauch des
                 Befehlssatzes der Coprozessoren MC68881 und
                 MC68882. Der optionale Parameter ID spezifiziert
                 die Coprozessor-ID. Diese darf zwischen 0 und 7
                 liegen, voreingestellt ist 1.

-A               Wenn dieser Schalter zus„tzlich zum Schalter -P
                 gesetzt ist, wird jede expandierte Makrozeile in
                 die EListing-DateiF aufgefhrt.

-B               Der Assembler erzeugt Objektdateien im DRI-Format,
                 wenn Sie diesen Schalter setzen. Standardm„ig
                 werden Objektdateien im Pure-Format angelegt.

-C               Wenn dieser Schalter zusammen mit der Option -P
                 angegeben ist, wird auch der Inhalt von Include-
                 Dateien in der EListing-DateiF aufgefhrt.

-D=symbol=value  Wie mit der =-Direktive, so k”nnen Sie auch ber
                 die Kommandozeile Symbole definieren. Dazu geben
                 Sie den Symbolnamen symbol gefolgt von einem
                 Gleichheitszeichen = und dem Wert value, den das
                 Symbol erhalten soll, an.

-F               Wenn diese Option angegeben ist, werden alle Zeilen
                 innerhalb eines IF-ELSE-ENDIF-Blocks, die die
                 Bedingung nicht erfllen, im EListingF unterdrckt.
                 Voraussetzung ist natrlich, da auch der Schalter
                 -P gesetzt wird. Normalerweise werden alle Zeilen
                 ausgegeben.

-I=path          šber diese Option k”nnen Sie einen Pfad angeben,
                 unter dem der Assembler die Include-Dateien suchen
                 soll.

-M               Wenn dieser Schalter zus„tzlich zum Schalter -P
                 gesetzt ist, werden in der EListing-DateiF nur die
                 Makroaufrufe aufgefhrt, nicht jedoch der fr sie
                 erzeugte Code.

-N=outdir        Mit dieser Option k”nnen Sie spezifizieren, in
                 welches Verzeichnis die Ausgabedatei geschrieben
                 werden soll.

-O=file[.ext]    M”chten Sie der erzeugten Objektdatei einen anderen
                 Namen geben, so mssen Sie ihn mit dieser Option
                 spezifizieren. Lassen Sie die Extension weg, so
                 wird die Extension .O an den Dateinamen file geh„ngt.

-P               Die Wahl dieser Option fhrt zur Erzeugung einer
                 EListing-DateiF. Diese erh„lt den Namen der Quelldatei,
                 versehen mit der Extension .LST.

-S               Diese Option fhrt dazu, da Sie auch die privile-
                 gierten Befehle in der Quelldatei benutzen drfen.

-U               Wenn Sie diesen Schalter angeben, behandelt der
                 Assembler alle nicht definierten Symbole als
                 externe Referenzen, statt eine Fehlermeldung
                 auszugeben.

-V               Dieser Schalter fhrt dazu, da der Assembler
                 zus„tzliche Informationen ber die Assemblierung
                 ausgibt.

-Y               Dieser Schalter veranlat die Erzeugung von Debug-
                 Information fr den Pure Debugger.Listing
----------------------------------------------------------------------

Die Listing-Datei enth„lt neben dem Quelltext auch Angaben zum
Verlauf der Assemblierung. In ihr wird der erzeugte Maschinencode 
und die Adresse neben den entsprechenden Assemblerbefehlen aus-
gegeben. Darberhinaus werden Informationen zu den verwendeten
ESymbolen und LabelsF gesammelt.
Um eine Listing-Datei zu erzeugen, mu man beim Aufruf des
Assemblers in der Kommandozeile den Schalter -P angeben. Es
wird dann eine Listing-Datei unter dem Namen der Quelldatei mit
der Dateierweiterung .LST angelegt.

Jede Seite der Listing-Datei beginnt mit einer speziellen
Kopfzeile. Diese enthalt die Versionsnummer des benutzten Pure
Assemblers und die fortlaufende Seitenzahl im Listing.
Das Listing besteht aus zwei Teilen, dem erweiterten Quelltext
und der Symboltabelle. 
Jede Zeile des ertweiterten Quelltexts hat folgendes Format:

<Zeile>   <Include>   <Adresse>   <Code>   <Makro>   <Quelltext>

Einzige Ausnahme von dieser Regel sind Zeilen, die Fehlermeldungen
oder Warnungen w„hrend der Assemblierung verursacht haben. Bei
ihnen fehlen die Informationen uber <Adresse> und <Code>.
Auerdem wird in der folgenden Zeile der Text der Meldung
wiederholt. Doch nun zur Beschreibung der einzelnen Komponenten
einer Zeile:

<Zeile>    enth„lt die Zeilennummer im Quelltext. Kopfzeilen und
           šberschriften gehen in die Zeilennummerierung nicht
           mit ein.
<Include>  wird mit einem Punkt (.) versehen, wenn gerade eine
           Include-Datei verarbeitet wird. Ansonsten befindet sich
           an dieser Stelle ein Leerzeichen.
<Adresse>  gibt die absolute Adresse oder den Offset innerhalb
           eines Segments oder Moduls fr die assemblierte Quell-
           textzeile an. Alle Adreangaben sind relativ zum Segment-
           bzw. Modulanfang.
<Code>     enth„lt den aus dem Quelltext erzeugten Maschinencode
           als Folge hexadezimaler Zahlen. Programmcode wird dabei
           aufgespalten in Befehlscode und Code fr Argumente
           (sofern sinnvoll).
           Bei Referenzen auf absolute externe Adressen wird an
           die Adreangabe im Code-Feld ein Asterisk (*) und bei 
           externen PC-relativen Referenzen ein Plus-Zeichen (+)
           angeh„ngt. Adressen im TEXT-, DATA und BSS-Segment werden
           durch verschiedene Arten von Anfhrungszeichen gekenn-
           zeichnet (', ', und "). Absolute Konstanten haben kein
           Suffix.
<Makro>    enth„lt ein Plus-Zeichen (+), wenn die betreffende Zeile
           aus einer Makroexpansion hervorgeht.
<Quelle>   beinhaltet die originale Quelltextzeile inklusive der
           Kommentare. Quelltextzeilen, die nur Kommentare enthalten,
           erzeugen keinen Code, so da das <Adresse>- und das
           <Code>-Feld leer bleiben.

Der zweite Teil der Listing-Datei beinhaltet die Symboltabelle.
Sie enth„lt, alphabetisch geordnet, Informationen zu allen im
Quelltext verwendeten Symbolen und Labels.
In der ersten Spalte, dem Feld Name befindet sich der Name des
Symbols bzw. des Labels. Im n„chsten Feld, Value, steht der
Initialwert des Symbols. Bei Labels, die sich auf Adressen beziehen,
wird diese angegeben. Im Feld Scope wird angegeben, ob ein Symbol
extern, global oder lokal ist. Das Feld Relocation base schlielich
gibt Auskunft darber, ob das Symbol relativ zu einem Segment oder
Modul definiert ist.Fehlermeldungen des Pure Assemblers
----------------------------------------------------------------------

Die Fehlermeldungen sind in die folgenden drei Kategorien
unterteilt:

EKommandozeilen-FehlerF

EAssemblierungsfehlerF

EFatale FehlerFKommandozeilen-Fehler
----------------------------------------------------------------------

Folgende Fehlermeldungen erhalten Sie, wenn in der EKommandozeileF
die Parameter falsch angegeben werden.

*** Invalid coprocessor id
Die angegebene Coprozessor-ID ist ungltig. Sie mu im Bereich
zwischen 0 und 7 liegen.

*** Invalid option
Die angegebene EOptionF existiert nicht.

*** Missing option character
Nach einem Minuszeichen mu ein EOptionszeichenF folgen.

*** Missing '-D' argument
Die Option -D verlangt als Argument einen Symbolnamen und einen
Wert. Mindestens eine der Angaben fehlt.

*** Missing '-I' argument
Die Option -I verlangt als Argument einen Verzeichnisnamen fr
die Suche von Include-Dateien. Dieser wurde nicht angegeben.

*** Missing '-N' argument
Die Option -O verlangt als Argument einen Verzeichnisnamen fr
die Ausgabedatei. Dieser wurde nicht angegeben.

*** Missing '-O' argument
Die Option -O verlangt als Argument einen Dateinamen fr die
Ausgabedatei. Dieser wurde nicht angegeben.

*** Missing source file name
In der Kommandozeile wurde nicht angegeben, welche Quelldatei
assembliert werden soll.

*** More than one source file name specified
Es wurde mehr als eine zu assemblierende Quelldatei angegeben, es
ist jedoch nur eine erlaubt.Assemblierungsfehler
----------------------------------------------------------------------

Diese Kategorie weist auf Fehler in den Quelltexten hin. Die
Assemblierung wird nach einem dieser Fehler nicht abgebrochen,
so da mehrere Fehler auf einmal gefunden werden k”nnen. Es wird
aber keine Objektdatei erzeugt.
Falls gleichzeitig eine EListing-DateiF angelegt wird, werden die
Fehlermeldungen auch dort, in der Zeile unter der Fehlerstelle,
aufgefhrt.
Fr jeden Fehler wird der Name der Quelldatei und die Zeilennummer
der Fehlerstelle ausgegeben.

*** Addressing mode for MC68020 only
Es wurde eine EAdressierungsartF gew„hlt, die erst ab dem MC68020
zur Verfgung steht. Um sie zu benutzen, mssen Sie den ent-
sprechenden Befehlssatz w„hlen.

*** Backward assignment to location counter
Eine Zuweisung an den EPositionsz„hlerF fhrte dazu, da dieser
verringert wurde. Es sind jedoch ausschlielich vorw„rtsge-
richtete Zuweisungen erlaubt.

*** Bad format in floating point number
Das Format der angegebenen Fliekommazahl entspricht nicht der
erlaubten ESyntaxF.

*** Code generation in this segment not allowed
Es wurde unerlaubterweise versucht, im EBSSF- oder einem
Eabsoluten SegmentF Code zu erzeugen. Zugelassen sind ausschlielich
Label-Definitionen und Speicherzuweisungsdirektiven.

*** Code not aligned
In der betreffenden Zeile sollte Code erzeugt werden, der auf eine
Byte-Grenze zu liegen gekommen w„re. Sie k”nnen diesen Fehler durch
die Verwendung einer EEVENF-Direktive beheben.

*** Constant too long
Dieser Fehler kann zwei Ursachen haben. Eine numerische Konstante
l„t sich nicht als 32-Bit-Wert darstellen oder eine Stringkonstante
ist langer als vier Zeichen.

*** Displacement out of range
Die Adredistanz der verwendeten EAdressierungsartF ist l„nger als
ein Byte oder ein Wort.

*** Division by zero
Bei der Auswertung eines Ausdrucks trat eine Division durch Null auf.

*** Duplicate register in register list
Ein Register wurde in einer Registerliste mehrmals aufgefhrt.

*** Duplicate global symbol(s)
Dieser Fehler kann nur auftreten, wenn Sie Objektdateien im DRI-
Format erzeugen. Bei diesem ist die L„nge an signifikanten Zeichen
fr Bezeichner auf 8 beschr„nkt. Pure Assembler verarbeitet Label-
namen bis zu 255 Zeichen L„nge, so kann er bespielsweise yourFunc1
und yourFunc2 unterscheiden. In einer DRI-Objektdatei ist dies
nicht mehr m”glich, da die beiden Labels erst im neunten Zeichen
differieren. Wenn Sie eine Objektdatei im Pure-Format erzeugen,
k”nnen Sie diese Schwierigkeiten umgehen.

*** Error direktive:
Es wurde mit der EERRORF-Direktive eine Fehlermeldung erzeugt.

*** Expression must be constant
Eine Direktive erwartete einen absoluten, nicht relozierbaren Ausdruck.

*** Immediate data out of range
Die Konstante fr eine Immediate-Adressierung pat nicht in ein
Byte oder Wort.

*** Index register scale must be 1,2,4 or 8
Die Skalierung fr ein Indexregister darf nur einer der Faktoren
1, 2, 4 oder 8 sein.

*** Index register size must be word or longword
Als Gr”enspezifikation fr ein Indexregister sind nur die
Datenformate Wort oder Langwort zul„ssig.

*** Invalid control character in input line
In der betreffenden Zeile befindet sich ein Zeichen, dessen
ASCII-Code kleiner 32 und kein Zeilenvorschub ist.

*** Invalid conditional directive
Es wurde eine EELSEF-, EENDIFF- oder EENDCF-Direktive ohne vorherige
EIFccF-Direktive gefunden.

*** Invalid digit
In einer numerischen Konstante wurde eine ungltige Ziffer entdeckt,
beispielsweise in einer Bin„rzahl eine andere Ziffer als 0 oder 1.

*** Invalid instruction argument(s)
Der betreffende Befehl wurde mit zuviel oder zuwenig Argumenten
benutzt. M”glich ist auch, da eine nichtzugelassene Adressierungsart
fr ein Argument des Befehls verwendet wurde.

*** Invalid macro directive
Es wurde eine ELOCALF-, EENDMF- oder EEXITMF-Direktive ohne vorherige
EMakrodefinitionF gefunden.

*** Label redefined
Das betreffende Label wurde bereits definiert. Die angegebene Stelle
ist der Ort der Redefinition.

*** Line overflow
Zeilen drfen maximal 512 Zeichen umfassen. Die betreffende Zeile
ist l„nger.

*** Macro name redefines opcode or directive
Makronamen drfen nicht mit denen von Befehlen oder Direktiven
bereinstimmen.

*** Missing argument
Fr die betreffende Direktive sind zu wenig Parameter vorhanden.

*** Missing 'endif'
Zu einer EIFccF-Direktive existiert kein EENDIFF oder EENDCF. Dieser
Fehler wird erst am Ende eines Quelltextes erkannt.

*** Missing 'endm'
Zu einer EMACROF-Direktive existiert kein EENDMF. Diese Fehlermeldung
wird erst am Ende eines Quelltextes ausgegeben.

*** Opcode for 68010 only
*** Opcode for 68020 only
*** Opcode for 68030 only
*** Opcode for 68040 only
*** Opcode for 68851 only
*** Opcode for 68881 only
Der betreffende Befehl ist im gew„hlten EBefehlssatzF nicht vorhanden.
W„hlen Sie den angegebenen Befehlssatz, wenn Sie den Befehl trotzdem
verwenden wollen.

*** Operand size not allowed
Das gew„hlte Datenformat ist fr den Befehl nicht zugelassen.

*** Privileged instruction
Der betreffende Befehl ist privilegiert. Um ihn verwenden zu k”nnen,
mssen Sie den privilegierten Befehlssatz aktivieren.

*** Relative address out of range
Die Verzweigung geht ber eine Distanz, die sich nicht mehr in
einem Byte oder Wort darstellen l„t.

*** Relocation error
Der Typ eines EAusdrucksF ist in diesem Zusammenhang nicht zugelassen.

*** String literal exceeds one line
Eine Stringkonstante geht ber mehr als eine Zeile. Dies ist nicht
erlaubt.

*** Syntax error in argument(s)
Die Argumente eines Befehls oder einer Direktive enthalten einen
Syntaxfehler.

*** Syntax error in input line
Der Assembler kann die angegebene Zeile nicht interpretieren.

*** Syntax error in register list
Die Registerliste enth„lt einen Fehler.

*** Undefined symbols
Zu den nach dieser Meldung aufgefhrten Labels findet sich in der
Quelldatei keine Definition oder EIMPORTF-Direktive.

*** Unknown mnemonic
Es wurde ein Bezeichner gefunden, der weder ein Befehl, noch eine
Direktive oder ein Makroname ist.

*** Unknown size specification
Es wurde eine unbekannte Gr”enspezifikation verwendet.

*** Unterminated C-comment
Fr einen C-Kommentar konnte kein Kommentarende gefunden werden.
Diese Fehlermeldung tritt erst am Ende eines Quelltextes auf.

*** Value not allowed
Der Wert eines Ausdrucks liegt nicht in dem fr diesen Zusammenhang
zugelassenen Bereich.Fatale Fehler
----------------------------------------------------------------------

Nach einem fatalen Fehler mu die šbersetzung sofort abgebrochen
werden. Eine Objektdatei kann in solchen Fallen nicht erzeugt
werden.

*** Cannot close output file
Das Betriebssystem kann die erzeugte Datei nicht schlieen.

*** Cannot create output file
Die Zieldatei kann nicht erzeugt werden. M”glicherweise ist die
Zieldiskette schreibgeschtzt, eine gleichnamige schreibgeschtzte
Datei existiert bereits oder es ist kein Platz auf dem Ziellaufwerk
vorhanden.

*** Cannot open include file
Der Assembler kann die angegebene Include-Datei nicht finden.
Entweder ist Ihnen ein Schreibfehler unterlaufen oder der Pfadname
existiert nicht.

*** Cannot open file
Der Assembler kann die angegebene Datei nicht finden. Entweder ist
Ihnen ein Schreibfehler unterlaufen oder der Pfadname existiert
nicht.

*** Internal error
*** Unknown error
Falls einer dieser Fehler auftritt, schreiben Sie sofort an Pure
Software. Nach M”glichkeit legen Sie ein Beispiel und eine
Beschreibung bei, wie es zu diesem Fehler kam, damit wir ihn
beheben k”nnen.

*** Out of memory
Sie haben zu wenig Arbeitsspeicher frei. Entfernen Sie alle
residenten Programme und Accessories. Starten Sie den Assembler
dann vom Desktop und unternehmen Sie einen neuen Versuch.

*** Seek error on output file
W„hrend eines Suchvorgangs in der Zieldatei trat ein Fehler auf.
M”glicherweise ist die Datei fehlerhaft.

*** Write error on output file
In die Zieldatei konnte nicht geschrieben werden. M”glicherweise
ist kein Platz mehr auf dem Ziellaufwerk vorhanden.Zeichensatz
----------------------------------------------------------------------

Der Pure Assembler erkennt den folgenden Zeichensatz:

- Die Buchstaben: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
                  a b c d e f g h i j k l m n o p q r s t u v w x y z
- Die Zahlen:     0 1 2 3 4 5 6 7 8 9
- Die Zeichen:    ! " # $ % & ' ( ) * + , - . / : ; < = >
                  ? [ ] ^ _ ` { | } ~ @.

- Die unsichtbaren Zeichen Leerstelle ( $20 ) und Tab ( $09 ).
- Die unsichtbaren Kontrollzeichen Carriage-Return ( $0D )
  und Line-Feed ( $0A ).

Eine Zeile darf maximal 512 Zeichen lang sein.Priorit„ten der Operatoren
----------------------------------------------------------------------

Die Operatoren haben unterschiedliche Gewichtung fr die Reihen-
folge der Auswertung. Die un„ren Operatoren und die Klammern
werden aufgrund der h”chsten Priorit„t zuerst verarbeitet. Die
geringste Priorit„t besitzen die Vergleichsoperatoren. Ausdrucke
mit Operatoren derselben Priorit„t werden von links nach rechts
ausgewertet.

Operator                    Priorit„t
-------------------------------------------------------
+  -  !  (  )               hoch
*  /  %  &  ^  <<  >>
+  -  |
==  !=  >=  >  <  <=        niedrig
-------------------------------------------------------Bezeichner
----------------------------------------------------------------------

Ein Bezeichner ist eine Folge von einem oder mehreren Zeichen.
Fr das erste Zeichen drfen

      A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
      a b c d e f g h i j k l m n o p q r s t u v w x y z
      ? _ ~ .

verwendet werden, fr alle weiteren Zeichen zusatzlich ($) und
(@), sowie die Ziffern

      1 2 3 4 5 6 7 8 9 0

nicht dagegen der Punkt (.).
Bezeichner dienen der Spezifikation von Befehlen, Datentypen und
Registernamen, Direktiven, sowie Makronamen und ELabelsF bzw.
Symbolen. Alle Zeichen eines Bezeichners sind signifikant.
Zwischen Gro- und Kleinschreibung wird unterschieden.Register-Spezifikationen
----------------------------------------------------------------------

Die verschieden Prozessoren der Motorola-Familie kennen zwei
unterschiedliche Betriebszust„nde. Der "Usermode" ist fr
Anwenderprogramme, der "Supervisormode" ist dem Betriebssytem
vorbehalten.

Im Usermode sind folgende Register erreichbar:

EDatenregisterF 
EAdreregisterF
EStatusregisterF               ( eingeschr„nkter Zugriff )
EStackpointerF                 ( eingeschr„nkter Zugriff )
EFliekomma-DatenregisterF     ( nur mit EMC68881F/2       )
EFPU-KontrollregisterF         ( nur mit EMC68881F/2       )

Im Supervisormode sind zus„tzlich folgende Register erreichbar:

EStatusregisterF               ( voller Zugriff )
EStackpointerF                 ( voller Zugriff )
ECPU-KontrollregisterF
EPMMU-KontrollregisterF

Bei den Registernamen wird Gro- und Kleinschreibung unterschieden,
d.h. Vbr bezieht sich nicht auf das Vector Base Register. Sie
mssen also entweder VBR oder vbr schreiben. Mit den Registernamen
gleichlautende Labelnamen sind nicht zul„ssig.Lokale Labels
----------------------------------------------------------------------

Lokale Labels sind ESymboleF mit  beschr„nktem Gltigkeits-
bereich. Man benutzt lokale Labels, um sich nicht st„ndig neue
Namen fr h„ufig wiederkehrende Konstrukte ausdenken zu mssen.
Ein lokales Label beginnt mit einem Punkt (.), gefolgt von einem
Labelnamen. Der Gltigkeitsbereich eines lokalen Labels ist auf
den Bereich zwischen zwei normalen Labels begrenzt.
Wenn Sie nun einen Programmabschnitt mit mehreren Schleifen haben, 
k”nnen Sie mit lokalen Labels programmieren:

            ...
Routine1:
            ...
.loop:      add.w   d0,(a0)+
            bne     .loop
            rts
            ...
Routine2:
            ...
.loop:      tst.l   -(a0)
            bne     .loop
            rts
            ...Labels ( Spungziele )
----------------------------------------------------------------------

Labels oder Symbole sind EBezeichnerF, die als Referenz fr
Konstanten und Adressen dienen. Sie sind gltig in dem Modul, in
dem sie definiert wurden. Falls ohne Module gearbeitet wird,
bezieht sich die Gltigkeit auf den gesamten Quelltext. Der
Gltigkeitsbereich ELokale LabelsF erstreckt sich auf den Bereich
zwischen zwei normalen Labels.
Soll auf ein Label Bezug genommen werden, das in einem anderen Modul
oder Quelltext definiert wurde, so mu dieses Label importiert bzw.
exportiert werden.
Fr die Namen von Labels ist die einzige Restriktion, da sie nicht
mit Registernamen bereinstimmen drfen.
Labels k”nnen mit den Zuweisungsdirektiven E=F, EEQUF, ESETF oder EREGF
definiert werden. Labels k”nnen aber auch in Leerzeilen oder vor
Befehlen und einigen Direktiven vereinbart werden. Folgende
Syntax gilt:

             label:[label:...]

So definierte Labels mssen stets mit einem Doppelpunkt abge-
schlossen werden. Vor einem Label drfen Leerzeichen oder
Tabulatoren stehen. Dem Label wird der aktuelle Wert des
EPositionz„hlersF zugewiesen. Erneute Zuweisung eines anderen Wertes
ist fr diese Labels nicht mehr erlaubt.Gr”en-Spezifikationen
----------------------------------------------------------------------

Die Datenformate oder Gr”en-Spezifikationen der MC68xxx-Familie
k”nnen mit den folgenden Namen spezifiziert werden:

Namen   Typ     Gr”e                           Gr”e in Bits
-----------------------------------------------------------------
.b      .B      Byte                            8 Bit
.w      .W      Word                            16 Bit
.l      .L      Longword                        32 Bit
.s      .S      Single Precision Binary Real    32 Bit
.d      .D      Double Precision Binary Real    64 Bit
.x      .X      Extended Precision Binary Real  96 Bit
.p      .P      Packed Decimal Real             64 Bit
-----------------------------------------------------------------Numerische Konstanten
----------------------------------------------------------------------

Numerische Konstanten k”nnen in bin„rer, oktaler, dezimaler oder
hexadezimaler Schreibweise angegeben werden. Numerische Konstanten
sind 32-Bit Werte.
Bin„re Zahlen beginnen mit einem Prozentzeichen (%), gefolgt von
den Ziffern 0 und 1. Das erste Zeichen einer oktalen Zahl ist der
Klammeraffe (@). Danach drfen die Ziffern 0 bis 7 stehen.
Dezimalzahlen werden in gewohnter Weise geschrieben. Hexadezimale
Zahlen werden durch ein Dollarzeichen ($), 0x oder 0X eingeleitet.
Die eigentliche Zahl setzt sich dann aus den Ziffern 0 bis 9 und
den Buchstaben a bis f bzw. A bis F zusammen.
Zur besseren Lesbarkeit darf innerhalb der Konstanten der Unterstrich
(_) benutzt werden, beispielsweise 1_000_000 fr eine Million.Stringkonstanten
----------------------------------------------------------------------

Stringkonstanten bestehen aus einer Folge von ASCII-Zeichen, die
durch einfache oder doppelte Anfhrungszeichen begrenzt wird. Um
Anfhrungszeichen in die Stringkonstante aufzunehmen, mu das
entsprechende Zeichen doppelt geschrieben werden. Steuerzeichen,
also Zeichen, deren ASCII-Code kleiner als 32 ist, sind nicht
erlaubt.
Ist ein String Parameter einer EDCF-, EASCIIF-, EASCIILF- oder EASCIIZF-
Direktive, so wird fr jedes Zeichen (mit Ausnahme der Begrenzer)
ein Byte erzeugt. In allen anderen F„llen darf der String maximal
vier Zeichen lang sein. Ist der String krzer als vier Zeichen,
so wird die 32-Bit Konstante von links mit Nullen gefllt.Der Positionsz„hler
----------------------------------------------------------------------

Auf den aktuellen Assemblierungs-Positionsz„hler wird mit dem
Asterisk (*) bezug genommen. Wenn (*) in einem Ausdruck bentzt
wird, repr„sentiert das Zeichen die Adresse des ersten Bytes
des gegenw„rtigen Statements. Da der Asterisk (*) gleichzeitig
auch als Begrenzer fr EKommentareF verwendet wird, empfiehlt es
sich, das Zeichen in Klammern einzuschlieen, damit es vom
Assembler korrekt interpretiert wird.Adressierungsarten
----------------------------------------------------------------------

Die MC68nnn-Mikroprozessorfamilie untersttzt eine Vielzahl von
Adressierungsarten. Die Syntax wird so akzeptiert, wie sie in den
Motorola User Manuals beschrieben ist. Die folgende Tabelle zeigt
die Syntax fr die unterschiedlichen Adressierungsarten:

Syntax  Modus
-----------------------------------------------------------------
EdnF                              Datenregister direkt
EanF                              Adreregister direkt
(EanF)                            Adreregister indirekt
(EanF)+                           Adreregister indirekt
                                mit Postincrement
-(EanF)                           Adreregister indirekt
                                mit Predecrement
(EdispF,EanF) od. EdispF(EanF)          Adreregister indirekt mit
                                Displacement
(EdispF,EanF,ExnF) od. EdispF(EanF,ExnF)    Adreregister indirekt mit
                                Index und Displacement
([EdispF,EanF],EdispF,ExnF)             Post-Indexed
([EdispF,EanF,ExnF],EdispF)             Speicher indirekt Pre-Indexed
(EdispF,EpcF) od. EdispF(EpcF)          Program Counter relativ mit
                                Displacement
(EdispF,EpcF,ExnF) od. EdispF(EpcF,ExnF)    Program Counter relativ mit
                                Index u. Displacement
([EdispF,EpcF],EdispF,ExnF)             Program Counter Speicher indirekt
                                Post-Indexed
([EdispF,EpcF,ExnF]EdispF)              Program Counter Speicher indirekt
                                Pre-Indexed
EaddrF                            Absolute Adresse
#EdataF                           Immediate Data

-----------------------------------------------------------------

Querverweis: EBeispiele der AdressierungsartenFBeispiele fr Standard-Adressierungsarten
----------------------------------------------------------------------
2
Ea6F
(Ea0F)
(Ea3F)+
-(EspF)
100(Ea2F)                         entspricht (100,a2)
5(Ea3F,Ed2F)                        entspricht (5,a3,d2.w*1)
var(EpcF)                         entspricht (var,pc)
10(pc,a2.l)                     entspricht (10,pc,a2.l*1)
$1fff0000
#1000


Beispiele fr erweiterte Adressierungsarten
----------------------------------------------------------------------
(1000,Ea2F,Ed0F.l*8)
(Ed2F.l)                  Displacement und Base-Register
                        unterdrckt
(Ea2F,Ed7F*4)               Displacement unterdrckt
([-44,EspF],1000,Ed3F.l)
([4,a2,d7.w*4],10)
([4,sp])                ueres displacement und Indexregister
                        unterdrckt
([d2.l],4)              Inneres Displacement und Indexregister
                        unterdrckt
([$1000])               ueres Displacement, Base-Register und
                        Indexregister unterdrckt
(var,EpcF,Ed1F.w*2)
($400,EzpcF)              Programmz„hler und Indexregister
                        unterdrckt
([var,EpcF,Ea2F.l],4)
([var,EpcF],d2.l)         ueres Displacement unterdrckt
([EzpcF])                 Beide Displacements, Programmz„hler und
                        Indexregister unterdrcktxn      Entweder  ein  Datenregister oder ein  Adreregister. Auf
        den Registernamen kann optional eine Gr”en-spezifikation
        und ein Skalierungswert  folgen. Die Gr”en-spezifikation
        kann .w ( .W )  fr  Word  oder  .l ( .L )  fr  Longword
        sein.   Wenn  keine  Gr”e  angegeben  wird,   wird  Word
        angenommen.    Der   Skalierungswert   wird   durch   den
        Multiplikationsoperator ( * )  spezifiziert,  auf den ein
        Ausdruck ( 1, 2, 4 oder 8 )  folgt.  Der  voreingestellte
        Skalierungswert ist 1.pc      Entweder  EpcF ( Program Counter )  oder EzpcF ( Zero Program
        Counter ). Wenn zpc spezifiziert ist,  wird  die Addition
        des Programmz„hlers w„hrend der Berechnung der effektiven
        Adresse unterdrckt. In diesem Fall ist das  Displacement
        tats„chlich eine absolute Adresse im Programmbereich.disp    Ein Ausdruck,   der  das  Displacement  angibt,   das zum
        Inhalt  des  Base-Registers  w„hrend  der  Berechnung der
        effektiven Adresse   addiert  wird.   Der  Ausdruck  kann
        absolut, segmentrelativ oder extern sein.
        Wenn die  Adressierungsart  Program  Counter relative ist
        und der Programmz„hler nicht  unterdrckt  wird,  mu ein
        Ausdruck relativ  zum  gegenw„rtigen  Segment  sein.   In
        diesem  Fall  wird  der  Wert  des  EPositionsz„hlerFs  vom
        Displacement  subtrahiert,  um das endgltige EpcF-relative
        Displacement zu ermitteln.addr    Ein  Ausdruck,  der eine absolute Adresse im Datenbereich
        angibt. Der Ausdruck  kann  absolut,  segmentrelativ oder
        extern sein.data    Ein   Ausdruck,  der  Immediate  Daten spezifiziert.  Der
        Ausdruck kann absolut,  segmentrelativ  oder extern sein.
        Die   Syntax   der   indirekten   Adressierungsarten  mit
        Displacement  wurde  in den Motorola User Manuals fr den
        MC68020 abweichend von der  Syntax  frherer  EProzessorFen
        definiert.  Wie  schon  in  der  Tabelle gezeigt,  werden
        vom Assembler beide Modi akzeptiert.
        Bei den  MC68000/08/10/12  Mikroprozessoren stehen einige
        Adressierungsarten  nicht zur Verfgung. Dabei handelt es
        sich um die Modi Memory  Indirect  und  Indexed mit einem
        Skalierungswert   abweichend  von  1. Displacement.   Ein
        Displacement  darf  16 Bit nicht berschreiten, wenn kein
        Indexregister bentzt wird.  Andernfalls ist das maximale
        Displacement 8 Bit.

        Bei den MC68020/30/40 Prozessoren  und  den MC68851/81/82
        Coprozessoren  stehen  s„mtliche  Adressierungsarten  zur
        Verfgung.  Allerdings  werden  diese  Erweiterungen  nur
        akzeptiert,   wenn  in  der  Befehlszeile  die  Option -2
        gesetzt wird.   Die  im  MC68020 User Manual als "generic
        modes"  bezeichneten  Erweiterungen  werden  untersttzt.
        Diese   Erweiterungen   werden   generiert,   indem   das
        Base-Register   und/oder  ein  Displacement   unterdrckt
        werden.  Der Assembler w„hlt automatisch das  kompakteste
        Kodierungsverfahren.

Hinweis:   Wenn  ein  Datenregister fr Indirektion bentzt wird,
ist Vorsicht angebracht, da Datenregister immer als Indexregister
behandelt werden und ihre voreingestellte Gr”e Word ist.Ausdrcke und Operatoren
----------------------------------------------------------------------

Ausdrcke sind auswertbare Kombinationen von Operanden und Opera-
toren. Operanden sind Konstanten oder Symbole. Bei Operatoren
unterscheidet man Eun„re OperatorenF, die einen Operanden haben
und Ebin„re OperatorenF, die zwei Operanden ben”tigen. Die Syntax
fr Ausdrucke orientiert sich an der der Programmiersprache C.Un„re Operatoren
----------------------------------------------------------------------

Der Operand eines un„ren Operators mu ein absoluter Wert sein.
Das Resultat ist wiederum ein absoluter Wert.

Operator   Operation
----------------------------------------------------------------------
+          ergibt den positiven Wert des Operanden
-          ergibt den negativen Wert des Operanden (Zweierkomplement)
!          negiert den Operanden (Einerkomplement)
----------------------------------------------------------------------Bin„re Operatoren
----------------------------------------------------------------------

Das Resultat der Vergleichsoperatoren ist die Konstante 0, wenn
die Relation nicht erfllt ist, ansonsten -1. Das Resultat ist
also ein absoluter Wert, unabh„ngig von den Operanden. Als
Ergebnis erh„lt man 0, wenn beide Operanden nicht absolut sind
oder nicht relativ im selben Segment sind. Folglich gibt es zwei
Ursachen fur das Resultat 0; entweder k”nnen die beiden Werte
nicht verglichen werden oder die Vergleichsbedingung ist nicht
erfllt.
Der Operator (+) erwartet mindestens einen absoluten Operanden.
Das Resultat ist vom Typ des anderen Operanden.
Fr den Operator (-) gibt es zwei gltige Operandenkombinationen.
Erstens kann der linke Operand absolut, relativ oder extern sein
und der rechte absolut. Zweitens drfen beide Operanden relativ
im selben Segment sein. Das Ergebnis ist immer absolut.
Fr alle anderen Operatoren mssen die Operanden absolut sein.

Operator   Operation
----------------------------------------------------------------------
+          Addition der beiden Operanden
-          Subtraktion des zweiten vom ersten Operanden
*          Multiplikation der beiden Operanden
/          Integerdivision des ersten durch den zweiten Operanden
%          Rest der Integerdivision des ersten durch den zweiten
           Operanden
|          Bitweise logische ODER-Verknupfung beider Operanden
&          Bitweise logische UND-Verknupfung beider Operanden
^          Bitweise logische EXKLUSIV-ODER-Verknupfung beider
           Operanden
<<         Schiebt die Bits des ersten Operanden um die im zweiten
           Operanden angegebene Zahl an Positionen nach links.
           Rechts werden Nullen nachgeschoben.
>>         Schiebt die Bits des ersten Operanden um die im zweiten
           Operanden angegebene Zahl an Positionen nach rechts.
           Links werden Nullen nachgeschoben.
=, ==      Prfung auf Gleichheit der beiden Operanden
!=,<>,#    Prfung auf Ungleichheit der beiden Operanden
>=         Prfung, ob der erste Operand gr”er oder gleich dem
           zweiten ist
>          Prfung, ob der erste Operand gr”er als der zweite ist
<=         Prfung, ob der erste Operand kleiner oder gleich dem
           zweiten ist
<          Prfung, ob der erste Operand kleiner als der zweite ist
----------------------------------------------------------------------Fliekomma-Ausdrcke
----------------------------------------------------------------------

Ausdrcke, in denen ein Operand eine Fliekommazahl ist oder
dessen Datenformat eine Fliekommazahl spezifiziert, werden
als Fliekommaausdrcke ausgewertet.
Fliekommakonstanten beginnen mit dem Integer-Anteil. Danach
kann ein durch einen Punkt abgetrennter Nachkommaanteil stehen.
Schlielich kann ein mit einem E bzw. e eingeleiteter Exponential-
teil folgen:

     digits[.digits][E|e[+|-]digits]

Fur alle Fliekommaformate gibt es die beiden un„ren Vorzeichen-
operatoren (+) und (-) und die bin„ren Operatoren (+), (-), (*)
und (/).
Die Berechnungen erfolgen per Software im Format extended precision
binary real. Kann das Zielformat das Ergebnis einer Ausdrucks-
auswertung nicht aufnehmen, so wird bei einem šberlauf Unendlich
und bei einem Unterlauf eine Null erzeugt. Bei ungltigen Opera-
tionen wird ein NAN (eine ungltige Zahl) generiert, aber keine
Fehlermeldung ausgegeben!Kommentare
----------------------------------------------------------------------

Der Pure Assembler kennt mehrere M”glichkeiten, Kommentare zu
kennzeichnen.
Der Asterisk (*) leitet einen Kommentar ein, wenn er direkt am
Zeilenanfang oder nach einem Leerzeichen oder Tabulator steht.
Auf den Asterisk darf kein Gleichheits-, Plus- oder Minuszeichen
folgen. Das Zeilenende beendet den Kommentar.
Findet der Assembler ein Semikolon (;), so fat er die restlichen
Zeichen der Zeile als Kommentar auf.
Mehrzeilige Kommentare erreicht man mit den in C blichen
Kommentarbegrenzern /* und */.
Schlielich werden Zeilen, die mit einem Doppelkreuz (#) beginnen,
als Kommentarzeilen interpretiert. Erlaubt ist auch, da zwischen
Zeilenanfang und Doppelkreuz Leerzeichen oder Tabulatoren stehen.Datenregister
----------------------------------------------------------------------

Die Datenregister der CPU k”nnen durch die Bezeichnungen d0 - d7,
D0 - D7, r0 - r7 bzw. R0 - R7 spezifiziert werden. 

Jedes Datenregister ist 32 Bit breit.  Byte Operanden belegen die
unteren  8 Bit,   Word  Operanden  die  unteren  16 Bit, Longword
Operanden  die  gesamten  32 Bit.  Das  erste  Bit wird als Bit 0
( Null ) bezeichnet.

Querverweis: ERegister-SpezifikationenFAdreregister
----------------------------------------------------------------------

Die Adreregister  der CPU k”nnen durch die Bezeichnungen a0 - a7,
A0 - A7, r8 - r16 bzw.  R8 - R16  spezifiziert werden.  Der Stack-
pointer EA7F kann auch durch ESPF bzw. EspF spezifiziert werden.  

Adreregister  sind  32  Bit  breit. Adreregister  k”nnen  nicht
byteweise benutzt werden.  Wird  ein  Adreregister  als  Source-
operand verwendet ist davon also  entweder  das untere Word, oder
das  gesamte  Langwort betroffen.  Wenn  ein  Adreregister   als
Destination  benutzt  wird, ist  davon  immer  das ganze Register
betroffen.  Word  Operationen bewirken eine automatische Erweite-
rung  des Operanden auf 32 Bit, wobei die Erweiterung vorzeichen-
behaftet ist. Alle  Adreregister lassen sich  als  Indexregister
verwenden.

Querverweis: ERegister-SpezifikationenFSP - Stackpointer
----------------------------------------------------------------------

Der Stack ist ein Speicherbereich, der nach dem LIFO-prinzip or-
ganisiert  ist.  (LIFO = Last In  First Out).  Solche  Speicher-
bereiche  nennt  man auch "Stapel".  Diese Bereiche  werden  zur 
Zwischenspeicherung  von  Rcksprungadressen, lokalen  Variablen
etc. verwendet. 

Das EAdreregisterF a7  bezeichnet den gerade aktiven Stackpointer.
Dieses Register kann auch mit  sp  oder  SP angesprochen  werden.
Alle auf Adreregister  anwendbaren Befehle lassen sich auch  auf
den  Stackpointer anwenden.  Der Stackpointer kann  immer nur auf 
eine gerade Adresse zeigen.  Das bedeutet, da bei den Postinkre-
ment oder Predekrement EAdressierungsartenF  auch bei Bytezugriffen
der Stackpointer um 2 erh”ht bzw. erniedrigt wird.

Die  CPUs der  MC680x0-familie  kennen  insgesamt 3  verschiedene 
Stackpointer wobei jedoch immer nur einer aktiv ist.  Im Usermode
(siehe EsrF) hat  man nur  Zugriff auf  den gerade  aktiven SP.  Im
Supervisormode kann man alle Stackpointer ansprechen.

Querverweis: EsspF, EuspF, EispF, EmspFSR - Statusregister
----------------------------------------------------------------------

Das Statusregister ist 16 Bit breit und aufgeteilt in:

            System-Byte         und          User-Byte (EccrF)
   15  14  13  12 |    11  10  9               4 | 3   2   1   0
 [-------------------------------|-------------------------------]
 | T0| T1| S |*M*|   | I2| I1| I0|   |   |   | X | N | Z | V | C |
 +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
 |       | |   |     |           |             |   |   |   |   |
 +-----+-+ |   |     +-----+-----+             |   |   |   |   |
ETraceF--+   |   |           |                   |   |   |   |   |
ESupervisorF-+   |           |                   |   |   |   |   |
EMasterF---------+           |                   |   |   |   |   |
EInterruptmaskeF-------------+                   |   |   |   |   |
                                               |   |   |   |   |
                                               |   |   |   |   |
EExtensionF--------------------------------------+   |   |   |   |
ENegativF--------------------------------------------+   |   |   |
ENullF---------------------------------------------------+   |   |
EšberlaufF---------------------------------------------------+   |
ECarryF----------------------------------------------------------+

*T* und *M* erst ab MC68020 verfgbar.

Die Zugriffsrechte unterscheiden sich je nach Betriebszustand und Typ 
der CPU:

               | EMC68000F/8               | EMC68010F und h”her
---------------+-------------------------+-------------------------
EUSERFmode       | lesen SR, schreiben CCR | lesen/schreiben CCR
---------------+-------------------------+-------------------------
ESUPERFvisormode | voller Zugriff          | voller Zugriff
---------------+-------------------------+-------------------------CCR - Condition Code Register
----------------------------------------------------------------------

Das CCR enth„lt die Condition Codes. Es ist derjenige Teil des
EStatusregistersF, der die Bedingungen (gesetzte oder nicht gesetzte
Flags) beinhaltet, welche die EProgrammstruktur-BefehleF vor einer
Verzweigung abfragen.

Mnemonic: | Bedeutung:       | Flags wie abgefragt:
----------+------------------+----------------------
T         | True             | 1
F         | False            | 0
HI        | Higher           | ~C ^ ~Z = 1
LS        | Lower Same       | C v Z = 1
CC(HS)    | Carry Clear      | C = 0
CS(LO)    | Carry Set        | C = 1
NE        | Not Equal        | Z = 0
EQ        | Equal            | Z = 1
PL        | Plus             | N = 0
MI        | Minus            | N = 1
          |                  |
VC        | Overflow Clear   | V = 0
VS        | Overflow Set     | V = 1
GE        | Greater or Equal | N ^ V v ~N ^ ~V = 1
LT        | Less Than        | N ^ ~V v ~N ^ V = 1
GT        | Greater Than     | N ^ V ^ ~Z v ~N ^ ~V ^ ~Z
LE        | Less or Equal    | Z v N ^ ~V v ~N ^ VInterruptmaske
----------------------------------------------------------------------

Die CPU kennt insgesamt 8 verschiedene Interuptpriorit„ten. Priorit„t
0 bedeutet kein Interrupt.  Priorit„t 7 ist ein NMI (Non Maskable In-
terrupt).  Wird von der externen Hardware ein  Interrupt angefordert,
wird von der CPU geprft, ob es sich um einen NMI oder um eine Inter-
ruptpriorit„t, die gr”er dem Wert in der  Interruptmaske des Status-
registers ESRF handelt.  Ist dies nicht der Fall, so wird der Interrupt
ignoriert.

Ist der Interrupt nun gltig,  wird der  Interrupt von der CPU best„-
tigt.  Nun mu nun die externe Hardware mitteilen,  um welchen Inter-
rupt es sich  handelt.  Dabei wird zwichen EAutovektor-InterruptFs  und
ENon-Autovektor-InterruptFs unterschieden.TRACE - Die Tracebits des Statusregisters
----------------------------------------------------------------------

Die Tracebits im EStatusregisterF zeigen an, ob sich die CPU im Tracemode
befindet oder nicht.  Ist der Tracemode eingeschaltet,  wird nach jedem
Befehl oder wechsel des  Programmflues eine EExceptionF mit der Nummer 9
ausgel”t.

Die m”glichen Bitkombinationen und ihre Bedeutung


     T0 | T1 | Tracemode
    ----+----+--------------------------------------------
      0 |  0 | Trace ist ausgeschaltet
      1 |  0 | Trace bei jedem Befehl
      0 |  1 | Trace bei jedem Wechsel des Programmflues 
      1 |  1 | reserviertDie m”glichen Ver„nderungen des ECCRF im EStatusregisterF nach einer 
Operation:

"E": Dieses Flag wird Je nach Ergebnis der Operation ver„ndert
"-": Dieses Flag wird nicht ver„ndert
"?": Dieses Flag ist nach der Operation undefiniert
"0": Dieses Flag wird nach der Operation gel”scht
"1": Dieses Flag wird nach der Operation gesetztExtend-Flag
----------------------------------------------------------------------

Das Extend-Flag des Statusregisters ( ESRF ) wird i.d.R. genauso ge-
setzt, wie das ECarryFflag. Jedoch wird es bei manchen Befehlen nicht 
ver„ndert.

Querverweis: EM”gliche Ver„nderungenFNegativflag
----------------------------------------------------------------------

Das Negativflag des Statusregisters ( ESRF ) wird, wenn nichts anderes an-
gegeben ist, gesetzt, wenn das Ergebnis einer Operation Negativ ist.

Querverweis: EM”gliche Ver„nderungenFNullflag
----------------------------------------------------------------------

Das Nullflag des Statusregisters ( ESRF ) wird, wenn nichts anderes an-
gegeben ist, gesetzt, wenn das Ergebnis einer Operation 0 ist.

Querverweis: EM”gliche Ver„nderungenFšberlaufflag
----------------------------------------------------------------------

Das šberlaufflag des Statusregisters ( ESRF ) wird, wenn nichts anderes 
angegeben ist, gesetzt,  wenn das Ergebnis einer Operation nicht mehr
in den gleichen  Zahlenbereich pat. D.H.  wenn z.B. die Summe zweier
positive Zahlen  eine negative Zahl ergibt.  Es wird also fr vorzei-
chenbehaftete Arithmetik ben”tigt.

Querverweis: EM”gliche Ver„nderungenFCarryflag
----------------------------------------------------------------------

Das Carryflag des Statusregisters ( ESRF ) wird, wenn nichts anderes an-
gegeben ist,  gesetzt, wenn das Ergebnis einer  Operation nicht in den
gleichen Datentyp pat. D.H. wenn z.B. die Summe zweier Worte nicht in
ein Wort pat, also ein "Borgen" stattfand.

Querverweis: EM”gliche Ver„nderungenFUSP - User Stack Pointer
----------------------------------------------------------------------

Der USP ist der aktive Stackpointer ( EA7F ), wenn das S-Flag des,
Statusregisters ( ESRF )  gel”scht ist.  Der explizite Zugriff auf
das USP ist nur im Supervisormode erlaubt, da im Usermode die Regis-
terbezeichnungen A7 bzw. SP verwendet wird.SSP - Supervisor Stackpointer
----------------------------------------------------------------------

Der SSP ist der aktive Stackpointer ( EA7F ), wenn das S-Flag des,
Statusregisters ( ESRF ) gesetzt ist.  Die Prozessoren ab MC68020
unterscheiden dabei zwischen dem EmspF und dem EispFPC - Program Counter
----------------------------------------------------------------------

Der Program Counter ist  32 Bit  breit und zeigt auf den  n„chsten
auszufhrenden Befehl.

Beim MC68000/10 sind jedoch nur 24 Bit auf den Addressbus gefhrt.
Es  steht also ein  16 Megabyte groer  Addressraum zur Verfgung.
Beim MC68008 sind es 20 Bit also ein  1 Megabyte Addressraum. Beim
MC68012 sind es 21 Bit also ein 2 Gigabyte groer Addressraum. Fr
die Prozessoren MC68020/30/40 gelten die Werte 32 Bit bzw. 4 Giga-
byte Addressraum.

Der PC darf nie auf eine ungerade Adresse zeigen.Die Kontrollregister
----------------------------------------------------------------------

EuspF     USP     User Stack Pointer
EvbrF     VBR     Vector Base Register;              ( MC68010 )
EdfcF     DFC     Destination Function Code Register ( MC68010 )
EsfcF     SFC     Source Function Code Register      ( MC68010 )
EcacrF    CACR    Cache Control Register             ( MC68020 )
EcaarF    CAAR    Cache Address Register             ( MC68020 )
EispF     ISP     Interrupt Stack Pointer            ( MC68020 )
EmspF     MSP     Master Stack Pointer               ( MC68020 )

Querverweis: EMOVECF, ERegister-SpezifikationenFVBR - Vector Base Register                                     MC68010
----------------------------------------------------------------------

Das VBR enth„lt die  Startaddresse der EExceptiontabelleF.  Damit kann
man in einem Multitaskingsystem fr jeden Proze eine eigene Tabelle 
anlegen.SFC - Source Function Code Register                            MC68010
----------------------------------------------------------------------

Enth„lt den EFunction CodeF fr den EMOVESF-befehl bei lesendem 
Zugriff auf den Arbeitsspeicher.DFC - Destination Function Code Register                       MC68010
----------------------------------------------------------------------

Enth„lt den EFunction CodeF fr den EMOVESF-befehl bei schreibendem 
Zugriff auf den Arbeitsspeicher.Function Code
----------------------------------------------------------------------

Mit den 3 EFunction CodeF Leitungen der CPU teilt diese dem Haupt-
speicher mit ber welchen Address Space die CPU auf den Speicher
zugreifen will. Normalerweise werden diese Leitungen automatisch
gesetzt, ab der MC68010 CPU  kann diese aber auch fr den EMOVESF-
Befehl  eingesellt  werden.  Hierzu  verfgt  die CPU  ber  ein
ESource Function CodeF und ein EDestination Function CodeF Register.

Der Function Code kann  aber auch zur  EAdrebersetzungF verwen-
det werden.

Folgende Function Codes sind definiert:

               FC | Address Space
           -------+-------------------------
                0 | reserviert
                1 | EUser Data SpaceF
                2 | EUser Program SpaceF
                3 | unbenutzt
                4 | reserviert
                5 | ESupervisor Data SpaceF
                6 | ESupervisor Program SpaceF
                7 | ECPU SpaceF

Die PMMU EMC68881F verfgt ber eine vierte Function Code Leitung.
Damit wird der PMMU mitgeteilt, da ein anderer Baustein als die
CPU den  Bus kontroliert ( z.B. ein  DMA-Controller ).  Ist dies
der Fall, wird als ERoot PointerF das EDRPF verwendet.Function Code Spezifikation
----------------------------------------------------------------------

Die EPMMU-BefehleF, welche den EFunction CodeF als Parameter erwarten,
k”nnen diesen auf folgende Arten erhalten:

1. Immediate - Der Function Code ist im PMMU-Befehl spezifiziert
2. EDnF        - Datenregister
3. ESFCF       - Source Function Code Register
4. EDFCF       - Destination Function Code Register

Beim EMC68030F bzw. EMC68040F  sind dies maximal  3 Bits fr den Func-
tion Code,  beim EMC68851F sind dies maximal 4 Bits,  wenn der Func-
tion Code nicht ber einer der beiden Function Code Register ber-
geben wird.

Querverweis: EPFLUSHF, EPLOADF, EPTESTFUser Data Space
----------------------------------------------------------------------

Dieser EFunction CodeF zeigt an, da die CPU Userdaten ( sie befindet
sich also im Usermode ) schreibt oder liest.User Program Space
----------------------------------------------------------------------

Dieser EFunction CodeF zeigt an, da die CPU Userbefehle ( sie befindet
sich also im Usermode ) liest.Supervisor Data Space
----------------------------------------------------------------------

Dieser EFunction CodeF zeigt an, da die CPU Supervisordaten ( sie 
befindet sich also im Supervisormode ) schreibt oder liest.Supervisor Program Space
----------------------------------------------------------------------

Dieser EFunction CodeF zeigt an, da die CPU Supervisorbefehle ( sie
befindet sich also im Supervisormode ) liest.CPU Space
----------------------------------------------------------------------

Dieser EFunction CodeF zeigt an,  da die CPU von sich aus auf den Haupt-
speicher zugreift ( um z.B. die  Nummer eines ENon-Autovektor-InterruptFs
zu holen ).CAAR - Cache Address Register                                  MC68020
----------------------------------------------------------------------

Das CAAR ist 32 Bit breit und enth„lt in den Bits 2 bis 7 den Index fr 
die  "Clear Cache Entry"  Funktion(en)  des ECACRF. Alle anderen Bit sind
fr zuknftige Versionen reserviert und sollten nicht ver„ndert werden.CACR - Cache Control Register                                  MC68020
----------------------------------------------------------------------

Das CACR ist 32 Bit breit und hat folgenden Aufbau:

 31  14  13   12    11   10    9    8   7    5  4     3    2    1     0
+------+----+-----+----+-----+----+----+------+-----+----+-----+----+----+ 
|unused|*WA*|*DBE*|*CD*|*CED*|*FD*|*ED*|unused|*IBE*| CI | CEI | FI | EI |
+------+----+-----+----+-----+----+----+------+-----+----+-----+----+----+
         |    |     |    |     |    |           |     |    |     |    |
EWriteF    |    |     |    |     |    |           |     |    |     |    |
EAllocateF-+    |     |    |     |    |           |     |    |     |    | 
EData Burst EnableF   |    |     |    |           |     |    |     |    |
EClear Data CacheF----+    |     |    |           |     |    |     |    |
EClear Entry in Data CacheF+     |    |           |     |    |     |    |
EFreeze Data CacheF--------------+    |           |     |    |     |    |
EEnable Data CacheF-------------------+           |     |    |     |    |
EInstruction Burst EnableF------------------------+     |    |     |    |
EClear Instruction CacheF-------------------------------+    |     |    |
EClear Entry in Instruction CacheF---------------------------+     |    |
EFreeze Instruction CacheF-----------------------------------------+    |
EEnable Instruction CacheF----------------------------------------------+

Die mit * gekennzeichneten Bits sind erst ab MC68030 verfgbar.Write Allocate Flag
----------------------------------------------------------------------

Das Write Allocate Flag des Cache Control Registers ( ECACRF ) gibt an,
ob das  Datencache auch bei Schreibzugriffen aktualisert  werden soll
oder nicht. Ist das Flag gel”scht wird das Datencache nur dann aktua-
lisert,  wenn ein Lesezugriff oder ein  Schreibzugriff auf eine Spei-
cherstelle, die sich im Cache befindet stattfindet.

Wenn es gesetzt ist, wird das Cache bei jedem Zugriff aktualisert. Es
sollte immer  dann gesetzt  werden,  wenn  unterschiedliche  logische
Adressen mit  der PMMU auf  gleiche physikalische Adressen  bersetzt 
werden.

Diese  Flag wird ignoriert,  wenn das  Datencache ausgeschaltet  oder
eingefroren ist.Data Burst Enable Flag
----------------------------------------------------------------------

Ist das  Data Burst Enable Flag des  Cache Control Registers ( ECACRF )
gesetzt wird eine Zeile (16 Bytes) des Datencache auf einmal eingele-
sen.  Dies ist jedoch  nur dann  sinnvoll,  wenn der  Arbeitsspeicher
schnell genug ist.Clear Data Cache Bit
----------------------------------------------------------------------

Wird das  Clear Data Cache  Bit des  Cache Control Registers ( ECACRF ) 
gesetzt,  so wird das komplette Datencache gel”scht.  Dieses Bit wird
immer als 0 gelesen.Clear Entry in Data Cache Bit
----------------------------------------------------------------------

Wird das  Clear Entry in Data Cache  Bit des  Cache Control Registers
( ECACRF ) gesetzt,  so wird ein Eintrag,  der durch das  Cache Address 
Register ( ECAARF ) spezifiziert wird, gel”scht.  Dieses Bit wird immer
als 0 gelesen.Freeze Data Cache Flag
----------------------------------------------------------------------

Wird das Freeze Data Cache Flag  des Cache Control Registers ( ECACRF )
gesetzt,  wird das Datencache eingefroren.  Dies bedeutet,  da keine
neuen Eintr„ge im Cache angelegt werden. Schreibzugriffe aktuallisie-
ren aber den Inhalt der Eintr„ge weiterhin.Enable Data Cache Flag
----------------------------------------------------------------------

Wird das Enable Data Cache Flag  des Cache Control Registers ( ECACRF )
gesetzt,  wird das Datencache eingeschaltet.  Ist es gel”scht, erfol-
gen Zugriffe auf Daten immer ber das externe RAM.Instruction Burst Enable Flag
----------------------------------------------------------------------

Ist das  Instruction Burst Enable  Flag des  Cache Control Registers
( ECACRF )  gesetzt wird  eine Zeile  (16 Bytes) des  Befehlscache auf
einmal  eingelesen.  Dies ist  jedoch  nur dann  sinnvoll,  wenn der
Arbeitsspeicher schnell genug ist.Clear Instruction Cache Bit
----------------------------------------------------------------------

Wird das  Clear Instruction Cache  Bit des  Cache Control  Registers
( ECACRF ) gesetzt,  so wird das komplette Befehlscache gel”scht. Die-
ses Bit wird immer als 0 gelesen.Clear Entry in Instruction Cache Bit
----------------------------------------------------------------------

Wird das Clear Entry in Instruction Cache  Bit des Cache Control Re-
gisters ( ECACRF ) gesetzt,  so wird ein Eintrag, der durch das  Cache
Address Register ( ECAARF )  spezifiziert wird,  gel”scht.  Dieses Bit
wird immer als 0 gelesen.Freeze Instruction Cache Flag
----------------------------------------------------------------------

Wird das  Freeze Instruction Cache Flag  des Cache Control  Registers 
( ECACRF ) gesetzt,  wird das Befehlscache eingefroren.  Dies bedeutet,
da keine neuen Eintr„ge im Cache angelegt werden.Enable Instruction Cache Flag
----------------------------------------------------------------------

Wird das Enable Instruction Cache Flag   des Cache Control Registers
( ECACRF ) gesetzt,  wird das  Befehlscache eingeschaltet.  Ist es ge-
l”scht, werden Befehle immer ber das externe RAM geholt.ISP - Interrupt Stack Pointer                                  MC68020
----------------------------------------------------------------------

Der ISP ist der aktive Stackpointer ( EA7F ), wenn das S-Flag gesetzt
und das M-Flag des Statusregisters ( ESRF ) gel”scht ist.  Das M-Flag
wird automatisch beim  Auftreten eines externen  Interupts gel”scht
und  nach Abarbeitung  der Interupt Service Routine  wieder restau-
riert.

Querveweis: EmspF, EsspFMSP - Master Stack Pointer                                     MC68020
----------------------------------------------------------------------

Der MSP ist der aktive Stackpointer ( EA7F ), wenn sowohl das S-Flag,
als auch das M-Flag des Statusregisters ( ESRF ) gesetzt ist.

Querverweis:  EispF, EsspFZPC - Zero Program Counter                  EMC68020F Adressierungsmodus
----------------------------------------------------------------------

siehe auch: EFFPn - Fliekomma-Datenregister                                 MC68881
----------------------------------------------------------------------

Die Datenregister der FPU k”nnen durch die Bezeichnungen fp0 - fp7,
bzw. FP0 - FP7 spezifiziert werden. 

Jedes Fliekomma-Datenregister ist 80 Bit breit.  Die Daten werden 
prinzipiel Extended gespeichert.  Berechnungen erfolegen ebenfalls
immer Extended.  Nur wenn Daten in den  Speicher bertragen werden
(EFMOVEF) erfolgt eine Umwandlung nach BYTE, WORD, LONGWORD, SINGLE,
oder DOUBLE.

Querverweis: ERegister-SpezifikationenFNeben den 8 Datenregister EFPnF enth„lt die  FPU
noch einige zus„tzliche Register:

EfpcrF    FPCR    Fliekomma-Kontrollregister
EfpsrF    FPSR    Fliekomma-Statusregister
EfpiarF   FPIAR   Fliekomma-Befehlsadreregister
 
Querverweis: EFMOVE FPcrF, EFMOVEM FPcrF, ERegister-SpezifikationenFFPCR Fliekomma-Kontrollregister                               MC68881
----------------------------------------------------------------------

Das Fliekomma-Kontrollregister ist 32 Bit breit und hat folgenden
Aufbau:

                                EException EnableF  EMode ControlF
                                       |               |
                                 <-------------> <------------->
+-------------------------------+---------------+---------------+
|   Unbenutzt (immer 0)         |x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|
+-------------------------------+---------------+---------------+
 |                               |               |             |
 31                              15              7             0

Das unbenutzte Wort dieses  Registers wird immer als 0 gelesen und
man sollte auch immer eine 0 reinschreiben, um fr zuknftige Ver-
sionen sicher kompatibel zu sein.Exception Enable
----------------------------------------------------------------------

Mit  dem  Exception Enable  Byte des  EFliekomma-KontrollregisterFs
k”nnen Sie jeden der 8 m”glichen Fliekomma-EExceptionFs einzeln ein
(1) bzw. ausschalten (0).

Der Aufbau dieses Bytes ist folgender:

         15     14     13      12     11     10   9       8
        +------+------+-------+------+------+----+-------+-------+
        | BSUN | SNAN | OPERR | OVFL | UNFL | DZ | INEX2 | INEX1 |
        +------+------+-------+------+------+----+-------+-------+
          |      |      |       |      |      |    |       |
EBranchF----+      |      |       |      |      |    |       |
ESet OnF           |      |       |      |      |    |       |
EUnorderedF        |      |       |      |      |    |       |
ESignaling NaNF ---+      |       |      |      |    |       |
(Not a Number)          |       |      |      |    |       |
EOperand ErrorF-----------+       |      |      |    |       |
EFPU overflowF--------------------+      |      |    |       |
EFPU underflowF--------------------------+      |    |       |
EDivide by ZeroF--------------------------------+    |       |
EInexact ResultF-------------------------------------+       |
EInexact Decimal InputF--------------------------------------+Mode Control
----------------------------------------------------------------------

Mit dem Mode Control Byte des EFliekomma-KontrollregisterFs k”nnen 
Sie festlegen, wie die FPU das Ergebnis einer Fliekommaoperation
runden soll.

Der Aufbau dieses Bytes ist folgender:

                7    6 5     4 3         0
               +------+-------+-----------+
               | PREC |  RND  | unbenutzt |
               +------+-------+-----------+
                |      |
Rounding Precision    Rounding Mode
 00 Extended           00 To Nearest
 01 Single             01 Toward Zero
 10 Double             10 Toward -ß
 11 Reserved           11 Toward +ßFPSR - Fliekomma-Statusregister                               MC68881
----------------------------------------------------------------------

Das Fliekomma-Statusregister ist 32 Bit breit und hat folgenden
Aufbau:

 ECondition CodeF     EQuotientF    EException StatusF EAccrued ExceptionF
        |               |               |               |
 <-------------> <-------------> <-------------> <------------->
+---------------+---------------+---------------+---------------+
|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|
+---------------+---------------+---------------+---------------+
 |               |               |               |             |
 31              23              15              7             0Condition Code                                                 MC68881
----------------------------------------------------------------------

Das Condition Code Byte des EFliekomma-StatusregisterFs ent-
h„lt Flags,  welche bestimmte  Zust„nde des Ergebnis  einer
Fliekommaoperation anzeigt. Es entspricht dem ECCRF der CPU.
Diese  Flags werden fr die  EBedingungenF der bedingten  Be-
fehle abgefragt.

Es hat folgenden Aufbau:

               31       28  27  26  25    24
              +-----------+---+---+---+-----+
              | unbenutzt | N | Z | I | NaN |
              +-----------+---+---+---+-----+
                           |   |   |   |
Negative-------------------+   |   |   |
Zero---------------------------+   |   |
ß (Inf)----------------------------+   |
Not a Number---------------------------+
or Unordered

NaN heit,  da das Ergebnis einer Fliekommaoperation undefiniert
ist. Unordered heit, da das Argument einer Funktion oder 1 Oper-
ator einer Operation NaN war.IEEE Non-Aware Tests:
----------------------------------------------------------------------

Alle folgenden Tests (bis auf EQ und NE) l”sen eine EBSUNF Ex-
ception aus, wenn das NaN Bit im ECondition CodeF Byte gesetzt
ist. 

Mnemonic: | Bedeutung:                    | Flags wie abgefragt:
----------+-------------------------------+-----------------------
EQ        | Equal                         | Z
NE        | Not Equal                     | ~Z
GT        | Greater Than                  | ~( NaN v Z v N )
NGT       | Not Greater Than              | NaN v Z v N
GE        | Greater or Equal              | Z v ~( NaN v N )
NGE       | Not( Greater or Equal )       | NaN v ( N ^ ~Z )
LT        | Less Than                     | N ^ ~( NaN v Z )
NLT       | Not Less Than                 | NaN v ( Z v ~N )
LE        | Less or Equal                 | Z v ( N ^ NaN )
NLE       | Not( Less or Equal )          | NaN v ~( N v Z )
GL        | Greater or Less               | ~( Nan v Z )
NGL       | Not ( Greater or Less )       | NaN v Z
GLE       | Greater, Less or Equal        | ~NaN
NGLE      | Not( Greater, Less or Equal ) | NaN


IEEE Aware Tests:
----------------------------------------------------------------------

Alle folgenden Tests setzen das BSUN-Bit unter gar keinen Umst„nden.

Mnemonic: | Bedeutung:                    | Flags wie abgefragt:
----------+-------------------------------+-----------------------
EQ        | Equal                         | Z
NE        | Not Equal                     | ~Z
OGT       | Ordered Greater Than          | ~( NaN v Z v N )
ULE       | Unordered or Less or Equal    | NaN v Z v N
OGE       | Ordered Greater or Equal      | Z v ~( NaN v N )
ULT       | Unordered or Less Than        | NaN v ( N ^ ~Z )
OLT       | Ordered Less Than             | N ^ ~( NaN v Z )
UGE       | Unordered or Gretaer or Equal | NaN v Z v N
OLE       | Ordered Less or Equal         | Z v ( N ^ ~NAN )
UGT       | Unordered or Greater Than     | NaN v ~( N v Z )
OGL       | Ordered Greater or Less       | ~( NaN v Z )
UEQ       | Unordered or Equal            | NaN v Z
OR        | Ordered                       | ~NaN
UN        | Unordered                     | NaN


Miscellaneous Tests:
----------------------------------------------------------------------

SF, ST, SEQ und SNE l”sen eine EBSUNF Exception aus, wenn  das 
NaN Bit im ECondition CodeF Byte gesetzt ist. 

Mnemonic: | Bedeutung:                    | Flags wie abgefragt:
----------+-------------------------------+-----------------------
F         | False                         | 0
T         | True                          | 1
SF        | Signaling False               | 0
ST        | Signaling True                | 1
SEQ       | Signaling Equal               | Z
SNE       | Signaling Not Equal           | ~ZQuotient Byte
----------------------------------------------------------------------

Das Quotient Byte des  EFliekomma-StatusregisterFs wird nach ei-
ner Modulo-operation ( EFMODF oder EFREMF ) gesetzt und enth„lt den
Quotienten der dabei berechneten Division.

Es hat folgenden Aufbau:

                 23  22            16
                +---+----------------+
                | S |    Quotient    |
                +---+----------------+
                 |       |
Vorzeichen-------+       |
7 wenigst signifikante---+
BitsException Status
----------------------------------------------------------------------

Mit dem  Exception Status  Byte des EFliekomma-StatusregisterFs
wird angezeigt welche Ausnahmebedingung bei der letzten Flie-
kommaoperation auftrat.  Die einzelnen  Bits werden  auch dann
gesetzt, wenn das entsprechende Bit des EException EnableF Bytes
im EFliekomma-KontrollregisterF gesetzt ist.

Der Aufbau dieses Bytes ist folgender:

         15     14     13      12     11     10   9       8
        +------+------+-------+------+------+----+-------+-------+
        | BSUN | SNAN | OPERR | OVFL | UNFL | DZ | INEX2 | INEX1 |
        +------+------+-------+------+------+----+-------+-------+
          |      |      |       |      |      |    |       |
EBranchF----+      |      |       |      |      |    |       |
ESet OnF           |      |       |      |      |    |       |
EUnorderedF        |      |       |      |      |    |       |
ESignaling NaNF ---+      |       |      |      |    |       |
(Not a Number)          |       |      |      |    |       |
EOperand ErrorF-----------+       |      |      |    |       |
EFPU overflowF--------------------+      |      |    |       |
EFPU underflowF--------------------------+      |    |       |
EDivide by ZeroF--------------------------------+    |       |
EInexact ResultF-------------------------------------+       |
EInexact Decimal InputF--------------------------------------+Accrued Exception
----------------------------------------------------------------------

Mit dem Accrued Exception  Byte des EFliekomma-StatusregisterFs
wird angezeigt welche Ausnahmebedingung seit dem letzten Reset
bzw. seit dem letzten l”schen dieses Bytes.

Der Aufbau dieses Bytes ist folgender:

             7     6     5      4    3      2         0
            +-----+-----+------+----+------+-----------+
            | IOP | OVL | UNFL | DZ | INEX | unbenutzt |    
            +-----+-----+------+----+------+-----------+
              |     |     |      |    |
EInvalid OperationF   |     |      |    |
EFPU overflowF--------+     |      |    |
EFPU underflowF-------------+      |    |
EDivide by ZeroF-------------------+    |
EInexact OperationF---------------------+

INEX wird auch bei einem  EFPU overflowF gesetzt.  UNFL wird nur
dann gesetzt, wenn EFPU underflowF und EInexact ResultF gleichzei-
tig auftraten.Invalid Operation
----------------------------------------------------------------------

Das IOP-Flag des EAccrued ExceptionF Bytes im Fliekomma-Status-
register ( EFPSRF )  wird dann gesetzt,  wenn eine Branch/Set on
Unordered-Bedingung ( EBSUNF ), ein ungltiges Ergebnis oder ein
EOperandenfehlerF auftrat.FPIAR - Fliekomma-Befehlsadreregister                        MC68881
----------------------------------------------------------------------

Das   Fliekomma-Befehlsadreregister   ist  sozusagen der EPCF
(Programm Counter) der FPU. Der  Grund fr  das Vorhandensein 
dieses Registers ist, da die FPU  unabg„ngig von der CPU die
Befehle  ausfhren kann.  Tritt  nun eine  Exception auf,  so 
k”nnte man ohne dieses Register nicht feststellen, an welcher
Stelle der aktuelle Befehl der FPU steht.Die Kontrolregister der PMMU
----------------------------------------------------------------------

EcrpF     CRP     CPU Root Pointer          ( MC68851, MC68030 )
EsrpF     SRP     Supervisor Root Pointer   ( MC68851, MC68030 )
EdrpF     DRP     DMA Root Pointer                   ( MC68851 )
-----------------------------------------------------------------
EtcF      TC      Translation Control Reg.  ( MC68851, MC68030 )
EpsrF     PSR     PMMU Statusregister       ( MC68851, MC68030 )
EpcsrF    PCSR    PMMU Cache Statusregister          ( MC68851 )
-----------------------------------------------------------------
EcalF     CAL     Current Access Level Register      ( MC68851 )
EvalF     VAL     Validate Access Level Register     ( MC68851 )
EacF      AC      Access Control Register            ( MC68851 )
-----------------------------------------------------------------
Ett0F     TT0     Transparent Translation Register 0 ( MC68030 )
Ett1F     TT1     Transparent Translation Register 1 ( MC68030 )
-----------------------------------------------------------------
Ebad0F    BAD0
Ebad1F    BAD1
Ebad2F    BAD2
Ebad3F    BAD3    Breakpoint Acknowledge Datenregister
Ebad4F    BAD4    ( MC68851 )
Ebad5F    BAD5
Ebad6F    BAD6
Ebad7F    BAD7
-----------------------------------------------------------------
Ebac0F    BAC0
Ebac1F    BAC1
Ebac2F    BAC2
Ebac3F    BAC3    Breakpoint Acknowledge Control Register
Ebac4F    BAC4    ( MC68851 )
Ebac5F    BAC5
Ebac6F    BAC6
Ebac7F    BAC7
-----------------------------------------------------------------

Querverweis: EPMOVEF, ERegister-SpezifikationenFCRP - CPU Root Pointer                                MC68851, MC68030
----------------------------------------------------------------------

Der CPU ERoot PointerF wird zur EAdrebersetzungF verwendet, falls die 
CPU sich im Usermode  befindet oder der ESupervisor Root PointerF aus-
geschaltet ist.SRP - Supervisor Root Pointer                         MC68851, MC68030
----------------------------------------------------------------------

Der  Supervisor ERoot PointerF wird zur  EAdrebersetzungF  verwendet,
falls die CPU sich im Supervisormode befindet und das Register nicht mit
dem SRE Flag des  Translation Control Registers ( ETCF ) ausgeschaltet
ist.DRP - DMA Root Pointer                                     Nur MC68851
----------------------------------------------------------------------

Der DMA ERoot PointerF wird zur EAdrebersetzungF verwendet, falls der
Bus gerade von einem anderen Baustein ( DMA ) gesetuert wird.Root Pointer
----------------------------------------------------------------------

Die Root Pointer der PMMU ( ECRPF, ESRPF und EDRPF ) haben folgenden Aufbau:

 63  62     48 47        42  41  40        34 33  32 31         4 3      0
+---+---------+------------+----+------------+------+------------+--------+
|L/U|  Limit  | reserviert |*SG*| reserviert |  DT  |     TA     | unused |
+---+---------+------------+----+------------+------+------------+--------+
   |         |                |                  |         |
ELimitflagF    |                |                  |         |
ELimitfieldF---+                |                  |         |
EShared GlobalyF----------------+                  |         |
EDescriptor TypeF----------------------------------+         |
ETable AddressF----------------------------------------------+

SG ist nur im MC68851 implementiert.Descriptor
----------------------------------------------------------------------

Descriptoren einer šbersetzungstabelle haben immer die gleiche Gr”e
von 4 oder 8 Byte.  Wie Gro nun die Eintr„ge einer  šbersetzungsta-
belle sind, wird vom EDescriptor TypeF der vorherigen Knotens des šber-
setzungsbaums festgelegt.

Querverweis: EAdrebersetzungFLimitflag
----------------------------------------------------------------------

Das Limitflag der EDescriptorFen zeigt an, ob das ELimitfieldF der Descrip-
toren eine obere ( gel”scht ) oder untere ( gesetzt ) Grenze darstellt.Limitfield
----------------------------------------------------------------------

Das  Limitfield  der  EDescriptorFen  enth„lt die  obere (  ELimitflagF ge-
l”scht ) bzw.  untere Grenze  der n„chsten  Descriptortabelle,  auf die
ETable AddressF zeigt.Descriptor Type
----------------------------------------------------------------------

Das Descriptor Type Field enth„lt die Art des aktuellen EDescriptorF oder
die  Gr”e der  Eintr„ge der  n„chsten Tabelle,  auf die  ETable AddressF
zeigt.

Die m”glichen Werte sind:
$0 INVALID
   Der aktuelle Descriptor ist ungltig. Erh„lt einer der ERoot PointerF
   diesen Wert, so wird ein EPMMU-FehlerF ausgel”st. Findet die PMMU bei
   der   EAdrebersetzungF  einen  solchen  Descriptor,  so  wird  ein 
   EBusfehlerF ausgel”st. Ein Betriebssytem kann dies dazu ausnutzen, um
   nicht den kompletten šbersetzungsbaum im Speicher halten zu mssen.
$1 PAGE DESCRIPTOR
   Der aktuelle Descriptor ist ein Page Descriptor. ETable AddressF ent-
   h„lt die fr die EAdrebersetzungF notwendige  Physikalische Adres-
   se.
$2 VALID 4-Byte
   Die  Eintr„ge in der  Tabelle, auf die  ETable AddressF zeigt,  haben
   eine Gr”e von 4 Byte.
$3 VALID 8-Byte
   Die  Eintr„ge in der  Tabelle, auf die  ETable AddressF zeigt,  haben
   eine Gr”e von 8 Byte.Table Address
----------------------------------------------------------------------

Das  Table Address Field  der EDescriptorenF  enth„lt die  Physikalische 
Adresse der n„chsten šbersetzungstabelle.  Ist der aktuelle Descriptor
ein EPage DescriptorF, so enth„lt dieses Feld eine Physikalische Adresse
fr die EAdrebersetzungF.TC - Translation Control Register                     MC68851, MC68030
----------------------------------------------------------------------

Das Register ist 32 Bit breit und hat folgenden Aufbau:

     31    30    26  25   24    23 20 19 16 15 12 11  8 7   4 3   0
    +-----+--------+-----+-----+-----+-----+-----+-----+-----+-----+
    |  E  | unused | SRE | FCL |  PS |  IS | TIA | TIB | TIC | TID |
    +-----+--------+-----+-----+-----+-----+-----+-----+-----+-----+
       |             |     |      |     |    |     |     |     |
EPMMU-EnableF          |     |      |     |    |     |     |     |
ESRP EnableF-----------+     |      |     |    |     |     |     | 
EFunction Code Lookup EnableF+      |     |    |     |     |     |
EPage SizeF-------------------------+     |    |     |     |     |
EInitial ShiftF---------------------------+    |     |     |     |
A, B, C, D ETable IndicesF---------------------+-----+-----+-----+PMMU-Enable 
----------------------------------------------------------------------

Das PMMU-Enable Bit des ETranslation ControlF Registers schaltet die 
EPMMUF ein ( Bit gesetzt ) bzw. aus.Supervisior Root Pointer Enable
----------------------------------------------------------------------

Das Supervisior Root Pointer Enable Bit des ETranslation ControlF
Registers schaltet den ESRPF ein ( Bit gesetzt ) bzw. aus.Function Code Lookup Enable
----------------------------------------------------------------------

Das Function Code Lookup Enable Bit des ETranslation ControlF Registers
gibt an,  ob die erste  Schachtelungstiefe,  des EšbersetzungsbaumF fr
die EAdrebersetzungF mit dem EFunction CodeF der logischen Adresse ge-
bildet  wird ( FCL gesetzt ).  Ist dies der Fall wird das  ELimitfieldF
des ERoot PointerFs ignoriert.Page Size
----------------------------------------------------------------------

Das Page Size Field des Translation Control Registers gibt codiert
die Gr”e einer Speicherseite an. Fr jede Speicherseite existiert
ein Page Descriptor im šbersetzungsbaum.

Folgende Werte fr Page Size sind m”glich:

      PS | Gr”e einer Seite
     ----+-------------------
       8 | 256 Bytes
       9 | 512   "
      10 |  1K   "
      11 |  2K   "
      12 |  4K   "
      13 |  8K   "
      14 | 16K   "
      15 | 32L   "

Alle  anderen  Werte  l”sen  einen  EPMMU-FehlerF  aus.  Siehe  auch
EInitial ShiftF, ETable IndicesF.Initial Shift
----------------------------------------------------------------------

Das Initial Shift Field des ETranslation ControlF Register gibt an,
wieviele Bits einer logischen Adresse, bei der EAdrebersetzungF
erst einmal ignoriert werden sollen.

Es ist zu beachten,  da die Summe aus EPage SizeF,  Initial Shift
und  ETable IndicesF 32 sein mu.  Ansonsten wird ein  EPMMU-FehlerF
ausgel”st.Table Indices TIx
----------------------------------------------------------------------

Die Table Indices TIA, TIB, TIC, TID des ETranslation ControlF Registers
geben an welche  Bits der  logischen Adresse fr welche Schachtelungs-
tiefe im EšbersetzungsbaumF  als Index  fr die  entsprechende  šberset-
zungstabelle verwendet werden soll.

Dabei sind folgende Regeln zu beachten:
- TIx wird ignoriert, wenn einer oder mehrere der vorherigen Table In-
  dices den Wert 0 enth„lt.
- TIA darf nicht den Wert 0 enthalten.
- TIA mu mindestens 2 sein, wenn TIB den Wert 0 hat.
- Die  Summe aus Initial Shift,  Page Size und den gltigen  Table In-
  dices mu 32 sein.
Wird eine der drei vorherigen Regeln verletzt, so wird ein EPMMU-FehlerF
ausgel”st.PSR - PMMU-Statusregister                             MC68851, MC68030
----------------------------------------------------------------------

Das PMMU-Statusregister enth„lt Flags, welche bestimmte Zust„nde des
Ergebnis  einer Adreberstezung anzeigt.  Es entspricht dem ECCRF der
CPU. Diese  Flags werden fr  die  EBedingungenF der bedingten  Befehle
abgefragt.


Das Statusregister der PMMU hat folgenden Aufbau:

          15  14  13  12  11  10  9   8   7   6   5    3 2   0
         +---+---+---+---+---+---+---+---+---+---+------+-----+
         | B | L | S | A | W | I | M | G | C | T |unused|  N  |
         +---+---+---+---+---+---+---+---+---+---+------+-----+
           |   |   |   |   |   |   |   |   |   |           | 
Bus Error--+   |   |   |   |   |   |   |   |   |           |
Limit Violation+   |   |   |   |   |   |   |   |           |
Privilegsverletzung+   |   |   |   |   |   |   |           |
Access Level Violation-+   |   |   |   |   |   |           |
Schreibschutz--------------+   |   |   |   |   |           |
Ungltig-----------------------+   |   |   |   |           |
Ver„ndert--------------------------+   |   |   |           |
Gate-( nur MC68851 )-------------------+   |   |           |
Globaly Sharable-( nur MC68851 )-----------+   |           |
Transparent Access-( nur MC68030 )-------------+           |
Anzahl der Levels------------------------------------------+Die Bedingungen werden an Hand der Flags im EPMMU-StatusregisterF gebildet.
Folgende EMC68851F-Bedinungen sind erlaubt:

       Mnemonic   |      Flags      |   Mnemonic   |      Flags
    --------------+-----------------+--------------+-----------------
          BS      |    B gesetzt    |      BC      |    B gel”scht
          LS      |    L    "       |      LC      |    L    "
          SS      |    S    "       |      SC      |    S    "
          AS      |    A    "       |      AC      |    A    "
          WS      |    W    "       |      WC      |    W    "
          IS      |    I    "       |      IC      |    I    "
          GS      |    G    "       |      GC      |    B    "
          CS      |    C    "       |      CC      |    C    "PCSR - PMMU-Cache-Statusregister                           Nur MC68851
----------------------------------------------------------------------

Das PCSR ist ein 16-Bit readonly Register, welches immer dann ver„ndert
wird,  wenn in  das ECRPF  mittels EPMOVEF oder EPRESTOREF  geschrieben
wird.

Es hat folgenden Aufbau:

                      15  14  13        3 2    0
                   +----+----+-----------+------+
                   |  F | LW | unbenutzt |  TA  |
                   +----+----+-----------+------+
                      |    |                 |
Flush ----------------+    |                 |
Lock Warning --------------+                 |
Task Aliases --------------------------------+CAL - Current Access Level Register                            MC68851
----------------------------------------------------------------------

Das CAL-Register bestimmt das Zugriffsrecht eines Tasks. CAL ist
8 Bit breit. Die oberen 3 Bits enthalten das Zugriffsrecht, das
durch die Befehle EPMOVEF oder EPRESTOREF gesetzt wird. Beim
MC68020 wird CAL automatisch durch ECALLMF und ERTMF gesetzt.VAL - Validate Access Level Register                           MC68851
----------------------------------------------------------------------

Das VAL-Register enth„lt das Zugriffsrecht eines Tasks. VAL ist
8 Bit breit. Die oberen 3 Bits enthalten das Zugriffsrecht, das
automatisch mit dem Wert aus dem EControl Access Level RegisterF
geladen wird.AC - Access Control Register                               Nur MC68851
----------------------------------------------------------------------

Das Access Control Register wird benutzt, um die zahlreichen Zu-
griffskontrollen des MC68851 zu konfigurieren, wie besipielsweise
die Zugriffsrechte, deren Anzahl oder die Gr”e eines Mudule
Descriptors.TTn - Transparent Translation Register 0 bzw. Register 1       MC68030
----------------------------------------------------------------------

Die  PMMU prft bei der  EAdrebersetzungF  zuerst,  ob die  logische 
Adresse ber die  Transparent Translation  Register zu einer physica-
lischen Adresse "bersetzt" werden kann.  Die "šbersetzung" kann dann
stattfinden, wenn alle Tests,  die durch die Flags in diesem Register
spezifiziert  wurden  positiv  verlaufen.  In diesem  Falle wird  die
logische Adresse als physicalische verwendet.  Damit lassen sich z.B.
max. 2 ( fr TT0  und TT1)  mindestens 16  MB groe  Speicherbereiche
als jeweils ein groer Block verwenden, fr den keine Adrebersetz-
ung notwendig ist.

Das TT0 und das TT1 sind 32 Bit breit und haben folgenden Aufbau:

        31 24 23 16 15  14    10   9     8    7  6   4  3  2   0
       +-----+-----+---+--------+-----+-----+---+-----+---+-----+
       | LAB | LAM | E | unused | R/W | RWM | 0 | FCB | 0 | FCM |
       +-----+-----+---+--------+-----+-----+---+-----+---+-----+
         |     |     |            |     |         |         |
ELogicalF  |     |     |            |     |         |         | 
EAddressF  |     |     |            |     |         |         | 
EBaseF-----+     |     |            |     |         |         |      
ELogical Address MaskF |            |     |         |         | 
EEnable TTnF-----------+            |     |         |         | 
ERead/WriteF------------------------+     |         |         |
ERead/Write MaskF-------------------------+         |         |
EFunction Code BaseF--------------------------------+         |
EFunction Code MaskF------------------------------------------+Logical Address Base / Mask
----------------------------------------------------------------------

Die oberen 8 Bits einer logischen Adresse,  welche durch die Logical
Address Mask ( das jeweilige Bit  in der Maske ist gel”scht ) spezi-
fiziert werden,  werden mit den  Bits der Logical Address  Base der
ETransparent TranslationF Register verglichen.Enable Transparent Translation
----------------------------------------------------------------------

Mit dem  Enable Transparent  Translation Flag der  ETTnF Register wird
die Transparent Translation  fr das jeweilige Register ein- ( Flag
gesetzt ) bzw. ausgeschaltet ( Flag gel”scht ).Read/Write (Mask)
----------------------------------------------------------------------

Ist die Read/Write Mask eines ETransparent TranslationF Registers ge-
setzt, so werden  alle Speicherzugriffe transparent  bersetzt. An-
sonsten  werden  nur  Schreibzugriffe  ( Read/Write-Flag gel”scht ) 
oder Lesezugriffe ( Read/Write-Flag gesetzt ) transparen šbersetzt.Function Code Base / Mask
----------------------------------------------------------------------

Die 3 Bits eines EFunction CodeF,  welche durch die Function Code Mask
( das jeweilige Bit in der Maske ist gel”scht ) spezifiziert werden,
werden mit den  Bits der Function Code Base der Transparent Transla-
tion Register ( ETTnF verglichen.Adrebersetzung mit der PMMU
----------------------------------------------------------------------

Die Adrebersetzung mit Hilfe der PMMU (Paged Memory Management 
Unit) auf dem EMC68030F oder dem EMC68851F unterscheidet sich nur ge-
ringfgig.  Sie  dient  dazu logische  Adressen zu  physikalische
Adressen  umzusetzen.  Will  z.B.  ein Programm  auf die  Adresse
$10000 zugreifen, so mu diese nun nicht unbedingt mit der physi-
kalischen Adresse bereinstimmen.

Die  Vorgehensweise der CPU bzw. PMMU l„t sich  dabei durch fol-
gendes  Fludiagramm  darstellen,  LA  steht  dabei  fr logische
Adresse, PA fr physikalische Adresse:

+===============================================================+
| LA im ECacheF ?                                                 |
|                                                               |
| Ja                                                     | Nein |
+--------------------------------------------------------+------+
| Schreibzugriff ?                                       |      |
|                                                        |      |
| Nein       |                                        Ja |      |
+------------+-------------------------------------------+------+
|            | Kann PA aus ETTnF berechnet werden ? ( EMC68030F )   |
|            |                                                  |
|            | Nein                                  |       Ja |
|            +---------------------------------------+----------+
|            | Ist PA im EATCF ?                       | PA = LA  |
|            |                                       |          |
|            | Nein                        |      Ja |          |
|            +-----------------------------+---------+          |
|            | Bestimme aktuellen          | Hole PA |          |
|            | ERoot PointerF                | aus ATC |          |   
|            +-----------------------------+         |          |
|            | Durchsuche                  |         |          |
|            | EšbersetzungsbaumF            |         |          |
|            +-----------------------------+         |          |
|            | Wurde EPage DescriptorF       |         |          |
|            | gefunden ?                  |         |          |
|            |                             |         |          |
|            | Nein      |              Ja |         |          |
|            +-----------+-----------------+         |          |
|            |           | Berechne PA     |         |          |
|            |           | mit             |         |          |
|            |           | ETable AddressF.  |         |          |
|            |           +-----------------+         |          |
|            |           | Trage PA ins    |         |          |
|            | L”se      | ATC ein.        |         |          |
| Hole Wert  | EExceptionF +-----------------+---------+----------+ 
| aus Cache. | aus.      | Verwende PA zum Speicherzugriff      |
+============+===========+======================================+ATC - Address Translation Cache
------ ----------------------------------------------------------------

Das Address Translation Cache ist ein PMMU-interner Speicherbereich,
der die letzten EAdrebersetzungenF enth„lt. Dadurch werden die
Speicherzugriffe zur Adrebersetzung minimiert. Auf das ATC haben
Sie nur ber die EPLOADF und EPFLUSHF Befehle zugriff. Es enh„lt
folgende Felder und Flags:

Krzel | Gr”e   | Bezeichnung
       | in Bits |
-------+---------+------------------------------
     V |       1 | Valid
    FC |       3 | EFunction CodeF
     B |       1 | Bus Error
    CI |       1 | Cache Inhibit
    WP |       1 | Write Protection
     M |       1 | Modified
    SG |       1 | EShared GlobalyF ( MC68851 )
    LA |      24 | Logical Address
    PA |      24 | Physical Address

V signalisiert die Gltigkeit des Eintrags. B wird gesetzt, wenn
w„hrend der Adrebersetzung ein Bus-Fehler, ein ungltiger Des-
kriptor, eine Privileg-Verletzung oder eine Limit-Verletzung
vorkamen. CI ist gesetzt, wenn es im zugeh”rigen EPage DescriptorF
ebenfalls gesetzt ist. WP bedeutet, das auf den zugeh”rigen
Speicher ausschlielich lesender Zugriff gestattet ist. M besagt,
da der Speicherinhalt ver„ndert wurde.šbersetzungsbaum
----------------------------------------------------------------------

Der šbersetzungsbaum enth„lt alle EšbersetzungstabelleFn, die zur  Adre-
bersetzung durch die EPMMUF notwendig sind.  Je nachdem welche Felder im
ETranslation ControlF Register  gesetzt sind,  hat er eine Schachtelungs-
tiefe von 0 ( der ERoot PointerF  enth„lt schon  einen  EPage DescriptorF )
bis 5 ( FCL und alle TIx-Felder sind gltig ).

Der šbersetzungsbaum im Hauptspeicher hat folgenden Aufbau:

Root Pointer | šbersetzungstabellen 1 .... šbersetzungstabellen 5


CRP----------->Descriptor----------------->Page Descriptor
                                              ...
                  ...                      Page Descriptor   
                     
               Descriptor----------------->Page Descriptor
                                              ...
                                           Page Descriptor

SRP----------->Descriptor----------------->Page Descriptor
                                              ...
                  ...                      Page Descriptor   
                     
               Descriptor----------------->Page Descriptor
                                              ...
                                           Page Descriptor

DRP----------->Descriptor----------------->Page Descriptor
                                              ...
                  ...                      Page Descriptor   
                     
               Descriptor----------------->Page Descriptor
                                              ...
                                           Page Descriptoršbersetzungstabelle
----------------------------------------------------------------------

Eine šbersetzungstabelle ist eine Liste von EDescriptorFen, die
je nach EDescriptor TypeF entweder  Page Descriptoren sind oder
auf eine neue  šbersetzungstabelle zeigen.  Alle Descriptoren
einer Tabelle  haben die gleiche Gr”e  von entweder 4 oder 8
Byte.  Wie  Gro  diese  Descriptoren  sind,  wird  durch den
Descriptor Type  desjenigen  Descriptor  festgelegt,  der auf
diese Tabelle zeigt. Die Anzahl der Descriptoren einer Tabel-
le wird durch das  Limitfield des auf diese Tabelle zeigenden
Descriptors festgelegt.

Welcher  Descriptor der  Tabelle  fr  die  EAdrebersetzungF
verwendet wird, h„ngt vom den verschiedenen Kombinationen aus
aktuelle  Schachtelungstiefe im EšbersetzungsbaumF, FCL und TIx
des ETranslation ControlF Registers, dem EFunction CodeF  und den
Adress Bits der logischen Adresse ab.----------------------------------------------------------------------

Ein Page Descriptor beschreibt den Zustand einer 4K bzw. 8K groen
Speicherseite oder ist ein Zeiger auf einen anderen Page Descriptor,
also ein indirekter Descriptor:

        31    12 11 10  9  8 7 6 5 4 3 2 1 0
       +--------+--+--+--+--+-+---+-+-+-+---+
8K     | PA     |UR|G |U1|U0|S|CM |M|U|W|PDT|
       +--------+--+--+--+--+-+---+-+-+-+---+

        31 13 12 11 10  9  8 7 6 5 4 3 2 1 0
       +-----+--+--+--+--+--+-+---+-+-+-+---+
4K     | PA  |UR|UR|G |U1|U0|S|CM |M|U|W|PDT|
       +-----+--+--+--+--+--+-+---+-+-+-+---+

        31                             2 1 0
       +--------------------------------+---+
Ind.   | Descriptor Address             |PDT|
       +--------------------------------+---+


Krzel |Bezeichnung
-------+---------------------
PA     | Physical Address
UR     | User Reserved
G      | Global
U0,U1  | User Page Attribute
S      | Supervisor Protected
CM     | Cache Mode
M      | Modified
U      | Used
W      | Write Protected
PDT    | Page Descriptor TypeExceptions bei der Adrebersetzung
----------------------------------------------------------------------

Wird bei der EAdrebersetzungF  ein ungltiger Descriptor gefunden,
ein indirect Descriptor, der nicht auf einen Page Descriptor zeigt,
gefunden oder ein Tabellen  Index das Limit  bersteigt bzw. unter-
schreitet, wird ein EBusfehlerF ausgel”st.BADn - Breakpoint Acknowledge Datenregister                Nur MC68851
----------------------------------------------------------------------

BADn ( 0 <= n <= 7 )

Wenn der Prozessor bei der Programmausfhrung auf einen der acht
EBKPTF-Befehle trifft, wird eine Ausnahmebehandlung eingeleitet.
Danach wird der Inhalt des zum BKPT-Befehl korrespondierenden
BAD-Registers mit diesem ausgetauscht und mit diesem Befehl
fortgefahren. D.h. ein BAD-Register sollte einen sinnvollen
Opcode enthalten.

Querverweis:   EBreakpoint Acknowledge Control RegisterFBACn - Breakpoint Acknowledge Control Register             Nur MC68851
----------------------------------------------------------------------

BACn ( 0 <= n <= 7 )

Die BAC-Register korrespondieren mit den entsprechenden EBADF-
Registern. Wenn das oberste Bit (15) nicht gesetzt ist, wird beim
Ausl”sen eines Breakpoints mittels des EBKPTF-Befehls ein Bus-Fehler
generiert. Die unteren 8 Bits geben an, nach dem wievieltem Male 
nach dem Treffen auf einen BKPT-Befehl die Ausnahmebehandlung
begonnen werden soll (Voraussetzung: Bit 15 gesetzt).

Querverweis:   EBreakpoint Acknowledge DatenregisterFDie Exceptiontabelle der Motorola CPUs
----------------------------------------------------------------------

Die Exceptiontabelle ist eine Liste von Exceptionvektoren,  die der CPU
anzeigen, wo sie mit der Programmausfhrung fortfahren soll, falls eine
bestimmte Bedingung bzw. Ereignis aufgetreten ist. Die Tabelle f„ngt ab
der Adresse 0 an,  kann jedoch ab der  MC68010 CPU mit dem EVBRF an einer 
anderen Adresse anfangen.

Vektor | Offset  | Bedeutung
-------+---------+---------------------------------------------------------
     0 |       0 | ESSPF nach Reset
     1 |       4 | EPCF nach Reset
     2 |       8 | EBusfehlerF
     3 |      12 | EAdressfehlerF
     4 |      16 | EIllegaler BefehlF
     5 |      20 | EDivision durch 0F
     6 |      24 | ECHKF-, ECHK2F-Befehle
     7 |      28 | ETRAPVF-, ETRAPccF, EFTRAPccF, EPTRAPccF-Befehle
     8 |      32 | EPrivilegsverletzungF
     9 |      36 | ETraceF
    10 |      40 | ELine-A-VektorF
    11 |      44 | ELine-F-VektorF
    12 |      48 | reserviert
    13 |      52 | ECoprozessor-ProtokollF                    ( MC68020 )
    14 |      56 | EFormatfehlerF                             ( MC68010 )
    15 |      60 | EFalscher Interrupt VektorF
 16-23 |   64-92 | reserviert
    24 |      96 | ESpurious InterruptF
 25-31 | 100-124 | EAutovektor-InterruptF, Level 1 bis Level 7
 32-47 | 128-188 | ETRAPF-Befehle 0 - 15
    48 |     192 | EBranch/Set on UnorderedF                ( MC68881/2 )
    49 |     196 | EInexact OperationF                      ( MC68881/2 )
    50 |     200 | EDivision durch 0.0F                     ( MC68881/2 )
    51 |     204 | EFPU underflowF                          ( MC68881/2 )
    52 |     208 | EOperandenfehlerF                        ( MC68881/2 )
    53 |     212 | EFPU overflowF                           ( MC68881/2 )
    54 |     216 | Ungltiges Ergebnis                    ( MC68881/2 )
    55 |     220 | reserviert
    56 |     224 | EPMMU-FehlerF                     ( MC68851, MC68030 )
    57 |     228 | EPMMU-Illegale OperationF                  ( MC68851 )
    58 |     232 | EPMMU-ZugriffsverletzungF                  ( MC68851 )
 59-63 | 236-252 | reserviert
64-255 |256-1020 | EBenutzerreservierte ExceptionsFBusfehler
----------------------------------------------------------------------

Bei einem Busfehler wird eine EExceptionF mit der Nummer 2 ausgel”st. Der
Busfehler wir von auen ber die BERR-Leitung der CPU erzeugt.  Er wird
dazu benutzt, um Zugriffe auf  nicht vorhandenen oder geschtzten Spei-
cher, der nur im Supervisorlevel erreichbar ist, zu verhindern.

Ein EBusfehlerF wird  auch von der EPMMUF erzeugt,  falls bei einer  Adre-
bersetzung ein ungltiger EDescriptorF gefunden wurde.  Die Adresse die-
ses Descriptors  kann die  Busfehlerroutine mit dem  EPTESTF-Befehl fest-
stellen.Adressfehler
----------------------------------------------------------------------

Bei einem  Adressfehler wird eine EExceptionF mit der Nummer 3 ausgel”st. 
Der Adressfehler wird ausgel”st,  wenn eine Wort-, Langwort- oder Quad-
wortzugriff auf eine ungerade Adresse auszufhren.Illegaler Befehl
----------------------------------------------------------------------

Trifft die CPU auf einen Befehl, der ihr unbekannt ist, so wird eine
EExceptionF mit der Nummer 4 ausgel”st. Der einzige Opcode, der garant-
iert (also auch bei zuknftigen CPUs) diese Exception ausl”st, ist 
der des "EILLEGALF"-Befehls.Division durch 0
----------------------------------------------------------------------

Wird versucht eine Division durch 0 auszufhren, so l”st  die CPU eine
EExceptionF mit der Nummer 5 aus. (siehe auch EDIVSLF, EDIVSF, EDIVUF, EDIVULF).Line-A-Vektor
----------------------------------------------------------------------

Trifft die CPU auf einen  Befehl, dessen Opcode mit der Bitkombination
1010 (das ist HEX A)  anf„ngt,  so wird eine EExceptionF  mit der Nummer
10 ausgel”st. Einen solchen Befehl, k”nnen Sie mit der Direktive EALINEF
erzeugen.Line-F-Vektor
----------------------------------------------------------------------

Trifft die CPU auf einen  Befehl, dessen Opcode mit der Bitkombination
1111 (das ist HEX F)  anf„ngt,  so wird eine EExceptionF  mit der Nummer
11 ausgel”st. Einen solchen Befehl, k”nnen Sie mit der Direktive EFLINEF
erzeugen.

Bevor allerdings die  Exception ausgel”st wird,  versuchen die CPUs ab 
MC68020 den  gefundenen Opcode an  einem  Coprozessor  (FPU oder PMMU) 
weiterzureichen. Erst wenn das nicht klappt (weil kein Coprozessor in-
staliert ist) wird die Exceotion ausgel”t.Coprozessor-Protokoll
----------------------------------------------------------------------

Tritt bei der  Kommunikation zwischen der CPU ( MC68020 ) und einem
Coprozessor ein Protokollfehler auf, so wird eine EExceptionF mit der
Nummer 13 ausgel”st. Dieser Fehler sollte eigentlich nie auftreten,
da er nur auf defekte Hardware schlieen l„t.Formatfehler
----------------------------------------------------------------------

In einigen F„llen prft die CPU oder ein Coprozessor Daten im Speicher
auf ihre Gltigkeit.  Entdeckt der Prozessor falsche Daten,  wird eine
EExceptionF mit der Nummer 14 ausgel”st. Dieser Test wird bei den Befeh-
len ECALLMF, EFRESTOREF, EPRESTOREF, ERTEF, ERTMF durchgefhrt.Falscher Interrupt Vektor
----------------------------------------------------------------------

Wird ein ENon-Autovektor-InterruptF ausgel”st, der (noch) nicht initia-
lisert ist, ausgel”st, so wird eine  EExceptionF mit der Nummer 15 aus-
gel”st.Spurious Interrupt
----------------------------------------------------------------------

Wird ein Interrupt ausgel”st, dessen Ursache nicht feststellbar ist,
so wird eine  EExceptionF mit der  Nummer 24 ausgel”st.  Dieser Fehler
sollte  eigentlich nie auftreten,  da er  nur auf  defekte  Hardware
schlieen l„t.Autovektor-Interrupt
----------------------------------------------------------------------

Autovektor-Interrupts sind  Interruptanforderungen externer Hardware,
bei der sich die CPU den EExceptionFvektor selbst aus der Interruptpri-
orit„t ( siehe "Interruptmaske" ) bestimmt.Non-Autovektor-Interrupt
----------------------------------------------------------------------

Non-Autovektor-Interrupts sind Interruptanforderungen externer Hard-
ware, bei der die CPU den EExceptionFvektor von der externen  Hardware
anfordert.  Non-Autovektor-Interrupts  werden  dazu  benutzt  um die
EBenutzerreservierte ExceptionsF zu erzeugen.

Querverweis: EFalscher Interrupt VektorF EInterruptmaskeF 
             EAutovektor-InterruptFBranch/Set on Unordered                               MC68881, MC68040
----------------------------------------------------------------------

Einige EFliekommabedingungenF  l”sen eine EExceptionF mit der  Nummer 48
aus, wenn das NAN-Bit im ECondition CodeF Byte des Fliekomma-Statusre-
gister ( EFPSRF ) gesetzt ist.

Das Auftreten dieser Exception kann mit dem EException EnableF Byte des
Fliekomma-Kontrollregisters ( EFPCRF ) ein- bzw. ausgeschaltet  werden. 
Es  wird  aber  auf  jeden  Fall  im  EException StatusF  Byte  und  im 
EAccrued ExceptionF  Byte des  Fliekommastatusregisters ( EFPSRF ) ange-
zeigt.Inexact Result/Decimal Input                          MC68881, MC68040
----------------------------------------------------------------------

Konnte das Ergebnis der letzten Fliekommaoperation nicht hinreichend
genau bestimmt werden oder war ein oder mehrere Operanden der letzten
Fliekommaoperation  nicht hinreichend genau,  so wird eine EExceptionF
mit der Nummer 49 ausgel”st.

Das Auftreten dieser Exception kann mit dem EException EnableF Byte des
Fliekomma-Kontrollregisters ( EFPCRF ) ein- bzw. ausgeschaltet  werden. 
Es  wird  aber  auf  jeden  Fall  im  EException StatusF  Byte  und  im 
EAccrued ExceptionF  Byte des  Fliekommastatusregisters ( EFPSRF ) ange-
zeigt.Division durch 0.0                                    MC68881, MC68040
----------------------------------------------------------------------

Wird versucht eine Division durch 0.0 auszufhren, so l”st  die FPU eine
EExceptionF mit der Nummer 50 aus. (siehe auch EFDIVF, EFREMF, EFSGLDIVF )

Das Auftreten dieser Exception kann mit dem EException EnableF Byte des
Fliekomma-Kontrollregisters ( EFPCRF ) ein- bzw. ausgeschaltet  werden. 
Es  wird  aber  auf  jeden  Fall  im  EException StatusF  Byte  und  im 
EAccrued ExceptionF  Byte des  Fliekommastatusregisters ( EFPSRF ) ange-
zeigt.FPU underflow                                         MC68881, MC68040
----------------------------------------------------------------------

Ist ein von 0.0 verschiedenes Ergebnis einer  Fliekommaoperation zu 
klein,  als da es  korrekt dargestellt  werden kann,  so wird  eine 
EExceptionF mit der Nummer 51 ausgel”st.

Das Auftreten dieser Exception kann mit dem EException EnableF Byte des
Fliekomma-Kontrollregisters ( EFPCRF ) ein- bzw. ausgeschaltet  werden. 
Es  wird  aber  auf  jeden  Fall  im  EException StatusF  Byte  und  im 
EAccrued ExceptionF  Byte des  Fliekommastatusregisters ( EFPSRF ) ange-
zeigt.Operandenfehler                                       MC68881, MC68040
----------------------------------------------------------------------

Sind ein oder mehrere  Operanden einer  Fliekommaoperation ungltig,
so wird eine EExceptionF mit der Nummer 42 ausgel”st.

Das Auftreten dieser Exception kann mit dem EException EnableF Byte des
Fliekomma-Kontrollregisters ( EFPCRF ) ein- bzw. ausgeschaltet  werden. 
Es  wird  aber  auf  jeden  Fall  im  EException StatusF  Byte  und  im 
EAccrued ExceptionF  Byte des  Fliekommastatusregisters ( EFPSRF ) ange-
zeigt.FPU overflow                                          MC68881, MC68040
----------------------------------------------------------------------

Ist das Ergebnis einer  Fliekommaoperation zu gro,  als da es kor-
rekt dargestellt werden kann,  so wird eine EExceptionF  mit der Nummer
53 ausgel”st.

Das Auftreten dieser Exception kann mit dem EException EnableF Byte des
Fliekomma-Kontrollregisters ( EFPCRF ) ein- bzw. ausgeschaltet  werden. 
Es  wird  aber  auf  jeden  Fall  im  EException StatusF  Byte  und  im 
EAccrued ExceptionF  Byte des  Fliekommastatusregisters ( EFPSRF ) ange-
zeigt.PMMU-Fehler                                           MC68851, MC68030
----------------------------------------------------------------------

Wird die  PMMU von der Systemsoftware falsch initialisiert, so wird
eine  EExceptionF  mit der Nummer  56 ausgel”st.  Ein solcher  Fehler
tritt auf, wenn ECRPF, ESRPF oder EDRPF ungltige Deskriptoren zugewiesen
bekommen, wenn die  Felder TIx, IS  und PS  des Translation Control
Registers ( ETCF ) ungltige Werte erhalten.PMMU-Illegale Operation                               MC68851, MC68030
----------------------------------------------------------------------

Wird  bei ausgeschalteter  PMMU ( MC68851 ) versucht,  einen EPLOADF
oder EPTESTF Befehl auszufhren, so wird eine EExceptionF mit der Num-
mer 57 ausgel”st.PMMU-Zugriffsverletzung                               MC68851, MC68030
----------------------------------------------------------------------

Wenn ein EPVALIDF-Test einen Zeiger zurckweist, wird eine EExceptionF
mit der Nummer 58 ausgel”st.Benutzerreservierte Exceptions
----------------------------------------------------------------------

Die CPU kennt insgesamt 192  Benutzerreservierte EExceptionFs. Diese
Exceptions  haben die Nummern 64 - 255.  Sie k”nnen vom jeweiligen
Betriebssytem fr eigene Zwecke verwendet werden. Die Exceptionnum-
mern werden ber die ENon-Autovektor-InterruptFs erzeugt.

Das Betriebssystem des Atari ST  kennt folgende Benutzerreservierte
Exceptions:

Vektor | Adresse | Bedeutung
-------+---------+---------------------------------------------------------
    64 |     256 | BUSY Interrupt
    65 |     260 | DCD Interrupt ( "Carrier detect" )
    66 |     264 | CTS Interrupt ( "Clear to send" )
    67 |     268 | GPU Done ( "Graphic Processing Unit" = Blitter )
    68 |     272 | Baudratengenerator ( Timer D der MFP )
    69 |     276 | 200 Hz System Timer ( Timer C )
    70 |     280 | IKBD/MIDI
    71 |     284 | FDC/ACSI
    72 |     288 | Display Enable Signal ( Timer B )
    73 |     292 | RS-232 Sendefehler
    74 |     296 | RS-232 Sendepuffer leer
    75 |     300 | RS-232 Empfangsfehler
    76 |     304 | RS-232 Empfangspuffer voll
    77 |     308 | Timer A ( steht dem Anwenderprogramm zur Verfgung )
    78 |     312 | Monochrom Monitor Detect
    
Die Vektoren 79 bis 223 werden auf dem ST nicht benutzt. Die Vektoren
224 - 255 werden fr andere Zwecke verwendet.Erkl„rung der Abkrzungen
----------------------------------------------------------------------

ea       Spezifikation einer Adressierungsart ( Effective Address ).
dn       Datenregister ( Data Register n ).
an       Adreregister ( Address Register n ).
xn       Adre- oder Datenregister n.
data     Adressierungsart die Daten unmittelbar spezifiziert.
         ( Immediate Data ).
label    Sprungmarke.
cr       Kontroll-Register des 680x0 Prozessors.
fc       EFunction CodeF beim Speicherzugriff.
reglist  Spezifikation einer Registerliste.
offs     Datenregister oder Immediate Data, um  einen  Bitfeld-
         Offset zu spezifizieren.
width    Datenregister oder Immediate Data,  um  eine  Bitfeld-
         Breite zu spezifizieren.
.x       EGr”en-SpezifikationenF fr Byte, Word oder Longword.
.a       Gr”en-Spezifikation fr Word oder Longword.
fpn      Fliekomma-Datenregister
fpcr     Fliekomma-Kontrollregister
fdlist   Liste von Fliekomma-Datenregistern
fclist   Liste von Fliekomma-Kontrollregistern
.p       Gr”en-Spezifikation fr Byte, Word, Longword,
         Single Precision Real, Double Precision Real,
         Extended Precision Real
.f       Gr”en-Spezifikation fr Byte, Word, Longword,
         Single Precision Real, Double Precision Real,
         Extended Precision Real oder Packed Decimal Real
cc       Condition Code. Je nach Befehl steht dies fr eine 
         Bedingung der ECPUF, EFPUF oder EPMMUF.Codeoptimierung
----------------------------------------------------------------------

Bei einigen Befehlen der MC680x0-Prozessoren kann man durch
Verwendung alternativer Befehle die Codegr”e verringern oder
die Ausfhrungsgeschwindigkeit vergr”ern.

Befehl              Optimierung         Voraussetzung
----------------------------------------------------------------------
ADD.X   #data,ea    ADDQ.X  #data,ea    1 <= data <= 8
ADDA.X  #data,ea    ADDQ.X  #data,ea
ADDI.X  #data,ea    ADDQ.X  #data,ea
SUB.X   #data,ea    SUBQ.X  #data,ea
SUBA.X  #data,ea    SUBQ.X  #data,ea
SUBI.X  #data,ea    SUBQ.X  #data,ea

CMP.X   #0,ea       TST.X   ea          ea ist kein An
CMPI.X  #0,ea       TST.X   ea

MOVE.L  #data,Dn    MOVEQ   #data,Dn    -128 <= data <= 127

MOVEA.L #data,An    MOVEA.W #data,An    -32768 <= data <= 32767
ADDA.L  #data,An    ADDA.W  #data,An
CMPA.L  #data,An    CMPA.W  #data,An
SUBA.L  #data,An    SUBA.W  #data,An

MOVE.X  #0,Dn       CLR.X   Dn

MOVEM.A #0,ea       nichts
MOVEM.A ea,#0       nichts

Die Befehle MOVE.X #0,ea werden nicht zu CLR.X ea optimiert,
weil sich der CLR-Befehl auf einigen frheren Prozessoren
aufgrund eines Fehlers im Mikrocode anders verh„lt als bei
neueren Typen, bei denen der Fehler behoben ist.

Fr die absolute Adressierung gibt es eine kurze Form, bei der
sich die Adresse als Wort darstellen l„t. Liegt eine Adresse
zwischen -32768 und 32767, so w„hlt Pure Assembler automatisch
die kurze Form.
Die Adressierungsart Adreregister indirekt mit Adredistanz wird
zu Adreregister indirekt reduziert, wenn die Adredistanz Null ist.
Die erweiterten Adressierungsarten ab dem MC68020 werden nur dann
erzeugt, wenn Speicherindirektion benutzt oder das Basisregister
unterdrckt wird. 
Die Gr”e fur das Basisregister beziehungsweise die „uere
Adredistanz wird ebenfalls optimiert.

Die Verzweigungsbefehle EBRAF, EBccF und EBSRF werden immer optimiert,
wenn es sich um vorw„rtsgerichtete Referenzen handelt, es sei
denn, es wurde eine Gr”e spezifiziert oder das Sprungziel liegt
in einem anderen Modul. Verzweigt ein BRA- oder Bcc-Befehl auf
den n„chstfolgenden Befehl, so wird fr den Verzweigungsbefehl
kein Code generiert.Signaling NaN
----------------------------------------------------------------------

Mittels Signaling NaN wird der FPU mitgeteilt, da ein benutzer-
definierter Datentyp benutzt wird. Die FPU kann niemals Signaling
NaN erzeugen.Shared Globaly
----------------------------------------------------------------------

Das SG-Bit besagt, da Teile des logischen Adreraums von allen
Tasks im System gemeinsam benutzt wird.Cache
----------------------------------------------------------------------

Mit einem Cachespeicher wird versucht die zeitintensiven Buszugriffe
zu minimieren. Beim MC68020 gab es nur einen Befehlscache. Seit dem
MC68030 sind die Motorula CPUs sowohl mit Befehls- als auch mit
Datencaches ausgestattet.Pure Assembler Direktiven
----------------------------------------------------------------------

Die Direktiven drfen gro oder klein geschrieben werden. Allen
Direktiven, mit Ausnahme von = und *=, darf ein Punkt vorangestellt
werden.

E=F                    EENDMF                 EMODULEF
E*=F                   EENDMODF               ENOLISTF
EALIGNF                EEQUF                  EOFFSETF
EALINEF                EERRORF                EORGF
EASCIIF                EEVENF                 EPAGEF
EASCIILF               EEXITMF                EPRINTF
EASCIIZF               EEXPORTF               EREGF
EBSSF                  EFLINEF                EREPTF
ECOMMF                 EGLOBLF                ESETF
EDATAF                 EIFccF                 ESUPERF
EDCF                   EIMPORTF               ETEXTF
EDCBF                  EINCLUDEF              ETTLF
EDSF                   ELCOMMF                EUSERF
EELSEF                 ELISTF                 EXDEFF
EENDF                  ELOCALF                EXREFF
EENDCF                 EMACROF
EENDIFF                EMC68nnnFDie Benutzung von Makros im šberblick
----------------------------------------------------------------------
 
EMakrodefinitionF
 
EParameterbewertungF
 
EParametersubstitutionF
 
ERekursive MakroaufrufeF
 
EVerschachtelung von MakrodefinitionenF
 
ERedefinieren von MakrosFName            Equate - Zuweisen eines Wertes

Syntax          label EQU expression
                EQU label,expression

Beschreibung    Mittels der EQU-Direktive wird einem Label ein
                Wert zugewiesen, der durch den Ausdruck expression
                bestimmt wird. Zu beachten ist, da der Ausdruck
                nicht relativ zu einer externen Referenz sein
                darf. Statt des Ausdrucks darf auch ein Register-
                name zugewiesen werden. Dieser wird dann als Syno-
                nym benutzt.
                Ein einmal mit EQU zugewiesener Wert darf in der
                Folge nicht mehr ver„ndert werden. Die Zuweisung
                mit EQU hat Konstanten-Charakter.
                Beachten Sie, da hinter label kein Doppelpunkt
                stehen darf!

Beispiel        cr EQU $d
                EQU lf,$a

                EQU lf,$a     ; erneute Zuweisung verursacht einen
                              ; Fehler!

Querverweis     E=F, ESETFName            Set value - Zuweisen eines Wertes

Syntax          SET label,expression
                label SET expression

Beschreibung    Die SET-Direktive weist dem Symbol label den Wert
                des Ausdrucks expression zu. Mit SET definierte
                Symbole haben Variablen-Charakter, das heit, der
                Wert des Symbols darf durch erneute Zuweisung
                ge„ndert werden. Der zugewiesene Ausdruck darf
                auch eine Registerbezeichnung sein. Das Symbol
                wird dann als Synonym fr das Register benutzt.
                Beachten Sie, da hinter label kein Doppelpunkt
                stehen darf!

Beispiel        Count SET 3      ; alter Wert
                SET Count,5      ; neuer Wert

                Parameter SET D0 ; Register sind auch erlaubt

Querverweis     E=F, EEQUFName            = - Zuweisen eines Wertes an ein Symbol

Syntax          symbol = expression

Beschreibung    Dem Symbol symbol wird der Wert des Ausdrucks
                expression zugewiesen. Mit der =-Direktive
                definierte Symbole haben Variablen-Charakter,
                das heit, der Wert des Symbols darf durch
                erneute Zuweisung ge„ndert werden.
                Der zugewiesene Ausdruck darf auch eine Register-
                bezeichnung sein. Das Symbol wird dann als Synonym
                fr das Register benutzt.

Beispiel        COUNT = 0
                ...
                COUNT = COUNT + 1

                Parameter = D0
                move.w  Parameter,-(sp)

Querverweis     EEQUF, ESETFName            Define Register List - Registerliste erzeugen

Syntax          label REG registerlist
                label REG 0
                REG label,registerlist
                REG label,0

Beschreibung    Die REG-Direktive stellt eine Registerliste fr
                die "move multiple"-Befehle der Prozessoren
                zusammen. Der Wert einer Registerliste darf
                ver„ndert werden. Eine leere Registerliste wird
                durch REG label,0 oder label REG 0 erzeugt.

Beispiel        SavedRegs REG A2-A4/D3
                ...

                ; -----------------------------------
                ; Beachten Sie die erweiterte Syntax:
                ; -----------------------------------

                movem.l  #SavedRegs,-(sp)
                ...
                movem.l  (sp)+,#SavedRegs ; <- kein Druckfehler!Name            Define Constant - Definieren konstanter Daten

Syntax          [label:] DC[.size] expression[,expression...]

Beschreibung    Die DC-Direktive dient der Initialisierung des
                Speichers mit konstanten Werten. Die Werte
                ergeben sich aus der Liste von Ausdrucken
                (expression). Das Datenformat kann ber den
                Parameter size eingestellt werden, wobei alle
                Datenformate zugelassen sind, die auch fr die
                Assemblerbefehle gltig sind. 
                Wird size nicht angegeben, wird angenommen, da
                es sich bei den Daten um Worte handelt.
                Als expression darf auch ein String angegeben
                werden. Die Zeichen des Strings werden unabh„ngig
                vom angegebenen Datenformat als Bytes abge-
                speichert. Ist das Datenformat nicht Byte, so
                wird gegebenfalls mit Nullen aufgefllt, bis der
                Positionsz„hler auf das entsprechende Datenformat
                wieder ausgerichtet ist.

Beispiel        dc.b "Hello!"       ; erzeugt $48656C6C6F21
                dc.l "Hello!"       ;         $48656C6C6F210000
                dc   -1,0,1            ;         $FFFF00000001
                dc.x 1.0            ;         $3FFF00008000000000000000

Querverweis     EASCIIF, EASCIILF, EASCIIZF, EDCBF, EDSFName            Define Constant Block - Definiere einen Block
                konstanter Daten

Syntax          [label:] DCB[.size] expr1[,expr2...]

Beschreibung    DCB initialisiert einen Speicherblock der durch
                size und expr1 spezifizierten Gr”e mit Konstanten.
                size gibt das Datenformat an. Voreingestellt ist
                Wort-Format. expr1 gibt die Anzahl an Einheiten
                der Gr”e size an, aus denen der Speicherblock 
                besteht. Die Konstante wird durch einen oder
                mehrere Ausdrcke (expr2) angegeben.

Beispiel        dcb.l 2,-2       ; erzeugt $FFFFFFFEFFFFFFFE
                dcb.w 2,3,4      ;         $0003000400030004
                dcb.b 3,"ABC"    ;         $414243414243414243

Querverweis     EDCFName            Generate ASCII-Characters - ASCII-Zeichen erzeugen

Syntax          [Label:] ASCII string[,string...]

Beschreibung    Die ASCII-Direktive dient dem Anlegen von Strings
                in DATA- und TEXT-Segmenten. Beachten Sie, da
                ASCII keine Stringendemarkierung erzeugt.

Beispiel        HelloText:    ASCII "Hello World!"
                              ASCII "Another", " Text"

Querverweis     EASCIILF, EASCIIZF, EDCFName            Generate Length Byte And ASCII-Characters -
                L„ngenbyte und ASCII-Zeichen erzeugen

Syntax          [Label:] ASCIIL string[,string...]

Beschreibung    ASCIIL legt die Strings, „hnlich wie ASCII, im
                aktuellen Segment ab. Zus„tzlich wird als erstes
                Byte fr jeden String dessen L„nge abgespeichert
                (Pascal-Strings).

Beispiel        HelloText:    ASCIIL "Hello World!"

                ; entspricht

                              DC.B  12
                              ASCII "Hello World!"

Querverweis     EASCIIF, EASCIIZF, EDCFName            Generate ASCII-Characters And Zero Byte -
                ASCII-Zeichen und Null-Byte erzeugen

Syntax          [Label:] ASCIIZ string[,string...]

Beschreibung    Mit ASCIIZ kann man Strings gem„ C-Konvention
                erzeugen, das heit, das Stringende wird mit einem
                zus„tzlichen Null-Byte markiert. Ansonsten arbeitet
                ASCIIZ wie ASCII.

Beispiel        HelloText:      ASCIIZ "Hello World!"

                ; entspricht

                                ASCII "Hello World!"
                                DC.B  0

Querverweis     EASCIIF, EASCIILF, EDCFName            Define Storage - Speicher reservieren

Syntax          [label:] DS[.size] expression

Beschreibung    Die DS-Direktive reserviert Speicher im aktuellen
                Segment. Ist dieses das Text- oder Datensegment,
                so wird der Speicher mit Nullen initialisiert.
                Die Gr”e des Speicherbereichs berechnet sich aus
                expression Einheiten des Datenformats size. Falls
                size nicht angegeben wird, bezieht sich die
                Direktive auf das Wort-Format.

Beispiel        ds.b $100        ; reserviert  256 Bytes
                ds.w $100        ;             512
                ds   $100        ;             512
                ds.l $100        ;            1024
                ds.s $100        ;            1024
                ds.p $100        ;            3072

Querverweis        ECOMMF, EDCFName            Origin - EPositionsz„hlerF setzen

Syntax          ORG expression

Beschreibung    Die ORG-Direktive setzt den Positionsz„hler
                auf den durch den Ausdruck expression angegebenen
                Wert. Dieser mu absolut sein. Der Positions-
                z„hler darf nicht auf Stellen zurckgesetzt 
                werden, fr die bereits Code erzeugt wurde.

Beispiel        ORG  $100 ; setzt den Positionsz„hler auf 256 Byte

Querverweis     E*=FName            *= - EPositionsz„hlerF setzen

Syntax          *= expression

Beschreibung    *= setzt den Positionsz„hler auf den durch den
                Ausdruck expression angebenen Wert. Dieser mu
                absolut sein. Der Positionsz„hler darf nicht auf
                Stellen zurckgesetzt werden, fr die bereits
                Code erzeugt wurde.
                Zwischen dem Asterisk (*) und dem Gleichheits-
                zeichen = darf kein Leerzeichen stehen, da sonst
                die Zeile fr einen Kommentar gehalten wrde.

Beispiel        *= $100 ; setzt den Positionsz„hler auf 256 Byte

                * = $100 ; gesamte Zeile ist ein Kommentar!

Querverweis     EORGFName            Align Position Counter - EPositionsz„hlerF ausrichten

Syntax          ALIGN [expression]

Beschreibung    Die ALIGN-Direktive erh”ht den Positionsz„hler
                soweit, da sein Wert durch den angegebenen
                Ausdruck expression teilbar wird. Der Wert von
                expression mu gr”er Null sein. Falls fr
                expression nichts angegeben wurde, wird der
                voreingestellte Wert 2 genommen.

Beispiel                   bra    prgStart
                           ASCII  "Copyright 1991 by ..."
                           ALIGN  256
                prgStart:  ...             ; beginnt auf Offset 256

Querverweis     EEVENFName            Align To Even Address - EPositionsz„hlerF auf gerade
                Adresse ausrichten

Syntax          EVEN

Beschreibung    Der Positionsz„hler des aktuellen Segments wird
                mittels der EVEN-Direktive auf eine gerade Adresse
                ausgerichtet. Die Wirkung von EVEN entspricht
                somit der von ALIGN 2. Die Verwendung von EVEN
                empfiehlt sich stets nach der Defintion von
                Daten im Byte-Format und Strings.

Beispiel        Bytes:  ds.b   13  ; Vorsicht, ungerade Gr”e!

                EVEN               ; jetzt wieder gerade Adresse!

                Words: ds.w   12

Querverweis     EALIGNFName            Select Text Segment - Ausw„hlen des Textsegments

Syntax          TEXT [expression]
                TEXT "name"

Beschreibung    Die TEXT-Direktive w„hlt das Textsegment aus.
                Dieses dient der Aufnahme von Programmcode.
                Mittels des optionalen Ausdrucks expression kann
                eines von vier Subsegmenten mit den Nummern 0 bis
                3 gew„hlt werden. Statt einer Nummer kann auch ein
                Name fr ein Subsegmentes angegeben werden.
                Ist weder eine Nummer noch ein Name eines
                Subsegmentes angegeben, so wird das Subsegment 0
                genommen. Beim Linken werden alle Subsegmente zu
                einem einzigen Textsegment zusammengefat.

Querverweis     EBSSF, EDATAFName            Data Segment - Auswahl des Datensegments

Syntax          DATA [expression]
                DATA "name"

Beschreibung    Die Direktive DATA w„hlt das Datensegment aus.
                Dieses dient der Aufnahme von Daten jeglicher Art.
                Mittels des optionalen Ausdrucks expression kann
                eines von vier Subsegmenten mit den Nummern 0 bis
                3 gew„hlt werden. Statt einer Nummer kann auch ein
                Name fr ein Subsegmentes angegeben werden.
                Ist weder eine Nummer noch ein Name eines Sub-
                segmentes angegeben, so wird das Subsegment 0
                genommen. Beim Linken werden alle Subsegmente zu
                einem einzigen Datensegment zusammengefat.

Querverweis     EBSSF, ETEXTFName            Block Storage - Auswahl des BSS-Segments

Syntax          BSS [ expression ]
                BSS "name"

Beschreibung    Die BSS-Direktive w„hlt das BSS-Segment aus.
                Dieses dient ausschlielich der Reservierung von
                nicht initialisiertem Speicher. Mittels des
                optionalen Ausdrucks expression kann eines von
                vier Subsegmenten mit den Nummern 0 bis 3 gew„hlt
                werden. Statt einer Nummer kann auch ein Name fr
                ein Subsegmentes angegeben werden. Ist weder eine
                Nummer noch ein Name eines Subsegmentes angegeben,
                so wird das Subsegment 0 genommen. Beim Linken
                werden alle Subsegmente zu einem einzigen BSS-
                Segment zusammengefat.

Querverweis     EDATAF, ETEXTFName            Offset - Absolutes Segment ausw„hlen

Syntax          OFFSET [expression]

Beschreibung    Die OFFSET-Direktive w„hlt ein absolutes Segment
                aus. In einem absolutem Segment kann man keinen
                Code erzeugen. Man darf nur Labels definieren und
                Speicherzuweisungen treffen. Somit sind absolute
                Segmente dazu geeignet, die Offsets von Struktur-
                elementen oder Stackframes zu definieren. Der
                optionale Parameter expression gibt einen Start-
                offset an. Fehlt er, beginnt das Segment bei Null.

Beispiel        # -------------------------------------------
                # Folgendes absolutes Segment entspricht
                # der C-Struktur
                #
                # struct  list
                # {
                #      struct list   *next;
                #      char          name[20];
                # };
                # -------------------------------------------

                OFFSET

                next:    ds.l  1
                name:    ds.b 20

                EVEN

                TEXT

                ...

                move.l   next(a0),a0
                lea.l    name(a0),a1

                ...Name            Local Common - Speicher im BSS-Segment zuweisen

Syntax          LCOMM label,expression

Beschreibung    Die LCOMM-Direktive reserviert unter dem Namen
                label expression Bytes im BSS-Segment. expression
                mu gr”er als Null sein. 

Beispiel        LCOMM  buffer,$1000 ; 4 KByte groen Buffer anlegen

Querverweis     ECOMMF, EBSSFName            Global Symbol - Globales Symbol definieren

Syntax          GLOBL label[,label...]

Beschreibung    Die GLOBL-Direktive definiert das bzw. die
                angegebenen Labels als global. Das heit, wenn
                ein gleichnamiges Label in dem betreffenden
                Modul definiert worden ist, so wird dieses
                exportiert, andernfalls importiert.

Beispiel        GLOBL   impLabel, expLabel

                ...
                expLabel: ...  ; expLabel wird exportiert!

                ...
                pea.l impLabel ; impLabel mu importiert werden
                ...

Querverweis     EEXPORTF, EIMPORTF, EXDEFF, EXREFFName            Extern Reference - Referenz auf externes Symbol

Syntax          XREF label,[label...]

Beschreibung    Die Direktive XREF macht ein oder mehrere globale
                Symbole in einem Modul sichtbar. Das heit, da
                ein aus einem anderen Modul exportiertes Symbol
                nach der Definition mit XREF im aktuellen Modul
                benutzt werden darf.

Beispiel        XREF  yourLabel
                ...
                lea.l   yourLabel,a0
                ...

Querverweis     EEXPORTF, EGLOBLF, EIMPORTF, EXDEFFName            Extern Definition - Definition fur externes Symbol

Syntax          XDEF label,[label...]

Beschreibung    Die Direktive XDEF exportiert ein oder mehrere
                Labels, so da diese auch in anderen Modulen
                verwendet werden k”nnen. Die Labels werden somit
                global gltig.

Beispiel        XDEF  myLabel
                ...
                myLabel:   ...

Querverweis     EEXPORTF, EGLOBLF, EIMPORTF, EXREFFName            Common - Variable in der Common Section definieren

Syntax          COMM label,expression

Beschreibung    Die COMM-Direktive definiert ein Label (label) und
                reserviert unter diesem Speicher im BSS-Segment.
                Die Gr”e des reservierten Speichers ergibt sich
                aus dem Wert von expression, der gr”er Null sein
                mu. 

Beispiel        COMM   buffer,$1000  ; 4 KByte groen Buffer 
                                     ; reservieren
                ...
                lea.l  buffer,a0

Querverweis     EDSF, ELCOMMFName            Generate $A-Line Opcode - Line-A Befehlscode erzeugen

Syntax          ALINE #expression

Beschreibung    Mittels der ALINE-Direktive kann man ein
                Befehlswort erzeugen, dessen Bits 12..15 den
                Wert $A enthalten. In die Bits 0..11 wird der
                Wert des Ausdrucks expression eingetragen, der
                zwischen $000 und $FFF liegen darf. Trifft der
                Prozessor auf einen Line-A-Opcode, wird eine
                spezielle Exception-Routine zur Auswertung dieser
                Befehle aufgerufen.

Beispiel        ALINE  #16    ; erzeugt den Opcode $A010

Querverweis     EFLINEFName            Generate $F-Line Opcode - Line-F Befehlscode erzeugen

Syntax          FLINE #expression

Beschreibung    Mittels der FLINE-Direktive kann man ein
                Befehlswort erzeugen, dessen Bits 12..15 den
                Wert $F enthalten. In die Bits 0..11 wird der
                Wert des Ausdrucks expression eingetragen, der
                zwischen $000 und $FFF liegen mu. Trifft der
                Prozessor auf einen Line-F-Opcode, wird eine
                spezielle Exception-Routine zur Auswertung
                dieser Befehle aufgerufen.

Beispiel        FLINE  #256   ; erzeugt den Opcode $F100

Querverweis     EALINEFName            Select Instruction Set - Ausw„hlen des Befehlssatzes

Syntax          MC68000
                MC68010
                MC68020
                MC68030
                MC68040
                MC68851
                MC68851 -
                MC68881 [expression]
                MC68881 -

Beschreibung    Die MC68nnn-Direktiven w„hlen den Befehlssatz fr
                einen spezifischen Prozessor aus.
                Mit MC68000 wird der Befehlssatz fr die
                Prozessoren MC68000 und MC68008 aktiviert. Die
                MC68010-Direktive selektiert die Befehle fr die
                Prozessortypen MC68010 und MC68012. Die Direktiven
                MC68020 und MC68030, sowie MC68040 w„hlen den
                Befehlssatz fr die gleichnamigen Prozessoren aus.
                Ein Befehlssatz bleibt solange aktiv, bis ein
                neuer ausgew„hlt wird.
                Um den Befehlssatz des Coprozessors MC68551 zu
                aktivieren, nehmen Sie die Direktive MC68851 in
                Ihren Quelltext auf. Wenn Sie den Befehlssatz fr
                einen Fliekommakoprozessor ben”tigen, so geschieht
                dies durch die Direktive MC68881. Diese erh„lt als
                Parameter die Coprozessor-Id. Fehlt der Parameter,
                so wird als Id 1 angenommen. Die Befehlss„tze fr
                Coprozessoren werden deaktiviert, indem die ent-
                sprechende Direktive mit nachgestelltem Minus-
                Zeichen aufgerufen wird.

Querverweis     ECacheF, EFliekomma-BefehleF, EPMMU-BefehleF
                EUSERF, ESUPERFName            Select Privileged Instruction Set - Ausw„hlen
                des Befehlssatzes fr den Supervisor-Modus

Syntax          SUPER

Beschreibung    Mit der Direktive SUPER kann man den privile-
                gierten Befehlssatz fr den Supervisor-Modus
                des aktuellen Prozessors ausw„hlen. Voreinge-
                stellt ist der nicht-privilegierte Befehlssatz.

Querverweis     EMC68nnnF, EUSERFName            Select Nonprivileged Instruction Set - Ausw„hlen
                des Befehlssatzes fr den User-Modus

Syntax          USER

Beschreibung    Mit der USER-Direktive kann man auf den nicht-
                privilegierten Befehlssatz fr den User-Modus
                des aktuellen Prozessors zurckschalten.

Querverweis     EMC68nnnF, ESUPERFName            Include File - Datei einbinden

Syntax          INCLUDE "filename"
                INCLUDE 'filename'

Beschreibung    Die INCLUDE-Direktive bindet die angegebene
                Datei in den Quelltext ein. INCLUDE-Direktiven
                k”nnen beliebig tief verschachtelt werden.

Beispiel        INCLUDE "macro.inc"
                INCLUDE 'INCLUDE\string.mac'Name            Print Message - Meldung ausgeben

Syntax          PRINT ["message"]

Beschreibung    Die PRINT-Direktive gibt den Text message
                w„hrend der Assemblierung aus. Ist kein Text
                angegeben, fhrt PRINT nur einen Zeilenvorschub
                aus.

Beispiel        PRINT "Dies sind ""Anfhrungszeichen"", alles klar?"

Querverweis     EERRORFName            Title - Untertitel fr Listing

Syntax          TTL "titel"

Beschreibung    Die TTL-Direktive erlaubt die Definition eines
                Untertitels fr die Seiten eines Listings. Es
                drfen in einer Quelltextdatei mehrere Untertitel
                vereinbart werden. Durch die Variable %f im Titel
                title kann der Name der Quelldatei in den Unter-
                titel mitaufgenommen werden. Voreingestellt ist
                Source File: %f.

Beispiel        ...
                TTL "Beispiel fr einen Untertitel"
                ...
                TTL "Beispiel mit Filenamen: %f"
                ...

Querverweis     ELISTF, ENOLISTF, EPAGEFName            Set Page Size - Setzen der Seitenl„nge fr Listings

Syntax          PAGE [expression]

Beschreibung    Mit der PAGE-Direktive wird die Seitenl„nge
                fr Listings festgelegt. Wenn der optionale
                Parameter expression fehlt, erzwingt die
                Direktive einen sofortigen Seitenumbruch.
                Andernfalls gibt expression die neue Seiten-
                l„nge an. Voreingestellt sind 59 Zeilen pro
                Seite.

Beispiel        ; Dieser Text steht auf der alten Seite ...

                PAGE

                ; und dieser auf einer neuen Seite!

                PAGE 70   ; ab jetzt sind Seiten 70 Zeilen lang

Querverweis     ELISTF, ENOLISTF, ETTLFName            List - Text im Listing auffhren

Syntax          LIST

Beschreibung    Die LIST-Direktive aktiviert die Ausgabe in die
                Listing-Datei. Damit diese erzeugt wird, mu
                beim Assembleraufruf der P-Schalter gesetzt
                werden. Die Ausgabe in die Listing-Datei ist
                voreingestellt. Deshalb macht die LIST-Direktive
                nur Sinn, wenn zuvor mit NOLIST die Ausgabe
                unterdrckt wurde.

Beispiel        LIST
                ... ; ab hier steht alles im Listing!

Querverweis     ENOLISTF, EPAGEF, ETTLFName            Do not List - Text im Listing unterdrcken

Syntax          NOLIST

Beschreibung    Mit der NOLIST-Direktive kann die Aufnahme von
                Quelltext in eine Listing-Datei unterdrckt
                werden. Mit LIST wird die Ausgabe wieder aktiviert.

Beispiel        ; Diese Zeile steht im Listing.

                NOLIST

                ; Diese Zeile nicht!

                LIST

                ; Aber diese wieder!

Querverweis     ELISTF, EPAGEF, ETTLFName            If Condition - Bedingte Assemblierung

Syntax          IFcc expression
                    <statement list1>
                [ELSE
                    <statement list2>]
                ENDIF

Beschreibung    Die IFcc-Direktiven leiten eine bedingte
                Assemblierung ein. Ist die Bedingung expression
                erfllt, so werden die Anweisungen unter
                statement list1 assembliert. Andernfalls, sofern
                eine ELSE-Direktive vorhanden ist, werden die
                Anweisungen statement list2 bersetzt. Das
                Konstrukt zur bedingten Assemblierung wird durch
                ENDIF oder ENDC abgeschlossen.
                Die folgende Tabelle zeigt die m”glichen Bedin-
                gungen fr IFcc-Direktiven:

                Syntax             Bedingung erfllt, falls
                -------------------------------------------------
                IF expression      expression != 0
                IFF expression     expression == 0
                IFB argument       argument ist nicht vorhanden
                IFNB argument      argument ist vorhanden
                IF1                1.Assemblerlauf
                IF2                2.Assemblerlauf
                IFEQ expression    expression == 0
                IFNE expression    expression != 0
                IFLE expression    expression <= 0
                IFLT expression    expression < 0
                IFGE expression    expression >= 0
                IFGT expression    expression > 0
                -------------------------------------------------

                Die Direktiven IF1 und IF2 sind lediglich aus
                Grnden der Kompatibilit„t implementiert, da
                Pure Assembler ein One-Pass-Assembler ist, d.h.
                er bersetzt die Quellen in einem Durchlauf.
                Konstrukte, die auf mehr als einem Assemblerlauf
                beruhen, sind also mit Vorsicht zu genieen.
                Die IFB- und IFNB-Direktiven werden im Zusammenhang
                mit Makros ben”tigt. Durch sie ist es m”glich,
                zu prfen, ob ein aktueller Parameter leer ist,
                also nicht angegeben wurde.

Beispiel        IF value = 0     ; oder IFEQ value
                    PRINT "value == 0"
                ENDIF

                ...
                EMACROF whatever parameter

                    IFB parameter
                        ERROR "missing parameter"
                        EXITM
                     ENDIF
                ...
                ENDM

Querverweis     EELSEF, EENDCF, EENDIFFName            ELSE - Einleiten einer Alternative fr die
                bedingte Assemblierung

Syntax          IFcc expression
                    <statement list>
                [ELSE
                    <statement list>]
                ENDIF

Beschreibung    Die ELSE-Direktive wird im Zusammenhang mit der
                bedingten Assemblierung benutzt. Sie leitet einen
                Block zur alternativen Ausfhrung ein, falls die
                Bedingung der IFcc-Direktive nicht erfllt ist.
                Die Verwendung der ELSE-Direktive bei der beding-
                ten Assemblierung ist optional.

Beispiel        IF expression
                    PRINT "expression != 0"
                ELSE
                    PRINT "expression == 0"
                ENDIF

Querverweis     EIFccF, EENDCF, EENDIFFName            End IF-Construction - Beenden einer IF-Konstruktion

Syntax          IFcc expression
                    <statement list>
                [ELSE
                    <statement list>]
                ENDIF

Beschreibung    Die ENDIF-Direktive schliet ein Konstrukt zur
                bedingten Assemblierung ab. ENDIF ist „quivalent
                zur ENDC-Direktive.

Beispiel        IF expression
                    PRINT "expression != 0"
                ENDIF

Querverweis     EIFccF, EENDCFName            End Conditional Assembling - Beenden der bedingten 
                Assemblierung

Syntax          IFcc expression
                    <statement list>
                [ELSE
                    <statement list>]
                ENDC

Beschreibung    Die Direktive ENDC beendet ein Konstrukt zur
                bedingten Assemblierung. ENDC bewirkt dasselbe
                wie die ENDIF-Direktive.

Beispiel        IF expression
                    PRINT "expression != 0"
                ENDC

Querverweis     EIFccF, EENDIFFName            End Assembling - Beenden der Assemblierung

Syntax          END

Beschreibung    Text nach der END-Direktive in einer Quelltext-
                datei wird vom Assembler ignoriert. Die Verwendung
                von END am Ende eines Quelltextes ist nicht
                unbedingt erforderlich.

Beispiel        ...
                .END

                Was hier steht, interessiert den Assembler nicht 
                mehr!Name            Define Macro - Makrodefinition

Syntax          MACRO name[.formal0] [[formal1],formal2...]
                    <statement list>
                ENDM

Beschreibung    Mit der MACRO-Direktive kann man Sequenzen von
                Anweisungen einen Namen zuordnen. Wird dieser
                Name bei der Assemblierung gefunden, wird er
                durch die Anweisungssequenz ersetzt. Makros
                k”nnen auch Parameter besitzen. Die formalen
                Parameter werden bei der Makroexpansion durch
                die aktuellen Parameter substituiert. Abge-
                schlossen werden Makrodefintionen durch die
                ENDM-Direktive.
                Beim Aufruf werden die aktuellen Parameter des
                Makros durch Kommata getrennt. Ist fr das Makro
                der optionale, formale Parameter formal0 definiert,
                so wird dieser beim Makroaufruf, durch einen Punkt
                abgetrennt, an den Makronamen angeh„ngt. Danach
                mu mindestens ein Leerzeichen vor den restlichen
                Parametern stehen:

                MACRO test.size param1, param2
                    ...
                ENDM

                ...
                test.l "First parameter", 2
                ...

                Der formale Parameter formal0 ist fr die Angabe
                von Gr”enoperationen gedacht. Fehlt er beim Aufruf,
                so wird er bei der Makroexpansion durch einen
                Leerstring substituiert. Fhrt dies dazu, da ein
                einzelner Punkt dastehen wrde, so wird der Punkt
                unterdrckt:

                MACRO Push.size parameter
                    move.size parameter,-(sp)
                ENDM

                ...
                Push.l  d0    ; wird zu move.l d0,-(sp) expandiert
                Push d0       ; wird zu move d0,-(sp)
                ...

                Werden beim Aufruf mehr aktuelle Parameter ange-
                geben, als formale definiert sind, werden die
                berzahligen ignoriert. Sollten dagegen zu wenig
                aktuelle Parameter bergeben werden, werden die
                fehlenden Parameter durch Leerstrings erg„nzt.
                Alle Zeichen innerhalb von Strings und Klammer-
                paaren gelten als zum Parameter geh”rig. Dies ist
                notwendig, damit Parameter Kommata enthalten
                drfen:

                MACRO anotherTest param1, param2
                    ...
                ENDM

                ...

                ; 1.Parameter: "Hello, here I am!"
                ; 2.Parameter: 20(a0,d0)
                ; --------------------------------

                anotherTest "Hello, here I am!", 20(a0,d0)

                ...

Querverweis     EENDMF, ELOCALFName            Repeat - Wiederholung

Syntax          REPT expression
                    <statement list>
                ENDM

Beschreibung    Mit Hilfe der REPT-Direktive kann man eine
                Sequenz von Anweisungen expression-mal wieder-
                holen. expression mu gr”er gleich Null sein,
                wobei fr Null die Anweisungsfolge unterdrckt
                wird. Beendet wird die Sequenz durch die ENDM-
                Direktive.

Beispiel        DISP = 0
                REPT 16

                    move.b   DISP(a0),(a1)+
                    DISP = DISP + 80

                ENDM

Querverweis     EENDMFName            End Macro or Repetition - Beenden eines Makros oder
                einer Wiederholung

Syntax          ENDM

Beschreibung    ENDM beendet eine Makrodefinition oder eine
                Wiederholungsanweisung.

Beispiel        Counter = 1
                REPT 10
                    dc.w   Counter
                     Counter = Counter + 1
                ENDM

                ...
                MACRO PushRegister RegNum
                    move.l   r&RegNum,-(sp)
                ENDM

Querverweis     EMACROF, EREPTFName            Exit Macro - Verlassen eines Makros

Syntax          EXITM

Beschreibung    Trifft der Assembler auf die EXITM-Direktive, so
                wird die Bearbeitung des aktuellen Makros sofort
                abgebrochen. Somit kann in Verbindung mit der
                bedingten Assemblierung beispielsweise die
                Erzeugung von unntzem Code durch Makros abgefangen
                werden.

Beispiel        MACRO xyz value1 value2

                    IFEQ value1 - value2
                        EXITM

                ...

Querverweis     EMACROFName            Local Label - Lokale Labeldefintion fr Makros

Syntax          LOCAL label[,label...]

Beschreibung    Wenn innerhalb von Makros ELabelsF ben”tigt
                werden, sollten diese mittels der LOCAL-
                Direktive definiert werden. Andernfalls
                wrden bei wiederholter Makroexpansion die
                Labels mehrfach erzeugt und somit Fehler
                verursacht. LOCAL sorgt dafr, da die Labels
                des Makros bei der Expansion durch Labels
                der Form ____XXXX ersetzt werden, wobei XXXX
                eine Dezimalzahl aus dem Bereich von 0000 bis
                9999 ist. Verwenden Sie deshalb selber keine
                Labels dieser Art in Ihren Quellen.

Beispiel        MACRO ABSOLUTE

                    LOCAL  end

                         tst.w   d0
                         bge     end
                         neg.w   d0
                    end:

                ENDM

                ...
                ABSOLUTE     ; erzeugt fur end ____0000

                ABSOLUTE     ; erzeugt fur end ____0001
                ...

Querverweis     EMACROFName            Import Symbol Definition - Symboldefinition importieren

Syntax          IMPORT label[,label...]

Beschreibung    Die IMPORT-Direktive macht ein oder mehrere globale
                Symbole in einem Modul sichtbar. Das heit, da ein
                aus einem anderen Modul exportiertes Symbol nach
                dem Importieren im aktuellen Modul bentzt werden
                darf.

Beispiel        IMPORT  yourLabel

                ...
                lea.l   yourLabel,a0
                ...

Querverweis     EEXPORTF, EGLOBLF, EXDEFF, EXREFFName            Export Symbol Definition - Exportieren einer Symbol-
                definition

Syntax          EXPORT label[,label...]

Beschreibung    Die EXPORT-Direktive exportiert ein oder mehrere
                Labels, so da diese auch in anderen Modulen
                verwendet werden k”nnen. Die Labels werden somit
                global gltig.

Beispiel        EXPORT  myLabel

                ...

                myLabel:   ...

Querverweis     EGLOBLF, EIMPORTF, EXDEFF, EXREFFName            Begin new Module - Neues Modul beginnen

Syntax          MODULE label

Beschreibung    Mit MODULE kann man ein neues Modul beginnen.
                Nach der Direktive mu der Name des Moduls
                stehen. Dieser wird als Label fr die erste
                codeerzeugende Zeile des Moduls verwendet.
                Innerhalb des Moduls sind alle definierten
                Labels fr den Modulbereich lokal. Ein Segment-
                wechsel ist innerhalb eines Moduls nicht m”glich.
                Die gleichzeitige Verwendung von Moduln und
                Elokalen LabelsF ist nicht m”glich.
                Beim Linken werden nur die tats„chlich benutzten
                Module zum fertigen Programm gebunden.

Beispiel        TEXT

                MODULE example

                moveq.l  #0,d0       ; auf dieser Zeile ist das
                                     ; Label example definiert!
                ...
                bne      example

                ; -------------------------------------------
                ; Das folgende Label ist Modul-lokal. Soll es
                ; global sein, mu es explizit mit EXPORT
                ; anotherEntryPoint exportiert werden!
                ; -------------------------------------------

                anotherEntryPoint:
                ...
                ENDMOD

Querverweis     EENDMODFName            End Module - Beenden eines Moduls

Syntax          ENDMOD

Beschreibung    ENDMOD beendet ein durch MODULE eingeleitetes
                Modul. Bevor ein neues Modul begonnen werden kann,
                mu das aktuelle Modul zuvor durch ENDMOD abge-
                schlossen werden.

Querverweis     EMODULEFName            Generate Error Message - Fehlermeldung erzeugen

Syntax          ERROR "message"

Beschreibung    Mit der ERROR-Direktive kann man eine Fehler-
                meldung erzeugen. Zus„tzlich wird der Text
                message ausgegeben.

Beispiel        IF value < 0
                    ERROR "value < 0"
                ENDIF

Querverweis     EPRINTFParameterbewertung in Makros
----------------------------------------------------------------------

Beginnt ein aktueller Parameter mit einem Gleichheitszeichen (=),
einem Dollarzeichen ($) oder einem Klammeraffen (@) und als zweitem
Zeichen einer offnenden Klammer ((), so werden die darauffolgenden
Zeichen bis zur schlieenden Klammer ()) als Ausdruck fr einen
Long-Wert betrachtet. Der Ausdruck wird nach der Auswertung in
einen String umgewandelt. War das erste Zeichen ein Gleichheits-
zeichen, so erh„lt man einen Dezimalstring, fr das Dollarzeichen
einen Hexadezimal- und fr den Klammeraffen einen Oktalstring.

        MACRO test3 parameter
        ...
        ENDM

        ; $(3*9) ergibt "$1b"
        ; -------------------

        test3 $(3*3)
        ...Parametersubstitution in Makros
----------------------------------------------------------------------

Innerhalb von Strings findet normalerweise keine Parameter-
substituierung statt. Soll trotzdem eine Substituierung erfolgen,
so ist der entsprechende formale Parameter in dem String durch
ein vorangestelltes kaufm„nnisches Additionszeichen (&) zu
kennzeichnen. Dies gilt auch fr nicht eindeutige Substitutionen
im brigen Makrotext:

         MACRO PushRegister RegNumber
             move.l  R&RegNumber,-(sp)
         ENDM

Das Ergebnis einer Parametersubstitution wird nicht weiter sub-
stituiert. So werden ungewollte, nicht terminierende Substitutions-
rekursionen vermieden.Rekursive Makroaufrufe
----------------------------------------------------------------------

Ein Makro kann sich selbst aufrufen oder ein Aufruf von einem
anderen Makro aus kann schlielich zum ursprnglich aufrufenden
Makro zurckfhren. Diese direkte oderindirekte Rekursion ist
nur dann sinnvoll, wenn durch eine bedingte Direktive eine
unendliche Rekursion verhindert wird.Verschachtelung von Makrodefinitionen
----------------------------------------------------------------------

Eine Makrodefinition darf weitere Makrodefinitionen enthalten.
Die inneren Makros werden dann erst nach der ersten Expansion
des „ueren Makros definiert.
Wenn beispielsweise ein Makro eine Initialisierung ben”tigt, so
kann damit sichergestellt werden, da vor dem ersten Makroaufruf
die Initialisierung stattfand.

         MACRO Init
             ...
             MACRO DoWhatYouLike
             ...
             ENDM
         ENDM

         ...
         DoWhatYouLike      ; hier gibt es eine Fehlermeldung!
         ...

         Init
         DoWhatYouLike      ; jetzt geht's!
         ...Redefinieren von Makros
----------------------------------------------------------------------

Makros kann man unter demselben Namen, aber mit anderem Makro-
k”rper redefinieren. Im Extremfall kann sich ein Makro sogar
selbst redefinieren.
Hierbei macht man sich Everschachtelte DefinitionF zunutze. Sinnvoll
sind solche Redefinitionen besonders im Zusammenhang mit
Intialisierungen. Ben”tigt ein Makro ein Unterprogramm, so kann
dieses beim ersten Makroaufruf erzeugt werden. Danach redefiniert
sich das Makro mit dem Text, den man eigentlich von der Expansion
erwartet und ruft sich schlielich selbst nochmals auf.
Das folgende Beispiel zeigt das Makro BlockMove, das zun„chst
ein Unterprogramm zum Verschieben von Bl”cken erzeugt und sich
dann redefiniert, so da es Aufrufe fr das Unterprogramm
generieren kann.

       MACRO BlockMove source, destination, size
           TEXT 3
           BlckMv:
                   bra    .test
           .loop:  move.b  (a0)+,(a1)+
           .test:  dbra    d0,.loop
                   rts

           MACRO BlockMove src, dst, siz
                   move.w  siz,d0
                   lea.l   src,a0
                   lea.l   dst,a1
                   jsr     BlckMv
           ENDM

           TEXT

           BlockMove source, destination, size

       ENDMPure Assembler Befehlsbersicht
----------------------------------------------------------------------

ETransfer-BefehleF
 
EArithmetische BefehleF
 
ELogische BefehleF
 
EBit-BefehleF
 
EBitschiebe- und RotierbefehleF
 
EProgrammstruktur-BefehleF
 
EFliekomma-BefehleF

EPMMU-BefehleFTransfer-Befehle im šberblick
----------------------------------------------------------------------

ECASF       Vergleiche und Tausche                             ( MC68020 )
ECAS2F      Vergleiche und Tausche doppelt                     ( MC68020 )|
EEXGF       Vertausche Registerinhalte
EPEAF       Lege Adresse auf den Stack
ELEAF       Lade Adresse in ein Adreregister
ELINKF      Lege neuen Stackbereich an
EMOVEF      šbertrage Daten
EMOVE16F    šbertrage 16-Byte-Block                            ( MC68040 )
EMOVEAF     šbertrage Daten in ein Adreregister
EMOVECF     šbertrage Kontrollregister                         ( MC68010 )
EMOVEMF     šbertrage mehrere Register
EMOVEPF     šbertrage Daten fr die Peripherie
EMOVEQF     šbertrage Konstante schnell in ein Datenregister
EMOVESF     šbertrage Register via SFC oder DFC                ( MC68010 )
EPACKF      Packe BCD-Zahlen                                   ( MC68020 )
ESWAPF      Tausche Registerh„lften
EUNLKF      Hole den Stackpointer zurck
EUNPKF      Entpacke BCD-Zahlen                                ( MC68020 )Arithmetische Befehle im šberblick
----------------------------------------------------------------------

EABCDF      Addition von BCD-Zahlen
EADDF       Bin„re Addition
EADDAF      Bin„re Addition mit Adreregister als Ziel
EADDIF      Bin„re Addition mit Konstante als Quelle
EADDQF      Bin„re Addition (schnell)
EADDXF      Bin„re Addition mit Extendbit
ECLRF       L”sche den Inhalt des Operanden
ECMPF       Vergleiche zwei Operanden
ECMPAF      Vergleiche zwei Operanden mit Adreregister als Ziel
ECMPIF      Vergleiche zwei Operanden mit Konstante als Quelle
ECMPMF      Vergleiche zwei Speicherzellen
ECMP2F      Vergleiche Datenregister mit 2 Grenzen             ( MC68020 )
EDIVSF      Division mit Vorzeichen
EDIVUF      Division ohne Vorzeichen
EEXTF       Vorzeichenrichtige Erweiterung eines Datenregisters
EMULSF      Multiplikation mit Vorzeichen
EMULUF      Multiplikation ohne Vorzeichen
ENBCDF      Negation von BCD-Zahlen
ENEGF       Bin„re Negation
ENEGXF      Bin„re Negation mit Extendbit
ESBCDF      Subtraktion von BCD-Zahlen
ESUBF       Bin„re Subtraktion
ESUBAF      Bin„re Subtraktion mit Adreregister als Ziel
ESUBIF      Bin„re Subtraktion mit Konstante als Quelle
ESUBQF      Bin„re Subtraktion (schnell)
ESUBXF      Bin„re Subtraktion mit Extendbit
ETSTF       Prfe Inhalt des OperandenLogische Befehle im šberblick
----------------------------------------------------------------------

EANDF     Logisches UND
EANDIF    Logisches UND mit einer Konstanten  
EEORF     Logisches Exklusiv-ODER
EEORIF    Logisches Exklusiv-ODER mit einer Konstanten
ENOTF     Logisches Komplement
EORF      Logisches ODER
EORIF     Logisches ODER mit einer KonstantenBit-Befehle im šberblick
----------------------------------------------------------------------

EBCHGF    Prfe ein Bit und „ndere es     
EBCLRF    Prfe ein Bit und setze es auf 0     
EBFCHGF   Prfe Bitfield und „ndere es                         ( MC68020 )
EBFCLRF   Prfe Bitfield und setze es auf 0                    ( MC68020 )
EBFEXTSF  Extrahiere signed Bitfield                           ( MC68020 )
EBFEXTUF  Extrahiere unsigned Bitfield                         ( MC68020 )
EBFFFOF   Suche in Bitfield                                    ( MC68020 )
EBFINSF   Fge Daten in ein Bitfield ein                       ( MC68020 )
EBFSETF   Prfe Bitfield und setze es auf 1                    ( MC68020 )
EBFTSTF   Prfe Bitfield                                       ( MC68020 )
EBSETF    Prfe ein Bit und setze es auf 1    
EBTSTF    Prfe ein Bit    
ETASF     Prfe und setzte ein Bit im ZieloperandenBitschiebe- und Rotierbefehle im šberblick
----------------------------------------------------------------------

EASLF     Arithmetische Verschiebung nach links
EASRF     Arithmetische Verschiebung nach rechts
ELSLF     Logische Verschiebung nach links
ELSRF     Logische Verschiebung nach rechts
EROLF     Rotiere links
ERORF     Rotiere rechts
EROXLF    Rotiere links unter Einbeziehung des X-Flags
EROXRF    Rotiere rechts unter Einbeziehung des X-FlagsProgrammstruktur-Befehle im šberblick
----------------------------------------------------------------------

EBccF     Bedingte Verzweigung
EBKPTF    Breakpoint                                           ( MC68010 )
EBRAF     Verzweige immer
EBSRF     Verzweige zu Unterprogramm
EBTF      Verzweige immer
ECALLMF   Springe zu Modul                                 ( nur MC68020 )
ECHKF     Prfe Datenregister gegen obere Grenze
ECHK2F    Prfe Datenregister gegen zwei Grenzen               ( MC68020 )
EDBccF    Prfe Bedingung, dekrementiere und verzweige
EDBFF     Dekrementiere und verzweige
EDBRAF    Dekrementiere und verzweige
EILLEGALF Unzul„ssiger Opcode
EJMPF     Sringe zu Adresse
EJSRF     Springe zu Unterprogramm
ENOPF     Keine Operationm
ERESETF   Setze Peripherie zurck
ERTDF     Rckkehr aus Unterprogramm mit Aufr„umen des Stacks  ( MC68010 )
ERTEF     Rckkehr aus einer Exception
ERTMF     Rckkehr aus Modul                               ( nur MC68020 )
ERTSF     Rckkehr aus Unterprogramm
ERTRF     Rckkehr aus Exception ohne Ver„ndern des Systembyte
ESccF     Setze ein Byte in Anh„ngigkeit von einer Bedingung
ESTOPF    Lade Status Register und stoppe Programmausfhrung
ETRAPF    Gehe in Ausnahmebehandlung
ETRAPccF  Trap bei Bedingung                                   ( MC68020 )
ETRAPVF   Trap bei šberlaufFliekomma-Befehle im šberblick ( MC68040, MC68881 )
----------------------------------------------------------------------

Arithmetische Befehle:
EFABSF     Absolutwert
EFDABSF    Absolutwert mit doppelter Genauigkeit               ( MC68040 )
EFSABSF    Absolutwert mit einfacher Genauigkeit               ( MC68040 )
EFADDF     Addition
EFDADDF    Addition mit doppelter Genauigkeit                  ( MC68040 )
EFSADDF    Addition mit einfacher Genauigkeit                  ( MC68040 )
EFCMPF     Vergleiche zwei Operanden
EFDIVF     Division
EFDDIVF    Division mit doppelter Genauigkeit                  ( MC68040 )
EFSDIVF    Division mit einfacher Genauigkeit                  ( MC68040 )
EFGETEXPF  Exponent des Operanden                              ( MC68881 )
EFGETMANF  Mantisse des Operanden                              ( MC68881 )
EFINTF     Integerteil des Operanden                           ( MC68881 )
EFINTRZF   Integerteil des Operanden, gerundet auf 0           ( MC68881 )
EFMODF     Modulorest                                          ( MC68881 )
EFMULF     Multiplikation
EFDMULF    Multiplikation mit doppelter Genauigkeit            ( MC68040 )
EFSMULF    Multiplikation mit einfacher Genauigkeit            ( MC68040 )
EFNEGF     Negation
EFDNEGF    Negation mit doppelter Genauigkeit                  ( MC68040 )
EFSNEGF    Negation mit einfacher Genauigkeit                  ( MC68040 )
EFREMF     IEEE-Rest                                           ( MC68881 )
EFSCALEF   Skaliere Exponent                                   ( MC68881 )
EFSGLDIVF  Division mit einfacher Genauigkeit                  ( MC68881 )
EFSGLMULF  Multiplikation mit einfacher Genauigkeit            ( MC68881 )
EFSUBF     Substraktion
EFDSUBF    Substraktion mit doppelter Genauigkeit              ( MC68040 )
EFSSUBF    Substraktion mit einfacher Genauigkeit              ( MC68040 )

Potenzen und Logarithmen:
EFETOXF    Exponentialfunktion e^x                             ( MC68881 )
EFETOXM1F  Exponentialfunktion e^x-1                           ( MC68881 )
EFLOGNF    Natrlicher Logarithmus                             ( MC68881 )
EFLOGNP1F  Natrlicher Logarithmus von x+1                     ( MC68881 )
EFLOG10F   Dekadischer Logarithmus                             ( MC68881 )
EFLOG2F    Logarithmus zur Basis 2                             ( MC68881 )
EFSQRTF    Quadratwurzel
EFDSQRTF   Quadratwurzel mit doppelter Genauigkeit             ( MC68040 )
EFSSQRTF   Quadratwurzel mit einfacher Genauigkeit             ( MC68040 )
EFTENTOXF  Zehnerpotenz                                        ( MC68881 )
EFTWOTOXF  Zweierpotenz                                        ( MC68881 )

Trigonometrie:
EFACOSF    Arcus Cosinus                                       ( MC68881 )
EFASINF    Arcus Sinus                                         ( MC68881 )
EFATANF    Arcus Tangens                                       ( MC68881 )
EFCOSF     Cosinus                                             ( MC68881 )
EFSINF     Sinus                                               ( MC68881 )
EFSINCOSF  Sinus und Cosinus gleichzeitig                      ( MC68881 )
EFTANF     Tangens                                             ( MC68881 )

Hyperbelfunktionen:
EFATANHF   Arcus Tangens Hyperbolicus                          ( MC68881 )
EFCOSHF    Cosinus Hyperbolicus                                ( MC68881 )
EFSINHF    Sinus Hyperbolicus                                  ( MC68881 )
EFTANHF    Tangens Hyperbolicus                                ( MC68881 )

Transfer- und Strukturbefehle:
EFBccF     Bedingte Verzweigung
EFDBccF    Prfe Bedingung, dekrementiere und verzweige
EFMOVEF    šbertrage Daten
EFDMOVEF   šbertrage Daten und runde auf doppelte Genauigkeit  ( MC68040 )
EFSMOVEF   šbertrage Daten und runde auf einfache Genauigkeit  ( MC68040 )
EFMOVECRF  Hole Konstante aus dem ROM der FPU                  ( MC68881 )
EFMOVEMF   šbertrage mehrere Register
EFNOPF     Keine Operation
EFRESTOREF Wiederherstellung des Prozessorzustandes
EFSAVEF    Retten des Prozessorzustandes
EFSccF     Setze ein Byte in Anh„ngigkeit von einer Bedingung
EFTRAPccF  Trap bei Bedingung
EFTSTF     Prfe Inhalt des OperandenPMMU-Befehle im šberblick ( MC68030, MC68851 )
----------------------------------------------------------------------

Alle PMMU-Befehle sind privilegiert. D.h. sie drfen nur im Supervisor-
mode verwendet werden.

EPBccF     Bedingte Verzweigung                            ( nur MC68851 )
EPDBccF    Prfe Bedingung, dekrementiere und verzweige    ( nur MC68851 )
EPFLUSHF   L”sche Address Translation Cache
EPLOADF    Lade Address Translation Cache
EPMOVEF    šbertrage Daten von und zu einem PMMU-Register
EPRESTOREF Wiederherstellung des Prozessorzustandes        ( nur MC68851 )
EPSAVEF    Retten des Prozessorzustandes                   ( nur MC68851 )
EPSccF     Setze ein Byte in Anh„ngigkeit von einer Bedingung
                                                         ( nur MC68851 )
EPTESTF    Prfe logische Adresse
EPTRAPccF  Trap bei Bedingung                              ( nur MC68851 )
EPVALIDF   Prfe Zeiger                                    ( nur MC68851 )Supervisor Mode: Privilegierter Befehlssatz
----------------------------------------------------------------------

Aus dem Supervisior Mode sind alle ERegisterF der CPU und eventuel vorhandener
Coprozessoren erreichbar.

Auerdem sind zus„tzlich folgende Befehle erlaubt:

EANDI to SRF, EEORI to SRF,  EFRESTOREF, EFSAVEF, Alle EPMMU-BefehleF,  EMOVE to SRF,
EMOVE from SRF (ist erst ab MC68010 privilegiert), EMOVECF, EMOVESF, EORI to SRF,
ERTEF, ERESETF, ESTOPF.

Befindet sich die CPU im Usermode und wird versucht ein Befehl auszufh-
ren oder auf ein  Register zuzugreifen,  welches nur im Supervisor Mode 
erlaubt ist, wird eine EExceptionF mit der Vektornummer 8 ausgefhrt.

Wenn Sie einen dieser Befehle oder Register verwenden wollen, mssen Sie
dies dem Assembler mit der Direktive ESUPERF anzeigen.Die Verarbeitungszeit ist, wenn nichts anderes angegeben ist, die Anzahl 
der Taktzyklen fr das Holen der Operanden, Ausfhrung des Befehls, Ablegen 
des Ergebnisses und Holen des n„chsten Opcodes. Sie gelten nur fr den 
MC68000 und k”nnen bei den anderen Prozessoren differieren.

Die Befehlsl„nge ist die Anzahl der Bytes im Speicher fr diesen Befehl.

Ein Tabelleneintrag hat folgenden Aufbau:

  t/t,b/b
  | | | |
  | | | +-- Anzahl der Bytes bei Langwortverarbeitung 
  | | |     (nur falls es differiert)
  | | +---- Anzahl der Bytes bei Byte- und Wortverarbeitung
  | +------ Anzahl der Taktzyklen bei Langwortverarbeitung
  +-------- Anzahl der Taktzyklen bei Byte- und Wortverarbeitung

oder

  */b/b
  |
  +----- Diese Adresierungsart ist nicht fr den MC68000 oder MC68008
         verfgbar.ABCD - Addition von BCD-Zahlen
----------------------------------------------------------------------

Assembler Syntax: ABCD Dy,Dx
                  ABCD -(Ay),-(Ax)
Beschreibung:
Addiere dezimal kodierte  Nibbles  mit  Extended  Bit.  ( Binary
Coded Decimal )

Gr”e: Byte

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | ? | * | ? | E    <=  EM”gliche Ver„nderungenF
 |       |
 |       +-------- Dieses Flag wird gel”scht, wenn das Ergebnis ungleich 0 
 |                 ist, ansonsten bleibt es unver„ndert. Es empfielt sich 
 |                 daher das Z-Flag vorher zu setzen, wenn man das Ergebnis 
 |                 auf 0 prfen will.
 +---------------- Wie das C-Bit.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle  |   Ziel
        +--------------
        | Dn   | -(An)
--------+------+-------
Dn      | 6,2  |
-(An)   |      | 18,2

Gruppe: EArithmetische BefehleFADD - Bin„re Addition
----------------------------------------------------------------------

Assembler Syntax: ADD <ea>,Dn
                  ADD Dn,<ea>
Beschreibung:
Addiert den Source Operanden auf den Destination Operanden.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | E    <=  EM”gliche Ver„nderungenF
 |
 +----------------- Wie das C-Bit.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    |   Ziel
          +----------+---------+---------+---------+----------
          | Dn       | (An)    | (An)+   | -(An)   | d(An)
----------+----------+---------+---------+---------+----------
Dn        | 4/6,2    | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 
An        | 4/8,2    |
(An)      | 8/14,2   |
(An)+     | 8/14,2   |
-(An)     | 10/16,2  |
d(An)     | 12/18,4  |
d(An,Rx)  | 14/20,4  | 
$xxxx     | 12/18,4  |
$xxxxxxxx | 16/22,6  |
d(PC)     | 12/18,4  |
d(PC,Rx)  | 14/20,4  |
#         | 8/14,4/6 |

Quelle |   Ziel
       +----------+--------+-----------
       | d(An,Rx) | $xxxx  | $xxxxxxxx
-------+----------+--------+-----------
Dn     | 18/26,4  |16/24,4 | 20/28,6

Hinweise:
ADD.x <ea>,An wird automatisch zu EADDAF bersetzt.
ADD.x #<data>, <ea>  wird automatisch zu EADDIF bersetzt.
ADD.x #<data>, Rn wird automatisch zu EADDQF bersetzt, wenn der Quell-
operand im Bereich 0 bis 8 liegt.

Gruppe: EArithmetische BefehleF

Querverweis: EADDAF, EADDIF, EADDQF, EADDXFADDA - Bin„re Addition mit Adreregister als Ziel
----------------------------------------------------------------------

Assembler Syntax: ADDA <ea>,An

Beschreibung:
Addiert den Source Operanden auf ein Destination Adreregister. 
Die Gr”enspezifikation betrifft nur den Quelloperanden, dieser 
wird bei Wortverabeitung Vorzeichenrichtig erweitert und dann
erst zum Adreregister aufadiert.


Gr”e:  Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    |   Ziel
          +-----------
          | An        
----------+-----------
Dn        | 8/6,2
An        | 8/8,2
(An)      | 12/14,2
(An)+     | 12/14,2
-(An)     | 14/16,2
d(An)     | 16/18,4
d(An,Rx)  | 18/20,4 
$xxxx     | 16/18,4
$xxxxxxxx | 20/22,6
d(PC)     | 18/20,4
d(PC,Rx)  | 12/20,4
#         | 8/14,4/6

Hinweis: 
ADDA #..., An wird automatisch zu EADDQF bersetzt, wenn der Quell-
operand im Bereich von 0 bis 8 liegt.

Gruppe: EArithmetische BefehleF

Querverweis: EADDF, EADDIF, EADDQF, EADDXFADDI - Bin„re Addition mit Konstante als Quelle
----------------------------------------------------------------------

Assembler Syntax: ADDI #<data>,<ea>

Beschreibung:
Addiert Immediate Daten auf den Destination Operanden.

Gr”e:  Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | E    <=  EM”gliche Ver„nderungenF
 |
 +----------------- Wie das C-Bit.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +----------+-----------+-----------+-----------+----------
       | Dn       | (An)      | (An)+     | -(An)     | d(An)
-------+----------+-----------+-----------+-----------+----------
#      | 8/16,4/6 | 16/28,4/6 | 16/28,4/6 | 18/30,4/6 | 20/32,6/8

Quelle |   Ziel
       +-----------+-----------+------------
       | d(An,Rx)  | $xxxx     | $xxxxxxxx
-------+-----------+-----------+------------
#      | 22/34,6/8 | 20/32,6/8 | 24/36,8/10

Hinweis: ADDI wird automatisch zu EADDQF bersetzt, wenn der Quell-
operand im Bereich von 0 bis 8 liegt.

Gruppe: EArithmetische BefehleF

Querverweis: EADDF, EADDAF, EADDQF, EADDXFADDQ - Bin„re Addition (schnell)
----------------------------------------------------------------------

Assembler Syntax: ADDQ #<data>,<ea>

Beschreibung:
Addiert Immediate Daten auf den Destination Operanden. Der
Wertebereich der Immediate Daten kann im Bereich von 1 bis 8
liegen.

Gr”e:  Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | E    <=  EM”gliche Ver„nderungenF
 |
 +----------------- Wie das C-Bit.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +--------+-------+---------+---------+---------
       | Dn     | An    | (An)    | (An)+   | -(An)
-------+--------+-------+---------+---------+---------
#      | 4/8,2  | 8/8,2 | 12/20,2 | 12/20,2 | 14/22,2 

Quelle |   Ziel
       +---------+----------+---------+-----------
       | d(An)   | d(An,Rx) | $xxxx   | $xxxxxxxx
-------+---------+----------+---------+-----------
#      | 16/24,4 | 18/26,4  | 16/24,4 | 20/28,6

Hinweis: ADDQ #...,An arbeitet immer mit Langwortverarbeitung.

Gruppe: EArithmetische BefehleF

Querverweis: EADDF, EADDAF, EADDIF, EADDXFADDX - Bin„re Addition mit Extend-Bit
----------------------------------------------------------------------

Assembler Syntax: ADDX Dy,Dx
                  ADDX -(Ay),-(Ax)

Beschreibung:
Addiert den Source Operanden auf den Destination Operanden
zusammen mit dem Extended Bit.

Gr”e: Byte, Word, Long

 X | N | Z | V | C
---+---+---+---+---
 * | E | * | E | E    <=  EM”gliche Ver„nderungenF
 |       |
 |       +--------- Dieses Flag wird gel”scht, wenn das Ergebnis ungleich 
 |                  0 ist, ansonsten bleibt es unver„ndert. Es empfielt 
 |                  sich daher das Z-Flag vorher zu setzen, wenn man das 
 |                  Ergebnis auf 0 prfen will.
 +----------------- Wie das C-Bit.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle  |   Ziel
        +-------+---------
        | Dn    | -(An)
--------+-------+---------
Dn      | 4/8,2 |
-(An)   |       | 18/30,2

Gruppe: EArithmetische BefehleF

Querverweis: EADDF, EADDAF, EADDIF, EADDQFAND - Logisches UND
----------------------------------------------------------------------

Assembler Syntax: AND <ea>,Dn
                  AND Dn,<ea>

Beschreibung: Logisches UND.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+--- -
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    |   Ziel
          +----------+---------+---------+---------+---------
          | Dn       | (An)    | (An)+   | -(An)   | d(An)
----------+----------+---------+---------+---------+---------
Dn        | 4/6,2    | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 
(An)      | 8/14,2   |
(An)+     | 8/14,2   |
-(An)     | 10/16,2  |
d(An)     | 12/18,4  |
d(An,Rx)  | 14/20,4  | 
$xxxx     | 12/18,4  |
$xxxxxxxx | 16/22,6  |
d(PC)     | 12/18,4  |
d(PC,Rx)  | 14/20,4  |
#         | 8/14,4/6 |

Quelle |   Ziel
       +----------+--------+-----------
       | d(An,Rx) | $xxxx  | $xxxxxxxx
-------+----------+--------+-----------
Dn     | 18/26,4  |16/24,4 | 20/28,6

Hinweis:
AND #<data>, <ea> wird automatisch zu EANDIF bersetzt.

Gruppe: ELogische BefehleF

Querverweis: EANDIF, EANDI to CCRF, EANDI to SRFANDI - Logisches UND mit einer Konstanten
----------------------------------------------------------------------

Assembler Syntax: ANDI #<data>,<ea>
                 
Beschreibung: Logisches UND Immediate.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+--- -
 | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +----------+-----------+-----------+-----------+----------
       | Dn       | (An)      | (An)+     | -(An)     | d(An)
-------+----------+-----------+-----------+-----------+----------
#      | 8/16,4/6 | 16/28,4/6 | 16/28,4/6 | 18/30,4/6 | 20/32,6/8

Quelle |   Ziel
       +-----------+-----------+------------
       | d(An,Rx)  | $xxxx     | $xxxxxxxx
-------+-----------+-----------+------------
#      | 22/34,6/8 | 20/32,6/8 | 24/36,8/10

Gruppe: ELogische BefehleF

Querverweis: EANDF, EANDI to CCRF, EANDI to SRFANDI to CCR - Logisches UND mit einer Konstanten und dem CCR
----------------------------------------------------------------------

Assembler Syntax: ANDI #<data>,CCR
                 
Beschreibung: Logisches UND Immediate mit dem Condition Code Register.
              Dieser Befehl dient dazu gezielt Flags des CCR zu l”schen
              oder unberhrt zu lassen.

Gr”e: Byte (es k”nnen nur die unteren 5 Bit des ECCRF ver„ndert werden).

Verarbeitungszeit: 20
Befehlsl„nge     :  4

Gruppe: ELogische BefehleF

Querverweis: EANDF, EANDIF, EANDI to SRFANDI to SR - Logisches UND mit einer Konstanten und dem SR
----------------------------------------------------------------------

Assembler Syntax: ANDI #<data>,SR
                 
Beschreibung: Logisches UND Immediate mit dem Status Register.
              Dieser Befehl dient dazu gezielt Flags des SR zu l”schen
              oder unberhrt zu lassen.

Gr”e: Word (es k”nnen nur einige Bit des ESRF ver„ndert werden).

Verarbeitungszeit: 20
Befehlsl„nge     :  4

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.
          
Gruppe: ELogische BefehleF

Querverweis: EANDF, EANDIF, EANDI to CCRFASL - Arithmetische Verschiebung nach links
LSL - Logische Verschiebung nach links
----------------------------------------------------------------------
 
Assembler Syntax: ASL Dx,Dy
                  ASL #<data>,Dy
                  ASL <ea>

                  LSL Dx,Dy
                  LSL #<data>,Dy
                  LSL <ea>

(Beide Befehle sind bis auf den Opcode v”lig identisch)

Beschreibung:
Der Zieloperand wird um die angegebene Anzahl von Bit nach links 
verschoben. In die "frei"-werdenden Bit werden Nullen reingeschrieben. 
Ein Speicherinhalt  kann  nur um jeweils 1 ( Ein ) Bit geschoben 
werden und ist auf Size Word beschr„nkt. Der m”gliche Bereich fr 
<data> liegt von 1 bis 8.

Gr”e: Byte, Word, Long (Byte und Long nur wenn das Ziel ein Datenregister
                         ist).

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | * | *    <=  EM”gliche Ver„nderungenF
 |           |   |
 |           |   +--- Wird entsprechend dem letzten aus dem Ziel 
 |           |        geschobenem Bit gesetzt. Falls die Anzahl der Bit
 |           |        0 ist wird das Flag gel”scht. 
 |           +------- Wird auf 1 gesetzt falls w„hrend des Schiebens 
 |                    irgendwann ein Vorzeichenwechsel stattfand.
 +------------------- Wird wie C behandelt nur mit dem Unterschied, da das
                      Flag unberhrt bleibt, falls die Anzahl der Bit 0 
                      ist.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +-------------+------+-------+-------+-------+----------+-------
       | Dn          | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx 
-------+-------------+------+-------+-------+-------+----------+-------
Dn     | 6+2n/8+2n,2 |      |       |       |       |          |
#      | 6+2n/8+2n,2 |      |       |       |       |          |
1      |             | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4   

Quelle |   Ziel
       +-----------
       | $xxxxxxxx
-------+-----------
1      | 20,6

Hinweis: n ist die Anzahl der Bit, um die verschoben werden soll.

Gruppe: EBitschiebe- und RotierbefehleF

Querverweis: EASRF, ELSRFASR - Arithmetische Verschiebung nach rechts
----------------------------------------------------------------------
 
Assembler Syntax: ASR Dx,Dy
                  ASR #<data>,Dy
                  ASR <ea>

Beschreibung:
Der Zieloperand wird um die angegebene Anzahl von Bit nach rechts 
verschoben. Das Vorzeichen bleibt dabei unberhrt. Ein Speicherinhalt kann
nur um jeweils 1 ( Ein ) Bit geschoben werden und ist auf Size Word 
beschr„nkt. Der m”gliche Bereich fr <data> liegt von 1 bis 8.

Gr”e: Byte, Word, Long (Byte und Long nur wenn das Ziel ein Datenregister
                         ist).

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | 0 | *    <=  EM”gliche Ver„nderungenF
 |               |
 |               +--- Wird entsprechend dem letzten aus dem Ziel 
 |                    geschobenem Bit gesetzt. Falls die Anzahl der Bit
 |                    0 ist wird das Flag gel”scht. 
 +------------------- Wird wie C behandelt nur mit dem Unterschied, da das
                      Flag unberhrt bleibt, falls die Anzahl der Bit 0 
                      ist.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +-------------+------+-------+-------+-------+----------+-------
       | Dn          | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx 
-------+-------------+------+-------+-------+-------+----------+-------
Dn     | 6+2n/8+2n,2 |      |       |       |       |          |
#      | 6+2n/8+2n,2 |      |       |       |       |          |
1      |             | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4   

Quelle |   Ziel
       +-----------
       | $xxxxxxxx
-------+-----------
1      | 20,6

Hinweis: n ist die Anzahl der Bit, um die verschoben werden soll.

Gruppe: EBitschiebe- und RotierbefehleF

Querverweis: EASLF, ELSLF, ELSRFBcc - Bedingte Verzweigung
----------------------------------------------------------------------

Assembler Syntax: BEccF <label>

Beschreibung:

Falls die Bedingung ( EccF ) erfllt ist wird das Programm an der
Adresse weitegefhrt, fr die label steht.

Gr”e: Byte, Word, Long ( MC68020 )

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

EVerarbeitungszeitF und EBefehlsl„ngeF:

Bedingung  | Gr”e
           | Byte | Word 
-----------+------+------
erfllt    | 10,2 | 10,4  
nicht erf. | 8,2  | 12,4

Hinweis: Der Assembler verwendet automatisch den krzeren Befehl, wenn die
Adredistanz zwischen -128 und +127 liegt.

Gruppe: EProgrammstruktur-BefehleF

Querverweis:  EBTF, EBRAF, EDBccF, EDBRAF, EDBFF, EJMPFBCHG - Prfe ein Bit und „ndere es
----------------------------------------------------------------------

Assembler Syntax: BCHG <Dn>,<ea>
                  BCHG #<data>,<ea>

Beschreibung: Testet und invertiert ein Bit.

Gr”e: Byte (Nur Speicher als Ziel), Long (Nur Datenregister als Ziel)

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | * | - | -    <=  EM”gliche Ver„nderungenF
         |
         +--- 1 falls das Bit vorher Null war, ansonsten 0.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle | Ziel
       +-------+------+-------+-------+-------+----------+-------+-----------
       | Dn    | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
-------+-------+------+-------+-------+-------+----------+-------+-----------
Dn     | <8,2  | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4  | 20,6
#      | <12,4 | 16,4 | 16,4  | 18,4  | 20,6  | 22,6     | 20,6  | 24,8

Hinweis: Die Zeiten sind die Anzahl der Taktzyklen fr die Ausfhrung der
Operation.

Gruppe: EBit-BefehleF

Querverweis: EBCLRF, EBSETF, EBTSTFBCLR - Prfe ein Bit und setze es auf 0
----------------------------------------------------------------------

Assembler Syntax: BCLR <Dn>,<ea>
                  BCLR #<data>,<ea>

Beschreibung: Testet und l”scht ein Bit.

Gr”e: Byte (Nur Speicher als Ziel), Long (Nur Datenregister als Ziel)

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | * | - | -    <=  EM”gliche Ver„nderungenF
         |
         +--- 1 falls das Bit vorher Null war, ansonsten 0.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle | Ziel
       +-------+------+-------+-------+-------+----------+-------+-----------
       | Dn    | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
-------+-------+------+-------+-------+-------+----------+-------+-----------
Dn     | <12,2 | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4  | 20,6
#      | <14,4 | 16,4 | 16,4  | 18,4  | 20,6  | 22,6     | 20,6  | 24,8

Hinweis: Die Zeiten sind die Anzahl der Taktzyklen fr die Ausfhrung der
Operation.

Gruppe: EBit-BefehleF

Querverweis: EBCHGF, EBSETF, EBTSTFBFCHG - Prfe Bitfield und „ndere es                           MC68020
----------------------------------------------------------------------

Assembler Syntax: BFCHG <ea>{offs:width}

Beschreibung:
Invertiere ein Bit Field.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF
 
Gruppe: EBit-BefehleF

Querverweis: EBFCLRF, EBFSETF, EBFTSTFBFCLR - Prfe Bitfield und setze es auf 0                      MC68020
----------------------------------------------------------------------

Assembler Syntax: BFCLR <ea>{offs:width}

Beschreibung:
Setze ein Bit Field auf 0 ( Null ).

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Gruppe: EBit-BefehleF

Querverweis: EBFCHGF, EBFSETF, EBFTSTFBFEXTS - Extrahiere signed Bitfield                            MC68020
----------------------------------------------------------------------

Assembler Syntax: BFEXTS <ea>{offs:width},Dn

Beschreibung:
Extrahiere ein Bit Field signed 

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Gruppe: EBit-BefehleF

Querverweis: EBFEXTUF, EBFFFOF, EBFINSFBFEXTU - Extrahiere unsigned Bitfield                          MC68020
----------------------------------------------------------------------

Assembler Syntax: BFEXTU <ea>{offs:width},Dn

Beschreibung:
Extrahiere ein Bit Field unsigned 

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Gruppe: EBit-BefehleF

Querverweis: EBFEXTSF, EBFFFOF, EBFINSFBFFFO - Suche in Bitfield                                      MC68020
----------------------------------------------------------------------

Assembler Syntax: BFFFO <ea>{offs:width},Dn

Beschreibung:
Sucht das h”chste gesetzte Bit in einem Bit Field.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Gruppe: EBit-BefehleF

Querverweis: EBFEXTSF, EBFEXTUF, EBFINSFBFINS - Fge Daten in ein Bitfield ein                         MC68020
----------------------------------------------------------------------

Assembler Syntax: BFINS Dn,<ea>{offs:width}

Beschreibung:
Bewegt die untersten Bits eines Datenregisters in ein Bit Field
der spezifizierten Adresse.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Gruppe: EBit-BefehleF

Querverweis: EBFEXTSF, EBFEXTUF, EBFFFOFBFSET - Prfe Bitfield und setze es auf 1                      MC68020
----------------------------------------------------------------------

Assembler Syntax: BFSET <ea>{offs:width}

Beschreibung:
Setzt alle Bits eines Bit Fields.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Gruppe: EBit-BefehleF

Querverweis: EBFCHGF, EBFCLRF, EBFTSTFBFTST - Prfe Bitfield                                         MC68020
----------------------------------------------------------------------

Assembler Syntax: BFTST <ea>{offs:width}

Beschreibung:
Extrahiert ein Bit Field und setzt die entsprechenden Flags.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Gruppe: EBit-BefehleF

Querverweis: EBFCHGF, EBFCLRF, EBFSETFBKPT - Breakpoint                                              MC68010
----------------------------------------------------------------------

Assembler Syntax: BKPT #<data>

Beschreibung: 
Ausfhrung eines Breakpoint Acknowledge Bus Zyklus.

Gr”e: Ohne Gr”enspezifikation

Gruppe: EProgrammstruktur-BefehleF

Querverweis: EILLEGALFBRA - Verzweige immer
BT
----------------------------------------------------------------------

Assembler Syntax: BRA <label>
                  BT  <label>

Beschreibung: Verzweige auf PC + 16 Bit Displacement ( label ).

Gr”e: Byte, Word, Long (MC68020)

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Verarbeitungszeit: 10
Befehlsl„nge     : 2 (Byte) 4 (Word) 6 (Long)

Hinweis: Der Assembler verwendet automatisch den krzeren Befehl, wenn die
Adredistanz zwischen -128 und +127 liegt.

Gruppe: EProgrammstruktur-BefehleF

Querverweis: EBccF, EDBccF, EJMPFBSET - Prfe ein Bit und setze es auf 1
----------------------------------------------------------------------

Assembler Syntax: BSET Dn,<ea>
                  BSET #<data>,<ea>

Beschreibung:
Ein Bit wird getestet und das Zero-Flag entsprechend gesetzt.
Anschlieend wird das spezifizierte Bit gesetzt.

Gr”e: Byte (Nur Speicher als Ziel), Long (Nur Datenregister als Ziel)

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | * | - | -    <=  EM”gliche Ver„nderungenF
         |
         +--- 1 falls das Bit vorher Null war, ansonsten 0.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle | Ziel
       +-------+------+-------+-------+-------+----------+-------+-----------
       | Dn    | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
-------+-------+------+-------+-------+-------+----------+-------+-----------
Dn     | <8,2  | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4  | 20,6
#      | <12,4 | 16,4 | 16,4  | 18,4  | 20,6  | 22,6     | 20,6  | 24,8

Hinweis: Die Zeiten sind die Anzahl der Taktzyklen fr die Ausfhrung der
Operation.

Querverweis: EBCHGF, EBCLRF, EBTSTFBSR - Verzweige zu Unterprogramm
----------------------------------------------------------------------

Assembler Syntax: BSR <label>

Beschreibung:
Die Adresse  des  auf  den BSR-Befehl folgenden Befehls wird auf
den Stack abgelegt. Darauf wird der PC um die angegebene Distanz
ver„ndert und das Program an der Stelle fortgefhrt  auf die der
PC nun zeigt.

Gr”e: Byte, Word, Long ( MC68020 )

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Verarbeitungszeit: 18
Befehlsl„nge     : 2 (Byte) 4 (Word) 6 (Long)

Hinweis: Der Assembler verwendet automatisch den krzeren Befehl, wenn die
Adredistanz zwischen -128 und +127 liegt.

Gruppe: EProgrammstruktur-BefehleF

Querverweis: EJSRF, ERTSFBTST - Prfe ein Bit
----------------------------------------------------------------------

Assembler Syntax: BTST Dn,<ea>
                  BTST #<data>,ea

Beschreibung:
Testet spezifiziertes Bit und setzt das Zero-Flag entsprechend.

Gr”e: Byte (Nur Speicher als Ziel), Long (Nur Datenregister als Ziel)

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | * | - | -    <=  EM”gliche Ver„nderungenF
         |
         +--- 1 falls das Bit vorher Null war, ansonsten 0.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle | Ziel
       +------+------+-------+-------+-------+----------+-------+-----------
       | Dn   | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
-------+------+------+-------+-------+-------+----------+-------+-----------
Dn     | 6,2  | 8,2  | 8,2   | 10,2  | 12,4  | 14,4     | 12,4  | 16,6
#      | 10,4 | 12,4 | 12,4  | 14,4  | 16,6  | 18,6     | 16,6  | 20,8

Quelle | Ziel
       +------+-----------+------
       | d(PC) | d(PC,Rx) | #
-------+-------+----------+------
Dn     | 12,4  | 14,4     | 10,4
#      | 16,6  | 18,6     |

Hinweis: Die Zeiten sind die Anzahl der Taktzyklen fr die Ausfhrung der
Operation.

Querverweis: EBCHGF, EBCLRF, EBSETFCALLM - Springe zu Modul                                   Nur MC68020
----------------------------------------------------------------------

Assembler Syntax: CALLM #<data>,<ea>

Beschreibung:
Bewirkt einen Modulaufruf,   wobei  die  effektive Adresse auf
einen Moduldeskriptor zeigt und data die Anzahl der zu berge-
benden Parameter in Bytes angibt. Der  momentane  Modulzustand 
wird auf dem Stack abgelegt und der neue Modulzustand wird aus
der spezifizierten Adresse bernommen.

Gr”e: Ohne Gr”enspezifikation

Gruppe: EProgrammstruktur-BefehleF

Querverweis: ERTMFCAS - Vergleiche und tausche                                   MC68020
----------------------------------------------------------------------

Assembler Syntax: CAS Dc,Du,<ea>

Beschreibung:  
Es wird ein  Vergleich auf das  Vergleichs-Datenregister  Du mit  
dem durch die effektive Adresse  spezifizierten Operanden ausge-
fhrt.  Im Falle der  Gleichheit wird die  effektive Adresse mit 
dem  Wert des  Registers Du geladen.  Im Falle der  Ungleichheit 
wird das  Register Dc mit dem  Inhalt der effektiven Adresse ge-
laden. Dieser Befehl l„t sich wie der ETASF- oder der ECAS2F-Befehl
nicht unterbrechen und  eignet sich dadurch hervoragend zur Syn-
chronisation in einem Mehrprozessorsystem.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | E    <=  EM”gliche Ver„nderungenF

Querverweis: ECAS2F

Gruppe: ETransfer-BefehleFCAS2 - Vergleiche und tausche doppelt                          MC68020
----------------------------------------------------------------------

Assembler Syntax: CAS2 Dc1:Dc2,Du1:Du2,(Rn1):(Rn2)

Beschreibung:  
Es wird ein Vergleich auf die  Vergleichs-Datenregister Du1 und
Du2 mit den  durch die Register  Rn1 bzw. Rn2 indirekt spezifi-
zierte Operanden ausgefhrt. Im Falle der Gleichheit werden die
Vergleichsoperanden im Speicher mit den Werten der Register Du1
bzw. Du2 geladen. Im Falle der Ungleichheit werden die Register
Dc1 bzw. Dc2 mit diesen Vergleichsoperanden geladen. Dieser Be-
fehl  l„t sich  wie der ETASF- oder  der ECASF-Befehl nicht unter-
brechen und eignet sich dadurch hervoragend zur Synchronisation
in einem Mehrprozessorsystem.

Gr”e:  Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | E    <=  EM”gliche Ver„nderungenF

Querverweis: ECASF

Gruppe: ETransfer-BefehleFCHK - Prfe Datenregister gegen obere Grenze
----------------------------------------------------------------------

Assembler Syntax: CHK <ea>,Dn

Beschreibung: Der Wert eines Registers wird darauf untersucht
ob er innerhalb zweier Grenzen liegt. Wenn der Wert < 0  oder
gr”er als der Inhalt von <ea> ist wird eine  EExceptionF  ber
den Vektor Nummer 6 ausgel”st.

Gr”e: Word, Long ( MC68020 )

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | * | ? | ? | ?    <=  EM”gliche Ver„nderungenF
     |
     +------------- 1 falls Dn < 0, 0 falls Dn > Quelle, ansonsten ?

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    | Ziel        Die Zeiten enthalten die Anzahl der Taktzyklen fr
          +------       die Ausfhrung des Befehls, wenn KEINE Exception
          | Dn          ausgel”st wird. Eine Exception ben”tigt noch einmal
----------+------       30 Taktzyklen.
Dn        | 10,2
(An)      | 14,2
(An)+     | 14,2
-(An)     | 16,2
d(An)     | 18,4
d(An,Rx)  | 20,4
$xxxx     | 18,4
$xxxxxxxx | 22,6
d(PC)     | 18,4
d(PC,Rx)  | 20,4
#         | 14,4

Gruppe: EProgrammstruktur-BefehleF

Querverweis: ECHK2FCHK2 - Prfe Datenregister gegen zwei Grenzen                  MC68020
----------------------------------------------------------------------

Assembler Syntax: CHK2 <ea>,Rn

Beschreibung:
Der Wert eines Registers wird darauf untersucht ob er innerhalb
zweier Grenzen liegt. Wenn der Wert des Adre- oder  Datenregi-
sters innerhalb der durch die effektive  Adresse spezifizierten
Grenze liegt werden lediglich die  entsprechenden Flags gesetzt.  
Andernfalls wird eine  EExceptionF ber den  Vektor Nummer  6 aus-
gel”st.

Beispiel:
        EMC68020F     ; allow MC68020 instruction set
test:               ; checks D0 for bounds
                    ; returns if value is ok
                    ; otherwise trap
        CHK2.W      bounds, D0
        ERTSF
        
bounds: EDCF.w    20, 100

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | ? | E | ? | E    <=  EM”gliche Ver„nderungenF

Gruppe: EProgrammstruktur-BefehleF

Querverweis: ECHKF, ECMP2FCLR - L”sche den Inhalt des Operanden
----------------------------------------------------------------------

Assembler Syntax: CLR <ea>

Beschreibung:
Der Inhalt der effektiven Adresse wird auf 0 ( Null ) gesetzt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | 0 | 1 | 0 | 0    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

 Ziel
------+---------+---------+---------+---------+----------+---------
 Dn   | (An)    | (An)+   | -(An)   | d(An)   | d(An,Rx) | $xxxx   
------+---------+---------+---------+---------+----------+---------
4/6,2 | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 | 18/26,4  | 16/24,4 

 Ziel
-----------
 $xxxxxxxx
-----------
20/28,6

Gruppe: EArithmetische BefehleF

Querverweis: EMOVEFCMP - Vergleiche zwei Operanden
----------------------------------------------------------------------

Assembler Syntax: CMP <ea>,Dn

Beschreibung:
Es werden zwei Operanden verglichen. Fr den Vergleich wird der
Quell- vom Zieloperand subtrahiert.  Das Resultat  wird  jedoch
nicht geschrieben,  lediglich  die  Flags  werden  entsprechend
gesetzt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | E    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    |   Ziel
          +----------
          | Dn       
----------+----------
Dn        | 4/6,2    
An        | 4/8,2    
(An)      | 8/14,2   
(An)+     | 8/14,2   
-(An)     | 10/16,2  
d(An)     | 12/18,4  
d(An,Rx)  | 14/20,4   
$xxxx     | 12/18,4  
$xxxxxxxx | 16/22,6  
d(PC)     | 12/18,4  
d(PC,Rx)  | 14/20,4  
#         | 8/14,4/6 

Hinweise:
CMP <ea>, An wird automatisch zu ECMPAF bersetzt.
CMP #..., <ea> wird automatisch zu ECMPIF bersetzt.
CMP (Ax)+, (Ay)+ wird automatisch zu ECMPMF bersetzt.
CMP #0, D0 bzw. CMP #0, <ea> wird automatisch zu ETSTF  bersetzt.

Gruppe: EArithmetische BefehleF

Querverweis: ECMPAF, ECMPIF, ECMPMF, ECMP2FCMPA - Vergleiche zwei Operanden mit Adreregister als Ziel
----------------------------------------------------------------------

Assembler Syntax: CMPA <ea>,An

Beschreibung: Es wird die Differenz zwischen  Ziel- und Quell-
openand berechnet. Das Ergeniss wird nicht geschrieben sondern
lediglich die entsprechenden Flags gesetzt.

Gr”e: Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | E    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    |   Ziel
          +----------
          | An       
----------+----------
Dn        | 6/6,2    
An        | 6/6,2    
(An)      | 10/14,2   
(An)+     | 10/14,2   
-(An)     | 12/16,2  
d(An)     | 14/18,4  
d(An,Rx)  | 16/20,4   
$xxxx     | 14/18,4  
$xxxxxxxx | 18/22,6  
d(PC)     | 14/18,4  
d(PC,Rx)  | 16/20,4  
#         | 8/18,4/6 

Gruppe: EArithmetische BefehleF

Querverweis: ECMPF, ECMPIF, ECMPMF, ECMP2FCMPI - Vergleiche zwei Operanden mit Konstante als Quelle
----------------------------------------------------------------------

Assembler Syntax: CMPI #<data>,<ea>

Beschreibung:
Immediate Daten werden mit dem Zieloperanden  verglichen.  Dazu
wird der Ouelloperand vom Zieloperand subtrahiert. Das Resultat
wird nicht  geschrieben,  lediglich  die  entsprechenden  Flags
werden gesetzt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | E    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +----------+-----------+-----------+-----------+----------
       | Dn       | (An)      | (An)+     | -(An)     | d(An)
-------+----------+-----------+-----------+-----------+----------
#      | 8/14,4/6 | 12/20,4/6 | 12/20,4/6 | 14/22,4/6 | 16/24,6/8

Quelle |   Ziel
       +-----------+-----------+------------
       | d(An,Rx)  | $xxxx     | $xxxxxxxx
-------+-----------+-----------+------------
#      | 18/26,6/8 | 16/24,6/8 | 20/28,8/10

Gruppe: EArithmetische BefehleF

Querverweis: ECMPF, ECMPAF, ECMPMF, ECMP2FCMPM - Vergleiche zwei Speicherzellen
----------------------------------------------------------------------

Assembler Syntax: CMPM (Ay)+,(Ax)+

Beschreibung:
Es wird die Differenz  zweier  Speicherinhalte  gebildet.  Das
Ergebnis wird nicht geschrieben, lediglich die entsprechenden
Flags werden gesetzt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | E    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle | Ziel
       +---------
       | (An)+     
-------+--------- 
(An)+  | 12/20,2 

Gruppe: EArithmetische BefehleF

Querverweis: ECMPF, ECMPAF, ECMPIF, ECMP2FCMP2 - Vergleiche Datenregister mit 2 Grenzen                  MC68020
----------------------------------------------------------------------

Assembler Syntax: CMP2 <ea>,Rn

Beschreibung:
Es wird der Wert eines Adre- oder Datenregister mit den Werten
die ber die effektive Adresse spezifiziert sind auf Grenzen hin
untersucht. Die untere Grenze wird durch den Wert bestimmt der
direkt ber die effektive Adresse angegeben wurde.
Der obere Grenzwert liegt an der effektiven Adresse plus den Wert
der Operandengr”e.

Beispiel:
        EMC68020F     ; allow MC68020 instruction set
test:               ; checks D0 for bounds
                    ; returns TRUE if value is ok
                    ; otherwise FALSE
        CMP2.W      bounds, D0
        ESCCF         D0
        ERTSF
        
bounds: EDCF.w    20, 100

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | ? | * | ? | *    <=  EM”gliche Ver„nderungenF
         |       |
         |       +-- 1, wenn Rn auserhalb der Grenzen liegt, 
         |           ansonsten 0.
         +---------- 1, wenn Rn auf einer der beiden Grenzen
                     liegt, ansonsten 0.

Gruppe: EArithmetische BefehleF

Querverweis: ECMPF, ECMPAF, ECMPIF, ECMPMFDBcc - Prfe Bedingung, dekrementiere und verzweige
----------------------------------------------------------------------

Assembler Syntax: DBEccF Dn,<label>

Beschreibung:
Diese Befehl erm”glich es eine einfache Schleife zu programmieren.
Zuerst wird die  ber  EccF  spezifizierte  Bedingung  geprft um
festzustellen ob die Abbruchsbedingung  fr  die Schleife erreicht
ist. Wenn dies der Fall ist wird keine weitere Aktion vorgenommen.
Wenn die Abbruchsbedingung nicht erfllt ist,  werden  die unteren
16 Bit ( Achtung: Word ) um 1  ( Eins )  dekrementiert.  Wenn  das
Ergebnis -1 (Achtung:  Minus Eins) ist, wird die Schleife  beendet.
Andernfalls wird auf die durch label  spezifizierte  Adresse  ver-
zweigt.

Gr”e: Word, Long (MC68020)

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF
 
Verarbeitungszeiten: 
                
cc nicht erfllt, Dn=-1 : 14 (Sprung findet nicht statt)
cc erfllt              : 12 (   "     "      "     "  )
cc nicht erfllt, Dn>-1 : 10 (Sprung findet statt)

Befehlsl„nge: immer 4

Hinweis:
DBT Dn,<label> tut nichts, da die Bedingung immer erfllt ist. Man
kann deshalb auf diesen Befehl verzichten.
   
Gruppe: EProgrammstruktur-BefehleF

Querverweis: EBccF, EBRAF, EDBRAF, EJMPFDBRA - Dekrementiere und verzweige
DBF
----------------------------------------------------------------------

Assembler Syntax: DBRA Dn,<label>
                  DBF  Dn,<label>

Beschreibung:
Die unteren 16 Bit ( Achtung: Word )  werden um 1  ( Eins ) dekre-
mentiert.  Wenn  das Ergebnis -1 ( Achtung: Minus Eins ) ist, wird
die  Schleife beendet. Andernfalls wird auf die durch label spezi-
fizierte Adresse verzweigt.

Gr”e: Word, Long ( MC68020 )

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF
 
Verarbeitungszeiten: 
                
Dn=-1 : 14 (Sprung findet nicht statt)
Dn>-1 : 10 (Sprung findet statt)

Befehlsl„nge: immer 4

Gruppe: EProgrammstruktur-BefehleF

Querverweis: EBccF, EBRAF, EDBccF, EJMPFDIVS - Division mit Vorzeichen
----------------------------------------------------------------------

Assembler Syntax: DIVS.W <ea>,Dn      32/16 -> 16r:16q
                  DIVS.L <ea>,Dq      32/32 -> 32q     ( MC68020 )
                  DIVS.L <ea>,Dr:Dq   64/32 -> 32r:32q ( MC68020 )
                  DIVSL.L <ea>,Dr:Dq  32/32 -> 32r:32q ( MC68020 )

Beschreibung:
Es wird  eine Division des Zieloperanden durch den  Ouelloperanden
unter  Beachtung des Vorzeichens ausgefhrt.  Das Resultat wird im
Zieloperanden  als 32 Bit Wert abgelegt, wobei im unteren Wort des
Registers der  Ouotient steht und im oberen  Wort  der  Divisions-
rest.    Der  Divisionsrests  hat  das  selbe  Vorzeichen  wie der
Dividend.   Der  Zieloperand   kann  auf  einem   MC68020   gr”er
als 16  Bit  sein.   Bei  einer  Division  durch  Null  wird  eine
EExceptionF ber den Vektor Nummer 5 ausgel”st.

Gr”e: Word, Long ( MC68020 )

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | 0    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    | Ziel
          +-------
          | Dn       
----------+-------
Dn        | 158,2 Bei der Anzahl der Taktzyklen handelt es sich dabei   
(An)      | 162,2 um einen Maximalwert.  
(An)+     | 162,2   
-(An)     | 164,2  
d(An)     | 166,4  
d(An,Rx)  | 168,4   
$xxxx     | 166,4  
$xxxxxxxx | 170,6  
d(PC)     | 166,4  
d(PC,Rx)  | 168,4  
#         | 162,4 

Hinweis: Oft ist es ratsam, diesen Befehl durch andere Operationen zu 
         ersetzen. So bewirkt z.B DIVS #2,Dn das gleiche wie 
         EASRF.L #1, Dn

Gruppe: EArithmetische BefehleF

Querverweis: EDIVUF, EMULSF, EMULUFDIVU - Division ohne Vorzeichen
----------------------------------------------------------------------

Assembler Syntax: DIVU.W <ea>,Dn      32/16 -> 16r:16q
                  DIVU.L <ea>,Dq      32/32 -> 32q     ( MC68020 )
                  DIVU.L <ea>,Dr:Dq   64/32 -> 32r:32q ( MC68020 )
                  DIVUL.L <ea>,Dr:Dq  32/32 -> 32r:32q ( MC68020 )

Beschreibung:
Es wird  eine Division des Zieloperanden durch den  Ouelloperanden
ohne  Beachtung  des Vorzeichens ausgefhrt.  Das Resultat wird im
Zieloperanden  als 32 Bit Wert abgelegt, wobei im unteren Wort des
Registers der  Ouotient steht und im oberen  Wort  der  Divisions-
rest.   Der   Divisionsrests  hat  das  selbe  Vorzeichen  wie der
Dividend.   Der  Zieloperand   kann  auf  einem   MC68020   gr”er
als  16  Bit  sein.  Bei  einer  Division  durch  Null  wird  eine
EExceptionF ber den Vektor Nummer 5 ausgel”st.

Gr”e: Word, Long ( MC68020 )

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | 0    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    | Ziel
          +------
          | Dn       
----------+------
Dn        | 140,2 Bei der Anzahl der Taktzyklen handelt es sich dabei   
(An)      | 144,2 um einen Maximalwert.  
(An)+     | 144,2   
-(An)     | 146,2  
d(An)     | 148,4  
d(An,Rx)  | 150,4   
$xxxx     | 148,4  
$xxxxxxxx | 152,6  
d(PC)     | 148,4  
d(PC,Rx)  | 150,4  
#         | 144,4 

Hinweis: Oft ist es ratsam, diesen Befehl durch andere Operationen zu 
         ersetzen. So bewirkt z.B DIVU #2,Dn das gleiche wie 
         ELSRF.L #1, Dn

Gruppe: EArithmetische BefehleF

Querverweis: EDIVSF, EMULSF, EMULUFEOR - Logisches Exklusiv-ODER
----------------------------------------------------------------------

Assembler Syntax: EOR Dn,<ea>

Beschreibung:
Logische Exclusive-Oder-Verkpfung.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    |   Ziel
          +----------+---------+---------+---------+---------
          | Dn       | (An)    | (An)+   | -(An)   | d(An)
----------+----------+---------+---------+---------+---------
Dn        | 4/8,2    | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 

Quelle |   Ziel
       +----------+--------+-----------
       | d(An,Rx) | $xxxx  | $xxxxxxxx
-------+----------+--------+-----------
Dn     | 18/26,4  |16/24,4 | 20/28,6

Hinweis:
EOR #...,<ea> wird automatisch zu EEORIF bersetzt.

Gruppe: ELogische BefehleF

Querverweis: EEORIF, EEORI to CCRF, EEORI to SRFEOR - Logisches Exklusiv-ODER mit einer Konstanten
----------------------------------------------------------------------

Assembler Syntax: EORI #<data>,<ea>
                 
Beschreibung:
Logische Exclusive-Oder-Verknpfung von konstanten Daten auf den
Zieloperanden.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +----------+-----------+-----------+-----------+---------
       | Dn       | (An)      | (An)+     | -(An)     | d(An)
-------+----------+-----------+-----------+-----------+---------
#      | 8/16,4/6 | 16/28,4/6 | 16/28,4/6 | 18/30,4/6 | 20/32,6/8

Quelle |   Ziel
       +------------+----------+------------
       | d(An,Rx)   | $xxxx    | $xxxxxxxx
-------+------------+----------+------------
#      | 22/34,6/8  |20/32,6/8 | 24/36,8/10

Gruppe: ELogische BefehleF

Querverweis: EEORF, EEORI to CCRF, EEORI to SRFEORI to CCR - Logisches Exklusiv-ODER mit einer Konstanten und dem CCR
----------------------------------------------------------------------

Assembler Syntax: EORI #<data>,CCR
                 
Beschreibung:
Logische Exclusive-Oder-Verknpfung von konstanten Daten auf das
Condition Code Register.

Gr”e: Byte (es k”nnen nur die unteren 5 Bit des ECCRF ver„ndert werden).

Verarbeitungszeit: 20
Befehlsl„nge     :  4

Gruppe: ELogische BefehleF

Querverweis: EEORF, EEORIF, EEORI to SRFEORI to SR - Logisches Exklusiv-ODER mit einer Konstanten und dem SR
----------------------------------------------------------------------

Assembler Syntax: EORI #<data>,SR
                 
Beschreibung:
Logische Exclusive-Oder-Verknpfung von konstanten Daten auf das
Status Register.

Gr”e: Word (es k”nnen nur einige Bit des ESRF ver„ndert werden).

Verarbeitungszeit: 20
Befehlsl„nge     :  4

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.
          
Gruppe: ELogische BefehleF

Querverweis: EEORF, EEORIF, EEORI to SRFEXG - Vertausche Registerinhalte
----------------------------------------------------------------------

Assembler Syntax: EXG Rx,Ry

Beschreibung:
Der Inhalt zweier Register wird vertauscht.

Gr”e: Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +-----+-----
       | Dn  | An
-------+-----+-----
Dn     | 6,2 | 6,2
An     | 6,2 | 6,2

Gruppe: ETransfer-BefehleFEXT - Vorzeichenrichtige Erweiterung eines Datenregisters
----------------------------------------------------------------------

Assembler Syntax: EXT.W Dn   Erweitere Byte zu Word
                  EXT.L Dn   Erweitere Word zu Long
                  EXTB.L Dn  Erweitere Byte zu Longword ( MC68020 )
Beschreibung:
Das Vorzeichen-Bit wird je nach  Gr”enspezifikation  auf  jeweils
8, 16 oder 32 h”herwertige Bits bertragen.

Gr”e: Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Verarbeitungszeit: 4
Befehlsl„nge     : 2

Gruppe: EArithmetische BefehleFILLEGAL - Unzul„ssiger Opcode
----------------------------------------------------------------------

Assembler Syntax: ILLEGAL

Beschreibung:
Wird dieser Befehl von der CPU entdeckt, wird eine EExceptionF ber
den Vektor Nummer 4 ausgel”st.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Verarbeitungszeit: 34 Anzahl der Taktzyklen bis sich die CPU im 
                      Exceptionhandler befindet.
Befehlsl„nge     : 2

Hinweis: Der Opcode mit der Nummer $4AFC ist von Motorola fr diesen
         Befehl reserviert. Damit lassen sich einfach Breakpoints 
         setzen.

Gruppe: EProgrammstruktur-BefehleF

Querverweis: EBKPTFJMP - Sringe zu Adresse
----------------------------------------------------------------------

Assembler Syntax: JMP <ea>

Beschreibung:
Das Program wird an der durch die effektive Adresse angegebenen
Stelle fortgesetzt.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

 Ziel (Die Anzahl der Taktzyklen gelten fr die Ausfhrung des Befehls)
------+-------+----------+-------+-----------+-------+----------
 (An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx | d(PC) | d(PC,Rx)
------+-------+----------+-------+-----------+-------+----------
 8,2  | 10,4  | 14,4     | 10,4  | 12,6      | 10,4  | 14,4

Gruppe: EProgrammstruktur-BefehleF

Querverweis:  EBRAF, EBccF, EDBccFJSR - Springe in Unterprogramm
----------------------------------------------------------------------

Assembler Syntax: JSR <ea>

Beschreibung:
Die Adresse des auf den JSR-Befehl folgenden  Befehls  wird  auf
den Stack abgelegt. Darauf wird der PC auf die angegebene Adresse
ver„ndert und das Program an der Stelle fortgefhrt auf die  der
PC nun zeigt.

Gr”e: Ohne Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

 Ziel (Die Anzahl der Taktzyklen gelten fr die Ausfhrung des Befehls)
------+-------+----------+-------+-----------+-------+----------
 (An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx | d(PC) | d(PC,Rx)
------+-------+----------+-------+-----------+-------+----------
 16,2 | 18,4  | 22,4     | 18,4  | 20,6      | 18,4  | 22,4

Gruppe: EProgrammstruktur-BefehleF

Querverweis: EBSRF, ERTSFLEA - Lade Adresse in ein Adreregister
----------------------------------------------------------------------

Assembler Syntax: LEA <ea>,An

Beschreibung:
Die effektive Adresse wird in das spezifizierte Adreregister
geladen. Im Gegensatz zu EMOVEAF wird nicht der Quelloperand 
zum Adreregister geladen sondern dessen Adresse.

Gr”e: Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    | Ziel
          +------
          | An
----------+------
(An)      | 4,2
d(An)     | 8,4
d(An,Rx)  | 12,4
$xxxx     | 8,4
$xxxxxxxx | 12,6
d(PC)     | 8,4
d(PC,Rx)  | 12,4

Hiweis:
LEA d(An), An sollte durch EADDQF #d, An ersetzt werden, wenn das
Displacement im Bereich von 0 bis 7 liegt.

Gruppe: ETransfer-BefehleFLINK - Lege neuen Stackbereich an
----------------------------------------------------------------------
 
Assembler Syntax: LINK.W An,#<displacement>
                  LINK.L An,#<displacement> ( MC68020 )
Beschreibung:
Das spezifizierte Adreregister wird auf den Stack abgelegt.
Danach wird das Adreregister mit dem neuen Stackpointer geladen.
Zuletzt wird das displacement auf das Adreregister addiert.
Um einen lokalen Stack aufzubauen wird ein negatives Displacement
angegeben.

Zur Veranschaulichung soll hier ein alternativer Code angegeben
werden:

EPEAF     (An)
EMOVEAF.L A7, An
EADDAF.L  #<displacement>, A7

Gr”e: Word, Long ( MC68020 )

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Verarbeitungszeit: 18 
Befehlsl„nge     : 4

Gruppe: ETransfer-BefehleF

Querverweis: EUNLKFLSR - Logische Verschiebung nach rechts
----------------------------------------------------------------------
 
Assembler Syntax: LSR Dx,Dy
                  LSR #<data>,Dy
                  LSR <ea>

Beschreibung:
Der Zieloperand wird um die angegebene Anzahl von Bit nach rechts 
verschoben. Die "frei"-werdenden Stellen werden mit 0 gefllt. Ein 
Speicherinhalt kann nur um jeweils 1 ( Ein ) Bit geschoben werden und 
ist auf Size Word beschr„nkt. Der m”gliche Bereich fr <data> liegt von 1 bis 8.

Gr”e: Byte, Word, Long (Byte und Long nur wenn das Ziel ein Datenregister
                         ist).

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | * | *    <=  EM”gliche Ver„nderungenF
 |           |   |
 |           |   +--- Wird entsprechend dem letzten aus dem Ziel 
 |           |        geschobenem Bit gesetzt. Falls die Anzahl der Bit
 |           |        0 ist wird das Flag gel”scht. 
 |           +------- Wird auf 1 gesetzt falls w„hrend des Schiebens 
 |                    ein Vorzeichenwechsel stattfand.
 +------------------- Wird wie C behandelt nur mit dem Unterschied, da das
                      Flag unberhrt bleibt, falls die Anzahl der Bit 0 
                      ist.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +-------------+------+-------+-------+-------+----------+-------
       | Dn          | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx 
-------+-------------+------+-------+-------+-------+----------+-------
Dn     | 6+2n/8+2n,2 |      |       |       |       |          |
#      | 6+2n/8+2n,2 |      |       |       |       |          |
1      |             | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4   

Quelle |   Ziel
       +-----------
       | $xxxxxxxx
-------+-----------
1      | 20,6

Hinweis: n ist die Anzahl der Bit, um die verschoben werden soll.

Gruppe: EBitschiebe- und RotierbefehleF

Querverweis: EASLF, EASRF, ELSLFMOVE - šbertrage Daten
----------------------------------------------------------------------

Assembler Syntax: MOVE <ea>,<ea>

Beschreibung:
Der Inhalt des Source Operanden wird zum Ziel bewegt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0   <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    |   Ziel
          +----------+-----------+-----------+-----------+-----------
          | Dn       | (An)      | (An)+     | -(An)     | d(An)
----------+----------+-----------+-----------+-----------+-----------
Dn        | 4/4,2    | 8/12,2    | 8/12,2    | 8/14,2    | 12/16,4
An        | 4/4,2    | 8/12,2    | 8/12,2    | 8/14,2    | 12/16,4
(An)      | 8/12,2   | 12/20,2   | 12/20,2   | 12/20,2   | 16/24,4
(An)+     | 8/12,2   | 12/20,2   | 12/20,2   | 12/20,2   | 16/24,4
-(An)     | 10/14,2  | 14/22,2   | 14/22,2   | 14/22,2   | 18/26,4
d(An)     | 12/16,4  | 16/24,4   | 16/24,4   | 16/24,4   | 20/28,6
d(An,Rx)  | 14/18,4  | 18/26,4   | 18/26,4   | 18/26,4   | 22/30,6
$xxxx     | 12/16,4  | 16/24,4   | 16/24,4   | 16/24,4   | 20/28,6
$xxxxxxxx | 16/20,6  | 20/28,6   | 20/28,6   | 20/28,6   | 24/32,8
d(PC)     | 12/16,4  | 16/24,4   | 16/24,4   | 16/24,4   | 20/28,6
d(PC,Rx)  | 14/18,4  | 18/26,4   | 18/26,4   | 18/26,4   | 22/30,6
#         | 8/12,4/6 | 12/20,4/6 | 12/20,4/6 | 12/20,4/6 | 16/24,6/8

Quelle    |   Ziel
          +-----------+-----------+------------
          | d(An,Rx)  | $xxxx     | $xxxxxxxx
----------+-----------+-----------+------------
Dn        | 14/18,4   | 12/16,4   | 16/20,6
An        | 14/18,4   | 12/16,4   | 16/20,6
(An)      | 18/26,4   | 16/24,4   | 20/28,6
(An)+     | 18/26,4   | 16/24,4   | 20/28,6
-(An)     | 20/28,4   | 18/26,4   | 22/30,6
d(An)     | 22/30,6   | 20/28,6   | 24/32,8
d(An,Rx)  | 24/32,6   | 22/30,6   | 26/34,8
$xxxx     | 22/30,6   | 20/28,6   | 24/32,8
$xxxxxxxx | 26/34,8   | 24/32,8   | 28/36,10
d(PC)     | 22/30,6   | 20/28,6   | 24/32,8
d(PC,Rx)  | 24/32,6   | 22/30,6   | 26/34,8
#         | 18/26,6/8 | 16/24,6/8 | 20/28,8/10

Hinweis:
MOVE   <ea>,An    wird automatisch zu EMOVEAF bersetzt.
MOVE.L #<data>,Dn wird automatisch zu EMOVEQF bersetzt, wenn <data> im 
Bereich von -128 bis +127 liegt.
Fr MOVE #0,Dn sollte man besser ECLRF Dn verwenden.

Gruppe: ETransfer-BefehleF

Querverweis: EMOVE to CCRF, EMOVE from CCRF, EMOVE to SRF, EMOVE from SRF,
             EMOVE from USPF, EMOVE to USPF, EMOVEAF, EMOVECF, EMOVEMF, 
             EMOVEPF, EMOVEQF, EMOVESF, EMOVE16FMOVE16 - šbertrage 16-Byte-Block                               MC68040
----------------------------------------------------------------------

Assembler Syntax: MOVE16 <ea>,<ea>

Beschreibung:
MOVE16 bewegt einen auf einer 16-Byte-Grenze beginnenden 16 Byte
groen Block zur ebenfalls ausgerichteten Zieladresse. Dieser
Befehl arbeitet nur im Speicher, d.h. Register k”nnen mit ihm
nicht geladen werden.

Gr”e: Auf 16-Byte-Grenze ausgerichteter 16 Byte-Block.

Gruppe: ETransfer-BefehleF

Querverweis: EMOVEFMOVE to CCR - šbertrage ein Datum ins Condition Code Register
----------------------------------------------------------------------

Assembler Syntax: MOVE.W <ea>,ccr

Beschreibung:
Der Inhalt des Source Operanden wird zum CCR bewegt.

Gr”e: Word (es k”nnen nur einige Bit des ECCRF ver„ndert werden).

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    | Ziel
          +------
          | CCR
----------+------
Dn        | 12,2
(An)      | 16,2
(An)+     | 16,2
-(An)     | 18,2
d(An)     | 20,4
d(An,Rx)  | 22,4
$xxxx     | 20,4
$xxxxxxxx | 24,6
d(PC)     | 20,4
d(PC,Rx)  | 22,4
#         | 16,4

Gruppe: ETransfer-BefehleF

Querverweis: EMOVEF, EMOVE from CCRF, EMOVE to SRF, EMOVE from SRF,
             EMOVE from USPF, EMOVE to USPF, EMOVEAF, EMOVECF, EMOVEMF, 
             EMOVEPF, EMOVEQF, EMOVESFMOVE from CCR - šbertrage Datum aus Condition Code Register    MC68010
----------------------------------------------------------------------

Assembler Syntax: MOVE.W CCR,<ea>

Beschreibung:
Der Inhalt des CCR wird zum Ziel bewegt. Es werden jedoch nur einige Bit 
des ECCRF bertragen, die brigen werden auf 0 gesetzt.

Gr”e: Word 

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -   <=  EM”gliche Ver„nderungenF

Gruppe: ETransfer-BefehleF

Querverweis: EMOVEF, EMOVE to CCRF, EMOVE to SRF, EMOVE from SRF,
             EMOVE from USPF, EMOVE to USPF, EMOVEAF, EMOVECF, EMOVEMF, 
             EMOVEPF, EMOVEQF, EMOVESFMOVE to SR - šbertrage ein Datum ins Status Register
----------------------------------------------------------------------

Assembler Syntax: MOVE.W <ea>,SR

Beschreibung:
Der Inhalt des Source Operanden wird zum SR bewegt.

Gr”e: Word (es k”nnen nur einige Bit des ESRF ver„ndert werden).

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    | Ziel
          +------
          | SR
----------+------
Dn        | 12,2
(An)      | 16,2
(An)+     | 16,2
-(An)     | 18,2
d(An)     | 20,4
d(An,Rx)  | 22,4
$xxxx     | 20,4
$xxxxxxxx | 24,6
d(PC)     | 20,4
d(PC,Rx)  | 22,4
#         | 16,4

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.

Gruppe: ETransfer-BefehleF

Querverweis: EMOVEF, EMOVE to CCRF, EMOVE from CCRF, EMOVE from SRF,
             EMOVE from USPF, EMOVE to USPF, EMOVEAF, EMOVECF, EMOVEMF, 
             EMOVEPF, EMOVEQF, EMOVESFMOVE from SR - šbertrage ein Datum aus dem Status Register
----------------------------------------------------------------------

Assembler Syntax: MOVE.W SR,<ea>

Beschreibung:
Der Inhalt des SR wird zum Ziel bewegt. Es werden jedoch nur einige Bit 
des ECCRF bertragen, die brigen werden auf 0 gesetzt.

Gr”e: Word 

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -   <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle | Ziel
       +-----+------+-------+-------+-------+----------+-------+-----------
       | Dn  | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
-------+-----+------+-------+-------+-------+----------+-------+-----------
SR     | 6,2 | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4  | 20,6

Achtung: Dieser Befehl ist bei den CPUs ab 68010 privilegiert, d.h. diese 
         Prozessororen mssen sich im Supervisormode befinden, um ihn 
         korrekt ausfhren zu k”nnen. Sie sollten ihn auch auf 68000er Sys-
         temen nur im Supervisermode verwenden um kompatibel zu bleiben.

Gruppe: ETransfer-BefehleF

Querverweis: EMOVEF, EMOVE to CCRF, EMOVE from CCRF, EMOVE to SRF, 
             EMOVE from USPF, EMOVE to USPF, EMOVEAF, EMOVECF, EMOVEMF, 
             EMOVEPF, EMOVEQF, EMOVESFMOVE USP - šbertrage Inhalt des User Stack Pointers
----------------------------------------------------------------------

Assembler Syntax: MOVE USP,An
                  MOVE An,USP

Beschreibung:
Der Inhalt des User Stack Pointers wird in ein Adreregister bertragen 
oder der Inhalt eines Adreregisters wird zum EUSPF bertragen.

Gr”e: Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -   <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle | Ziel
       +-----+-----
       | USP | An
-------+-----+-----
USP    |     | 4/2
An     | 4/2 |

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.

Gruppe: ETransfer-BefehleF

Querverweis: EMOVEF, EMOVE to CCRF, EMOVE from CCRF, EMOVE to SRF, 
             EMOVE from SRF, EMOVEAF, EMOVECF, EMOVEMF, EMOVEPF, EMOVEQF, EMOVESFMOVEA - šbertrage Daten in ein Adreregister
----------------------------------------------------------------------

Assembler Syntax: MOVEA <ea>,An

Beschreibung:
Der Inhalt des Source Operanden wird zu einem Adreregister bewegt. 
Die Gr”enspezifikation ist auf  Word und  Long beschr„nkt. Ist die 
Word Gr”e spezifiziert, wird vor  der Operation  automatisch  eine
Wandlung des Source Operanden auf 32 Bit unter Beachtung des Vor-
zeichens vorgenommen.

Gr”e: Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    | Ziel
          +----------
          | An
----------+----------
Dn        | 4/4,2
An        | 4/4,2
(An)      | 8/12,2
(An)+     | 8/12,2
-(An)     | 10)14,2
d(An)     | 12/16,4
d(An,Rx)  | 14/18,4
$xxxx     | 12/16,4
$xxxxxxxx | 16/20,6
d(PC)     | 12/16,4
d(PC,Rx)  | 14/18,4
#         | 8/12,4/6 

Gruppe: ETransfer-BefehleF

Querverweis: EMOVEF, EMOVE to CCRF, EMOVE from CCRF, EMOVE to SRF, EMOVE from SRF,
             EMOVE from USPF, EMOVE to USPF, EMOVECF, EMOVEMF, EMOVEPF, 
             EMOVEQF, EMOVESFMOVEC - šbertrage Kontrolregister                MC68010, privilegiert
----------------------------------------------------------------------

Assembler Syntax: MOVEC cr,Rn
                  MOVEC Rn,cr

Beschreibung:
Kopiert den Inhalt des angegebenen ECPU-KontrollregisterFs in ein
allgemeines Register und umgekehrt.

Gr”e: Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.

Gruppe: ETransfer-BefehleF

Querverweis: EMOVEF, EMOVE to CCRF, EMOVE from CCRF, EMOVE to SRF, EMOVE from SRF,
             EMOVE from USPF, EMOVE to USPF, EMOVEAF, EMOVEMF, EMOVEPF, 
             EMOVEQF, EMOVESFMOVEM - šbertrage mehrere Register
----------------------------------------------------------------------

Assembler Syntax: MOVEM reglist,<ea>
                  MOVEM <ea>,reglist
Beschreibung:
Die durch  reglist  bezeichneten  Register  werden  an  der durch
die effektive Adresse angegebenen Speicherstelle  abgelegt,  bzw.
aus dem Speicher  in  die  Register  geschrieben.  Dieser  Befehl
erm”glicht das schnelle Retten und Wiederherstellen von Register-
inhalten. Wenn Sie Gr”e Word angeben und das Ziel die  Register-
liste ist, werden die  Worddaten vorzeichenrichtig auf 32 Bit er-
weitert und dann in das Register geschrieben.

Gr”e: Word, Long

Ablagereihenfolge:

Register -> Speicher (Ziel: -(An))
A7 A6 A5 A4 A3 A2 A1 A0 D7 D6 D5 D4 D3 D2 D1 D0
---------------------------------------------->

Speicher -> Register (Quelle: (An)+)
D0 D1 D2 D3 D4 D5 D6 D7 A0 A1 A2 A3 A4 A5 A6 A7
---------------------------------------------->

Alle anderen F„lle
D0 D1 D2 D3 D4 D5 D6 D7 A0 A1 A2 A3 A4 A5 A6 A7
---------------------------------------------->

Gr”e: Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    | Ziel
          +---------------+-------------+-------------+---------------
          | Dn/An         | (An)        | -(An)       | d(An)
----------+---------------+-------------+-------------+---------------
Dn/An     |               | 8+4n/8+8n,4 | 8+4n/8+8n,4 | 12+4n/12+8n,6
(An)      | 12+4n/12+8n,4 | 
(An)+     | 12+4n/12+8n,4 | 
d(An)     | 16+4n/16+8n,6 | 
d(An,Rx)  | 18+4n/18+8n,6 | 
$xxxx     | 16+4n/16+8n,6 | 
$xxxxxxxx | 20+4n/20+8n,8 | 
d(PC)     | 16+4n/16+8n,6 | 
d(PC,Rx)  | 18+4n/18+8n,6 | 

Quelle    | Ziel
          +---------------+---------------+---------------
          | d(An,Rx)      | $xxxx         | -(An)
----------+---------------+---------------+---------------
Dn/An     | 14+4n/14+8n,6 | 12+4n/12+8n,6 | 16+4n/16+8n,8

Hinweis:
n ist die Anzahl der Register.

Gruppe: ETransfer-BefehleF

Querverweis: EMOVEF, EMOVE to CCRF, EMOVE from CCRF, EMOVE to SRF, EMOVE from SRF,
             EMOVE from USPF, EMOVE to USPF, EMOVEAF, EMOVECF, EMOVEPF, 
             EMOVEQF, EMOVESFMOVEP - šbertrage Daten fr die Peripherie
----------------------------------------------------------------------

Assembler Syntax: MOVEP Dx,dist((Ay)
                  MOVEP dist(Ay),Dx
Beschreibung:
Es werden  Register-Daten  in  den  Speicher  bzw. vom Speicher
in ein Register bewegt. Dabei wird die Speicheradresse nicht wie
blich per Byte um Eins erh”ht,  sondern  um Zwei.  Dies hat zur
Folge, da der Byte Transfer sich  entweder  ausschlielich  auf
den  unteren  oder  den  oberen 8 Bit eines 16 Bit breiten Buses
abspielen kann.

Dieser Befehl dient haupts„chlich zur Erleichterung  des  Daten-
transfers von und zu 8-Bit Peripherieger„ten.

Der MOVEP-Befehl ist der einzige, der Wort- bzw. Langwortdaten an 
einer ungeraden Adresse bertragen kann.

Gr”e: Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle | Ziel
       +---------+---------
       | Dn      | d(An)
-------+---------+---------
Dn     |         | 16/24,4
d(An)  | 16/24,4 |

Gruppe: ETransfer-BefehleF

Querverweis: EMOVEF, EMOVE to CCRF, EMOVE from CCRF, EMOVE to SRF, EMOVE from SRF,
             EMOVE from USPF, EMOVE to USPF, EMOVEAF, EMOVECF, EMOVEMF,
             EMOVEQF, EMOVESFMOVEQ - šbertrage Konstante schnell in ein Datenregister
----------------------------------------------------------------------

Assembler Syntax: MOVEQ #<data>,Dn

Beschreibung:
Bewegt konstante Daten in ein Datenregister.  Der Wertebereich
der konstanten Daten kann 8-Bit gro sein und reicht damit von
-127 bis +128. 

Gr”e: Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+--- 
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle | Ziel
       +-----
       | Dn
-------+-----
#      | 4,2

Gruppe: ETransfer-BefehleF

Querverweis: EMOVEF, EMOVE to CCRF, EMOVE from CCRF, EMOVE to SRF, EMOVE from SRF,
             EMOVE from USPF, EMOVE to USPF, EMOVEAF, EMOVECF, EMOVEMF,
             EMOVEPF, EMOVESFMOVES - šbertrage Register via DFC oder SFC      MC68010, privilegiert
----------------------------------------------------------------------

Assembler Syntax: MOVES Rn,<ea>
                  MOVES <ea>,Rn

Beschreibung:
Bewegt den Inhalt des allgemeinen  Register Rn an  die angege-
bene effektive Addresse und  benutzt dabei den im  Destination
Function Code Register (EDFCF)  spezifizierten Funktionscode. Im
umgekehrten Fall wird der im ESource Function CodeF Register ge-
speicherte Funktionscode verwendet.  Der Funktionscode wird im
Normalfall automatisch von der CPU gesetzt  und dient dazu der
externen  Harware  mitzuteilen,  ob sich z.B der  Prozessor im 
Supervisormode befindet.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF
 
Gruppe: ETransfer-BefehleF

Querverweis: EMOVEF, EMOVE to CCRF, EMOVE from CCRF, EMOVE to SRF, EMOVE from SRF,
             EMOVE from USPF, EMOVE to USPF, EMOVEAF, EMOVECF, EMOVEMF,
             EMOVEPF, EMOVEQFMULS - Multiplikation mit Vorzeichen
----------------------------------------------------------------------

Assembler Syntax: MULS.W <ea>,Dn    16*16->32
                  MULS.L <ea>,Dl    32*32->32   ( MC68020 )
                  MULS.L <ea>,Dh:Dl 32*32->64   ( MC68020 )

Beschreibung:
Zwei  Operanden  werden  unter  Beachtung  des  Vorzeichens
miteinander multipliziert.

Gr”e: Word, Long (MC68020)

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | 0    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    | Ziel
          +-------
          | Dn       
----------+-------
Dn        | 70,2  Bei der Anzahl der Taktzyklen handelt es sich dabei  
(An)      | 74,2  um einen Maximalwert.
(An)+     | 74,2   
-(An)     | 76,2  
d(An)     | 78,4  
d(An,Rx)  | 80,4   
$xxxx     | 78,4  
$xxxxxxxx | 82,6  
d(PC)     | 78,4  
d(PC,Rx)  | 80,4  
#         | 74,4 

Hinweis: Oft ist es ratsam, diesen Befehl durch andere Operationen zu 
         ersetzen. So kann man eine Multiplikation mit einer Potenz
         von 2 leicht auf eine Verschiebung mit EASLF oder ELSLF
         zurckfhren.

Gruppe: EArithmetische BefehleF

Querverweis: EDIVSF, EDIVUF, EMULUFMULU - Multiplikation ohne Vorzeichen
----------------------------------------------------------------------

Assembler Syntax: MULU.W <ea>,Dn    16*16->32
                  MULU.L <ea>,Dl    32*32->32   ( MC68020 )
                  MULU.L <ea>,Dh:Dl 32*32->64   ( MC68020 )

Beschreibung:
Zwei  Operanden  werden  ohne  Beachtung  des  Vorzeichens
miteinander multipliziert.

Gr”e: Word, Long ( MC68020 )

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | E | 0    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    | Ziel
          +-------
          | Dn       
----------+-------
Dn        | 70,2  Bei der Anzahl der Taktzyklen handelt es sich dabei  
(An)      | 74,2  um einen Maximalwert.
(An)+     | 74,2   
-(An)     | 76,2  
d(An)     | 78,4  
d(An,Rx)  | 80,4   
$xxxx     | 78,4  
$xxxxxxxx | 82,6  
d(PC)     | 78,4  
d(PC,Rx)  | 80,4  
#         | 74,4 

Hinweis: Oft ist es ratsam, diesen Befehl durch andere Operationen zu 
         ersetzen. So kann man eine Multiplikation mit einer Potenz
         von 2 leicht auf eine Verschiebung mit EASLF oder ELSLF
         zurckfhren.

Gruppe: EArithmetische BefehleF

Querverweis: EDIVSF, EDIVUF, EMULSFNBCD - Negation von BCD-Zahlen
----------------------------------------------------------------------

Assembler Syntax: NBCD <ea>
                 
Beschreibung: Dieser Befehl dient zur Bildung des 10er- bzw. 9er-komplement.
Ist das X-Flag vorher 0, wird das 10er-komplement gebildet im anderen Falle
das 9er-komplement.

Gr”e: Byte

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | ? | * | ? | E    <=  EM”gliche Ver„nderungenF
 |       |
 |       +-------- Dieses Flag wird gel”scht, wenn das Ergebnis ungleich 0 
 |                 ist, ansonsten bleibt es unver„ndert. Es empfielt sich 
 |                 daher das Z-Flag vorher zu setzen, wenn man das Ergebnis 
 |                 auf 0 prfen will.
 +---------------- Wie das C-Bit.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

 Ziel
-----+------+-------+-------+-------+----------+-------+-----------
 Dn  | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
-----+------+-------+-------+-------+----------+-------+-----------
 6,2 | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4  | 20,6

Gruppe: EArithmetische BefehleFNEG - Bin„re Negation
----------------------------------------------------------------------

Assembler Syntax: NEG <ea>

Beschreibung:
Der unter der effektiven Adresse angegebene Wert wird negiert.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | E    <=  EM”gliche Ver„nderungenF
 |
 +---------------- Wie das C-Bit.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

 Ziel
-------+---------+---------+---------+---------+----------+---------
 Dn    | (An)    | (An)+   | -(An)   | d(An)   | d(An,Rx) | $xxxx
-------+---------+---------+---------+---------+----------+---------
 4/6,2 | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 | 18/26,4  | 16/24,4

 Ziel
-----------
 $xxxxxxxx
-----------
 20/28,6
 
Gruppe: EArithmetische BefehleF
 
Querverweis: ENEGXFNEGX - Bin„re Negation mit Extend-Bit
----------------------------------------------------------------------

Assembler Syntax: NEGX <ea>

Beschreibung:
Der unter der effektiven Adresse angegebene Wert wird unter
Beachtung des Extended Bits negiert.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | *    <=  EM”gliche Ver„nderungenF
 |               |
 |               +-- Auf 1 gesetzt, falls das Ergebnis ungleich 0 ist, 
 |                   asonsten auf 0.
 +------------------ Wie das C-Bit.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

 Ziel
-------+---------+---------+---------+---------+----------+---------
 Dn    | (An)    | (An)+   | -(An)   | d(An)   | d(An,Rx) | $xxxx
-------+---------+---------+---------+---------+----------+---------
 4/6,2 | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 | 18/26,4  | 16/24,4

 Ziel
-----------
 $xxxxxxxx
-----------
 20/28,6

Gruppe: EArithmetische BefehleF

Querverweis: ENEGFNOP - Keine Operation
----------------------------------------------------------------------

Assembler Syntax: NOP

Beschreibung: Keine Operation. Dieser Befehl bekommt z.B. im
Zusammenhang mit Verz”gerungsschleifen einen Sinn.

Gr”e: Keine Gr”enspezifikation.

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Ausfhrungszeit: 4
Befehlsl„nge   : 2

Gruppe: EProgrammstruktur-BefehleFNOT - Logisches Komplement
----------------------------------------------------------------------

Assembler Syntax: NOT <ea>

Beschreibung:
Von dem durch die effektive Adresse spezifizierten Wert wird
das Einerkomplement gebildet.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

 Ziel
-------+---------+---------+---------+---------+----------+---------
 Dn    | (An)    | (An)+   | -(An)   | d(An)   | d(An,Rx) | $xxxx
-------+---------+---------+---------+---------+----------+---------
 4/6,2 | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 | 18/26,4  | 16/24,4

 Ziel
-----------
 $xxxxxxxx
-----------
 20/28,6
 
Gruppe: ELogische BefehleFOR - Logisches ODER
----------------------------------------------------------------------

Assembler Syntax: OR <ea>,Dn
                  OR dn,<ea>

Beschreibung:
Logische Inclusiv ODER-Verknpfung des Source Operanden mit dem
Zielinhalt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    |   Ziel
          +----------+---------+---------+---------+---------
          | Dn       | (An)    | (An)+   | -(An)   | d(An)
----------+----------+---------+---------+---------+---------
Dn        | 4/6,2    | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 
(An)      | 8/14,2   |
(An)+     | 8/14,2   |
-(An)     | 10/16,2  |
d(An)     | 12/18,4  |
d(An,Rx)  | 14/20,4  |
$xxxx     | 12/18,4  |
$xxxxxxxx | 16/22,6  |
d(PC)     | 12/18,4  |
d(PC,Rx)  | 14/20,4  |
#         | 8/14,4/6 |

Quelle |   Ziel
       +----------+--------+-----------
       | d(An,Rx) | $xxxx  | $xxxxxxxx
-------+----------+--------+-----------
Dn     | 18/26,4  |16/24,4 | 20/28,6

Hinweis:
OR #<data>, <ea> wird automatisch zu EORIF bersetzt.

Gruppe: ELogische BefehleF

Querverweis: EORIF, EORI to CCRF, EORI to SRFORI - Logisches ODER mit einer Konstanten
----------------------------------------------------------------------

Assembler Syntax: ORI #<data>,<ea>
                 
Beschreibung:
Logische Inclusiv ODER-Verknpfung konstanter Daten mit dem
Zielinhalt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +----------+-----------+-----------+-----------+----------
       | Dn       | (An)      | (An)+     | -(An)     | d(An)
-------+----------+-----------+-----------+-----------+----------
#      | 8/16,4/6 | 16/28,4/6 | 16/28,4/6 | 18/30,4/6 | 20/32,6/8

Quelle |   Ziel
       +-----------+-----------+------------
       | d(An,Rx)  | $xxxx     | $xxxxxxxx
-------+-----------+-----------+------------
#      | 22/34,6/8 | 20/32,6/8 | 24/36,8/10

Gruppe: ELogische BefehleF

Querverweis: EORF, EORI to CCRF, EORI to SRFORI to CCR - Logisches ODER mit einer Konstanten und dem CCR
----------------------------------------------------------------------

Assembler Syntax: ORI #<data>, CCR
                 
Beschreibung: Logisches ODER Immediate mit dem Condition Code Register.
              Dieser Befehl dient dazu gezielt Flags des CCR zu l”schen
              oder unberhrt zu lassen.

Gr”e: Byte (es k”nnen nur die unteren 5 Bit des ECCRF ver„ndert werden).

Verarbeitungszeit: 20
Befehlsl„nge     :  4

Gruppe: ELogische BefehleF

Querverweis: EORF, EORIF, EORI to SRFORI to SR - Logisches ODER mit einer Konstanten und dem SR
----------------------------------------------------------------------

Assembler Syntax: ORI #<data>, SR
                 
Beschreibung: Logisches ODER Immediate mit dem Status Register.
              Dieser Befehl dient dazu gezielt Flags des SR zu l”schen
              oder unberhrt zu lassen.

Gr”e: Word (es k”nnen nur einige Bit des ESRF ver„ndert werden).

Verarbeitungszeit: 20
Befehlsl„nge     :  4

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.
          
Gruppe: ELogische BefehleF

Querverweis: EORF, EORIF, EORI to CCRFPACK - Packe BCD-Zahlen                                        MC68020
----------------------------------------------------------------------

Assembler Syntax: PACK -(Ax),-Ay),#<adjustment>
                  PACK Dx,Dy,-(am),#<adjustment>

Beschreibung:
Zwei in verschiedenen Bytes abgelegte BCD Zahlen ( Binary Coded
Decimal ) werden in ein einziges Byte gepackt.

Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF
 
Gruppe: ETransfer-BefehleF

Querverweis: EUNPKFPEA - Lege Adresse auf den Stack
----------------------------------------------------------------------

Assembler Syntax: PEA <ea>

Beschreibung:
Die angegebene effektive Adresse wird auf dem Stack abgelegt.

Gr”e: Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    | Ziel ist immer -(A7)
----------+----------------------
(An)      | 12,2
d(An)     | 16,4
d(An,Rx)  | 20,4
$xxxx     | 16,4
$xxxxxxxx | 20,6
d(PC)     | 16,4
d(PC,Rx)  | 20,4

Gruppe: ETransfer-BefehleFRESET - Setze Peripherie zurck                           privilegiert
----------------------------------------------------------------------

Assembler Syntax: RESET

Beschreibung:
Die Reset Leitung wird aktiviert und damit ein Reset  fr  alle
pheripheren Ger„te ausgel”st. Der Zustand des Prozessors „ndert
sich nicht und das Program wird  nach  dem  Reset beim n„chsten
Befehl fortgefhrt.

Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Verarbeitungszeit: 132
Befehlsl„nge     :   2

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.

Gruppe: EProgrammstruktur-BefehleFROL - Rotiere links
----------------------------------------------------------------------

Assembler Syntax: ROL Dx,Dy
                  ROL #<data>,Dy
                  ROL <ea>

Beschreibung:
Der Zieloperand wird um die angegeben Anzahl von Bits nach links
rotiert.   Wird  ein  konstanter  Wert  fr  die Anzahl der Bits
angegeben,  liegt  der  m”gliche  Wertebereich zwischen 1 und 8.
Wird  ein  Datenregister  spezifiziert,  wird der Rotation Count
des Registers verwendet.  Im  Speicher  kann  nur um jeweils ein
Bit rotiert werden und  die Gr”enspezifikation  ist  auf   Word
beschr„nkt.

Gr”e: Byte, Word, Long (Byte und Long nur wenn das Ziel ein Datenregister
                         ist).

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | *    <=  EM”gliche Ver„nderungenF
                 |
                 +-- Enth„lt das letzte aus dem Ziel geschobene Bit. Falls
                     der Rotationsz„hler 0 ist, wird das Flag auf 0 gesetzt.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +-------------+------+-------+-------+-------+----------+-------
       | Dn          | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx 
-------+-------------+------+-------+-------+-------+----------+-------
Dn     | 6+2n/8+2n,2 |      |       |       |       |          |
#      | 6+2n/8+2n,2 |      |       |       |       |          |
1      |             | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4   

Quelle |   Ziel
       +-----------
       | $xxxxxxxx
-------+-----------
1      | 20,6

Hinweis: n ist die Anzahl der Bit, um die verschoben werden soll.

Gruppe: EBitschiebe- und RotierbefehleF

Querverweis: ERORF, EROXLF, EROXRFROR - Rotiere rechts
----------------------------------------------------------------------

Assembler Syntax: ROR Dx,Dy
                  ROR #<data>,Dy
                  ROR <ea>

Beschreibung:
Der Zieloperand wird um die angegeben Anzahl von Bits nach rechts
rotiert.   Wird  ein  konstanter  Wert  fr  die Anzahl der  Bits
angegeben,  liegt  der  m”gliche  Wertebereich zwischen  1 und 8.
Wird  ein  Datenregister  spezifiziert,  wird der  Rotation Count
des Registers verwendet.  Im  Speicher  kann  nur um jeweils  ein
Bit rotiert werden und  die  Gr”enspezifikation  ist  auf   Word
beschr„nkt.

Gr”e: Byte, Word, Long (Byte und Long nur wenn das Ziel ein Datenregister
                         ist).

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | *    <=  EM”gliche Ver„nderungenF
                 |
                 +-- Enth„lt das letzte aus dem Ziel geschobene Bit. Falls
                     der Rotationsz„hler 0 ist, wird das Flag auf 0 gesetzt.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +-------------+------+-------+-------+-------+----------+-------
       | Dn          | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx 
-------+-------------+------+-------+-------+-------+----------+-------
Dn     | 6+2n/8+2n,2 |      |       |       |       |          |
#      | 6+2n/8+2n,2 |      |       |       |       |          |
1      |             | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4   

Quelle |   Ziel
       +-----------
       | $xxxxxxxx
-------+-----------
1      | 20,6

Hinweis: n ist die Anzahl der Bit, um die verschoben werden soll.

Gruppe: EBitschiebe- und RotierbefehleF

Querverweis: EROLF, EROXLF, EROXRFROXL - Rotiere links unter Einbeziehung des Extend-Bits
----------------------------------------------------------------------

Assembler Syntax: ROXL Dx,Dy
                  ROXL #<data>,Dy
                  ROXL <ea>

Beschreibung:
Der Zieloperand wird um  die  angegeben  Anzahl  von  Bits  unter
Bercksichtigung des Extended Bits nach links  rotiert.  Wird ein
konstanter  Wert  fr  die Anzahl der  Bits angegeben,  liegt der
m”gliche  Wertebereich zwischen  1 und 8. Wird ein  Datenregister
spezifiziert, wird der Rotation Count des Registers ( Modulo 32 )
verwendet.  Im  Speicher  kann  nur um jeweils  ein  Bit  rotiert
werden und die  Gr”enspezifikation  ist  auf  Word  beschr„nkt.

Gr”e: Byte, Word, Long (Byte und Long nur wenn das Ziel ein Datenregister
                         ist).

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | 0 | *    <=  EM”gliche Ver„nderungenF
 |               |
 |               +-- Enth„lt das letzte aus dem Ziel geschobene Bit. Falls
 |                   der Rotationsz„hler 0 ist, wird das Flag auf 0 gesetzt.
 +------------------ Enth„lt das letzte aus dem Ziel geschobene Bit. Falls
                     der Rotationsz„hler 0 ist, bleibt das Flag unberhrt.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +-------------+------+-------+-------+-------+----------+-------
       | Dn          | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx 
-------+-------------+------+-------+-------+-------+----------+-------
Dn     | 6+2n/8+2n,2 |      |       |       |       |          |
#      | 6+2n/8+2n,2 |      |       |       |       |          |
1      |             | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4   

Quelle |   Ziel
       +-----------
       | $xxxxxxxx
-------+-----------
1      | 20,6

Hinweis: n ist die Anzahl der Bit, um die verschoben werden soll.

Gruppe: EBitschiebe- und RotierbefehleF

Querverweis: EROLF, ERORF, EROXRFROXR - Rotiere rechts unter Einbeziehung des Extend-Bits
----------------------------------------------------------------------

Assembler Syntax: ROXR Dx,Dy
                  ROXR #<data>,Dy
                  ROXR <ea>

Beschreibung:
Der Zieloperand wird um  die  angegeben  Anzahl  von  Bits  unter
Bercksichtigung des Extended Bits nach rechts rotiert.  Wird ein
konstanter  Wert  fr  die Anzahl der  Bits angegeben,  liegt der
m”gliche  Wertebereich zwischen  1 und 8. Wird ein  Datenregister
spezifiziert, wird der Rotation Count des Registers ( Modulo 64 )
verwendet.  Im  Speicher  kann  nur um jeweils  ein  Bit  rotiert
werden und die Gr”enspezifikation ist auf Word beschr„nkt.

Gr”e: Byte, Word, Long (Byte und Long nur wenn das Ziel ein Datenregister
                         ist).

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | 0 | *    <=  EM”gliche Ver„nderungenF
 |               |
 |               +-- Enth„lt das letzte aus dem Ziel geschobene Bit. Falls
 |                   der Rotationsz„hler 0 ist, wird das Flag auf 0 gesetzt.
 +------------------ Enth„lt das letzte aus dem Ziel geschobene Bit. Falls
                     der Rotationsz„hler 0 ist, bleibt das Flag unberhrt.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +-------------+------+-------+-------+-------+----------+-------
       | Dn          | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx 
-------+-------------+------+-------+-------+-------+----------+-------
Dn     | 6+2n/8+2n,2 |      |       |       |       |          |
#      | 6+2n/8+2n,2 |      |       |       |       |          |
1      |             | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4   

Quelle |   Ziel
       +-----------
       | $xxxxxxxx
-------+-----------
1      | 20,6

Hinweis: n ist die Anzahl der Bit, um die verschoben werden soll.

Gruppe: EBitschiebe- und RotierbefehleF

Querverweis: EROLF, ERORF, EROXLFRTD - Unterprogrammrckkehr mit Aufr„umen des Stacks    Nur MC68010/20
----------------------------------------------------------------------

Assembler Syntax: RTD #<displacement>

Beschreibung:
Die Return-Adresse wird vom Stack geholt, das  displacement  unter
Beachtung des Vorzeichens auf 32 Bit erweitert und  auf  den Stack
addiert. Anschlieend wird das Programm mit dem auf die Subroutine
folgenden Befehl fortgefhrt.


Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Gruppe: EProgrammstruktur-BefehleF

Querverweis: ERTEF, ERTMF, ERTRF, ERTSFRTE - Rckkehr aus einer Exception                        privilegiert
----------------------------------------------------------------------

Assembler Syntax: RTE

Beschreibung:
Dieser Befehl beendet die Behandlung einer Exception-Routine.

Die Informationen ber den Zustand des Prozessors vor dem Ein-
tritt  in  die  Exception  werden  vom Stack geholt und in die
Register des  Prozessors  bernommen.  Anschlieend  wird  das
Programm mit dem  auf  die  Subroutine folgenden Befehl fortge-
fhrt.

Gr”e: Ohne Gr”enspezifikation.

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | * | * | * | *    <=  EM”gliche Ver„nderungenF
 |   |   |   |   |
 +---+---+---+---+--- Entsprechend dem Stackinhalt.

Verarbeitungszeit: 20
Befehlsl„nge     :  2

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich im 
         Supervisormode befinden, um ihn korrekt ausfhren zu k”nnen.
          
Gruppe: EProgrammstruktur-BefehleF

Querverweis: ETRAPF, ETRAPVF, ETRAPccF, ERTDF, ERTMF, ERTRF, ERTSFRTM - Rckkehr aus Modul                                   Nur MC68020
----------------------------------------------------------------------

Assembler Syntax: RTM

Beschreibung:
Die Informationen ber den Zustand eines Moduls werden vom
Stack geholt.

Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | * | * | * | *    <=  EM”gliche Ver„nderungenF
 |   |   |   |   |
 +---+---+---+---+--- Entsprechend dem Stackinhalt.

Gruppe: EProgrammstruktur-BefehleF

Querverweis: ECALLMF, ERTDF, ERTEF, ERTRF, ERTSFRTR - Rckkehr aus Exception ohne Ver„ndern des Systembyte
----------------------------------------------------------------------

Assembler Syntax: RTR
                 
Beschreibung:
Die Return-Adresse und das Condition Code Register werden vom
Stack geholt.  Anschlieend wird das Programm mit dem auf die
Subroutine folgenden Befehl fortgefhrt.

Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | * | * | * | *    <=  EM”gliche Ver„nderungenF
 |   |   |   |   |
 +---+---+---+---+--- Entsprechend dem Stackinhalt.

Verarbeitungszeit: 20
Befehlsl„nge     :  2

Gruppe: EProgrammstruktur-BefehleF

Querverweis: ERTDF, ERTEF, ERTMF, ERTSFRTS - Rckkehr aus Unterprogramm
----------------------------------------------------------------------

Assembler Syntax: RTS
      
Beschreibung:
Rcksprung von einer Subroutine zu der Stelle, von der aus zu der
Subroutine verzweigt  wurde.   Der  neue  EPCF  wird  vom  Stack
geholt, der alte EPCF geht verloren.

Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Verarbeitungszeit: 16
Befehlsl„nge     :  2

Gruppe: EProgrammstruktur-BefehleF

Querverweis: EBSRF, EJSRF, ERTDF, ERTEF, ERTMF, ERTRFSBCD - Subtraktion von BCD-Zahlen
----------------------------------------------------------------------

Assembler Syntax: SBCD Dx,Dy
                  SBCD -(Ax),-(Ay)

Beschreibung:
Der dezimal kodierte Ouelloperanden wird vom  dezimal  kodierten
Zieloperanden subtrahiert. Das Resultat steht nach der Operation
im Zielregister.

Gr”e: Byte

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | ? | * | ? | E    <=  EM”gliche Ver„nderungenF
 |       |
 |       +-------- Dieses Flag wird gel”scht, wenn das Ergebnis ungleich 0 
 |                 ist, ansonsten bleibt es unver„ndert. Es empfielt sich 
 |                 daher das Z-Flag vorher zu setzen, wenn man das Ergebnis 
 |                 auf 0 prfen will.
 +---------------- Wie das C-Bit.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle  |   Ziel
        +--------------
        | Dn   | -(An)
--------+------+-------
Dn      | 6,2  |
-(An)   |      | 18,2

Gruppe: EArithmetische BefehleFScc - Setze ein Byte in Anh„ngigkeit von einer Bedingung
----------------------------------------------------------------------

Assembler Syntax: SEccF <ea>

Beschreibung:
Setzt ein Byte in Abh„ngigkeit vom Zustand der jeweiligen Flags
des Condition Code Registers.
 
Gr”e: Byte

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Beding. |   Ziel
        +-----+------+-------+-------+-------+----------+-------+-----------
        | Dn  | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
--------+-----+------+-------+-------+-------+----------+-------+-----------
erfllt | 6,2 | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4  | 20,6
n. erf. | 4,2 | 12,2 | 12,2  | 14,2  | 16,4  | 18,4     | 16,4  | 20,6

Gruppe: EProgrammstruktur-BefehleFSTOP - Stoppe Programmausfhrung                          privilegiert
----------------------------------------------------------------------

Assembler Syntax: STOP #<data>

Beschreibung:
Wenn sich der Prozessor im Supervisor State  befindet  wird das
Status Register  mit  den  konstanten  Daten  geladen  und  der
Prozessor in den Halt Zustand  versetzt.  Dieser  Zustand  wird
solange  beibehalten  bis  entweder ein Interrupt auftritt, ein
Reset  ausgel”st  wurde  oder   bis   eine Exception  auftritt.
Letzteres kann z.B. der Fall sein, wenn das Trace Bit im Status
Register gesetzt war als der Stop Befehl ausgefhrt wurde.  Ein
Interrupt kann den Haltezustand  nur  aufheben  wenn  er  h”her
priorisiert ist als das gltige Interrupt Level.

Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | * | * | * | *     <=  EM”gliche Ver„nderungenF
 |   |   |   |   |
 +---+---+---+---+--- Entsprechend den kostanten Daten.

Verarbeitungszeit: 4
Befehlsl„nge     : 4

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich 
         sowohl vor als nach Ausfhrung des Befehls im Supervisormode 
         befinden, um ihn korrekt ausfhren zu k”nnen.

Gruppe: EProgrammstruktur-BefehleFSUB - Bin„re Subtraktion
----------------------------------------------------------------------

Assembler Syntax: SUB <ea>,Dn
                  SUB Dn,<ea>

Beschreibung:
Der Quelloperand wird vom Zieloperanden subtrahiert und das
Ergebnis in dem unter effektiver Adresse spezifizierten Ziel
abgelegt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | E    <=  EM”gliche Ver„nderungenF
 |
 +----------------- Wie das C-Bit.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    |   Ziel
          +----------+---------+---------+---------+----------
          | Dn       | (An)    | (An)+   | -(An)   | d(An)
----------+----------+---------+---------+---------+----------
Dn        | 4/6,2    | 12/20,2 | 12/20,2 | 14/22,2 | 16/24,4 
An        | 4/8,2    |
(An)      | 8/14,2   |
(An)+     | 8/14,2   |
-(An)     | 10/16,2  |
d(An)     | 12/18,4  |
d(An,Rx)  | 14/20,4  | 
$xxxx     | 12/18,4  |
$xxxxxxxx | 16/22,6  |
d(PC)     | 12/18,4  |
d(PC,Rx)  | 14/20,4  |
#         | 8/14,4/6 |

Quelle |   Ziel
       +----------+--------+-----------
       | d(An,Rx) | $xxxx  | $xxxxxxxx
-------+----------+--------+-----------
Dn     | 18/26,4  |16/24,4 | 20/28,6

Hinweise:
SUB.x <ea>,An wird automatisch zu ESUBAF bersetzt.
SUB.x #<data>, <ea>  wird automatisch zu ESUBIF bersetzt.
SUB.x #<data>, Rn wird automatisch zu ESUBQF bersetzt, wenn der Quell-
operand im Bereich 0 bis 8 liegt.

Gruppe: EArithmetische BefehleF

Querverweis: ESUBAF, ESUBIF, ESUBQF, ESUBXFSUBA - Bin„re Subtraktion mit Adreregister als Ziel
----------------------------------------------------------------------

Assembler Syntax: SUBA <ea>,An

Beschreibung:
Der Quelloperand wird von einem Adreregister subtrahiert  und
das Ergebnis in das  Adreregister  geschrieben.  Dieser Befehl
ist nur im Word oder Long Format gltig. Ein SUBA.W Befehl wird
automatisch unter Beachtung des Vorzeichens auf 32 Bit  vor der
Operation erweitert.

Gr”e: Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle    |   Ziel
          +-----------
          | An        
----------+-----------
Dn        | 8/6,2
An        | 8/8,2
(An)      | 12/14,2
(An)+     | 12/14,2
-(An)     | 14/16,2
d(An)     | 16/18,4
d(An,Rx)  | 18/20,4 
$xxxx     | 16/18,4
$xxxxxxxx | 20/22,6
d(PC)     | 18/20,4
d(PC,Rx)  | 12/20,4
#         | 8/14,4/6

Hinweis: 
SUBA #..., An wird automatisch zu ESUBQF bersetzt, wenn der Quell-
operand im Bereich von 0 bis 8 liegt.

Gruppe: EArithmetische BefehleF

Querverweis: ESUBF, ESUBIF, ESUBQF, ESUBXFSUBI - Bin„re Subtraktion mit Konstante als Quelle
----------------------------------------------------------------------

Assembler Syntax: SUBI #<data>,<ea>

Beschreibung:
Die konstanten Daten werden vom Zieloperanden subtrahiert und das
Ergebnis  in dem durch die effektive Adresse spezifizierten  Ziel
abgelegt.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | E    <=  EM”gliche Ver„nderungenF
 |
 +----------------- Wie das C-Bit.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +----------+-----------+-----------+-----------+----------
       | Dn       | (An)      | (An)+     | -(An)     | d(An)
-------+----------+-----------+-----------+-----------+----------
#      | 8/16,4/6 | 16/28,4/6 | 16/28,4/6 | 18/30,4/6 | 20/32,6/8

Quelle |   Ziel
       +-----------+-----------+------------
       | d(An,Rx)  | $xxxx     | $xxxxxxxx
-------+-----------+-----------+------------
#      | 22/34,6/8 | 20/32,6/8 | 24/36,8/10

Hinweis: SUBI wird automatisch zu ESUBQF bersetzt, wenn der Quell-
operand im Bereich von 0 bis 8 liegt.

Gruppe: EArithmetische BefehleF

Querverweis: ESUBF, ESUBAF, ESUBQF, ESUBXFSUBQ - Bin„re Subtraktion (schnell)
----------------------------------------------------------------------

Assembler Syntax: SUBQ #<data>,<ea>

Beschreibung:
Konstante Daten im Wertebereich zwischen 1 und 8 werden vom
Zieloperanden subtrahiert.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | E | E | E    <=  EM”gliche Ver„nderungenF
 |
 +----------------- Wie das C-Bit.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle |   Ziel
       +--------+-------+---------+---------+---------
       | Dn     | An    | (An)    | (An)+   | -(An)
-------+--------+-------+---------+---------+---------
#      | 4/8,2  | 8/8,2 | 12/20,2 | 12/20,2 | 14/22,2 

Quelle |   Ziel
       +---------+----------+---------+-----------
       | d(An)   | d(An,Rx) | $xxxx   | $xxxxxxxx
-------+---------+----------+---------+-----------
#      | 16/24,4 | 18/26,4  | 16/24,4 | 20/28,6

Hinweis: SUBQ #...,An arbeitet immer mit Langwortverarbeitung.

Gruppe: EArithmetische BefehleF

Querverweis: ESUBF, ESUBAF, ESUBIF, ESUBXFSUBX - Bin„re Subtraktion mit Extend-Bit
----------------------------------------------------------------------

Assembler Syntax: SUBX Dx,Dy
                  SUBX -(Ax),-(Ay)

Beschreibung:
Der  Quelloperand  wird  vom  Zieloperand  unter Bercksichtigung
des Extend Bit subtrahiert. Zwei EAdressierungsartenF sind m”glich:
Datenregister/Datenregister und Speicher/Speicher.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 * | E | * | E | E    <=  EM”gliche Ver„nderungenF
 |       |
 |       +--------- Dieses Flag wird gel”scht, wenn das Ergebnis ungleich 
 |                  0 ist, ansonsten bleibt es unver„ndert. Es empfielt 
 |                  sich daher das Z-Flag vorher zu setzen, wenn man das 
 |                  Ergebnis auf 0 prfen will.
 +----------------- Wie das C-Bit.

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

Quelle  |   Ziel
        +-------+---------
        | Dn    | -(An)
--------+-------+---------
Dn      | 4/8,2 |
-(An)   |       | 18/30,2

Gruppe: EArithmetische BefehleF

Querverweis: ESUBF, ESUBAF, ESUBIF, ESUBQFSWAP - Tausche Registerh„lften
----------------------------------------------------------------------

Assembler Syntax: SWAP Dn

Beschreibung:  Es  werden  die zwei 16 Bit H„lften eines 32 Bit
Datenregisters vertauscht.

Gr”e: Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Verarbeitungszeit: 4
Befehlsl„nge:      2

Gruppe: ETransfer-BefehleFTAS - Prfe und setzte ein Bit im Zieloperanden
----------------------------------------------------------------------

Assembler Syntax: TAS <ea>

Beschreibung:
Das durch die effektive Adresse spezifizierte Byte wird getestet
und und das Ergebnis im CCR abgelegt. Anschlieend wird das obeste
Bit des Zieloperanden gesetzt. Die Operation wird in einem einzigen 
Read-Modify-Write Speicherzyklus ausgefhrt um Prozesskommunikation  
ber Semaphoren sicherzustellen.

Gr”e: Byte

Anwendungsbeispiel:

try_again:
        TAS     semaphore
        EBEQF     do_it
        EBCLRF.B  #7, semaphore
        EBRAF     try_again
do_it:
        EORIF.B   #$FF, semaphore
; Begin der kritischen Zone
; Hier k”nnen keine zwei Prozesse gleichzeitig reinkommen
; Beachten Sie, da das Problem von DEADLOCKS nicht gel”st ist
        ...........................
; Ende der kritischen Zone
        ECLRF.B   semaphore
                
Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

 Ziel
-----+------+-------+-------+-------+----------+-------+-----------
 Dn  | (An) | (An)+ | -(An) | d(An) | d(An,Rx) | $xxxx | $xxxxxxxx
-----+------+-------+-------+-------+----------+-------+-----------
 4,2 | 14,2 | 14,2  | 16,2  | 18,4  | 20,4     | 18,4  | 22,6

Querverweis: ECASF, ECAS2F

Gruppe: EBit-BefehleFTRAP - Gehe in Ausnahmebehandlung
----------------------------------------------------------------------

Assembler Syntax: TRAP #<vector>

Beschreibung:
Durch  diesen  Befehl  wird  die  durch  vector  spezifizierte
EExceptionF Behandlung initialisiert. Es stehen 16 TRAP Vektoren
zur Verfgung ( 0 - 15 ).
 
Gr”e: Keine Gr”enspezifikation

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Verarbeitungszeit: 38
Befehlsl„nge     :  2

Gruppe: EProgrammstruktur-BefehleF

Querverweis: ERTEF, ETRAPccF, ETRAPVFTRAPcc - Trap bei Bedingung                                    MC68020
----------------------------------------------------------------------

Assembler Syntax: TRAPEccF
                  TRAPEccF.W #<data>
                  TRAPEccF.L #<data>

Beschreibung:
Wenn die spezifizierte Bedingung erfllt ist, wird die Behandlung
der EExceptionF mit Vektor Nummer 7 eingeleitet. Wird die Bedingung
nicht   erfllt,   wird  der  auf  den  TRAPcc   folgende  Befehl
abgearbeitet.

Gr”e: Keine Gr”enspezifikation oder Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Hinweis:
TRAPF tut nichts und sollte deshalb weggelassen werden.

Gruppe: EProgrammstruktur-BefehleF

Querverweis: ERTEF, ETRAPF, ETRAPVFTRAPV - Trap bei šberlauf
----------------------------------------------------------------------

Assembler Syntax: TRAPV

Beschreibung:
Wenn  das  Overflow  Flag  im  Condition  Coder  Register gesetzt
ist, wird die Behandlung der EExceptionF mit Vektor Nummer 7 einge-
leitet.  Ansonsten  wird  der  auf  den  TRAPV   folgende  Befehl
abgearbeitet.

Gr”e: Keine Gr”enspezifikation oder Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Verarbeitungszeit: 4 (Trap nicht ausgefhrt) 38 (Trap ausgefhrt)
Befehlsl„nge     : 2
          
Gruppe: EProgrammstruktur-BefehleF

Querverweis: ERTEF, ETRAPF, ETRAPccFTST - Prfe Inhalt des Operanden
----------------------------------------------------------------------

Assembler Syntax: TST <ea>

Beschreibung:
Testet einen Operanden und setzt die entsprechenden Flags im
Condition Code Register.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | E | E | 0 | 0    <=  EM”gliche Ver„nderungenF

Erlaubte EAdressierungsartenF, EVerarbeitungszeitF und EBefehlsl„ngeF:

 Ziel
-----+--------+--------+---------+---------+----------+---------+-----------
 Dn  | (An)   | (An)+  | -(An)   | d(An)   | d(An,Rx) | $xxxx   | $xxxxxxxx
-----+--------+--------+---------+---------+----------+---------+-----------
 4,2 | 8/12,2 | 8/12,2 | 10/14,2 | 12/16,4 | 14/18,4  | 12/16,4 | 16/20,6

Gruppe: EArithmetische BefehleF

Querverweis ECMPFUNLNK - Hole den Stackpointer zurck
----------------------------------------------------------------------

Assembler Syntax: UNLK An

Beschreibung:
Der  Stackpointer  wird  mit  dem  spezifizierten Adreregister
geladen,  vom  Stack  wird  dann  ein Langwort geholt und in das
Adreregister geschrieben.

Zur Veranschaulichung soll hier ein alternativer Code angegeben
werden:

EMOVEAF.L An, A7
EMOVEAF.L (A7)+, An

Gr”e: Keine Gr”enspezifikation.

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Verarbeitungszeit: 12 
Befehlsl„nge     :  2

Gruppe: ETransfer-BefehleF

Querverweis: ELINKFUNPK - Entpacke BCD-Zahlen                                     MC68020
----------------------------------------------------------------------

Assembler Syntax: UNPK Dx,Dy,#<adjustment>
                  UNPK -(Ax),-(Ay),#<adjustment>

Beschreibung:
Zwei dezimal kodierte und in ein Byte gepackte Zahlen werden  aus
einem Byte in zwei Bytes aufgel”st. Dabei werden die Bits 7 bis 3
in die Bits 11 bis 8 des so entstehenden Wortes kopiert  und  die
oberen  Nibbels   auf  0  ( Null )  gesetzt.   Anschlieend  wird
adjustment auf den entstandenen Wert addiert.

Gr”e: Byte, Word, Long

Beeinflussung der Flags im ECCRF ( Condition Code Register ):

 X | N | Z | V | C
---+---+---+---+---
 - | - | - | - | -    <=  EM”gliche Ver„nderungenF

Gruppe: ETransfer-BefehleF

Querverweis: EPACKFDefinitions- und Wertemenge
----------------------------------------------------------------------

Die  Definitionsmenge D  einer Funktion ist  die Untermenge von 
R (Menge der reellen Zahlen) in der die Funktion definiert ist. 
In der Menge R \ D ( R ohne D ) ist das  Funktionsergebnis  NaN
(Not a number). Im  Gegensatz zur  Mathematik kann bei den FPUs 
MC 68881/2 das Argument einer Funktion ñß ( unendlich ) sein.

Analog zur  Definitionsmenge ist  die  Wertemenge die  kleinste 
Untermenge von R,  die alle m”glichen  Ergebnisse der  Funktion
enth„lt. Auch hier kann ñß Element dieser Menge sein.FABS - Absolutwert                                    MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FABS.f <ea>,FPn
                  FABS.X FPm,FPn
                  FABS.X FPn

Beschreibung:
Der Absolutwert des Arguments wird berechnet und in das Zielregister
geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [-ß,+ß], W = [0,+ß]

Querverweis: EFSABSF, EFDABSF

Gruppe: EFliekomma-BefehleFFDABS - Absolutwert                                            MC68040
FSABS
----------------------------------------------------------------------

Assembler Syntax: FDABS.f <ea>,FPn
                  FDABS.X FPm,FPn
                  FDABS.X FPn
                  FSABS.f <ea>,FPn
                  FSABS.X FPm,FPn
                  FSABS.X FPn

Beschreibung:
Der Absolutwert des Arguments wird berechnet und in das Zielregister
geschrieben. FDABS rundet das Resultat auf doppelte und FSABS auf
einfache Genauigkeit.

EDefinitionsmengeF und EWertemengeF:

D = [-ß,+ß], W = [0,+ß]

Querverweis: EFABSF

Gruppe: EFliekomma-BefehleFFACOS - Arcus Cosinus                                          MC68881
----------------------------------------------------------------------

Assembler Syntax: FACOS.f <ea>,FPn
                  FACOS.x FPm,FPn
                  FACOS.x FPn
Beschreibung:
Es wird der Arcus Cosinus des Arguments berechnet und in das Ziel-
register geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [-1,+1], W=[0,ã]

Umkehrfunktion: EFCOSF

Gruppe: EFliekomma-BefehleFFADD - Fliekommaaddition                             MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FADD.f <ea>,FPn
                  FADD.x FPm,FPn

Beschreibung:
Es wird die Summe aus dem Quelloperanden und dem Zieloperanden berechnet
und in das Zielregister geschrieben.

Querverweis: EFSUBF, EFDADDF, EFSADDF

Gruppe: EFliekomma-BefehleFFSADD - Fliekommaaddition                                     MC68040
FDADD
----------------------------------------------------------------------

Assembler Syntax: FSADD.f <ea>,FPn
                  FSADD.X FPm,FPn
                  FDADD.f <ea>,FPn
                  FDADD.X FPm,FPn

Beschreibung:
Es wird die Summe aus dem Quelloperanden und dem Zieloperanden
berechnet und in das Zielregister geschrieben. Dabei wird bei FSADD
das Resultat auf einfache Genauigkeit gerundet und bei FDADD auf
doppelte Genauigkeit.

Querverweis: EFADDF

Gruppe: EFliekomma-BefehleFFASIN - Arcus Sinus                                            MC68881
----------------------------------------------------------------------

Assembler Syntax: FASIN.f <ea>,FPn
                  FASIN.x FPm,FPn
                  FASIN.x FPn

Beschreibung:
Es wird der Arcus Sinus des Arguments berechnet und in das Ziel-
register geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [-1,+1], W=[-ã/2,+ã/2]

Umkehrfunktion: EFSINF

Gruppe: EFliekomma-BefehleFFATAN - Arcus Tangens                                          MC68881
----------------------------------------------------------------------

Assembler Syntax: FATAN.f <ea>,FPn
                  FATAN.x FPm,FPn
                  FATAN.x FPn

Beschreibung:
Es wird der Arcus Tangens des Arguments berechnet und in das Ziel-
register geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [-ß,+ß], W=[-ã/2,+ã/2]

Umkehrfunktion: EFTANF

Gruppe: EFliekomma-BefehleFFATANH - Arcus Tangens Hyperbolicus                            MC68881
----------------------------------------------------------------------

Assembler Syntax: FATANH.f <ea>,FPn 
                  FATANH.x FPm,FPn
                  FATANH.x FPn

Beschreibung:
Es wird der Arcus Tangens Hyperbolicus des Arguments berechnet und 
in das Zielregister geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [-1,+1], W=[-ß,+ß]

Umkehrfunktion: EFTANHF

Gruppe: EFliekomma-BefehleFFBcc - Bedingte Verzweigung                           MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FBEccF <label>

Beschreibung:

Falls die Bedingung ( EccF ) erfllt ist wird das Programm an der
Adresse weitegefhrt, fr die label steht.

Gr”e: Word, Long

Querverweis: EFDBccF
 
Gruppe: EFliekomma-BefehleFFCMP - Vergleiche zwei Operanden                      MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FCMP.f <ea>,FPn
                  FCMP.x FPm,FPn

Beschreibung:
Es werden zwei Operanden verglichen. Fr den Vergleich wird der
Quell- vom Zieloperand subtrahiert.  Das Resultat  wird  jedoch
nicht geschrieben,  lediglich  die  Flags  werden  entsprechend
gesetzt.

Gruppe: EFliekomma-BefehleFFCOS - Cosinus                                                 MC68881
----------------------------------------------------------------------

Assembler Syntax: FCOS.f <ea>,FPn
                  FCOS.x FPm,FPn
                  FCOS.x FPn
Beschreibung:
Es wird der Cosinus des Arguments berechnet und in das Zielregister 
geschrieben.  Je gr”er der  Absolutwert des  Arguments ist,  desto 
gr”er ist die Ungenauigkeit des Ergebnisses.

EDefinitionsmengeF und EWertemengeF:

D = ]-ß,+ß[, W=[-1,+1] (Hinweis: D sollte [-2ã,+2ã] sein.)  

Umkehrfunktion: EFACOSF

Gruppe: EFliekomma-BefehleFFCOSH - Cosinus Hyperbolicus                                   MC68881
----------------------------------------------------------------------

Assembler Syntax: FCOSH.f <ea>,FPn 
                  FCOSH.x FPm,FPn
                  FCOSH.x FPn

Beschreibung:
Es wird der Cosinus Hyperbolicus des Arguments berechnet und in das 
Zielregister geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [-ß,+ß], W=[-ã/2,+ã/2]

Umkehrfunktion: EFTANHF

Gruppe: EFliekomma-BefehleFFDBcc - Prfe Bedingung, dekrementiere und verzweige  MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FDBEccF Dn,<label>

Beschreibung:
Diese Befehl erm”glich es eine einfache Schleife zu programmieren.
Zuerst  wird  die  ber  EccF  spezifizierte  Bedingung  geprft um
festzustellen ob die Abbruchsbedingung  fr  die Schleife erreicht
ist. Wenn dies der Fall ist wird keine weitere Aktion vorgenommen.
Wenn die Abbruchsbedingung nicht erfllt ist,  werden  die unteren
16 Bit ( Achtung: Word ) um 1  ( Eins )  dekrementiert.  Wenn  das
Ergebnis -1 (Achtung: Minus Eins) ist, wird die Schleife  beendet.
Andernfalls  wird  auf  die durch label spezifizierte Adresse ver-
zweigt.

Gr”e: Word

Querverweis: EFBccF

Gruppe: EFliekomma-BefehleFFDIV - Division                                       MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FDIV.f <ea>,FPn
                  FDIV.x FPm,FPn

Beschreibung:
Es wird  eine Division des Zieloperanden durch den  Ouelloperanden
ausgefhrt und das Ergebnis in das Zielregister geschrieben. Wenn 
beide Operanden 0 sind  oder beide +/-ß sind wird als Ergebnis NaN
( Not a number ) zurckgeliefert.

Querverweis: EFMULF, EFSGLDIVF

Gruppe: EFliekomma-BefehleFFSDIV - Division                                               MC68040
FDDIV
----------------------------------------------------------------------

Assembler Syntax: FDDIV.f <ea>,FPn
                  FDDIV.X FPm,FPn
                  FSDIV.f <ea>,FPn
                  FSDIV.X FPm,FPn


Beschreibung:
Es wird  eine Division des Zieloperanden durch den  Ouelloperanden
ausgefhrt und das Ergebnis in das Zielregister geschrieben. Wenn 
beide Operanden 0 sind  oder beide +/-ß sind wird als Ergebnis NaN
( Not a number ) zurckgeliefert. Bei FSDIV wird das Resultat auf
einfache Genauigkeit und bei FDDIV auf doppelte Genauigkeit ge-
rundet.

Querverweis: EFDIVF, EFSGLDIVF

Gruppe: EFliekomma-BefehleFFETOX - Exponentialfunktion e^x                                MC68881
----------------------------------------------------------------------

Assembler Syntax: FETOX.f <ea>,FPn
                  FETOX.x FPm,FPn
                  FETOX.x FPn

Beschreibung:
Es wird die Exponentialfunktion e^x (e hoch x) des Arguments berechnet
und in das Zielregister geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [-ß,+ß], W=[0,+ß]

Umkehrfunktion: EFLOGNF

Querverweis: EFETOXM1F

Gruppe: EFliekomma-BefehleFFETOXM1 - Exponentialfunktion e^x-1                            MC68881
----------------------------------------------------------------------

Assembler Syntax: FETOXM1.f <ea>,FPn
                  FETOXM1.x FPm,FPn
                  FETOXM1.x FPn

Beschreibung:
Es wird die Exponentialfunktion e^x-1 (e hoch x) des Arguments berech-
net und in das Zielregister geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [-ß,+ß], W=[-1,+ß]

Umkehrfunktion: EFLOGNP1F

Querverweis: EFETOXF

Gruppe: EFliekomma-BefehleFFGETEXP - Exponent des Operanden                               MC68881
----------------------------------------------------------------------

Assembler Syntax: FGETEXP.f <ea>,FPn
                  FGETEXP.x FPm,FPn
                  FGETEXP.x FPn
Beschreibung:
Berechnet den bin„ren Exponenten des Quelloperanden und schreibt 
das Ergebnis in das Zielregister.

EDefinitionsmengeF und EWertemengeF:

D = ]-ß,+ß[, W=[-16383,+16384], W c N

Querverweis: EFGETMANF

Gruppe: EFliekomma-BefehleFFGETMAN - Mantisse des Operanden                               MC68881
----------------------------------------------------------------------

Assembler Syntax: FGETMAN.f <ea>,FPn
                  FGETMAN.x FPm,FPn
                  FGETMAN.x FPn
Beschreibung:
Berechnet die Mantisse des Quelloperanden und schreibt das 
Ergebnis in das Zielregister.

EDefinitionsmengeF und EWertemengeF:

D = ]-ß,+ß[, W = [1.0,+2.0[ u {0.0}

Querverweis: EFGETEXPF

Gruppe: EFliekomma-BefehleFFINT - Integerteil des Operanden                               MC68881
----------------------------------------------------------------------

Assembler Syntax: FINT.f <ea>,FPn
                  FINT.x FPm,FPn
                  FINT.x FPn
Beschreibung:
Berechnet den Integerteil des Quelloperanden und schreibt das 
Ergebnis in das Zielregister.  Bei der Rundung wird der Wert
des EMode ControlF Bytes im EFliekomma-KontrollregisterF berck-
sichtigt.

EDefinitionsmengeF und EWertemengeF:

D = [-ß,+ß], W = [-ß,+ß]

Querverweis: EFINTRZF

Gruppe: EFliekomma-BefehleFFINTRZ - Integerteil des Operanden, gerundet auf 0             MC68881
----------------------------------------------------------------------

Assembler Syntax: FINTRZ.f <ea>,FPn
                  FINTRZ.x FPm,FPn
                  FINTRZ.x FPn
Beschreibung:
Es wird der Quelloperand nach 0 gerundet gerundet und das Ergebnis
in das Zielregister geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [-ß,+ß], W = [-ß,+ß]

Querverweis: EFINTF

Gruppe: EFliekomma-BefehleFFLOGN - Natrlicher Logarithmus                                MC68881
----------------------------------------------------------------------

Assembler Syntax: FLOGN.f <ea>,FPn
                  FLOGN.x FPm,FPn
                  FLOGN.x FPn

Beschreibung:
Es wird der natrliche Logarithmus des Arguments berechnet und in das
Zielregister geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [0,+ß], W = [-ß,+ß]

Umkehrfunktion: EFETOXF

Gruppe: EFliekomma-BefehleFFLOGNP1 - Natrlicher Logarithmus von x+1                      MC68881
----------------------------------------------------------------------

Assembler Syntax: FLOGNP1.f <ea>,FPn
                  FLOGNP1.x FPm,FPn
                  FLOGNP1.x FPn

Beschreibung:
Es wird der natrliche Logarithmus des Arguments +1 berechnet und in 
das Zielregister geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [-1,+ß], W = [-ß,+ß]

Umkehrfunktion: EFETOXM1F

Gruppe: EFliekomma-BefehleFFLOG10 - Dekadischer Logarithmus                               MC68881
----------------------------------------------------------------------

Assembler Syntax: FLOG10.f <ea>,FPn
                  FLOG10.x FPm,FPn
                  FLOG10.x FPn

Beschreibung:
Es wird der dekadischer Logarithmus des Arguments berechnet und in das
Zielregister geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [0,+ß], W = [-ß,+ß]

Umkehrfunktion: EFTENTOXF

Gruppe: EFliekomma-BefehleFFLOG2 - Logarithmus zur Basis 2                                MC68881
----------------------------------------------------------------------

Assembler Syntax: FLOG2.f <ea>,FPn
                  FLOG2.x FPm,FPn
                  FLOG2.x FPn

Beschreibung:
Es wird der Logarithmus zur Basis 2 des Arguments berechnet und in das
Zielregister geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [0,+ß], W = [-ß,+ß]

Umkehrfunktion: EFTWOTOXF

Gruppe: EFliekomma-BefehleFFMOD - Modulorest                                              MC68881
----------------------------------------------------------------------

Assembler Syntax: FMOD.f <ea>,FPn
                  FMOD.x FPm,FPn

Beschreibung:
Es wird der Modulorest aus Quelle und Ziel berechnet und das Ergebnis
in das Zielregister geschrieben. Der Modulorest ist definiert als:

                  FPn * ( Quelle * N )
wobei gilt:
                  N = INT( FPn / Quelle ) (round to zero mode)

Das Ergebnis dieser Division  steht anschlieend im  EQuotientF Byte des
EFliekomma-StatusregistersF.

Querverweis: EFREMF

Gruppe: EFliekomma-BefehleFFMOVE - šbertrage Daten                               MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FMOVE.f <ea>,FPn
                  FMOVE.f FPm,FPn
                  FMOVE.p FPm,<ea>{Dn}
                  FMOVE.p FPm,<ea>{#data}

Beschreibung:
Der Inhalt des Source Operanden wird zum Ziel bewegt.

Querverweis: EFMOVE FPcrF, EFMOVECRF, EFMOVEMF, EFMOVEM FPcrF

Gruppe: EFliekomma-BefehleFFSMOVE - šbertrage Daten und runde                             MC68040
FDMOVE
----------------------------------------------------------------------

Assembler Syntax: FSMOVE.X FPm,FPn
                  FSMOVE.X <ea>,FPn
                  FDMOVE.p FPm,FPn
                  FDMOVE.p <ea>,FPn

Beschreibung:
Der Inhalt des Source Operanden wird zum Ziel bewegt. Dabei rundet
FSMOVE das Resultat auf einfache Genauigkeit und FDMOVE auf doppelte
Genauigkeit.

Querverweis: EFMOVEF

Gruppe: EFliekomma-BefehleFFMOVE FPcr - šbertrage Daten in/aus ein FPU-Kontrollregister
                                                      MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FMOVE.l <ea>,FPcr
                  FMOVE.l FPcr,<ea>

Beschreibung:
Der Inhalt  eines EFPU-KontrollregisterFs wird von oder nach einer 
effektiven  Adresse  geschrieben.  Dabei ist  zu  beachten,  da 
nicht  definierte Bit  beim Lesen  aus einem Register  0 ergeben
und beim Schreiben in ein Register 0 sein sollten, um kompatibel
mit zuknftigen Versionen zu sein.

Querverweis: EFMOVEF, EFMOVECRF, EFMOVEMF, EFMOVEM FPcrF

Gruppe: EFliekomma-BefehleFFMOVECR - Hole Konstante aus dem ROM der FPU                   MC68881
----------------------------------------------------------------------

Assembler Syntax: FMOVECR.x #<data>,FPn

Beschreibung:
Es wird eine Konstante aus dem ROM des  Fliekommaprozessors in ein
Fliekommaregister bertragen. Je nach dem, welcher Wert fr <data>
angegeben wurde, wird eines von 22 m”glichen Konstanten geschrieben.

<data>      Konstante
----------------------
$00         ã (3.14159265358979323846)
$0B         EFLOG10F(2)
$0C         e (2.71828182845904523536)
$0D         EFLOG2F(e)
$0E         EFLOG10F(e)
$0F         0.0
$30         1n(2)
$31         1n(10)
$32         1.0
$33         10.0
$34         100.0
$35         10000.0
$36         1.0e8
$37         1.0e16
$38         1.0e32
$39         1.0e64
$3A         1.0e128
$3B         1.0e256
$3C         1.0e512
$3D         1.0e1024
$3E         1.0e2048
$3F         1.0e4096

Querverweis: EFMOVEF, EFMOVE FPcrF, EFMOVEMF, EFMOVEM FPcrF

Gruppe: EFliekomma-BefehleFFMOVEM - šbertrage mehrere Register                   MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FMOVEM.x <fdlist>,<ea>
                  FMOVEM.x Dn,<ea>
                  FMOVEM.x <ea>,<fdlist>
                  FMOVEM.x <ea>,Dn

Beschreibung:
Die spezifizierte Registerliste wird in den Speicher šbertragen 
oder aus dem  Speicher geholt.  Die Registerliste kann entweder 
direkt  angegeben  werden oder ber  ein Datenregister der  CPU 
spezifiziert werden.

Querverweis: EFMOVEF, EFMOVE FPcrF, EFMOVECRF, EFMOVEM FPcrF

Gruppe: EFliekomma-BefehleFFMOVEM FPcr - šbertrage mehrere Fliekomma-Kontrollregister    MC68881
----------------------------------------------------------------------

Assembler Syntax: FMOVEM.l <fclist>,<ea>   
                  FMOVEM.l <ea>,fclist

Beschreibung:
Die angegebenen EFPU-KontrollregisterF werden in den Speicher bertragen
oder aus diesem gelesen.
 
Querverweis: EFMOVEF, EFMOVE FPcrF, EFMOVECRF, EFMOVEMF

Gruppe: EFliekomma-BefehleFFMUL - Multiplikation                                 MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FMUL.f <ea>,FPn
                  FMUL.X FPm,FPn

Beschreibung:
Es wird das Produkt aus dem Quelloperanden und dem Zieloperanden 
berechnet und in das Zielregister geschrieben.

Querverweis: EFDIVF, EFSGLMULF

Gruppe: EFliekomma-BefehleFFDMUL - Multiplikation                                         MC68040
FSMUL
----------------------------------------------------------------------

Assembler Syntax: FDMUL.f <ea>,FPn
                  FDMUL.X FPm,FPn
                  FSMUL.f <ea>,FPn
                  FSMUL.X FPm,FPn

Beschreibung:
Es wird das Produkt aus dem Quelloperanden und dem Zieloperanden 
berechnet und in das Zielregister geschrieben.

Querverweis: EFMULF, EFSGLMULF

Gruppe: EFliekomma-BefehleFFNEG - Fliekomma Negation                            MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FNEG.f <ea>,FPn
                  FNEG.X FPm,FPn
                  FNEG.X FPm

Beschreibung:
Es wird der negative Wert des Arguments berechnet und in das Ziel-
register geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [-ß,+ß], W = [-ß,+ß]

Umkehrfunktion: FNEG

Querverweis: EFDNEGF, EFSNEGF

Gruppe: EFliekomma-BefehleFFDNEG - Negation                                               MC68040
FSNEG
----------------------------------------------------------------------

Assembler Syntax: FDNEG.f <ea>,FPn
                  FDNEG.X FPm,FPn
                  FDNEG.X FPm
                  FSNEG.f <ea>,FPn
                  FSNEG.X FPm,FPn
                  FSNEG.X FPm

Beschreibung:
Es wird der negative Wert des Arguments berechnet und in das Ziel-
register geschrieben. FDNEG rundet das Resultat auf einfache Ge-
nauigkeit und FDNEG auf doppelte Genauigkeit.

EDefinitionsmengeF und EWertemengeF:

D = [-ß,+ß], W = [-ß,+ß]

Querverweis: EFNEGF

Gruppe: EFliekomma-BefehleFFNOP - Keine Operation                                MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FNOP

Beschreibung: 
Keine Operation. Dieser Befehl dient haupts„chlich zur 
Synchronistation von CPU und FPU.

Gruppe: EFliekomma-BefehleFFREM - IEEE-Rest                                               MC68881
----------------------------------------------------------------------

Assembler Syntax: FREM.f <ea>,FPn
                  FREM.X FPm,FPn

Beschreibung:
Es wird der IEEE-Rest aus Quelle und Ziel berechnet und das Ergebnis
in das Zielregister geschrieben. Der Modulorest ist definiert als:

                  FPn - ( Quelle * N )
wobei gilt:
                  N = INT( FPn / Quelle ) (round to nearest mode)

Das Ergebnis dieser Division  steht anschlieend im EQuotientF Byte des
EFliekomma-StatusregisterFs.

Querverweis: EFMODF

Gruppe: EFliekomma-BefehleFFRESTORE - Wiederherstellung des Prozessorzustandes   MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FRESTORE <ea>

Beschreibung:
Dieser Befehl stellt den Zustand der FPU wieder her, der vorher mit
EFSAVEF gerettet wurde:

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich 
         sowohl vor als nach Ausfhrung des Befehls im Supervisormode 
         befinden, um ihn korrekt ausfhren zu k”nnen.

Querverweis: EFSAVEF

Gruppe: EFliekomma-BefehleFFSAVE - Retten des Prozessorzustandes                 MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FSAVE <ea>

Beschreibung:
Dieser Befehl dient dazu,  den aktuellen Zustand der FPU zu retten, 
um  ihn  sp„ter  mit  EFRESTOREF  wiederherstellen  zu  k”nnen.  <ea> 
spezifiziert den Speicherbereich,  wo der  Zustand abgelegt  werden 
soll. Der Speicherbereich mu folgende Daten aufnehmen k”nnen:

Zustand     |  MC68881       |  MC68882/MC68040
------------+----------------+-----------------
NULL        |   6 Bytes      |   6 Bytes
IDLE        |  30 Bytes      |  62 Bytes
BUSY        | 186 Bytes      | 218 Bytes

Achtung: Dieser Befehl ist privilegiert, d.h. der Prozessor mu sich 
         sowohl vor als nach Ausfhrung des Befehls im Supervisormode 
         befinden, um ihn korrekt ausfhren zu k”nnen.

Querverweis: EFRESTOREF

Gruppe: EFliekomma-BefehleFFSCALE - Skaliere Exponent                                     MC68881
----------------------------------------------------------------------

Assembler Syntax: FSCALE.f <ea>,FPn
                  FSCALE.X FPm,FPn

Beschreibung:
Der Quelloperand wird zu einem Integer umgewandelt und auf den 
Exponenten des Zielregister aufaddiert. Das Ergebnis ist das 
gleiche. Das Ergebnis entpricht folgendem Term:

                 Fpn * 2^<Quelle>

Gruppe: EFliekomma-BefehleFFScc - Setze Byte in Anh„ngigkeit von Bedingung       MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FSEccF <ea>

Beschreibung:
Setzt ein Byte in Abh„ngigkeit vom Zustand der jeweiligen Flags
des Condition Code der FPU.

Falls die Bedingung zutrifft, das BSUN Bit des EException EnableF
Byte und das NAN Bit des ECondition CodeF gesetzt ist,  wird eine
EExceptionF mit der Nummer 48 ausgel”st.

Gruppe: EFliekomma-BefehleFFSGLDIV - Division mit einfacher Genauigkeit                   MC68881
----------------------------------------------------------------------

Assembler Syntax: FSGLDIV.f <ea>,FPn
                  FSGLDIV.X FPm,FPn

Beschreibung:
Es wird eine Division des Zieloperanden durch den Ouelloperanden
ausgefhrt und das Ergebnis in das Zielregister geschrieben. Wenn 
beide Operanden 0 sind oder beide +/-ß sind wird als Ergebnis NaN
( Not a number ) zurckgeliefert. Im Gegensatz zu FDIV wird nur 
mit einfacher Genaugikeit gerechnet.

Querverweis: EFDIVF, EFSGLMULF

Gruppe: EFliekomma-BefehleFFSGLMUL - Multiplikation mit einfacher Genauigkeit             MC68881
----------------------------------------------------------------------

Assembler Syntax: FSGLMUL.f <ea>,FPn
                  FSGLMUL.X FPm,FPn

Beschreibung:
Es wird das Produkt aus dem Quelloperanden und dem Zieloperanden 
berechnet und in das Zielregister geschrieben. Im Gegensatz zu  
FMUL wird nur mit einfacher Genaugikeit gerechnet.

Querverweis: EFMULF, EFSGLDIVF

Gruppe: EFliekomma-BefehleFFSIN - Sinus                                                   MC68881
----------------------------------------------------------------------

Assembler Syntax: FSIN.f <ea>,FPn
                  FSIN.x FPm,FPn
                  FSIN.x FPn

Beschreibung:
Es wird der Sinus  des  Arguments berechnet und in das Zielregister 
geschrieben.  Je gr”er der  Absolutwert des  Arguments ist,  desto 
gr”er ist die Ungenauigkeit des Ergebnisses.

EDefinitionsmengeF und EWertemengeF:

D = ]-ß,+ß[, W=[-1,+1] (Hinweis: D sollte [-2ã,+2ã] sein.)  

Umkehrfunktion: EFASINF

Gruppe: EFliekomma-BefehleFFSINCOS - Sinus und Cosinus gleichzeitig                       MC68881
----------------------------------------------------------------------

Assembler Syntax: FSINCOS.f <ea>,FPc:FPs
                  FSINCOS.x FPm,fpc:fps

Beschreibung:
Er wird sowohl der Sinus als auch der Cosinus des Quelloperanden 
berechnet und in die  beiden Zielregister geschrieben. Der Sinus 
steht anschlieend im Register FPs, der Cosinus im Register FPc.

EDefinitionsmengeF und EWertemengeF:

D = ]-ß,+ß[, W=[-1,+1] (Hinweis: D sollte [-2ã,+2ã] sein.)  

Querverweis: EFSINF, EFCOSF

Umkehrfunktionen: EFASINF, EFACOSF

Gruppe: EFliekomma-BefehleFFSINH - Sinus Hyperbolicus                                     MC68881
----------------------------------------------------------------------

Assembler Syntax: FSINH.f <ea>,FPn
                  FSINH.x FPm,FPn
                  FSINH.x FPn

Beschreibung:
Es wird der Sinus Hyperbolicus des  Arguments berechnet und in das 
Zielregister geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [-ß,+ß], W = [-ß,+ß]

Gruppe: EFliekomma-BefehleFFSQRT - Quadratwurzel                                 MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FSQRT.f <ea>,FPn
                  FSQRT.X FPm,FPn
                  FSQRT.X FPm

Beschreibung:
Es wird die Quadratwurzel des Arguments berechnet und in das Ziel-
register geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [0,+ß], W = [0,+ß]

Querverweis: EFDSQRTF, EFSSQRTF

Gruppe: EFliekomma-BefehleFFDSQRT - Quadratwurzel                                         MC68040
FSSORT
----------------------------------------------------------------------

Assembler Syntax: FDSQRT.f <ea>,FPn
                  FDSQRT.X FPm,FPn
                  FDSQRT.X FPm
                  FSSQRT.f <ea>,FPn
                  FSSQRT.X FPm,FPn
                  FSSQRT.X FPm

Beschreibung:
Es wird die Quadratwurzel des Arguments berechnet und in das Ziel-
register geschrieben. FSSQRT berechnet die Quadratwurzel mit ein-
facher und FDSQRT mit doppelter Genauigkeit.

EDefinitionsmengeF und EWertemengeF:

D = [0,+ß], W = [0,+ß]

Querverweis: EFSQRTF

Gruppe: EFliekomma-BefehleFFSUB - Substraktion                                   MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FSUB.f <ea>,FPn
                  FSUB.X FPm,FPn

Beschreibung:
Es wird die Differenz des Zieloperanden minus Ouelloperanden aus-
gefhrt und das Ergebnis in das Zielregister geschrieben. 

Querverweis: EFADDF, EFDSUBF, EFSSUBF

Gruppe: EFliekomma-BefehleFFDSUB - Substraktion                                           MC68040
FSSUB
----------------------------------------------------------------------

Assembler Syntax: FDSUB.f <ea>,FPn
                  FDSUB.X FPm,FPn
                  FSSUB.f <ea>,FPn
                  FSSUB.X FPm,FPn

Beschreibung:
Es wird die Differenz des Zieloperanden minus Ouelloperanden aus-
gefhrt und das Ergebnis in das Zielregister geschrieben. FSSUB
berechnet das Ergebnis mit einfacher Genauigkeit, FDSUB mit
doppelter.

Querverweis: EFSUBF

Gruppe: EFliekomma-BefehleFTAN - Tangens                                                  MC68881
----------------------------------------------------------------------

Assembler Syntax: FTAN.f <ea>,FPn
                  FTAN.x FPm,FPn
                  FTAN.x FPn

Beschreibung:
Es wird der Tangens des Arguments berechnet und in das Zielregister 
geschrieben.  Je gr”er der  Absolutwert des  Arguments ist,  desto 
gr”er ist die Ungenauigkeit des Ergebnisses.

EDefinitionsmengeF und EWertemengeF:

D = ]-ß,+ß[, W=[-ß,+ß] (Hinweis: D sollte [-2ã,+2ã] sein.)  

Umkehrfunktion: EFATANF

Gruppe: EFliekomma-BefehleFFTANH - Tangens Hyperbolicus                                   MC68881
----------------------------------------------------------------------

Assembler Syntax: FTANH.f <ea>,FPn
                  FTANH.x FPm,FPn
                  FTANH.x FPn

Beschreibung:
Es wird der Tangens Hyperbolicus des Arguments berechnet und in das 
Zielregister geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [-ß,+ß], W = [-1.0,+1.0]

Gruppe: EFliekomma-BefehleFFTENTOX - Zehnerpotenz                                         MC68881
----------------------------------------------------------------------

Assembler Syntax: FTENTOX.f <ea>,FPn
                  FTENTOX.x FPm,FPn
                  FTENTOX.x FPm

Beschreibung:
Es wird die Zehnerpotenz (10^x) des Arguments berechnet und in das Ziel-
register geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [-ß,+ß], W = [0,+ß]

Umkehrfunktion: EFLOG10F

Gruppe: EFliekomma-BefehleFFTRAPcc - Trap bei Bedingung                          MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FTRAPEccF
                  FTRAPEccF.W #<data>
                  FTRAPEccF.L #<data>

Beschreibung:
Wenn die spezifizierte Bedingung erfllt ist, wird die Behandlung
der EExceptionF mit Vektor Nummer 7 eingeleitet. Wird die Bedingung
nicht   erfllt,   wird  der  auf  den  FTRAPcc  folgende  Befehl
abgearbeitet.

Das dem Befehl folgende Wort oder Langwort wird von der CPU ber-
gangen und kann vom Trap-Handler ausgewertet werden.

Gruppe: EFliekomma-BefehleFFTST - Prfe Inhalt des Operanden                     MC68881, MC68040
----------------------------------------------------------------------

Assembler Syntax: FTST.f <ea>
                  FTST.X FPm

Beschreibung:
Testet einen Operanden und setzt die entsprechenden Flags im
Condition Code Register der FPU.

Gruppe: EFliekomma-BefehleFFTWOTOX - Zweierpotenz                                         MC68881
----------------------------------------------------------------------

Assembler Syntax: FTWOTOX.f <ea>,FPn
                  FTWOTOX.x FPm,FPn
                  FTWOTOX.x FPm

Beschreibung:
Es wird die Zweierpotenz (2^x) des Arguments berechnet und in das Ziel-
register geschrieben.

EDefinitionsmengeF und EWertemengeF:

D = [-ß,+ß], W = [0,+ß]

Umkehrfunktion: EFLOG2F

Gruppe: EFliekomma-BefehleFPBcc - Bedingte Verzweigung                                    MC68851
----------------------------------------------------------------------

Assembler Syntax: PBEccF <label>

Beschreibung:
Falls die Bedingung ( EccF ) erfllt ist wird das Programm an der
Adresse weitegefhrt, fr die label steht.

Gr”e: Word, Long

Hinweis: Der Assembler verwendet automatisch den krzeren Befehl, wenn die
Adredistanz zwischen -32768 und +32767 liegt.

Gruppe: EPMMU-BefehleFPDBcc - Prfe Bedingung, dekrementiere und verzweige           MC68851
----------------------------------------------------------------------

Assembler Syntax: PDBEccF Dn,<label>

Beschreibung:
Diese Befehl erm”glich es eine einfache Schleife zu programmieren.
Zuerst  wird die  ber  EccF  spezifizierte  Bedingung  geprft um
festzustellen ob die Abbruchsbedingung  fr  die Schleife erreicht
ist. Wenn dies der Fall ist wird keine weitere Aktion vorgenommen.
Wenn die Abbruchsbedingung nicht erfllt ist,  werden  die unteren
16 Bit ( Achtung: Word ) um 1  ( Eins )  dekrementiert.  Wenn  das
Ergebnis -1 (Achtung: Minus Eins) ist, wird die Schleife  beendet.
Andernfalls  wird  auf  die durch label spezifizierte Adresse ver-
zweigt.

Gr”e: Word, Long

Hinweis: Der Assembler verwendet automatisch den krzeren Befehl, wenn die
Adredistanz zwischen -32768 und +32767 liegt.

Gruppe: EPMMU-BefehleFPFLUSH - L”sche Address Translation Cache              MC68030/MC68851
----------------------------------------------------------------------

Assembler Syntax: PFLUSHA
                  PFLUSHA.N                        ( nur MC68040 )
                  PFLUSH   <fc>, #<mask>
                  PFLUSH   <fc>, #<mask>, <ea>
                  PFLUSH.N (An)                    ( nur MC68040 )
                  PFLUSHS  <fc>, #<mask>           ( nur MC68851 )
                  PFLUSHS  <fc>, #<mask>, <ea>     ( nur MC68851 )

Beschreibung:
L”scht alle (PFLUSHA), nicht globale (PFLUSH.N, PFLUSHA.N) oder
bestimmte (PFLUSH, PFLUSHS) Eintr„ge im Address Translation
Cache ( EATCF ). 

<fc>    bezeichnet den EFunction CodeF.
<mask>  beschreibt die Bits,  welche im <fc>-Parameter bercksich-
        tigt werden sollen.
<ea>    Ist  die logische Adresse,  fr die die  Eintr„ge gel”scht
        werden sollen.

Die MC68851-PMMU l”scht nur Eintr„ge, bei denen das EShared GlobalyF
Flag NICHT gesetzt ist. Hierzu ist PFLUSHS notwendig.

Gruppe: EPMMU-BefehleFPLOAD - Lade Address Translation Cache                 MC68030/MC68851
----------------------------------------------------------------------

Assembler Syntax: PLOADR  <fc>, <ea>
                  PLOADW  <fc>, <ea>

Beschreibung:
Durchsucht die šbersetzungstabelle, nach einen Eintrag fr die ange-
gebene Adresse ( <ea> )  und den EFunction CodeF ( <fc> ).  Konnte die
zugeh”rige physikalische Adresse ermittelt werden,  wird ein Eintrag
im Address Translation Cache ( EATCF ) angelegt. PLOADR setzt dann das
Used-Bit. PLOADW setzt zus„tlich das Modified-Bit.

Ist der  EMC68851F-PMMU ausgeschaltet,  so wird eine EExceptionF mit der
Nummer 57 ausgel”st. ( EPMMU-Illegale OperationF )

Querverweis: EPFLUSHF

Gruppe: EPMMU-BefehleFPMOVE - šbertrage Daten in/aus einem PMMU-Register     MC68030/MC68851
----------------------------------------------------------------------

Assembler Syntax: PMOVE   <PMMU Register>, <ea>
                  PMOVE   <ea>, <PMMU Register>
                  PMOVEFD <ea>, <PMMU Register>  ( MC68030 )

Beschreibung:
Der Inhalt eines EPMMU-KontrollregisterFs wird von oder nach einer 
effektiven  Adresse  geschrieben.  Dabei ist  zu  beachten,  da 
nicht  definierte Bit  beim Lesen  aus einem Register  0 ergeben
und beim Schreiben in ein Register 0 sein sollten, um kompatibel
mit zuknftigen Versionen zu sein. PMOVEFD bewirkt,  da das EATCF
NICHT gel”scht wird ( flush disable ).
                  
Gruppe: EPMMU-BefehleFPRESTORE - Wiederherstellung des Prozessorzustandes            MC68851
----------------------------------------------------------------------

Assembler Syntax: PRESTORE <ea>

Beschreibung:
Dieser Befehl stellt den Zustand der PMMU wieder her, der vorher mit
EPSAVEF gerettet wurde:

***Achtung***:
Erh„lt  eines der  ERoot PointerF Register  durch diesen  Befehl einen
ungltigen  EDescriptor TypeF,  so ist das weitere  Verhalten der PMMU 
undefiniert.

Querverweis: EPSAVEF

Gruppe: EPMMU-BefehleFPSAVE - Retten des Prozessorzustandes                          MC68851
----------------------------------------------------------------------

Assembler Syntax: PSAVE <ea>

Beschreibung:
Dieser Befehl dient dazu, den aktuellen Zustand der PMMU zu retten, 
um  ihn  sp„ter  mit  EPRESTOREF  wiederherstellen  zu  k”nnen.  <ea> 
spezifiziert den Speicherbereich,  wo der  Zustand abgelegt  werden 
soll. Der Speicherbereich mu folgende Daten aufnehmen k”nnen:

     Zustand  | Anzahl der Bytes       
    ----------+-------------------
     NULL     | 36 Bytes
     IDLE     | 44 Bytes
     BUSY     | 76 Bytes

Querverweis: EPRESTOREF

Gruppe: EPMMU-BefehleFPScc - Setze ein Byte in Anh„ngigkeit von einer Bedingung      MC68851
----------------------------------------------------------------------

Assembler Syntax: PSEccF <ea>

Beschreibung:
Setzt ein Byte in Abh„ngigkeit vom Zustand der jeweiligen Flags
des Condition Code der PMMU.

Gruppe: EPMMU-BefehleFPTEST - Prfe logische Adresse                         MC68030/MC68851
----------------------------------------------------------------------

Assembler Syntax: PTESTR <fc>,<ea>,#<level>
                  PTESTR <fc>,<ea>,#<level>, An
                  PTESTW <fc>,<ea>,#<level>
                  PTESTW <fc>,<ea>,#<level>, An

Beschreibung:
PTEST prft eine logische Adresse spezifiziert durch EFunction CodeF
( <fc> ) und <ea> auf einen Eintrag in der EšbersetzungstabelleF bis
zur Suchtiefe <level>.  Das  Ergebnis dieser Prfung wird im PMMU-
Statusregister ( EPSRF ) abgelegt. PTESTR setzt die Flags im PSR fr
einen Lesezugriff, PTESTW entsprechend einen Schreibzugriff.  Wird
noch ein Adreregister angegeben, so wird die Adresse des letzten
untersuchten EDescriptorFs in diesem Register angelegt.

Eine Suchtiefe  von 0 bedeutet,  da nur das  Address  Translation
Cache ( EATCF ) und beim EMC68030F bzw. EMC68040F auch die beiden Trans-
parent Translation  Register ( ETTnF ) durchsucht werden. Eine Such-
tiefe ungleich 0 durchsucht nur die EšbersetzungstabelleF.

Ist der EMC68851F-PMMU ausgeschaltet, so wird eine EExceptionF mit der
Nummer 57 ausgel”st. ( EPMMU-Illegale OperationF )

Dieser  Befehl  ist z.B.  sinnvoll,  falls eine  EBusfehlerF-Routine
feststellen soll, ob der Busfehler durch einen ungltigen Descrip-
tor verursacht wurde.

Gruppe: EPMMU-BefehleFPTRAPcc - Trap bei Bedingung                                   MC68851
----------------------------------------------------------------------

Assembler Syntax: PTRAPEccF
                  PTRAPEccF.W #<data>
                  PTRAPEccF.L #<data>

Beschreibung:
Wenn die spezifizierte Bedingung erfllt ist, wird die Behandlung
der EExceptionF mit Vektor Nummer 7 eingeleitet. Wird die Bedingung
nicht   erfllt,   wird  der  auf  den  PTRAPcc  folgende  Befehl
abgearbeitet.

Das dem Befehl folgende Wort oder Langwort wird von der CPU ber-
gangen und kann vom Trap-Handler ausgewertet werden.

Gruppe: EPMMU-BefehleFPVALID - Prfe Zeiger                            MC68851, privilegiert
----------------------------------------------------------------------

Assembler Syntax: PVALID VAL,<ea>
                  PVALID An,<ea>

Beschreibung:
PVALID vergleicht die oberen Bits des Quelloperanden mit den oberen
Bits des Zieloperanden. Die Anzahl der zu vergleichenden Bits ist
im ALC-Feld des EACF-Registers festgelegt. Wenn die oberen Bits
des Quelloperanden einen numerische gr”eren Wert enthalten als
die des Zieloperanden, d.h. weniger privilegiert sind, wird eine
MMU Access Level Exception ausgel”st. Andernfalls wird die Programm-
ausfhrung fortgesetzt.
Der Inhalt des Statusregisters EPSRF bleibt unver„ndert.

Gruppe: EPMMU-BefehleF